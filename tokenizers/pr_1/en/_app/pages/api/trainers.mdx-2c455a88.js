import{S as Z,i as ee,s as ne,e as h,k as T,w as P,t as A,M as re,c as f,d as i,m as x,a as _,x as W,h as E,b,F as s,g as k,y as L,q,o as U,B,v as te,L as oe}from"../../chunks/vendor-0d3f0756.js";import{D as J}from"../../chunks/Docstring-f752f2c3.js";import{I as ae}from"../../chunks/IconCopyLink-9193371d.js";import{T as ie,M as G}from"../../chunks/TokenizersLanguageContent-ca787841.js";function se(g){let n,t,e,r,c,d,l,p,D,w,u,z,a,m,$,I,S,N,y,M,O,R,j,V;return t=new J({props:{name:"class tokenizers.trainers.BpeTrainer",anchor:"tokenizers.trainers.BpeTrainer",parameters:[{name:"vocab_size",val:" = 30000"},{name:"min_frequency",val:" = 0"},{name:"show_progress",val:" = True"},{name:"special_tokens",val:" = []"},{name:"limit_alphabet",val:" = None"},{name:"initial_alphabet",val:" = []"},{name:"continuing_subword_prefix",val:" = None"},{name:"end_of_word_suffix",val:" = None"}],parametersDescription:[{anchor:"tokenizers.trainers.BpeTrainer.vocab_size",description:`<strong>vocab_size</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The size of the final vocabulary, including all tokens and alphabet.`,name:"vocab_size"},{anchor:"tokenizers.trainers.BpeTrainer.min_frequency",description:`<strong>min_frequency</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The minimum frequency a pair should have in order to be merged.`,name:"min_frequency"},{anchor:"tokenizers.trainers.BpeTrainer.show_progress",description:`<strong>show_progress</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether to show progress bars while training.`,name:"show_progress"},{anchor:"tokenizers.trainers.BpeTrainer.special_tokens",description:`<strong>special_tokens</strong> (<code>List[Union[str, AddedToken]]</code>, <em>optional</em>) &#x2014;
A list of special tokens the model should know of.`,name:"special_tokens"},{anchor:"tokenizers.trainers.BpeTrainer.limit_alphabet",description:`<strong>limit_alphabet</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The maximum different characters to keep in the alphabet.`,name:"limit_alphabet"},{anchor:"tokenizers.trainers.BpeTrainer.initial_alphabet",description:`<strong>initial_alphabet</strong> (<code>List[str]</code>, <em>optional</em>) &#x2014;
A list of characters to include in the initial alphabet, even
if not seen in the training dataset.
If the strings contain more than one character, only the first one
is kept.`,name:"initial_alphabet"},{anchor:"tokenizers.trainers.BpeTrainer.continuing_subword_prefix",description:`<strong>continuing_subword_prefix</strong> (<code>str</code>, <em>optional</em>) &#x2014;
A prefix to be used for every subword that is not a beginning-of-word.`,name:"continuing_subword_prefix"},{anchor:"tokenizers.trainers.BpeTrainer.end_of_word_suffix",description:`<strong>end_of_word_suffix</strong> (<code>str</code>, <em>optional</em>) &#x2014;
A suffix to be used for every subword that is a end-of-word.`,name:"end_of_word_suffix"}]}}),p=new J({props:{name:"class tokenizers.trainers.UnigramTrainer",anchor:"tokenizers.trainers.UnigramTrainer",parameters:[{name:"vocab_size",val:" = 8000"},{name:"show_progress",val:" = True"},{name:"special_tokens",val:" = []"},{name:"shrinking_factor",val:" = 0.75"},{name:"unk_token",val:" = None"},{name:"max_piece_length",val:" = 16"},{name:"n_sub_iterations",val:" = 2"}],parametersDescription:[{anchor:"tokenizers.trainers.UnigramTrainer.vocab_size",description:`<strong>vocab_size</strong> (<code>int</code>) &#x2014;
The size of the final vocabulary, including all tokens and alphabet.`,name:"vocab_size"},{anchor:"tokenizers.trainers.UnigramTrainer.show_progress",description:`<strong>show_progress</strong> (<code>bool</code>) &#x2014;
Whether to show progress bars while training.`,name:"show_progress"},{anchor:"tokenizers.trainers.UnigramTrainer.special_tokens",description:`<strong>special_tokens</strong> (<code>List[Union[str, AddedToken]]</code>) &#x2014;
A list of special tokens the model should know of.`,name:"special_tokens"},{anchor:"tokenizers.trainers.UnigramTrainer.initial_alphabet",description:`<strong>initial_alphabet</strong> (<code>List[str]</code>) &#x2014;
A list of characters to include in the initial alphabet, even
if not seen in the training dataset.
If the strings contain more than one character, only the first one
is kept.`,name:"initial_alphabet"},{anchor:"tokenizers.trainers.UnigramTrainer.shrinking_factor",description:`<strong>shrinking_factor</strong> (<code>float</code>) &#x2014;
The shrinking factor used at each step of the training to prune the
vocabulary.`,name:"shrinking_factor"},{anchor:"tokenizers.trainers.UnigramTrainer.unk_token",description:`<strong>unk_token</strong> (<code>str</code>) &#x2014;
The token used for out-of-vocabulary tokens.`,name:"unk_token"},{anchor:"tokenizers.trainers.UnigramTrainer.max_piece_length",description:`<strong>max_piece_length</strong> (<code>int</code>) &#x2014;
The maximum length of a given token.`,name:"max_piece_length"},{anchor:"tokenizers.trainers.UnigramTrainer.n_sub_iterations",description:`<strong>n_sub_iterations</strong> (<code>int</code>) &#x2014;
The number of iterations of the EM algorithm to perform before
pruning the vocabulary.`,name:"n_sub_iterations"}]}}),m=new J({props:{name:"class tokenizers.trainers.WordLevelTrainer",anchor:"tokenizers.trainers.WordLevelTrainer",parameters:[{name:"vocab_size",val:" = 30000"},{name:"min_frequency",val:" = 0"},{name:"show_progress",val:" = True"},{name:"special_tokens",val:" = []"},{name:"limit_alphabet",val:" = None"},{name:"initial_alphabet",val:" = []"},{name:"continuing_subword_prefix",val:" = None"},{name:"end_of_word_suffix",val:" = None"}],parametersDescription:[{anchor:"tokenizers.trainers.WordLevelTrainer.vocab_size",description:`<strong>vocab_size</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The size of the final vocabulary, including all tokens and alphabet.`,name:"vocab_size"},{anchor:"tokenizers.trainers.WordLevelTrainer.min_frequency",description:`<strong>min_frequency</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The minimum frequency a pair should have in order to be merged.`,name:"min_frequency"},{anchor:"tokenizers.trainers.WordLevelTrainer.show_progress",description:`<strong>show_progress</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether to show progress bars while training.`,name:"show_progress"},{anchor:"tokenizers.trainers.WordLevelTrainer.special_tokens",description:`<strong>special_tokens</strong> (<code>List[Union[str, AddedToken]]</code>) &#x2014;
A list of special tokens the model should know of.`,name:"special_tokens"}]}}),M=new J({props:{name:"class tokenizers.trainers.WordPieceTrainer",anchor:"tokenizers.trainers.WordPieceTrainer",parameters:[{name:"vocab_size",val:" = 30000"},{name:"min_frequency",val:" = 0"},{name:"show_progress",val:" = True"},{name:"special_tokens",val:" = []"},{name:"limit_alphabet",val:" = None"},{name:"initial_alphabet",val:" = []"},{name:"continuing_subword_prefix",val:" = '##'"},{name:"end_of_word_suffix",val:" = None"}],parametersDescription:[{anchor:"tokenizers.trainers.WordPieceTrainer.vocab_size",description:`<strong>vocab_size</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The size of the final vocabulary, including all tokens and alphabet.`,name:"vocab_size"},{anchor:"tokenizers.trainers.WordPieceTrainer.min_frequency",description:`<strong>min_frequency</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The minimum frequency a pair should have in order to be merged.`,name:"min_frequency"},{anchor:"tokenizers.trainers.WordPieceTrainer.show_progress",description:`<strong>show_progress</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether to show progress bars while training.`,name:"show_progress"},{anchor:"tokenizers.trainers.WordPieceTrainer.special_tokens",description:`<strong>special_tokens</strong> (<code>List[Union[str, AddedToken]]</code>, <em>optional</em>) &#x2014;
A list of special tokens the model should know of.`,name:"special_tokens"},{anchor:"tokenizers.trainers.WordPieceTrainer.limit_alphabet",description:`<strong>limit_alphabet</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The maximum different characters to keep in the alphabet.`,name:"limit_alphabet"},{anchor:"tokenizers.trainers.WordPieceTrainer.initial_alphabet",description:`<strong>initial_alphabet</strong> (<code>List[str]</code>, <em>optional</em>) &#x2014;
A list of characters to include in the initial alphabet, even
if not seen in the training dataset.
If the strings contain more than one character, only the first one
is kept.`,name:"initial_alphabet"},{anchor:"tokenizers.trainers.WordPieceTrainer.continuing_subword_prefix",description:`<strong>continuing_subword_prefix</strong> (<code>str</code>, <em>optional</em>) &#x2014;
A prefix to be used for every subword that is not a beginning-of-word.`,name:"continuing_subword_prefix"},{anchor:"tokenizers.trainers.WordPieceTrainer.end_of_word_suffix",description:`<strong>end_of_word_suffix</strong> (<code>str</code>, <em>optional</em>) &#x2014;
A suffix to be used for every subword that is a end-of-word.`,name:"end_of_word_suffix"}]}}),{c(){n=h("div"),P(t.$$.fragment),e=T(),r=h("p"),c=A("Trainer capable of training a BPE model"),d=T(),l=h("div"),P(p.$$.fragment),D=T(),w=h("p"),u=A("Trainer capable of training a Unigram model"),z=T(),a=h("div"),P(m.$$.fragment),$=T(),I=h("p"),S=A("Trainer capable of training a WorldLevel model"),N=T(),y=h("div"),P(M.$$.fragment),O=T(),R=h("p"),j=A("Trainer capable of training a WordPiece model"),this.h()},l(o){n=f(o,"DIV",{class:!0});var v=_(n);W(t.$$.fragment,v),e=x(v),r=f(v,"P",{});var K=_(r);c=E(K,"Trainer capable of training a BPE model"),K.forEach(i),v.forEach(i),d=x(o),l=f(o,"DIV",{class:!0});var C=_(l);W(p.$$.fragment,C),D=x(C),w=f(C,"P",{});var Q=_(w);u=E(Q,"Trainer capable of training a Unigram model"),Q.forEach(i),C.forEach(i),z=x(o),a=f(o,"DIV",{class:!0});var F=_(a);W(m.$$.fragment,F),$=x(F),I=f(F,"P",{});var X=_(I);S=E(X,"Trainer capable of training a WorldLevel model"),X.forEach(i),F.forEach(i),N=x(o),y=f(o,"DIV",{class:!0});var H=_(y);W(M.$$.fragment,H),O=x(H),R=f(H,"P",{});var Y=_(R);j=E(Y,"Trainer capable of training a WordPiece model"),Y.forEach(i),H.forEach(i),this.h()},h(){b(n,"class","docstring"),b(l,"class","docstring"),b(a,"class","docstring"),b(y,"class","docstring")},m(o,v){k(o,n,v),L(t,n,null),s(n,e),s(n,r),s(r,c),k(o,d,v),k(o,l,v),L(p,l,null),s(l,D),s(l,w),s(w,u),k(o,z,v),k(o,a,v),L(m,a,null),s(a,$),s(a,I),s(I,S),k(o,N,v),k(o,y,v),L(M,y,null),s(y,O),s(y,R),s(R,j),V=!0},p:oe,i(o){V||(q(t.$$.fragment,o),q(p.$$.fragment,o),q(m.$$.fragment,o),q(M.$$.fragment,o),V=!0)},o(o){U(t.$$.fragment,o),U(p.$$.fragment,o),U(m.$$.fragment,o),U(M.$$.fragment,o),V=!1},d(o){o&&i(n),B(t),o&&i(d),o&&i(l),B(p),o&&i(z),o&&i(a),B(m),o&&i(N),o&&i(y),B(M)}}}function ce(g){let n,t;return n=new G({props:{$$slots:{default:[se]},$$scope:{ctx:g}}}),{c(){P(n.$$.fragment)},l(e){W(n.$$.fragment,e)},m(e,r){L(n,e,r),t=!0},p(e,r){const c={};r&2&&(c.$$scope={dirty:r,ctx:e}),n.$set(c)},i(e){t||(q(n.$$.fragment,e),t=!0)},o(e){U(n.$$.fragment,e),t=!1},d(e){B(n,e)}}}function le(g){let n,t,e,r,c;return{c(){n=h("p"),t=A("The Rust API Reference is available directly on the "),e=h("a"),r=A("Docs.rs"),c=A(" website."),this.h()},l(d){n=f(d,"P",{});var l=_(n);t=E(l,"The Rust API Reference is available directly on the "),e=f(l,"A",{href:!0,rel:!0});var p=_(e);r=E(p,"Docs.rs"),p.forEach(i),c=E(l," website."),l.forEach(i),this.h()},h(){b(e,"href","https://docs.rs/tokenizers/latest/tokenizers/"),b(e,"rel","nofollow")},m(d,l){k(d,n,l),s(n,t),s(n,e),s(e,r),s(n,c)},d(d){d&&i(n)}}}function de(g){let n,t;return n=new G({props:{$$slots:{default:[le]},$$scope:{ctx:g}}}),{c(){P(n.$$.fragment)},l(e){W(n.$$.fragment,e)},m(e,r){L(n,e,r),t=!0},p(e,r){const c={};r&2&&(c.$$scope={dirty:r,ctx:e}),n.$set(c)},i(e){t||(q(n.$$.fragment,e),t=!0)},o(e){U(n.$$.fragment,e),t=!1},d(e){B(n,e)}}}function me(g){let n,t;return{c(){n=h("p"),t=A("The node API has not been documented yet.")},l(e){n=f(e,"P",{});var r=_(n);t=E(r,"The node API has not been documented yet."),r.forEach(i)},m(e,r){k(e,n,r),s(n,t)},d(e){e&&i(n)}}}function pe(g){let n,t;return n=new G({props:{$$slots:{default:[me]},$$scope:{ctx:g}}}),{c(){P(n.$$.fragment)},l(e){W(n.$$.fragment,e)},m(e,r){L(n,e,r),t=!0},p(e,r){const c={};r&2&&(c.$$scope={dirty:r,ctx:e}),n.$set(c)},i(e){t||(q(n.$$.fragment,e),t=!0)},o(e){U(n.$$.fragment,e),t=!1},d(e){B(n,e)}}}function he(g){let n,t,e,r,c,d,l,p,D,w,u,z;return d=new ae({}),u=new ie({props:{python:!0,rust:!0,node:!0,$$slots:{node:[pe],rust:[de],python:[ce]},$$scope:{ctx:g}}}),{c(){n=h("meta"),t=T(),e=h("h1"),r=h("a"),c=h("span"),P(d.$$.fragment),l=T(),p=h("span"),D=A("Trainers"),w=T(),P(u.$$.fragment),this.h()},l(a){const m=re('[data-svelte="svelte-1phssyn"]',document.head);n=f(m,"META",{name:!0,content:!0}),m.forEach(i),t=x(a),e=f(a,"H1",{class:!0});var $=_(e);r=f($,"A",{id:!0,class:!0,href:!0});var I=_(r);c=f(I,"SPAN",{});var S=_(c);W(d.$$.fragment,S),S.forEach(i),I.forEach(i),l=x($),p=f($,"SPAN",{});var N=_(p);D=E(N,"Trainers"),N.forEach(i),$.forEach(i),w=x(a),W(u.$$.fragment,a),this.h()},h(){b(n,"name","hf:doc:metadata"),b(n,"content",JSON.stringify(fe)),b(r,"id","tokenizers.trainers.BpeTrainer"),b(r,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),b(r,"href","#tokenizers.trainers.BpeTrainer"),b(e,"class","relative group")},m(a,m){s(document.head,n),k(a,t,m),k(a,e,m),s(e,r),s(r,c),L(d,c,null),s(e,l),s(e,p),s(p,D),k(a,w,m),L(u,a,m),z=!0},p(a,[m]){const $={};m&2&&($.$$scope={dirty:m,ctx:a}),u.$set($)},i(a){z||(q(d.$$.fragment,a),q(u.$$.fragment,a),z=!0)},o(a){U(d.$$.fragment,a),U(u.$$.fragment,a),z=!1},d(a){i(n),a&&i(t),a&&i(e),B(d),a&&i(w),B(u,a)}}}const fe={local:"tokenizers.trainers.BpeTrainer",title:"Trainers"};function _e(g){return te(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class be extends Z{constructor(n){super();ee(this,n,_e,he,ne,{})}}export{be as default,fe as metadata};
