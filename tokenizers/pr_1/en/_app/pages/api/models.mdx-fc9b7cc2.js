import{S as fa,i as va,s as ua,e as r,k as c,w as v,t as s,M as ga,c as n,d as t,m,a,x as u,h as i,b as p,F as e,g as P,y as g,q as $,o as _,B as k,v as $a,L as _a}from"../../chunks/vendor-0d3f0756.js";import{D as W}from"../../chunks/Docstring-f752f2c3.js";import{C as hn}from"../../chunks/CodeBlock-7b0cb15c.js";import{I as nt}from"../../chunks/IconCopyLink-9193371d.js";import{T as ka,M as fn}from"../../chunks/TokenizersLanguageContent-ca787841.js";function Ea(S){let d,f,l,h,y,x,B,q,D,C,V,U,E,I,z,O,je,le,mo,po,at,ho,fo,$e,vo,R,uo,st,go,$o,it,_o,ko,Ge,Eo,bo,j,_e,Po,te,wo,lt,yo,zo,dt,xo,To,Do,ct,Wo,Gt,oe,de,mt,ke,Ao,pt,Bo,Ht,w,Ee,Io,ht,Lo,Mo,ft,qo,No,vt,So,Co,G,be,Vo,He,Uo,ut,Oo,Ro,re,jo,gt,Go,Ho,Fe,Fo,Jo,Ko,ce,Pe,Qo,$t,Xo,Yo,H,we,Zo,_t,er,tr,kt,or,rr,me,ye,nr,Et,ar,sr,pe,ze,ir,bt,lr,Ft,ne,he,Pt,xe,dr,wt,cr,Jt,ae,Te,mr,yt,pr,Kt,se,fe,zt,De,hr,xt,fr,Qt,A,We,vr,Tt,ur,gr,Dt,$r,_r,L,Ae,kr,Wt,Er,br,At,Pr,wr,Be,yr,F,zr,Bt,xr,Tr,It,Dr,Wr,Je,Ar,Br,J,Ie,Ir,Ke,Lr,Lt,Mr,qr,Mt,Nr,Xt,ie,ve,qt,Le,Sr,Nt,Cr,Yt,N,Me,Vr,St,Ur,Or,M,qe,Rr,Ct,jr,Gr,Vt,Hr,Fr,Ne,Jr,K,Kr,Ut,Qr,Xr,Ot,Yr,Zr,Qe,en,tn,Q,Se,on,Ce,rn,Rt,nn,an,sn,Ve,ln,jt,dn,cn,Zt;return h=new nt({}),C=new W({props:{name:"class tokenizers.models.BPE",anchor:"tokenizers.models.BPE",parameters:[{name:"vocab",val:" = None"},{name:"merges",val:" = None"},{name:"cache_capacity",val:" = None"},{name:"dropout",val:" = None"},{name:"unk_token",val:" = None"},{name:"continuing_subword_prefix",val:" = None"},{name:"end_of_word_suffix",val:" = None"},{name:"fuse_unk",val:" = None"}],parametersDescription:[{anchor:"tokenizers.models.BPE.vocab",description:`<strong>vocab</strong> (<code>Dict[str, int]</code>, <em>optional</em>) &#x2014;
A dictionnary of string keys and their ids <code>{&quot;am&quot;: 0,...}</code>`,name:"vocab"},{anchor:"tokenizers.models.BPE.merges",description:`<strong>merges</strong> (<code>List[Tuple[str, str]]</code>, <em>optional</em>) &#x2014;
A list of pairs of tokens (<code>Tuple[str, str]</code>) <code>[(&quot;a&quot;, &quot;b&quot;),...]</code>`,name:"merges"},{anchor:"tokenizers.models.BPE.cache_capacity",description:`<strong>cache_capacity</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The number of words that the BPE cache can contain. The cache allows
to speed-up the process by keeping the result of the merge operations
for a number of words.`,name:"cache_capacity"},{anchor:"tokenizers.models.BPE.dropout",description:`<strong>dropout</strong> (<code>float</code>, <em>optional</em>) &#x2014;
A float between 0 and 1 that represents the BPE dropout to use.`,name:"dropout"},{anchor:"tokenizers.models.BPE.unk_token",description:`<strong>unk_token</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The unknown token to be used by the model.`,name:"unk_token"},{anchor:"tokenizers.models.BPE.continuing_subword_prefix",description:`<strong>continuing_subword_prefix</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The prefix to attach to subword units that don&#x2019;t represent a beginning of word.`,name:"continuing_subword_prefix"},{anchor:"tokenizers.models.BPE.end_of_word_suffix",description:`<strong>end_of_word_suffix</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The suffix to attach to subword units that represent an end of word.`,name:"end_of_word_suffix"},{anchor:"tokenizers.models.BPE.fuse_unk",description:`<strong>fuse_unk</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether to fuse any subsequent unknown tokens into a single one`,name:"fuse_unk"}]}}),O=new W({props:{name:"from_file",anchor:"tokenizers.models.BPE.from_file",parameters:[{name:"vocab",val:""},{name:"merge",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"tokenizers.models.BPE.from_file.vocab",description:`<strong>vocab</strong> (<code>str</code>) &#x2014;
The path to a <code>vocab.json</code> file`,name:"vocab"},{anchor:"tokenizers.models.BPE.from_file.merges",description:`<strong>merges</strong> (<code>str</code>) &#x2014;
The path to a <code>merges.txt</code> file`,name:"merges"}],returnDescription:`
<p>An instance of BPE loaded from these files</p>
`,returnType:`
<p><a href="/docs/tokenizers/pr_1/en/api/models#tokenizers.models.BPE">BPE</a></p>
`}}),$e=new hn({props:{code:`vocab, merges = BPE.read_file(vocab_filename, merges_filename)
bpe = BPE(vocab, merges)`,highlighted:`vocab, merges = BPE.read_file(vocab_filename, merges_filename)
bpe = BPE(vocab, merges)`}}),_e=new W({props:{name:"read_file",anchor:"tokenizers.models.BPE.read_file",parameters:[{name:"vocab",val:""},{name:"merges",val:""}],parametersDescription:[{anchor:"tokenizers.models.BPE.read_file.vocab",description:`<strong>vocab</strong> (<code>str</code>) &#x2014;
The path to a <code>vocab.json</code> file`,name:"vocab"},{anchor:"tokenizers.models.BPE.read_file.merges",description:`<strong>merges</strong> (<code>str</code>) &#x2014;
The path to a <code>merges.txt</code> file`,name:"merges"}],returnDescription:`
<p>The vocabulary and merges loaded into memory</p>
`,returnType:`
<p>A <code>Tuple</code> with the vocab and the merges</p>
`}}),ke=new nt({}),Ee=new W({props:{name:"class tokenizers.models.Model",anchor:"tokenizers.models.Model",parameters:""}}),be=new W({props:{name:"get_trainer",anchor:"tokenizers.models.Model.get_trainer",parameters:"",returnDescription:`
<p>The Trainer used to train this model</p>
`,returnType:`
<p><code>Trainer</code></p>
`}}),Pe=new W({props:{name:"id_to_token",anchor:"tokenizers.models.Model.id_to_token",parameters:[{name:"id",val:""}],parametersDescription:[{anchor:"tokenizers.models.Model.id_to_token.id",description:`<strong>id</strong> (<code>int</code>) &#x2014;
An ID to convert to a token`,name:"id"}],returnDescription:`
<p>The token associated to the ID</p>
`,returnType:`
<p><code>str</code></p>
`}}),we=new W({props:{name:"save",anchor:"tokenizers.models.Model.save",parameters:[{name:"folder",val:""},{name:"prefix",val:""}],parametersDescription:[{anchor:"tokenizers.models.Model.save.folder",description:`<strong>folder</strong> (<code>str</code>) &#x2014;
The path to the target folder in which to save the various files`,name:"folder"},{anchor:"tokenizers.models.Model.save.prefix",description:`<strong>prefix</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional prefix, used to prefix each file name`,name:"prefix"}],returnDescription:`
<p>The list of saved files</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),ye=new W({props:{name:"token_to_id",anchor:"tokenizers.models.Model.token_to_id",parameters:[{name:"tokens",val:""}],parametersDescription:[{anchor:"tokenizers.models.Model.token_to_id.token",description:`<strong>token</strong> (<code>str</code>) &#x2014;
A token to convert to an ID`,name:"token"}],returnDescription:`
<p>The ID associated to the token</p>
`,returnType:`
<p><code>int</code></p>
`}}),ze=new W({props:{name:"tokenize",anchor:"tokenizers.models.Model.tokenize",parameters:[{name:"sequence",val:""}],parametersDescription:[{anchor:"tokenizers.models.Model.tokenize.sequence",description:`<strong>sequence</strong> (<code>str</code>) &#x2014;
A sequence to tokenize`,name:"sequence"}],returnDescription:`
<p>The generated tokens</p>
`,returnType:`
<p>A <code>List</code> of <code>Token</code></p>
`}}),xe=new nt({}),Te=new W({props:{name:"class tokenizers.models.Unigram",anchor:"tokenizers.models.Unigram",parameters:[{name:"vocab",val:""}],parametersDescription:[{anchor:"tokenizers.models.Unigram.vocab",description:`<strong>vocab</strong> (<code>List[Tuple[str, float]]</code>, <em>optional</em>) &#x2014;
A list of vocabulary items and their relative score [(&#x201C;am&#x201D;, -0.2442),&#x2026;]`,name:"vocab"}]}}),De=new nt({}),We=new W({props:{name:"class tokenizers.models.WordLevel",anchor:"tokenizers.models.WordLevel",parameters:[{name:"vocab",val:""},{name:"unk_token",val:""}],parametersDescription:[{anchor:"tokenizers.models.WordLevel.vocab",description:`<strong>vocab</strong> (<code>str</code>, <em>optional</em>) &#x2014;
A dictionnary of string keys and their ids <code>{&quot;am&quot;: 0,...}</code>`,name:"vocab"},{anchor:"tokenizers.models.WordLevel.unk_token",description:`<strong>unk_token</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The unknown token to be used by the model.`,name:"unk_token"}]}}),Ae=new W({props:{name:"from_file",anchor:"tokenizers.models.WordLevel.from_file",parameters:[{name:"vocab",val:""},{name:"unk_token",val:""}],parametersDescription:[{anchor:"tokenizers.models.WordLevel.from_file.vocab",description:`<strong>vocab</strong> (<code>str</code>) &#x2014;
The path to a <code>vocab.json</code> file`,name:"vocab"}],returnDescription:`
<p>An instance of WordLevel loaded from file</p>
`,returnType:`
<p><a
  href="/docs/tokenizers/pr_1/en/api/models#tokenizers.models.WordLevel"
>WordLevel</a></p>
`}}),Be=new hn({props:{code:`vocab = WordLevel.read_file(vocab_filename)
wordlevel = WordLevel(vocab)`,highlighted:`vocab = WordLevel.read_file(vocab_filename)
wordlevel = WordLevel(vocab)`}}),Ie=new W({props:{name:"read_file",anchor:"tokenizers.models.WordLevel.read_file",parameters:[{name:"vocab",val:""}],parametersDescription:[{anchor:"tokenizers.models.WordLevel.read_file.vocab",description:`<strong>vocab</strong> (<code>str</code>) &#x2014;
The path to a <code>vocab.json</code> file`,name:"vocab"}],returnDescription:`
<p>The vocabulary as a <code>dict</code></p>
`,returnType:`
<p><code>Dict[str, int]</code></p>
`}}),Le=new nt({}),Me=new W({props:{name:"class tokenizers.models.WordPiece",anchor:"tokenizers.models.WordPiece",parameters:[{name:"vocab",val:""},{name:"unk_token",val:""},{name:"max_input_chars_per_word",val:""}],parametersDescription:[{anchor:"tokenizers.models.WordPiece.vocab",description:`<strong>vocab</strong> (<code>Dict[str, int]</code>, <em>optional</em>) &#x2014;
A dictionnary of string keys and their ids <code>{&quot;am&quot;: 0,...}</code>`,name:"vocab"},{anchor:"tokenizers.models.WordPiece.unk_token",description:`<strong>unk_token</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The unknown token to be used by the model.`,name:"unk_token"},{anchor:"tokenizers.models.WordPiece.max_input_chars_per_word",description:`<strong>max_input_chars_per_word</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The maximum number of characters to authorize in a single word.`,name:"max_input_chars_per_word"}]}}),qe=new W({props:{name:"from_file",anchor:"tokenizers.models.WordPiece.from_file",parameters:[{name:"vocab",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"tokenizers.models.WordPiece.from_file.vocab",description:`<strong>vocab</strong> (<code>str</code>) &#x2014;
The path to a <code>vocab.txt</code> file`,name:"vocab"}],returnDescription:`
<p>An instance of WordPiece loaded from file</p>
`,returnType:`
<p><a
  href="/docs/tokenizers/pr_1/en/api/models#tokenizers.models.WordPiece"
>WordPiece</a></p>
`}}),Ne=new hn({props:{code:`vocab = WordPiece.read_file(vocab_filename)
wordpiece = WordPiece(vocab)`,highlighted:`vocab = WordPiece.read_file(vocab_filename)
wordpiece = WordPiece(vocab)`}}),Se=new W({props:{name:"read_file",anchor:"tokenizers.models.WordPiece.read_file",parameters:[{name:"vocab",val:""}],parametersDescription:[{anchor:"tokenizers.models.WordPiece.read_file.vocab",description:`<strong>vocab</strong> (<code>str</code>) &#x2014;
The path to a <code>vocab.txt</code> file`,name:"vocab"}],returnDescription:`
<p>The vocabulary as a <code>dict</code></p>
`,returnType:`
<p><code>Dict[str, int]</code></p>
`}}),{c(){d=r("h2"),f=r("a"),l=r("span"),v(h.$$.fragment),y=c(),x=r("span"),B=s("BPE"),q=c(),D=r("div"),v(C.$$.fragment),V=c(),U=r("p"),E=s("An implementation of the BPE (Byte-Pair Encoding) algorithm"),I=c(),z=r("div"),v(O.$$.fragment),je=c(),le=r("p"),mo=s("Instantiate a BPE model from the given files."),po=c(),at=r("p"),ho=s("This method is roughly equivalent to doing:"),fo=c(),v($e.$$.fragment),vo=c(),R=r("p"),uo=s("If you don\u2019t need to keep the "),st=r("code"),go=s("vocab, merges"),$o=s(` values lying around,
this method is more optimized than manually calling
`),it=r("code"),_o=s("read_file()"),ko=s(" to initialize a "),Ge=r("a"),Eo=s("BPE"),bo=c(),j=r("div"),v(_e.$$.fragment),Po=c(),te=r("p"),wo=s("Read a "),lt=r("code"),yo=s("vocab.json"),zo=s(" and a "),dt=r("code"),xo=s("merges.txt"),To=s(" files"),Do=c(),ct=r("p"),Wo=s(`This method provides a way to read and parse the content of these files,
returning the relevant data structures. If you want to instantiate some BPE models
from memory, this method gives you the expected input from the standard files.`),Gt=c(),oe=r("h2"),de=r("a"),mt=r("span"),v(ke.$$.fragment),Ao=c(),pt=r("span"),Bo=s("Model"),Ht=c(),w=r("div"),v(Ee.$$.fragment),Io=c(),ht=r("p"),Lo=s("Base class for all models"),Mo=c(),ft=r("p"),qo=s(`The model represents the actual tokenization algorithm. This is the part that
will contain and manage the learned vocabulary.`),No=c(),vt=r("p"),So=s("This class cannot be constructed directly. Please use one of the concrete models."),Co=c(),G=r("div"),v(be.$$.fragment),Vo=c(),He=r("p"),Uo=s("Get the associated "),ut=r("code"),Oo=s("Trainer"),Ro=c(),re=r("p"),jo=s("Retrieve the "),gt=r("code"),Go=s("Trainer"),Ho=s(` associated to this
`),Fe=r("a"),Fo=s("Model"),Jo=s("."),Ko=c(),ce=r("div"),v(Pe.$$.fragment),Qo=c(),$t=r("p"),Xo=s("Get the token associated to an ID"),Yo=c(),H=r("div"),v(we.$$.fragment),Zo=c(),_t=r("p"),er=s("Save the current model"),tr=c(),kt=r("p"),or=s(`Save the current model in the given folder, using the given prefix for the various
files that will get created.
Any file with the same name that already exists in this folder will be overwritten.`),rr=c(),me=r("div"),v(ye.$$.fragment),nr=c(),Et=r("p"),ar=s("Get the ID associated to a token"),sr=c(),pe=r("div"),v(ze.$$.fragment),ir=c(),bt=r("p"),lr=s("Tokenize a sequence"),Ft=c(),ne=r("h2"),he=r("a"),Pt=r("span"),v(xe.$$.fragment),dr=c(),wt=r("span"),cr=s("Unigram"),Jt=c(),ae=r("div"),v(Te.$$.fragment),mr=c(),yt=r("p"),pr=s("An implementation of the Unigram algorithm"),Kt=c(),se=r("h2"),fe=r("a"),zt=r("span"),v(De.$$.fragment),hr=c(),xt=r("span"),fr=s("WordLevel"),Qt=c(),A=r("div"),v(We.$$.fragment),vr=c(),Tt=r("p"),ur=s("An implementation of the WordLevel algorithm"),gr=c(),Dt=r("p"),$r=s("Most simple tokenizer model based on mapping tokens to their corresponding id."),_r=c(),L=r("div"),v(Ae.$$.fragment),kr=c(),Wt=r("p"),Er=s("Instantiate a WordLevel model from the given file"),br=c(),At=r("p"),Pr=s("This method is roughly equivalent to doing:"),wr=c(),v(Be.$$.fragment),yr=c(),F=r("p"),zr=s("If you don\u2019t need to keep the "),Bt=r("code"),xr=s("vocab"),Tr=s(` values lying around, this method is
more optimized than manually calling `),It=r("code"),Dr=s("read_file()"),Wr=s(` to
initialize a `),Je=r("a"),Ar=s("WordLevel"),Br=c(),J=r("div"),v(Ie.$$.fragment),Ir=c(),Ke=r("p"),Lr=s("Read a "),Lt=r("code"),Mr=s("vocab.json"),qr=c(),Mt=r("p"),Nr=s(`This method provides a way to read and parse the content of a vocabulary file,
returning the relevant data structures. If you want to instantiate some WordLevel models
from memory, this method gives you the expected input from the standard files.`),Xt=c(),ie=r("h2"),ve=r("a"),qt=r("span"),v(Le.$$.fragment),Sr=c(),Nt=r("span"),Cr=s("WordPiece"),Yt=c(),N=r("div"),v(Me.$$.fragment),Vr=c(),St=r("p"),Ur=s("An implementation of the WordPiece algorithm"),Or=c(),M=r("div"),v(qe.$$.fragment),Rr=c(),Ct=r("p"),jr=s("Instantiate a WordPiece model from the given file"),Gr=c(),Vt=r("p"),Hr=s("This method is roughly equivalent to doing:"),Fr=c(),v(Ne.$$.fragment),Jr=c(),K=r("p"),Kr=s("If you don\u2019t need to keep the "),Ut=r("code"),Qr=s("vocab"),Xr=s(` values lying around, this method is
more optimized than manually calling `),Ot=r("code"),Yr=s("read_file()"),Zr=s(` to
initialize a `),Qe=r("a"),en=s("WordPiece"),tn=c(),Q=r("div"),v(Se.$$.fragment),on=c(),Ce=r("p"),rn=s("Read a "),Rt=r("code"),nn=s("vocab.txt"),an=s(" file"),sn=c(),Ve=r("p"),ln=s("This method provides a way to read and parse the content of a standard "),jt=r("em"),dn=s("vocab.txt"),cn=s(`
file as used by the WordPiece Model, returning the relevant data structures. If you
want to instantiate some WordPiece models from memory, this method gives you the
expected input from the standard files.`),this.h()},l(o){d=n(o,"H2",{class:!0});var b=a(d);f=n(b,"A",{id:!0,class:!0,href:!0});var vn=a(f);l=n(vn,"SPAN",{});var un=a(l);u(h.$$.fragment,un),un.forEach(t),vn.forEach(t),y=m(b),x=n(b,"SPAN",{});var gn=a(x);B=i(gn,"BPE"),gn.forEach(t),b.forEach(t),q=m(o),D=n(o,"DIV",{class:!0});var ue=a(D);u(C.$$.fragment,ue),V=m(ue),U=n(ue,"P",{});var $n=a(U);E=i($n,"An implementation of the BPE (Byte-Pair Encoding) algorithm"),$n.forEach(t),I=m(ue),z=n(ue,"DIV",{class:!0});var X=a(z);u(O.$$.fragment,X),je=m(X),le=n(X,"P",{});var _n=a(le);mo=i(_n,"Instantiate a BPE model from the given files."),_n.forEach(t),po=m(X),at=n(X,"P",{});var kn=a(at);ho=i(kn,"This method is roughly equivalent to doing:"),kn.forEach(t),fo=m(X),u($e.$$.fragment,X),vo=m(X),R=n(X,"P",{});var Ue=a(R);uo=i(Ue,"If you don\u2019t need to keep the "),st=n(Ue,"CODE",{});var En=a(st);go=i(En,"vocab, merges"),En.forEach(t),$o=i(Ue,` values lying around,
this method is more optimized than manually calling
`),it=n(Ue,"CODE",{});var bn=a(it);_o=i(bn,"read_file()"),bn.forEach(t),ko=i(Ue," to initialize a "),Ge=n(Ue,"A",{href:!0});var Pn=a(Ge);Eo=i(Pn,"BPE"),Pn.forEach(t),Ue.forEach(t),X.forEach(t),bo=m(ue),j=n(ue,"DIV",{class:!0});var Xe=a(j);u(_e.$$.fragment,Xe),Po=m(Xe),te=n(Xe,"P",{});var Ye=a(te);wo=i(Ye,"Read a "),lt=n(Ye,"CODE",{});var wn=a(lt);yo=i(wn,"vocab.json"),wn.forEach(t),zo=i(Ye," and a "),dt=n(Ye,"CODE",{});var yn=a(dt);xo=i(yn,"merges.txt"),yn.forEach(t),To=i(Ye," files"),Ye.forEach(t),Do=m(Xe),ct=n(Xe,"P",{});var zn=a(ct);Wo=i(zn,`This method provides a way to read and parse the content of these files,
returning the relevant data structures. If you want to instantiate some BPE models
from memory, this method gives you the expected input from the standard files.`),zn.forEach(t),Xe.forEach(t),ue.forEach(t),Gt=m(o),oe=n(o,"H2",{class:!0});var eo=a(oe);de=n(eo,"A",{id:!0,class:!0,href:!0});var xn=a(de);mt=n(xn,"SPAN",{});var Tn=a(mt);u(ke.$$.fragment,Tn),Tn.forEach(t),xn.forEach(t),Ao=m(eo),pt=n(eo,"SPAN",{});var Dn=a(pt);Bo=i(Dn,"Model"),Dn.forEach(t),eo.forEach(t),Ht=m(o),w=n(o,"DIV",{class:!0});var T=a(w);u(Ee.$$.fragment,T),Io=m(T),ht=n(T,"P",{});var Wn=a(ht);Lo=i(Wn,"Base class for all models"),Wn.forEach(t),Mo=m(T),ft=n(T,"P",{});var An=a(ft);qo=i(An,`The model represents the actual tokenization algorithm. This is the part that
will contain and manage the learned vocabulary.`),An.forEach(t),No=m(T),vt=n(T,"P",{});var Bn=a(vt);So=i(Bn,"This class cannot be constructed directly. Please use one of the concrete models."),Bn.forEach(t),Co=m(T),G=n(T,"DIV",{class:!0});var Ze=a(G);u(be.$$.fragment,Ze),Vo=m(Ze),He=n(Ze,"P",{});var mn=a(He);Uo=i(mn,"Get the associated "),ut=n(mn,"CODE",{});var In=a(ut);Oo=i(In,"Trainer"),In.forEach(t),mn.forEach(t),Ro=m(Ze),re=n(Ze,"P",{});var et=a(re);jo=i(et,"Retrieve the "),gt=n(et,"CODE",{});var Ln=a(gt);Go=i(Ln,"Trainer"),Ln.forEach(t),Ho=i(et,` associated to this
`),Fe=n(et,"A",{href:!0});var Mn=a(Fe);Fo=i(Mn,"Model"),Mn.forEach(t),Jo=i(et,"."),et.forEach(t),Ze.forEach(t),Ko=m(T),ce=n(T,"DIV",{class:!0});var to=a(ce);u(Pe.$$.fragment,to),Qo=m(to),$t=n(to,"P",{});var qn=a($t);Xo=i(qn,"Get the token associated to an ID"),qn.forEach(t),to.forEach(t),Yo=m(T),H=n(T,"DIV",{class:!0});var tt=a(H);u(we.$$.fragment,tt),Zo=m(tt),_t=n(tt,"P",{});var Nn=a(_t);er=i(Nn,"Save the current model"),Nn.forEach(t),tr=m(tt),kt=n(tt,"P",{});var Sn=a(kt);or=i(Sn,`Save the current model in the given folder, using the given prefix for the various
files that will get created.
Any file with the same name that already exists in this folder will be overwritten.`),Sn.forEach(t),tt.forEach(t),rr=m(T),me=n(T,"DIV",{class:!0});var oo=a(me);u(ye.$$.fragment,oo),nr=m(oo),Et=n(oo,"P",{});var Cn=a(Et);ar=i(Cn,"Get the ID associated to a token"),Cn.forEach(t),oo.forEach(t),sr=m(T),pe=n(T,"DIV",{class:!0});var ro=a(pe);u(ze.$$.fragment,ro),ir=m(ro),bt=n(ro,"P",{});var Vn=a(bt);lr=i(Vn,"Tokenize a sequence"),Vn.forEach(t),ro.forEach(t),T.forEach(t),Ft=m(o),ne=n(o,"H2",{class:!0});var no=a(ne);he=n(no,"A",{id:!0,class:!0,href:!0});var Un=a(he);Pt=n(Un,"SPAN",{});var On=a(Pt);u(xe.$$.fragment,On),On.forEach(t),Un.forEach(t),dr=m(no),wt=n(no,"SPAN",{});var Rn=a(wt);cr=i(Rn,"Unigram"),Rn.forEach(t),no.forEach(t),Jt=m(o),ae=n(o,"DIV",{class:!0});var ao=a(ae);u(Te.$$.fragment,ao),mr=m(ao),yt=n(ao,"P",{});var jn=a(yt);pr=i(jn,"An implementation of the Unigram algorithm"),jn.forEach(t),ao.forEach(t),Kt=m(o),se=n(o,"H2",{class:!0});var so=a(se);fe=n(so,"A",{id:!0,class:!0,href:!0});var Gn=a(fe);zt=n(Gn,"SPAN",{});var Hn=a(zt);u(De.$$.fragment,Hn),Hn.forEach(t),Gn.forEach(t),hr=m(so),xt=n(so,"SPAN",{});var Fn=a(xt);fr=i(Fn,"WordLevel"),Fn.forEach(t),so.forEach(t),Qt=m(o),A=n(o,"DIV",{class:!0});var Y=a(A);u(We.$$.fragment,Y),vr=m(Y),Tt=n(Y,"P",{});var Jn=a(Tt);ur=i(Jn,"An implementation of the WordLevel algorithm"),Jn.forEach(t),gr=m(Y),Dt=n(Y,"P",{});var Kn=a(Dt);$r=i(Kn,"Most simple tokenizer model based on mapping tokens to their corresponding id."),Kn.forEach(t),_r=m(Y),L=n(Y,"DIV",{class:!0});var Z=a(L);u(Ae.$$.fragment,Z),kr=m(Z),Wt=n(Z,"P",{});var Qn=a(Wt);Er=i(Qn,"Instantiate a WordLevel model from the given file"),Qn.forEach(t),br=m(Z),At=n(Z,"P",{});var Xn=a(At);Pr=i(Xn,"This method is roughly equivalent to doing:"),Xn.forEach(t),wr=m(Z),u(Be.$$.fragment,Z),yr=m(Z),F=n(Z,"P",{});var Oe=a(F);zr=i(Oe,"If you don\u2019t need to keep the "),Bt=n(Oe,"CODE",{});var Yn=a(Bt);xr=i(Yn,"vocab"),Yn.forEach(t),Tr=i(Oe,` values lying around, this method is
more optimized than manually calling `),It=n(Oe,"CODE",{});var Zn=a(It);Dr=i(Zn,"read_file()"),Zn.forEach(t),Wr=i(Oe,` to
initialize a `),Je=n(Oe,"A",{href:!0});var ea=a(Je);Ar=i(ea,"WordLevel"),ea.forEach(t),Oe.forEach(t),Z.forEach(t),Br=m(Y),J=n(Y,"DIV",{class:!0});var ot=a(J);u(Ie.$$.fragment,ot),Ir=m(ot),Ke=n(ot,"P",{});var pn=a(Ke);Lr=i(pn,"Read a "),Lt=n(pn,"CODE",{});var ta=a(Lt);Mr=i(ta,"vocab.json"),ta.forEach(t),pn.forEach(t),qr=m(ot),Mt=n(ot,"P",{});var oa=a(Mt);Nr=i(oa,`This method provides a way to read and parse the content of a vocabulary file,
returning the relevant data structures. If you want to instantiate some WordLevel models
from memory, this method gives you the expected input from the standard files.`),oa.forEach(t),ot.forEach(t),Y.forEach(t),Xt=m(o),ie=n(o,"H2",{class:!0});var io=a(ie);ve=n(io,"A",{id:!0,class:!0,href:!0});var ra=a(ve);qt=n(ra,"SPAN",{});var na=a(qt);u(Le.$$.fragment,na),na.forEach(t),ra.forEach(t),Sr=m(io),Nt=n(io,"SPAN",{});var aa=a(Nt);Cr=i(aa,"WordPiece"),aa.forEach(t),io.forEach(t),Yt=m(o),N=n(o,"DIV",{class:!0});var ge=a(N);u(Me.$$.fragment,ge),Vr=m(ge),St=n(ge,"P",{});var sa=a(St);Ur=i(sa,"An implementation of the WordPiece algorithm"),sa.forEach(t),Or=m(ge),M=n(ge,"DIV",{class:!0});var ee=a(M);u(qe.$$.fragment,ee),Rr=m(ee),Ct=n(ee,"P",{});var ia=a(Ct);jr=i(ia,"Instantiate a WordPiece model from the given file"),ia.forEach(t),Gr=m(ee),Vt=n(ee,"P",{});var la=a(Vt);Hr=i(la,"This method is roughly equivalent to doing:"),la.forEach(t),Fr=m(ee),u(Ne.$$.fragment,ee),Jr=m(ee),K=n(ee,"P",{});var Re=a(K);Kr=i(Re,"If you don\u2019t need to keep the "),Ut=n(Re,"CODE",{});var da=a(Ut);Qr=i(da,"vocab"),da.forEach(t),Xr=i(Re,` values lying around, this method is
more optimized than manually calling `),Ot=n(Re,"CODE",{});var ca=a(Ot);Yr=i(ca,"read_file()"),ca.forEach(t),Zr=i(Re,` to
initialize a `),Qe=n(Re,"A",{href:!0});var ma=a(Qe);en=i(ma,"WordPiece"),ma.forEach(t),Re.forEach(t),ee.forEach(t),tn=m(ge),Q=n(ge,"DIV",{class:!0});var rt=a(Q);u(Se.$$.fragment,rt),on=m(rt),Ce=n(rt,"P",{});var lo=a(Ce);rn=i(lo,"Read a "),Rt=n(lo,"CODE",{});var pa=a(Rt);nn=i(pa,"vocab.txt"),pa.forEach(t),an=i(lo," file"),lo.forEach(t),sn=m(rt),Ve=n(rt,"P",{});var co=a(Ve);ln=i(co,"This method provides a way to read and parse the content of a standard "),jt=n(co,"EM",{});var ha=a(jt);dn=i(ha,"vocab.txt"),ha.forEach(t),cn=i(co,`
file as used by the WordPiece Model, returning the relevant data structures. If you
want to instantiate some WordPiece models from memory, this method gives you the
expected input from the standard files.`),co.forEach(t),rt.forEach(t),ge.forEach(t),this.h()},h(){p(f,"id","tokenizers.models.BPE]][[tokenizers.models.BPE"),p(f,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(f,"href","#tokenizers.models.BPE]][[tokenizers.models.BPE"),p(d,"class","relative group"),p(Ge,"href","/docs/tokenizers/pr_1/en/api/models#tokenizers.models.BPE"),p(z,"class","docstring"),p(j,"class","docstring"),p(D,"class","docstring"),p(de,"id","tokenizers.models.Model]][[tokenizers.models.Model"),p(de,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(de,"href","#tokenizers.models.Model]][[tokenizers.models.Model"),p(oe,"class","relative group"),p(Fe,"href","/docs/tokenizers/pr_1/en/api/models#tokenizers.models.Model"),p(G,"class","docstring"),p(ce,"class","docstring"),p(H,"class","docstring"),p(me,"class","docstring"),p(pe,"class","docstring"),p(w,"class","docstring"),p(he,"id","tokenizers.models.Unigram]][[tokenizers.models.Unigram"),p(he,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(he,"href","#tokenizers.models.Unigram]][[tokenizers.models.Unigram"),p(ne,"class","relative group"),p(ae,"class","docstring"),p(fe,"id","tokenizers.models.WordLevel]][[tokenizers.models.WordLevel"),p(fe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(fe,"href","#tokenizers.models.WordLevel]][[tokenizers.models.WordLevel"),p(se,"class","relative group"),p(Je,"href","/docs/tokenizers/pr_1/en/api/models#tokenizers.models.WordLevel"),p(L,"class","docstring"),p(J,"class","docstring"),p(A,"class","docstring"),p(ve,"id","tokenizers.models.WordPiece]][[tokenizers.models.WordPiece"),p(ve,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(ve,"href","#tokenizers.models.WordPiece]][[tokenizers.models.WordPiece"),p(ie,"class","relative group"),p(Qe,"href","/docs/tokenizers/pr_1/en/api/models#tokenizers.models.WordPiece"),p(M,"class","docstring"),p(Q,"class","docstring"),p(N,"class","docstring")},m(o,b){P(o,d,b),e(d,f),e(f,l),g(h,l,null),e(d,y),e(d,x),e(x,B),P(o,q,b),P(o,D,b),g(C,D,null),e(D,V),e(D,U),e(U,E),e(D,I),e(D,z),g(O,z,null),e(z,je),e(z,le),e(le,mo),e(z,po),e(z,at),e(at,ho),e(z,fo),g($e,z,null),e(z,vo),e(z,R),e(R,uo),e(R,st),e(st,go),e(R,$o),e(R,it),e(it,_o),e(R,ko),e(R,Ge),e(Ge,Eo),e(D,bo),e(D,j),g(_e,j,null),e(j,Po),e(j,te),e(te,wo),e(te,lt),e(lt,yo),e(te,zo),e(te,dt),e(dt,xo),e(te,To),e(j,Do),e(j,ct),e(ct,Wo),P(o,Gt,b),P(o,oe,b),e(oe,de),e(de,mt),g(ke,mt,null),e(oe,Ao),e(oe,pt),e(pt,Bo),P(o,Ht,b),P(o,w,b),g(Ee,w,null),e(w,Io),e(w,ht),e(ht,Lo),e(w,Mo),e(w,ft),e(ft,qo),e(w,No),e(w,vt),e(vt,So),e(w,Co),e(w,G),g(be,G,null),e(G,Vo),e(G,He),e(He,Uo),e(He,ut),e(ut,Oo),e(G,Ro),e(G,re),e(re,jo),e(re,gt),e(gt,Go),e(re,Ho),e(re,Fe),e(Fe,Fo),e(re,Jo),e(w,Ko),e(w,ce),g(Pe,ce,null),e(ce,Qo),e(ce,$t),e($t,Xo),e(w,Yo),e(w,H),g(we,H,null),e(H,Zo),e(H,_t),e(_t,er),e(H,tr),e(H,kt),e(kt,or),e(w,rr),e(w,me),g(ye,me,null),e(me,nr),e(me,Et),e(Et,ar),e(w,sr),e(w,pe),g(ze,pe,null),e(pe,ir),e(pe,bt),e(bt,lr),P(o,Ft,b),P(o,ne,b),e(ne,he),e(he,Pt),g(xe,Pt,null),e(ne,dr),e(ne,wt),e(wt,cr),P(o,Jt,b),P(o,ae,b),g(Te,ae,null),e(ae,mr),e(ae,yt),e(yt,pr),P(o,Kt,b),P(o,se,b),e(se,fe),e(fe,zt),g(De,zt,null),e(se,hr),e(se,xt),e(xt,fr),P(o,Qt,b),P(o,A,b),g(We,A,null),e(A,vr),e(A,Tt),e(Tt,ur),e(A,gr),e(A,Dt),e(Dt,$r),e(A,_r),e(A,L),g(Ae,L,null),e(L,kr),e(L,Wt),e(Wt,Er),e(L,br),e(L,At),e(At,Pr),e(L,wr),g(Be,L,null),e(L,yr),e(L,F),e(F,zr),e(F,Bt),e(Bt,xr),e(F,Tr),e(F,It),e(It,Dr),e(F,Wr),e(F,Je),e(Je,Ar),e(A,Br),e(A,J),g(Ie,J,null),e(J,Ir),e(J,Ke),e(Ke,Lr),e(Ke,Lt),e(Lt,Mr),e(J,qr),e(J,Mt),e(Mt,Nr),P(o,Xt,b),P(o,ie,b),e(ie,ve),e(ve,qt),g(Le,qt,null),e(ie,Sr),e(ie,Nt),e(Nt,Cr),P(o,Yt,b),P(o,N,b),g(Me,N,null),e(N,Vr),e(N,St),e(St,Ur),e(N,Or),e(N,M),g(qe,M,null),e(M,Rr),e(M,Ct),e(Ct,jr),e(M,Gr),e(M,Vt),e(Vt,Hr),e(M,Fr),g(Ne,M,null),e(M,Jr),e(M,K),e(K,Kr),e(K,Ut),e(Ut,Qr),e(K,Xr),e(K,Ot),e(Ot,Yr),e(K,Zr),e(K,Qe),e(Qe,en),e(N,tn),e(N,Q),g(Se,Q,null),e(Q,on),e(Q,Ce),e(Ce,rn),e(Ce,Rt),e(Rt,nn),e(Ce,an),e(Q,sn),e(Q,Ve),e(Ve,ln),e(Ve,jt),e(jt,dn),e(Ve,cn),Zt=!0},p:_a,i(o){Zt||($(h.$$.fragment,o),$(C.$$.fragment,o),$(O.$$.fragment,o),$($e.$$.fragment,o),$(_e.$$.fragment,o),$(ke.$$.fragment,o),$(Ee.$$.fragment,o),$(be.$$.fragment,o),$(Pe.$$.fragment,o),$(we.$$.fragment,o),$(ye.$$.fragment,o),$(ze.$$.fragment,o),$(xe.$$.fragment,o),$(Te.$$.fragment,o),$(De.$$.fragment,o),$(We.$$.fragment,o),$(Ae.$$.fragment,o),$(Be.$$.fragment,o),$(Ie.$$.fragment,o),$(Le.$$.fragment,o),$(Me.$$.fragment,o),$(qe.$$.fragment,o),$(Ne.$$.fragment,o),$(Se.$$.fragment,o),Zt=!0)},o(o){_(h.$$.fragment,o),_(C.$$.fragment,o),_(O.$$.fragment,o),_($e.$$.fragment,o),_(_e.$$.fragment,o),_(ke.$$.fragment,o),_(Ee.$$.fragment,o),_(be.$$.fragment,o),_(Pe.$$.fragment,o),_(we.$$.fragment,o),_(ye.$$.fragment,o),_(ze.$$.fragment,o),_(xe.$$.fragment,o),_(Te.$$.fragment,o),_(De.$$.fragment,o),_(We.$$.fragment,o),_(Ae.$$.fragment,o),_(Be.$$.fragment,o),_(Ie.$$.fragment,o),_(Le.$$.fragment,o),_(Me.$$.fragment,o),_(qe.$$.fragment,o),_(Ne.$$.fragment,o),_(Se.$$.fragment,o),Zt=!1},d(o){o&&t(d),k(h),o&&t(q),o&&t(D),k(C),k(O),k($e),k(_e),o&&t(Gt),o&&t(oe),k(ke),o&&t(Ht),o&&t(w),k(Ee),k(be),k(Pe),k(we),k(ye),k(ze),o&&t(Ft),o&&t(ne),k(xe),o&&t(Jt),o&&t(ae),k(Te),o&&t(Kt),o&&t(se),k(De),o&&t(Qt),o&&t(A),k(We),k(Ae),k(Be),k(Ie),o&&t(Xt),o&&t(ie),k(Le),o&&t(Yt),o&&t(N),k(Me),k(qe),k(Ne),k(Se)}}}function ba(S){let d,f;return d=new fn({props:{$$slots:{default:[Ea]},$$scope:{ctx:S}}}),{c(){v(d.$$.fragment)},l(l){u(d.$$.fragment,l)},m(l,h){g(d,l,h),f=!0},p(l,h){const y={};h&2&&(y.$$scope={dirty:h,ctx:l}),d.$set(y)},i(l){f||($(d.$$.fragment,l),f=!0)},o(l){_(d.$$.fragment,l),f=!1},d(l){k(d,l)}}}function Pa(S){let d,f,l,h,y;return{c(){d=r("p"),f=s("The Rust API Reference is available directly on the "),l=r("a"),h=s("Docs.rs"),y=s(" website."),this.h()},l(x){d=n(x,"P",{});var B=a(d);f=i(B,"The Rust API Reference is available directly on the "),l=n(B,"A",{href:!0,rel:!0});var q=a(l);h=i(q,"Docs.rs"),q.forEach(t),y=i(B," website."),B.forEach(t),this.h()},h(){p(l,"href","https://docs.rs/tokenizers/latest/tokenizers/"),p(l,"rel","nofollow")},m(x,B){P(x,d,B),e(d,f),e(d,l),e(l,h),e(d,y)},d(x){x&&t(d)}}}function wa(S){let d,f;return d=new fn({props:{$$slots:{default:[Pa]},$$scope:{ctx:S}}}),{c(){v(d.$$.fragment)},l(l){u(d.$$.fragment,l)},m(l,h){g(d,l,h),f=!0},p(l,h){const y={};h&2&&(y.$$scope={dirty:h,ctx:l}),d.$set(y)},i(l){f||($(d.$$.fragment,l),f=!0)},o(l){_(d.$$.fragment,l),f=!1},d(l){k(d,l)}}}function ya(S){let d,f;return{c(){d=r("p"),f=s("The node API has not been documented yet.")},l(l){d=n(l,"P",{});var h=a(d);f=i(h,"The node API has not been documented yet."),h.forEach(t)},m(l,h){P(l,d,h),e(d,f)},d(l){l&&t(d)}}}function za(S){let d,f;return d=new fn({props:{$$slots:{default:[ya]},$$scope:{ctx:S}}}),{c(){v(d.$$.fragment)},l(l){u(d.$$.fragment,l)},m(l,h){g(d,l,h),f=!0},p(l,h){const y={};h&2&&(y.$$scope={dirty:h,ctx:l}),d.$set(y)},i(l){f||($(d.$$.fragment,l),f=!0)},o(l){_(d.$$.fragment,l),f=!1},d(l){k(d,l)}}}function xa(S){let d,f,l,h,y,x,B,q,D,C,V,U;return x=new nt({}),V=new ka({props:{python:!0,rust:!0,node:!0,$$slots:{node:[za],rust:[wa],python:[ba]},$$scope:{ctx:S}}}),{c(){d=r("meta"),f=c(),l=r("h1"),h=r("a"),y=r("span"),v(x.$$.fragment),B=c(),q=r("span"),D=s("Models"),C=c(),v(V.$$.fragment),this.h()},l(E){const I=ga('[data-svelte="svelte-1phssyn"]',document.head);d=n(I,"META",{name:!0,content:!0}),I.forEach(t),f=m(E),l=n(E,"H1",{class:!0});var z=a(l);h=n(z,"A",{id:!0,class:!0,href:!0});var O=a(h);y=n(O,"SPAN",{});var je=a(y);u(x.$$.fragment,je),je.forEach(t),O.forEach(t),B=m(z),q=n(z,"SPAN",{});var le=a(q);D=i(le,"Models"),le.forEach(t),z.forEach(t),C=m(E),u(V.$$.fragment,E),this.h()},h(){p(d,"name","hf:doc:metadata"),p(d,"content",JSON.stringify(Ta)),p(h,"id","models"),p(h,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(h,"href","#models"),p(l,"class","relative group")},m(E,I){e(document.head,d),P(E,f,I),P(E,l,I),e(l,h),e(h,y),g(x,y,null),e(l,B),e(l,q),e(q,D),P(E,C,I),g(V,E,I),U=!0},p(E,[I]){const z={};I&2&&(z.$$scope={dirty:I,ctx:E}),V.$set(z)},i(E){U||($(x.$$.fragment,E),$(V.$$.fragment,E),U=!0)},o(E){_(x.$$.fragment,E),_(V.$$.fragment,E),U=!1},d(E){t(d),E&&t(f),E&&t(l),k(x),E&&t(C),k(V,E)}}}const Ta={local:"models",sections:[{local:"tokenizers.models.BPE]][[tokenizers.models.BPE",title:"BPE"},{local:"tokenizers.models.Model]][[tokenizers.models.Model",title:"Model"},{local:"tokenizers.models.Unigram]][[tokenizers.models.Unigram",title:"Unigram"},{local:"tokenizers.models.WordLevel]][[tokenizers.models.WordLevel",title:"WordLevel"},{local:"tokenizers.models.WordPiece]][[tokenizers.models.WordPiece",title:"WordPiece"}],title:"Models"};function Da(S){return $a(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Ma extends fa{constructor(d){super();va(this,d,Da,xa,ua,{})}}export{Ma as default,Ta as metadata};
