import{S as to,i as ao,s as ro,e as t,k as u,w as K,t as s,M as io,c as a,d as o,m,a as r,x as Q,h as l,b as z,F as e,g as x,y as X,q as Y,o as Z,B as ee}from"../../chunks/vendor-7b1da053.js";import{T as xe}from"../../chunks/Tip-41a95816.js";import{D as Te}from"../../chunks/Docstring-f1352b16.js";import{C as so}from"../../chunks/CodeBlock-5f39b59e.js";import{I as lo}from"../../chunks/IconCopyLink-d24e9a6f.js";function co(G){let h,I,p,i,g,_,q,C,E,T,w,k,b,y,c,$,O,v,f,P,S;return{c(){h=t("p"),I=s("Raises the following errors:"),p=u(),i=t("ul"),g=t("li"),_=t("em"),q=s("EnvironmentError"),C=s(" if "),E=t("em"),T=s("use_auth_token=True"),w=s(" and the token cannot be found."),k=u(),b=t("li"),y=t("em"),c=s("OSError"),$=s(" if ETag cannot be determined."),O=u(),v=t("li"),f=t("em"),P=s("ValueError"),S=s(" if the file cannot be downloaded and cannot be found locally.")},l(d){h=a(d,"P",{});var N=r(h);I=l(N,"Raises the following errors:"),N.forEach(o),p=m(d),i=a(d,"UL",{});var D=r(i);g=a(D,"LI",{});var L=r(g);_=a(L,"EM",{});var V=r(_);q=l(V,"EnvironmentError"),V.forEach(o),C=l(L," if "),E=a(L,"EM",{});var W=r(E);T=l(W,"use_auth_token=True"),W.forEach(o),w=l(L," and the token cannot be found."),L.forEach(o),k=m(D),b=a(D,"LI",{});var j=r(b);y=a(j,"EM",{});var B=r(y);c=l(B,"OSError"),B.forEach(o),$=l(j," if ETag cannot be determined."),j.forEach(o),O=m(D),v=a(D,"LI",{});var M=r(v);f=a(M,"EM",{});var F=r(f);P=l(F,"ValueError"),F.forEach(o),S=l(M," if the file cannot be downloaded and cannot be found locally."),M.forEach(o),D.forEach(o)},m(d,N){x(d,h,N),e(h,I),x(d,p,N),x(d,i,N),e(i,g),e(g,_),e(_,q),e(g,C),e(g,E),e(E,T),e(g,w),e(i,k),e(i,b),e(b,y),e(y,c),e(b,$),e(i,O),e(i,v),e(v,f),e(f,P),e(v,S)},d(d){d&&o(h),d&&o(p),d&&o(i)}}}function ho(G){let h,I,p,i,g,_,q,C,E,T,w,k,b,y,c,$,O,v,f,P,S;return{c(){h=t("p"),I=s("Raises the following errors:"),p=u(),i=t("ul"),g=t("li"),_=t("em"),q=s("EnvironmentError"),C=s(" if "),E=t("em"),T=s("use_auth_token=True"),w=s(" and the token cannot be found."),k=u(),b=t("li"),y=t("em"),c=s("OSError"),$=s(" if ETag cannot be determined."),O=u(),v=t("li"),f=t("em"),P=s("ValueError"),S=s(" if the file cannot be downloaded and cannot be found locally.")},l(d){h=a(d,"P",{});var N=r(h);I=l(N,"Raises the following errors:"),N.forEach(o),p=m(d),i=a(d,"UL",{});var D=r(i);g=a(D,"LI",{});var L=r(g);_=a(L,"EM",{});var V=r(_);q=l(V,"EnvironmentError"),V.forEach(o),C=l(L," if "),E=a(L,"EM",{});var W=r(E);T=l(W,"use_auth_token=True"),W.forEach(o),w=l(L," and the token cannot be found."),L.forEach(o),k=m(D),b=a(D,"LI",{});var j=r(b);y=a(j,"EM",{});var B=r(y);c=l(B,"OSError"),B.forEach(o),$=l(j," if ETag cannot be determined."),j.forEach(o),O=m(D),v=a(D,"LI",{});var M=r(v);f=a(M,"EM",{});var F=r(f);P=l(F,"ValueError"),F.forEach(o),S=l(M," if the file cannot be downloaded and cannot be found locally."),M.forEach(o),D.forEach(o)},m(d,N){x(d,h,N),e(h,I),x(d,p,N),x(d,i,N),e(i,g),e(g,_),e(_,q),e(g,C),e(g,E),e(E,T),e(g,w),e(i,k),e(i,b),e(b,y),e(y,c),e(b,$),e(i,O),e(i,v),e(v,f),e(f,P),e(v,S)},d(d){d&&o(h),d&&o(p),d&&o(i)}}}function fo(G){let h,I,p,i,g,_,q,C,E,T,w,k,b,y,c,$,O,v,f,P,S;return{c(){h=t("p"),I=s("Raises the following errors:"),p=u(),i=t("ul"),g=t("li"),_=t("code"),q=s("EnvironmentError"),C=s(" if "),E=t("code"),T=s("use_auth_token=True"),w=s(" and the token cannot be found."),k=u(),b=t("li"),y=t("code"),c=s("OSError"),$=s(" if ETag cannot be determined."),O=u(),v=t("li"),f=t("code"),P=s("ValueError"),S=s(" if the file cannot be downloaded and cannot be found locally.")},l(d){h=a(d,"P",{});var N=r(h);I=l(N,"Raises the following errors:"),N.forEach(o),p=m(d),i=a(d,"UL",{});var D=r(i);g=a(D,"LI",{});var L=r(g);_=a(L,"CODE",{});var V=r(_);q=l(V,"EnvironmentError"),V.forEach(o),C=l(L," if "),E=a(L,"CODE",{});var W=r(E);T=l(W,"use_auth_token=True"),W.forEach(o),w=l(L," and the token cannot be found."),L.forEach(o),k=m(D),b=a(D,"LI",{});var j=r(b);y=a(j,"CODE",{});var B=r(y);c=l(B,"OSError"),B.forEach(o),$=l(j," if ETag cannot be determined."),j.forEach(o),O=m(D),v=a(D,"LI",{});var M=r(v);f=a(M,"CODE",{});var F=r(f);P=l(F,"ValueError"),F.forEach(o),S=l(M," if the file cannot be downloaded and cannot be found locally."),M.forEach(o),D.forEach(o)},m(d,N){x(d,h,N),e(h,I),x(d,p,N),x(d,i,N),e(i,g),e(g,_),e(_,q),e(g,C),e(g,E),e(E,T),e(g,w),e(i,k),e(i,b),e(b,y),e(y,c),e(b,$),e(i,O),e(i,v),e(v,f),e(f,P),e(v,S)},d(d){d&&o(h),d&&o(p),d&&o(i)}}}function go(G){let h,I,p,i,g,_,q,C,E,T,w,k,b,y;return{c(){h=t("p"),I=s("Notes:"),p=u(),i=t("p"),g=s(`Cloudfront is replicated over the globe so downloads are way faster for
the end user (and it also lowers our bandwidth costs).`),_=u(),q=t("p"),C=s(`Cloudfront aggressively caches files by default (default TTL is 24
hours), however this is not an issue here because we implement a
git-based versioning system on huggingface.co, which means that we
store the files on S3/Cloudfront in a content-addressable way (i.e.,
the file name is its hash). Using content-addressable filenames means
cache can\u2019t ever be stale.`),E=u(),T=t("p"),w=s(`In terms of client-side caching from this library, we base our caching
on the objects\u2019 entity tag (`),k=t("em"),b=s("ETag"),y=s(`), which is an identifier of a
specific version of a resource [1]_. An object\u2019s ETag is: its git-sha1
if stored in git, or its sha256 if stored in git-lfs.`)},l(c){h=a(c,"P",{});var $=r(h);I=l($,"Notes:"),$.forEach(o),p=m(c),i=a(c,"P",{});var O=r(i);g=l(O,`Cloudfront is replicated over the globe so downloads are way faster for
the end user (and it also lowers our bandwidth costs).`),O.forEach(o),_=m(c),q=a(c,"P",{});var v=r(q);C=l(v,`Cloudfront aggressively caches files by default (default TTL is 24
hours), however this is not an issue here because we implement a
git-based versioning system on huggingface.co, which means that we
store the files on S3/Cloudfront in a content-addressable way (i.e.,
the file name is its hash). Using content-addressable filenames means
cache can\u2019t ever be stale.`),v.forEach(o),E=m(c),T=a(c,"P",{});var f=r(T);w=l(f,`In terms of client-side caching from this library, we base our caching
on the objects\u2019 entity tag (`),k=a(f,"EM",{});var P=r(k);b=l(P,"ETag"),P.forEach(o),y=l(f,`), which is an identifier of a
specific version of a resource [1]_. An object\u2019s ETag is: its git-sha1
if stored in git, or its sha256 if stored in git-lfs.`),f.forEach(o)},m(c,$){x(c,h,$),e(h,I),x(c,p,$),x(c,i,$),e(i,g),x(c,_,$),x(c,q,$),e(q,C),x(c,E,$),x(c,T,$),e(T,w),e(T,k),e(k,b),e(T,y)},d(c){c&&o(h),c&&o(p),c&&o(i),c&&o(_),c&&o(q),c&&o(E),c&&o(T)}}}function uo(G){let h,I,p,i,g,_,q,C,E,T,w,k,b,y,c,$,O,v,f,P,S,d,N,D,L,V,W,j,B,M,F,ye,H,ae,ke,he,Ne,De,fe,Oe,Le,oe,Ee,A,re,Ie,ge,qe,Pe,ue,Ue,Ce,me,Ae,je,ie,Fe,ne,Re,pe,Se,Me,_e,de,He,se,Ve,$e;return _=new lo({}),k=new Te({props:{name:"huggingface_hub.hf_hub_download",anchor:"huggingface_hub.hf_hub_download",parameters:[{name:"repo_id",val:": str"},{name:"filename",val:": str"},{name:"subfolder",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"force_download",val:": typing.Optional[bool] = False"},{name:"force_filename",val:": typing.Optional[str] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_7/src/huggingface_hub/file_download.py#L632",parametersDescription:[{anchor:"huggingface_hub.hf_hub_download.repo_id",description:`<strong>repo_id</strong> (<em>str</em>) &#x2014;
A user or an organization name and a repo name seperated by a <em>/</em>.`,name:"repo_id"},{anchor:"huggingface_hub.hf_hub_download.filename",description:`<strong>filename</strong> (<em>str</em>) &#x2014;
The name of the file in the repo.`,name:"filename"},{anchor:"huggingface_hub.hf_hub_download.subfolder",description:`<strong>subfolder</strong> (<em>str</em>, <em>optional</em>) &#x2014;
An optional value corresponding to a folder inside the model repo.`,name:"subfolder"},{anchor:"huggingface_hub.hf_hub_download.repo_type",description:`<strong>repo_type</strong> (<em>str</em>, <em>optional</em>) &#x2014;
Set to <code>&quot;dataset&quot;</code> or <code>&quot;space&quot;</code> if uploading to a dataset
or space, <code>None</code> or <code>&quot;model&quot;</code> if uploading to a model.
Default is <code>None</code>.`,name:"repo_type"},{anchor:"huggingface_hub.hf_hub_download.revision",description:`<strong>revision</strong> (<em>str</em>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"},{anchor:"huggingface_hub.hf_hub_download.library_name",description:`<strong>library_name</strong> (<em>str</em>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.hf_hub_download.library_version",description:`<strong>library_version</strong> (<em>str</em>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.hf_hub_download.cache_dir",description:`<strong>cache_dir</strong> (<em>str</em>, <em>Path</em>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.hf_hub_download.user_agent",description:`<strong>user_agent</strong> (<em>dict</em>, <em>str</em>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.hf_hub_download.force_download",description:`<strong>force_download</strong> (<em>bool</em>, <em>optional</em>, defaults to <em>False</em>) &#x2014;
Whether the file should be downloaded even if it already exists in
the local cache.`,name:"force_download"},{anchor:"huggingface_hub.hf_hub_download.force_filename",description:`<strong>force_filename</strong> (<em>str</em>, <em>optional</em>) &#x2014;
Use this name instead of a generated file name.`,name:"force_filename"},{anchor:"huggingface_hub.hf_hub_download.proxies",description:`<strong>proxies</strong> (<em>dict</em>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<em>requests.request</em>.`,name:"proxies"},{anchor:"huggingface_hub.hf_hub_download.etag_timeout",description:`<strong>etag_timeout</strong> (<em>float</em>, <em>optional</em>, defaults to <em>10</em>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <em>requests.request</em>.`,name:"etag_timeout"},{anchor:"huggingface_hub.hf_hub_download.resume_download",description:`<strong>resume_download</strong> (<em>bool</em>, <em>optional</em>, defaults to <em>False</em>) &#x2014;
If <em>True</em>, resume a previously interrupted download.`,name:"resume_download"},{anchor:"huggingface_hub.hf_hub_download.use_auth_token",description:`<strong>use_auth_token</strong> (<em>str</em>, <em>bool</em>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <em>True</em>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.hf_hub_download.local_files_only",description:`<strong>local_files_only</strong> (<em>bool</em>, <em>optional</em>, defaults to <em>False</em>) &#x2014;
If <em>True</em>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"}],returnDescription:`
<p>Local path (string) of file or if networking is off, last version of
file cached on disk.</p>
`}}),O=new xe({props:{$$slots:{default:[co]},$$scope:{ctx:G}}}),P=new Te({props:{name:"huggingface_hub.snapshot_download",anchor:"huggingface_hub.snapshot_download",parameters:[{name:"repo_id",val:": str"},{name:"revision",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"},{name:"allow_regex",val:": typing.Union[typing.List[str], str, NoneType] = None"},{name:"ignore_regex",val:": typing.Union[typing.List[str], str, NoneType] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_7/src/huggingface_hub/snapshot_download.py#L21",parametersDescription:[{anchor:"huggingface_hub.snapshot_download.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A user or an organization name and a repo name seperated by a
<code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.snapshot_download.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"},{anchor:"huggingface_hub.snapshot_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.snapshot_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.snapshot_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.snapshot_download.user_agent",description:`<strong>user_agent</strong> (<code>str</code>, <code>dict</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.snapshot_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.snapshot_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em>, defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.snapshot_download.resume_download",description:`<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False) -- If </code>True<code>, resume a previously interrupted download. - **use_auth_token** (</code>str<code>, </code>bool\`, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"resume_download"},{anchor:"huggingface_hub.snapshot_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"},{anchor:"huggingface_hub.snapshot_download.allow_regex",description:`<strong>allow_regex</strong> (<code>list of str</code>, <code>str</code>, <em>optional</em>) &#x2014;
If provided, only files matching this regex are downladed.`,name:"allow_regex"},{anchor:"huggingface_hub.snapshot_download.ignore_regex",description:"<strong>ignore_regex</strong> (<code>list of str</code>, `str&#x201C;, <em>optional</em>) &#x2014;\nIf provided, files matching this regex are not downloaded.",name:"ignore_regex"}],returnDescription:`
<p>Local folder path (string) of repo snapshot</p>
`}}),F=new xe({props:{$$slots:{default:[ho]},$$scope:{ctx:G}}}),ae=new Te({props:{name:"huggingface_hub.cached_download",anchor:"huggingface_hub.cached_download",parameters:[{name:"url",val:": str"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"force_download",val:": typing.Optional[bool] = False"},{name:"force_filename",val:": typing.Optional[str] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_7/src/huggingface_hub/file_download.py#L392",parametersDescription:[{anchor:"huggingface_hub.cached_download.url",description:`<strong>url</strong> (<code>str</code>) &#x2014;
The path to the file to be downloaded.`,name:"url"},{anchor:"huggingface_hub.cached_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.cached_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.cached_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.cached_download.user_agent",description:`<strong>user_agent</strong> (<code>dict</code>, <code>str</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.cached_download.force_download",description:`<strong>force_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the file should be downloaded even if it already exists in
the local cache.`,name:"force_download"},{anchor:"huggingface_hub.cached_download.force_filename",description:`<strong>force_filename</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Use this name instead of a generated file name.`,name:"force_filename"},{anchor:"huggingface_hub.cached_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.cached_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em> defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.cached_download.resume_download",description:`<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, resume a previously interrupted download.`,name:"resume_download"},{anchor:"huggingface_hub.cached_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>bool</code>, <code>str</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.cached_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"}],returnDescription:`
<p>Local path (string) of file or if networking is off, last version of
file cached on disk.</p>
`}}),oe=new xe({props:{$$slots:{default:[fo]},$$scope:{ctx:G}}}),re=new Te({props:{name:"huggingface_hub.hf_hub_url",anchor:"huggingface_hub.hf_hub_url",parameters:[{name:"repo_id",val:": str"},{name:"filename",val:": str"},{name:"subfolder",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_7/src/huggingface_hub/file_download.py#L108",parametersDescription:[{anchor:"huggingface_hub.hf_hub_url.repo_id",description:`<strong>repo_id</strong> (<em>str</em>) &#x2014;
A namespace (user or an organization) name and a repo name
seperated by a <em>/</em>.`,name:"repo_id"},{anchor:"huggingface_hub.hf_hub_url.filename",description:`<strong>filename</strong> (<em>str</em>) &#x2014;
The name of the file in the repo.`,name:"filename"},{anchor:"huggingface_hub.hf_hub_url.subfolder",description:`<strong>subfolder</strong> (<em>str</em>, <em>optional</em>) &#x2014;
An optional value corresponding to a folder inside the repo.`,name:"subfolder"},{anchor:"huggingface_hub.hf_hub_url.repo_type",description:`<strong>repo_type</strong> (<em>str</em>, <em>optional</em>) &#x2014;
Set to <code>&quot;dataset&quot;</code> or <code>&quot;space&quot;</code> if uploading to a dataset
or space, <code>None</code> or <code>&quot;model&quot;</code> if uploading to a model.
Default is <code>None</code>.`,name:"repo_type"},{anchor:"huggingface_hub.hf_hub_url.revision",description:`<strong>revision</strong> (<em>str</em>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"}]}}),ie=new so({props:{code:`from huggingface_hub import hf_hub_url
hf_hub_url(
   repo_id="julien-c/EsperBERTo-small", filename="pytorch_model.bin"
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> huggingface_hub <span class="hljs-keyword">import</span> hf_hub_url
<span class="hljs-meta">&gt;&gt;&gt; </span>hf_hub_url(
<span class="hljs-meta">... </span>   repo_id=<span class="hljs-string">&quot;julien-c/EsperBERTo-small&quot;</span>, filename=<span class="hljs-string">&quot;pytorch_model.bin&quot;</span>
<span class="hljs-meta">... </span>)
<span class="hljs-string">&#x27;https://huggingface.co/julien-c/EsperBERTo-small/resolve/main/pytorch_model.bin&#x27;</span>`}}),ne=new xe({props:{$$slots:{default:[go]},$$scope:{ctx:G}}}),{c(){h=t("meta"),I=u(),p=t("h1"),i=t("a"),g=t("span"),K(_.$$.fragment),q=u(),C=t("span"),E=s("Downloading files"),T=u(),w=t("div"),K(k.$$.fragment),b=u(),y=t("p"),c=s("Download a given file if it\u2019s not already present in the local cache."),$=u(),K(O.$$.fragment),v=u(),f=t("div"),K(P.$$.fragment),S=u(),d=t("p"),N=s("Download all files of a repo."),D=u(),L=t("p"),V=s(`Downloads a whole snapshot of a repo\u2019s files at the specified revision.
This is useful when you want all files from a repo, because you don\u2019t know
which ones you will need a priori.
All files are nested inside a folder in order to keep their actual filename
relative to that folder.`),W=u(),j=t("p"),B=s(`An alternative would be to just clone a repo but this would require that
the user always has git and git-lfs installed, and properly configured.`),M=u(),K(F.$$.fragment),ye=u(),H=t("div"),K(ae.$$.fragment),ke=u(),he=t("p"),Ne=s("Download from a given URL and cache it if it\u2019s not already present in the local cache."),De=u(),fe=t("p"),Oe=s(`Given a URL, this function looks for the corresponding file in the local
cache. If it\u2019s not there, download it. Then return the path to the cached
file.`),Le=u(),K(oe.$$.fragment),Ee=u(),A=t("div"),K(re.$$.fragment),Ie=u(),ge=t("p"),qe=s("Construct the URL of a file from the given information."),Pe=u(),ue=t("p"),Ue=s(`The resolved address can either be a huggingface.co-hosted url, or a link
to Cloudfront (a Content Delivery Network, or CDN) for large files which
are more than a few MBs.`),Ce=u(),me=t("p"),Ae=s("Example:"),je=u(),K(ie.$$.fragment),Fe=u(),K(ne.$$.fragment),Re=u(),pe=t("p"),Se=s("References:"),Me=u(),_e=t("ul"),de=t("li"),He=s("[1] "),se=t("a"),Ve=s("https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),this.h()},l(n){const U=io('[data-svelte="svelte-1phssyn"]',document.head);h=a(U,"META",{name:!0,content:!0}),U.forEach(o),I=m(n),p=a(n,"H1",{class:!0});var le=r(p);i=a(le,"A",{id:!0,class:!0,href:!0});var be=r(i);g=a(be,"SPAN",{});var ve=r(g);Q(_.$$.fragment,ve),ve.forEach(o),be.forEach(o),q=m(le),C=a(le,"SPAN",{});var we=r(C);E=l(we,"Downloading files"),we.forEach(o),le.forEach(o),T=m(n),w=a(n,"DIV",{class:!0});var ce=r(w);Q(k.$$.fragment,ce),b=m(ce),y=a(ce,"P",{});var Be=r(y);c=l(Be,"Download a given file if it\u2019s not already present in the local cache."),Be.forEach(o),$=m(ce),Q(O.$$.fragment,ce),ce.forEach(o),v=m(n),f=a(n,"DIV",{class:!0});var J=r(f);Q(P.$$.fragment,J),S=m(J),d=a(J,"P",{});var ze=r(d);N=l(ze,"Download all files of a repo."),ze.forEach(o),D=m(J),L=a(J,"P",{});var Ge=r(L);V=l(Ge,`Downloads a whole snapshot of a repo\u2019s files at the specified revision.
This is useful when you want all files from a repo, because you don\u2019t know
which ones you will need a priori.
All files are nested inside a folder in order to keep their actual filename
relative to that folder.`),Ge.forEach(o),W=m(J),j=a(J,"P",{});var Je=r(j);B=l(Je,`An alternative would be to just clone a repo but this would require that
the user always has git and git-lfs installed, and properly configured.`),Je.forEach(o),M=m(J),Q(F.$$.fragment,J),J.forEach(o),ye=m(n),H=a(n,"DIV",{class:!0});var te=r(H);Q(ae.$$.fragment,te),ke=m(te),he=a(te,"P",{});var Ke=r(he);Ne=l(Ke,"Download from a given URL and cache it if it\u2019s not already present in the local cache."),Ke.forEach(o),De=m(te),fe=a(te,"P",{});var Qe=r(fe);Oe=l(Qe,`Given a URL, this function looks for the corresponding file in the local
cache. If it\u2019s not there, download it. Then return the path to the cached
file.`),Qe.forEach(o),Le=m(te),Q(oe.$$.fragment,te),te.forEach(o),Ee=m(n),A=a(n,"DIV",{class:!0});var R=r(A);Q(re.$$.fragment,R),Ie=m(R),ge=a(R,"P",{});var Xe=r(ge);qe=l(Xe,"Construct the URL of a file from the given information."),Xe.forEach(o),Pe=m(R),ue=a(R,"P",{});var Ye=r(ue);Ue=l(Ye,`The resolved address can either be a huggingface.co-hosted url, or a link
to Cloudfront (a Content Delivery Network, or CDN) for large files which
are more than a few MBs.`),Ye.forEach(o),Ce=m(R),me=a(R,"P",{});var Ze=r(me);Ae=l(Ze,"Example:"),Ze.forEach(o),je=m(R),Q(ie.$$.fragment,R),Fe=m(R),Q(ne.$$.fragment,R),Re=m(R),pe=a(R,"P",{});var eo=r(pe);Se=l(eo,"References:"),eo.forEach(o),Me=m(R),_e=a(R,"UL",{});var oo=r(_e);de=a(oo,"LI",{});var We=r(de);He=l(We,"[1] "),se=a(We,"A",{href:!0,rel:!0});var no=r(se);Ve=l(no,"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),no.forEach(o),We.forEach(o),oo.forEach(o),R.forEach(o),this.h()},h(){z(h,"name","hf:doc:metadata"),z(h,"content",JSON.stringify(mo)),z(i,"id","huggingface_hub.hf_hub_download"),z(i,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),z(i,"href","#huggingface_hub.hf_hub_download"),z(p,"class","relative group"),z(w,"class","docstring"),z(f,"class","docstring"),z(H,"class","docstring"),z(se,"href","https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),z(se,"rel","nofollow"),z(A,"class","docstring")},m(n,U){e(document.head,h),x(n,I,U),x(n,p,U),e(p,i),e(i,g),X(_,g,null),e(p,q),e(p,C),e(C,E),x(n,T,U),x(n,w,U),X(k,w,null),e(w,b),e(w,y),e(y,c),e(w,$),X(O,w,null),x(n,v,U),x(n,f,U),X(P,f,null),e(f,S),e(f,d),e(d,N),e(f,D),e(f,L),e(L,V),e(f,W),e(f,j),e(j,B),e(f,M),X(F,f,null),x(n,ye,U),x(n,H,U),X(ae,H,null),e(H,ke),e(H,he),e(he,Ne),e(H,De),e(H,fe),e(fe,Oe),e(H,Le),X(oe,H,null),x(n,Ee,U),x(n,A,U),X(re,A,null),e(A,Ie),e(A,ge),e(ge,qe),e(A,Pe),e(A,ue),e(ue,Ue),e(A,Ce),e(A,me),e(me,Ae),e(A,je),X(ie,A,null),e(A,Fe),X(ne,A,null),e(A,Re),e(A,pe),e(pe,Se),e(A,Me),e(A,_e),e(_e,de),e(de,He),e(de,se),e(se,Ve),$e=!0},p(n,[U]){const le={};U&2&&(le.$$scope={dirty:U,ctx:n}),O.$set(le);const be={};U&2&&(be.$$scope={dirty:U,ctx:n}),F.$set(be);const ve={};U&2&&(ve.$$scope={dirty:U,ctx:n}),oe.$set(ve);const we={};U&2&&(we.$$scope={dirty:U,ctx:n}),ne.$set(we)},i(n){$e||(Y(_.$$.fragment,n),Y(k.$$.fragment,n),Y(O.$$.fragment,n),Y(P.$$.fragment,n),Y(F.$$.fragment,n),Y(ae.$$.fragment,n),Y(oe.$$.fragment,n),Y(re.$$.fragment,n),Y(ie.$$.fragment,n),Y(ne.$$.fragment,n),$e=!0)},o(n){Z(_.$$.fragment,n),Z(k.$$.fragment,n),Z(O.$$.fragment,n),Z(P.$$.fragment,n),Z(F.$$.fragment,n),Z(ae.$$.fragment,n),Z(oe.$$.fragment,n),Z(re.$$.fragment,n),Z(ie.$$.fragment,n),Z(ne.$$.fragment,n),$e=!1},d(n){o(h),n&&o(I),n&&o(p),ee(_),n&&o(T),n&&o(w),ee(k),ee(O),n&&o(v),n&&o(f),ee(P),ee(F),n&&o(ye),n&&o(H),ee(ae),ee(oe),n&&o(Ee),n&&o(A),ee(re),ee(ie),ee(ne)}}}const mo={local:"huggingface_hub.hf_hub_download",title:"Downloading files"};function po(G,h,I){let{fw:p}=h;return G.$$set=i=>{"fw"in i&&I(0,p=i.fw)},[p]}class Eo extends to{constructor(h){super();ao(this,h,po,uo,ro,{fw:0})}}export{Eo as default,mo as metadata};
