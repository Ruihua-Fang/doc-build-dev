import{S as Ze,i as eo,s as oo,e as n,k as m,w as Z,t as d,M as no,c as t,d as o,m as _,a,x as ee,h as c,b as $,F as e,g as x,y as oe,q as ne,o as te,B as ae,v as to,L as ao}from"../../chunks/vendor-a09ded63.js";import{T as Te}from"../../chunks/Tip-27a54654.js";import{D as ke}from"../../chunks/Docstring-3f63de13.js";import{C as ro}from"../../chunks/CodeBlock-879da7fe.js";import{I as io}from"../../chunks/IconCopyLink-3f5556be.js";import{E as lo}from"../../chunks/ExampleCodeBlock-7aff195a.js";function so(K){let h,D,p,i,f,l,g,U,F,w,T,N,S,E,s,b,I,j,v,y,k,P,W,z;return{c(){h=n("p"),D=d("Raises the following errors:"),p=m(),i=n("ul"),f=n("li"),l=n("a"),g=n("code"),U=d("EnvironmentError"),F=d(`
if `),w=n("code"),T=d("use_auth_token=True"),N=d(" and the token cannot be found."),S=m(),E=n("li"),s=n("a"),b=n("code"),I=d("OSError"),j=d(`
if ETag cannot be determined.`),v=m(),y=n("li"),k=n("a"),P=n("code"),W=d("ValueError"),z=d(`
if some parameter value is invalid`),this.h()},l(u){h=t(u,"P",{});var O=a(h);D=c(O,"Raises the following errors:"),O.forEach(o),p=_(u),i=t(u,"UL",{});var q=a(i);f=t(q,"LI",{});var C=a(f);l=t(C,"A",{href:!0,rel:!0});var Q=a(l);g=t(Q,"CODE",{});var X=a(g);U=c(X,"EnvironmentError"),X.forEach(o),Q.forEach(o),F=c(C,`
if `),w=t(C,"CODE",{});var V=a(w);T=c(V,"use_auth_token=True"),V.forEach(o),N=c(C," and the token cannot be found."),C.forEach(o),S=_(q),E=t(q,"LI",{});var H=a(E);s=t(H,"A",{href:!0,rel:!0});var A=a(s);b=t(A,"CODE",{});var B=a(b);I=c(B,"OSError"),B.forEach(o),A.forEach(o),j=c(H,`
if ETag cannot be determined.`),H.forEach(o),v=_(q),y=t(q,"LI",{});var G=a(y);k=t(G,"A",{href:!0,rel:!0});var M=a(k);P=t(M,"CODE",{});var Y=a(P);W=c(Y,"ValueError"),Y.forEach(o),M.forEach(o),z=c(G,`
if some parameter value is invalid`),G.forEach(o),q.forEach(o),this.h()},h(){$(l,"href","https://docs.python.org/3/library/exceptions.html#EnvironmentError"),$(l,"rel","nofollow"),$(s,"href","https://docs.python.org/3/library/exceptions.html#OSError"),$(s,"rel","nofollow"),$(k,"href","https://docs.python.org/3/library/exceptions.html#ValueError"),$(k,"rel","nofollow")},m(u,O){x(u,h,O),e(h,D),x(u,p,O),x(u,i,O),e(i,f),e(f,l),e(l,g),e(g,U),e(f,F),e(f,w),e(w,T),e(f,N),e(i,S),e(i,E),e(E,s),e(s,b),e(b,I),e(E,j),e(i,v),e(i,y),e(y,k),e(k,P),e(P,W),e(y,z)},d(u){u&&o(h),u&&o(p),u&&o(i)}}}function co(K){let h,D,p,i,f,l,g,U,F,w,T,N,S,E,s,b,I,j,v,y,k,P,W,z;return{c(){h=n("p"),D=d("Raises the following errors:"),p=m(),i=n("ul"),f=n("li"),l=n("a"),g=n("code"),U=d("EnvironmentError"),F=d(`
if `),w=n("code"),T=d("use_auth_token=True"),N=d(" and the token cannot be found."),S=m(),E=n("li"),s=n("a"),b=n("code"),I=d("OSError"),j=d(` if
ETag cannot be determined.`),v=m(),y=n("li"),k=n("a"),P=n("code"),W=d("ValueError"),z=d(`
if some parameter value is invalid`),this.h()},l(u){h=t(u,"P",{});var O=a(h);D=c(O,"Raises the following errors:"),O.forEach(o),p=_(u),i=t(u,"UL",{});var q=a(i);f=t(q,"LI",{});var C=a(f);l=t(C,"A",{href:!0,rel:!0});var Q=a(l);g=t(Q,"CODE",{});var X=a(g);U=c(X,"EnvironmentError"),X.forEach(o),Q.forEach(o),F=c(C,`
if `),w=t(C,"CODE",{});var V=a(w);T=c(V,"use_auth_token=True"),V.forEach(o),N=c(C," and the token cannot be found."),C.forEach(o),S=_(q),E=t(q,"LI",{});var H=a(E);s=t(H,"A",{href:!0,rel:!0});var A=a(s);b=t(A,"CODE",{});var B=a(b);I=c(B,"OSError"),B.forEach(o),A.forEach(o),j=c(H,` if
ETag cannot be determined.`),H.forEach(o),v=_(q),y=t(q,"LI",{});var G=a(y);k=t(G,"A",{href:!0,rel:!0});var M=a(k);P=t(M,"CODE",{});var Y=a(P);W=c(Y,"ValueError"),Y.forEach(o),M.forEach(o),z=c(G,`
if some parameter value is invalid`),G.forEach(o),q.forEach(o),this.h()},h(){$(l,"href","https://docs.python.org/3/library/exceptions.html#EnvironmentError"),$(l,"rel","nofollow"),$(s,"href","https://docs.python.org/3/library/exceptions.html#OSError"),$(s,"rel","nofollow"),$(k,"href","https://docs.python.org/3/library/exceptions.html#ValueError"),$(k,"rel","nofollow")},m(u,O){x(u,h,O),e(h,D),x(u,p,O),x(u,i,O),e(i,f),e(f,l),e(l,g),e(g,U),e(f,F),e(f,w),e(w,T),e(f,N),e(i,S),e(i,E),e(E,s),e(s,b),e(b,I),e(E,j),e(i,v),e(i,y),e(y,k),e(k,P),e(P,W),e(y,z)},d(u){u&&o(h),u&&o(p),u&&o(i)}}}function ho(K){let h,D,p,i,f,l,g,U,F,w,T,N,S,E,s,b,I,j,v,y,k,P,W,z;return{c(){h=n("p"),D=d("Raises the following errors:"),p=m(),i=n("ul"),f=n("li"),l=n("a"),g=n("code"),U=d("EnvironmentError"),F=d(`
if `),w=n("code"),T=d("use_auth_token=True"),N=d(" and the token cannot be found."),S=m(),E=n("li"),s=n("a"),b=n("code"),I=d("OSError"),j=d(`
if ETag cannot be determined.`),v=m(),y=n("li"),k=n("a"),P=n("code"),W=d("ValueError"),z=d(`
if some parameter value is invalid`),this.h()},l(u){h=t(u,"P",{});var O=a(h);D=c(O,"Raises the following errors:"),O.forEach(o),p=_(u),i=t(u,"UL",{});var q=a(i);f=t(q,"LI",{});var C=a(f);l=t(C,"A",{href:!0,rel:!0});var Q=a(l);g=t(Q,"CODE",{});var X=a(g);U=c(X,"EnvironmentError"),X.forEach(o),Q.forEach(o),F=c(C,`
if `),w=t(C,"CODE",{});var V=a(w);T=c(V,"use_auth_token=True"),V.forEach(o),N=c(C," and the token cannot be found."),C.forEach(o),S=_(q),E=t(q,"LI",{});var H=a(E);s=t(H,"A",{href:!0,rel:!0});var A=a(s);b=t(A,"CODE",{});var B=a(b);I=c(B,"OSError"),B.forEach(o),A.forEach(o),j=c(H,`
if ETag cannot be determined.`),H.forEach(o),v=_(q),y=t(q,"LI",{});var G=a(y);k=t(G,"A",{href:!0,rel:!0});var M=a(k);P=t(M,"CODE",{});var Y=a(P);W=c(Y,"ValueError"),Y.forEach(o),M.forEach(o),z=c(G,`
if some parameter value is invalid`),G.forEach(o),q.forEach(o),this.h()},h(){$(l,"href","https://docs.python.org/3/library/exceptions.html#EnvironmentError"),$(l,"rel","nofollow"),$(s,"href","https://docs.python.org/3/library/exceptions.html#OSError"),$(s,"rel","nofollow"),$(k,"href","https://docs.python.org/3/library/exceptions.html#ValueError"),$(k,"rel","nofollow")},m(u,O){x(u,h,O),e(h,D),x(u,p,O),x(u,i,O),e(i,f),e(f,l),e(l,g),e(g,U),e(f,F),e(f,w),e(w,T),e(f,N),e(i,S),e(i,E),e(E,s),e(s,b),e(b,I),e(E,j),e(i,v),e(i,y),e(y,k),e(k,P),e(P,W),e(y,z)},d(u){u&&o(h),u&&o(p),u&&o(i)}}}function fo(K){let h,D,p,i,f;return i=new ro({props:{code:`from huggingface_hub import hf_hub_url

hf_hub_url(
    repo_id="julien-c/EsperBERTo-small", filename="pytorch_model.bin"
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> huggingface_hub <span class="hljs-keyword">import</span> hf_hub_url

<span class="hljs-meta">&gt;&gt;&gt; </span>hf_hub_url(
<span class="hljs-meta">... </span>    repo_id=<span class="hljs-string">&quot;julien-c/EsperBERTo-small&quot;</span>, filename=<span class="hljs-string">&quot;pytorch_model.bin&quot;</span>
<span class="hljs-meta">... </span>)
<span class="hljs-string">&#x27;https://huggingface.co/julien-c/EsperBERTo-small/resolve/main/pytorch_model.bin&#x27;</span>`}}),{c(){h=n("p"),D=d("Example:"),p=m(),Z(i.$$.fragment)},l(l){h=t(l,"P",{});var g=a(h);D=c(g,"Example:"),g.forEach(o),p=_(l),ee(i.$$.fragment,l)},m(l,g){x(l,h,g),e(h,D),x(l,p,g),oe(i,l,g),f=!0},p:ao,i(l){f||(ne(i.$$.fragment,l),f=!0)},o(l){te(i.$$.fragment,l),f=!1},d(l){l&&o(h),l&&o(p),ae(i,l)}}}function uo(K){let h,D,p,i,f,l,g,U,F,w,T,N,S,E;return{c(){h=n("p"),D=d("Notes:"),p=m(),i=n("p"),f=d(`Cloudfront is replicated over the globe so downloads are way faster for
the end user (and it also lowers our bandwidth costs).`),l=m(),g=n("p"),U=d(`Cloudfront aggressively caches files by default (default TTL is 24
hours), however this is not an issue here because we implement a
git-based versioning system on huggingface.co, which means that we store
the files on S3/Cloudfront in a content-addressable way (i.e., the file
name is its hash). Using content-addressable filenames means cache can\u2019t
ever be stale.`),F=m(),w=n("p"),T=d(`In terms of client-side caching from this library, we base our caching
on the objects\u2019 entity tag (`),N=n("code"),S=d("ETag"),E=d(`), which is an identifier of a
specific version of a resource [1]_. An object\u2019s ETag is: its git-sha1
if stored in git, or its sha256 if stored in git-lfs.`)},l(s){h=t(s,"P",{});var b=a(h);D=c(b,"Notes:"),b.forEach(o),p=_(s),i=t(s,"P",{});var I=a(i);f=c(I,`Cloudfront is replicated over the globe so downloads are way faster for
the end user (and it also lowers our bandwidth costs).`),I.forEach(o),l=_(s),g=t(s,"P",{});var j=a(g);U=c(j,`Cloudfront aggressively caches files by default (default TTL is 24
hours), however this is not an issue here because we implement a
git-based versioning system on huggingface.co, which means that we store
the files on S3/Cloudfront in a content-addressable way (i.e., the file
name is its hash). Using content-addressable filenames means cache can\u2019t
ever be stale.`),j.forEach(o),F=_(s),w=t(s,"P",{});var v=a(w);T=c(v,`In terms of client-side caching from this library, we base our caching
on the objects\u2019 entity tag (`),N=t(v,"CODE",{});var y=a(N);S=c(y,"ETag"),y.forEach(o),E=c(v,`), which is an identifier of a
specific version of a resource [1]_. An object\u2019s ETag is: its git-sha1
if stored in git, or its sha256 if stored in git-lfs.`),v.forEach(o)},m(s,b){x(s,h,b),e(h,D),x(s,p,b),x(s,i,b),e(i,f),x(s,l,b),x(s,g,b),e(g,U),x(s,F,b),x(s,w,b),e(w,T),e(w,N),e(N,S),e(w,E)},d(s){s&&o(h),s&&o(p),s&&o(i),s&&o(l),s&&o(g),s&&o(F),s&&o(w)}}}function go(K){let h,D,p,i,f,l,g,U,F,w,T,N,S,E,s,b,I,j,v,y,k,P,W,z,u,O,q,C,Q,X,V,H,A,B,G,M,Y,Ne,pe,De,Oe,le,$e,R,he,qe,me,Le,Ie,_e,Pe,Ce,se,Ae,de,Ue,be,Fe,Se,ve,ge,je,fe,Re,xe;return l=new io({}),N=new ke({props:{name:"huggingface_hub.hf_hub_download",anchor:"huggingface_hub.hf_hub_download",parameters:[{name:"repo_id",val:": str"},{name:"filename",val:": str"},{name:"subfolder",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"force_download",val:": typing.Optional[bool] = False"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"},{name:"legacy_cache_layout",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.hf_hub_download.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A user or an organization name and a repo name separated by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.hf_hub_download.filename",description:`<strong>filename</strong> (<code>str</code>) &#x2014;
The name of the file in the repo.`,name:"filename"},{anchor:"huggingface_hub.hf_hub_download.subfolder",description:`<strong>subfolder</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional value corresponding to a folder inside the model repo.`,name:"subfolder"},{anchor:"huggingface_hub.hf_hub_download.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Set to <code>&quot;dataset&quot;</code> or <code>&quot;space&quot;</code> if uploading to a dataset or space,
<code>None</code> or <code>&quot;model&quot;</code> if uploading to a model. Default is <code>None</code>.`,name:"repo_type"},{anchor:"huggingface_hub.hf_hub_download.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"},{anchor:"huggingface_hub.hf_hub_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.hf_hub_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.hf_hub_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.hf_hub_download.user_agent",description:`<strong>user_agent</strong> (<code>dict</code>, <code>str</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.hf_hub_download.force_download",description:`<strong>force_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the file should be downloaded even if it already exists in
the local cache.`,name:"force_download"},{anchor:"huggingface_hub.hf_hub_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.hf_hub_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em>, defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.hf_hub_download.resume_download",description:`<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, resume a previously interrupted download.`,name:"resume_download"},{anchor:"huggingface_hub.hf_hub_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code>, <code>bool</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.hf_hub_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"},{anchor:"huggingface_hub.hf_hub_download.legacy_cache_layout",description:`<strong>legacy_cache_layout</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, uses the legacy file cache layout i.e. just call <code>hf_hub_url</code>
then <code>cached_download</code>. This is deprecated as the new cache layout is
more powerful.`,name:"legacy_cache_layout"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_801/src/huggingface_hub/file_download.py#L746",returnDescription:`
<p>Local path (string) of file or if networking is off, last version of
file cached on disk.</p>
`}}),I=new Te({props:{$$slots:{default:[so]},$$scope:{ctx:K}}}),y=new ke({props:{name:"huggingface_hub.snapshot_download",anchor:"huggingface_hub.snapshot_download",parameters:[{name:"repo_id",val:": str"},{name:"revision",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"},{name:"allow_regex",val:": typing.Union[typing.List[str], str, NoneType] = None"},{name:"ignore_regex",val:": typing.Union[typing.List[str], str, NoneType] = None"}],parametersDescription:[{anchor:"huggingface_hub.snapshot_download.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A user or an organization name and a repo name separated by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.snapshot_download.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"},{anchor:"huggingface_hub.snapshot_download.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Set to <code>&quot;dataset&quot;</code> or <code>&quot;space&quot;</code> if uploading to a dataset or space,
<code>None</code> or <code>&quot;model&quot;</code> if uploading to a model. Default is <code>None</code>.`,name:"repo_type"},{anchor:"huggingface_hub.snapshot_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.snapshot_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.snapshot_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.snapshot_download.user_agent",description:`<strong>user_agent</strong> (<code>str</code>, <code>dict</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.snapshot_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.snapshot_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em>, defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.snapshot_download.resume_download",description:"<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False) -- If </code>True`, resume a previously interrupted download.",name:"resume_download"},{anchor:"huggingface_hub.snapshot_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code>, <code>bool</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.snapshot_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"},{anchor:"huggingface_hub.snapshot_download.allow_regex",description:`<strong>allow_regex</strong> (<code>list of str</code>, <code>str</code>, <em>optional</em>) &#x2014;
If provided, only files matching this regex are downloaded.`,name:"allow_regex"},{anchor:"huggingface_hub.snapshot_download.ignore_regex",description:`<strong>ignore_regex</strong> (<code>list of str</code>, <code>str</code>, <em>optional</em>) &#x2014;
If provided, files matching this regex are not downloaded.`,name:"ignore_regex"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_801/src/huggingface_hub/snapshot_download.py#L22",returnDescription:`
<p>Local folder path (string) of repo snapshot</p>
`}}),V=new Te({props:{$$slots:{default:[co]},$$scope:{ctx:K}}}),B=new ke({props:{name:"huggingface_hub.cached_download",anchor:"huggingface_hub.cached_download",parameters:[{name:"url",val:": str"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"force_download",val:": typing.Optional[bool] = False"},{name:"force_filename",val:": typing.Optional[str] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.cached_download.url",description:`<strong>url</strong> (<code>str</code>) &#x2014;
The path to the file to be downloaded.`,name:"url"},{anchor:"huggingface_hub.cached_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.cached_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.cached_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.cached_download.user_agent",description:`<strong>user_agent</strong> (<code>dict</code>, <code>str</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.cached_download.force_download",description:`<strong>force_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the file should be downloaded even if it already exists in
the local cache.`,name:"force_download"},{anchor:"huggingface_hub.cached_download.force_filename",description:`<strong>force_filename</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Use this name instead of a generated file name.`,name:"force_filename"},{anchor:"huggingface_hub.cached_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.cached_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em> defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.cached_download.resume_download",description:`<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, resume a previously interrupted download.`,name:"resume_download"},{anchor:"huggingface_hub.cached_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>bool</code>, <code>str</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.cached_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_801/src/huggingface_hub/file_download.py#L455",returnDescription:`
<p>Local path (string) of file or if networking is off, last version of
file cached on disk.</p>
`}}),le=new Te({props:{$$slots:{default:[ho]},$$scope:{ctx:K}}}),he=new ke({props:{name:"huggingface_hub.hf_hub_url",anchor:"huggingface_hub.hf_hub_url",parameters:[{name:"repo_id",val:": str"},{name:"filename",val:": str"},{name:"subfolder",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.hf_hub_url.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A namespace (user or an organization) name and a repo name separated
by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.hf_hub_url.filename",description:`<strong>filename</strong> (<code>str</code>) &#x2014;
The name of the file in the repo.`,name:"filename"},{anchor:"huggingface_hub.hf_hub_url.subfolder",description:`<strong>subfolder</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional value corresponding to a folder inside the repo.`,name:"subfolder"},{anchor:"huggingface_hub.hf_hub_url.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Set to <code>&quot;dataset&quot;</code> or <code>&quot;space&quot;</code> if uploading to a dataset or space,
<code>None</code> or <code>&quot;model&quot;</code> if uploading to a model. Default is <code>None</code>.`,name:"repo_type"},{anchor:"huggingface_hub.hf_hub_url.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"}],source:"https://github.com/huggingface/huggingface_hub/blob/vr_801/src/huggingface_hub/file_download.py#L153"}}),se=new lo({props:{anchor:"huggingface_hub.hf_hub_url.example",$$slots:{default:[fo]},$$scope:{ctx:K}}}),de=new Te({props:{$$slots:{default:[uo]},$$scope:{ctx:K}}}),{c(){h=n("meta"),D=m(),p=n("h1"),i=n("a"),f=n("span"),Z(l.$$.fragment),g=m(),U=n("span"),F=d("Downloading files"),w=m(),T=n("div"),Z(N.$$.fragment),S=m(),E=n("p"),s=d("Download a given file if it\u2019s not already present in the local cache."),b=m(),Z(I.$$.fragment),j=m(),v=n("div"),Z(y.$$.fragment),k=m(),P=n("p"),W=d("Download all files of a repo."),z=m(),u=n("p"),O=d(`Downloads a whole snapshot of a repo\u2019s files at the specified revision. This
is useful when you want all files from a repo, because you don\u2019t know which
ones you will need a priori. All files are nested inside a folder in order
to keep their actual filename relative to that folder.`),q=m(),C=n("p"),Q=d(`An alternative would be to just clone a repo but this would require that the
user always has git and git-lfs installed, and properly configured.`),X=m(),Z(V.$$.fragment),H=m(),A=n("div"),Z(B.$$.fragment),G=m(),M=n("p"),Y=d(`Download from a given URL and cache it if it\u2019s not already present in the
local cache.`),Ne=m(),pe=n("p"),De=d(`Given a URL, this function looks for the corresponding file in the local
cache. If it\u2019s not there, download it. Then return the path to the cached
file.`),Oe=m(),Z(le.$$.fragment),$e=m(),R=n("div"),Z(he.$$.fragment),qe=m(),me=n("p"),Le=d("Construct the URL of a file from the given information."),Ie=m(),_e=n("p"),Pe=d(`The resolved address can either be a huggingface.co-hosted url, or a link to
Cloudfront (a Content Delivery Network, or CDN) for large files which are
more than a few MBs.`),Ce=m(),Z(se.$$.fragment),Ae=m(),Z(de.$$.fragment),Ue=m(),be=n("p"),Fe=d("References:"),Se=m(),ve=n("ul"),ge=n("li"),je=d("[1] "),fe=n("a"),Re=d("https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),this.h()},l(r){const L=no('[data-svelte="svelte-1phssyn"]',document.head);h=t(L,"META",{name:!0,content:!0}),L.forEach(o),D=_(r),p=t(r,"H1",{class:!0});var ue=a(p);i=t(ue,"A",{id:!0,class:!0,href:!0});var we=a(i);f=t(we,"SPAN",{});var ye=a(f);ee(l.$$.fragment,ye),ye.forEach(o),we.forEach(o),g=_(ue),U=t(ue,"SPAN",{});var Ee=a(U);F=c(Ee,"Downloading files"),Ee.forEach(o),ue.forEach(o),w=_(r),T=t(r,"DIV",{class:!0});var ie=a(T);ee(N.$$.fragment,ie),S=_(ie),E=t(ie,"P",{});var He=a(E);s=c(He,"Download a given file if it\u2019s not already present in the local cache."),He.forEach(o),b=_(ie),ee(I.$$.fragment,ie),ie.forEach(o),j=_(r),v=t(r,"DIV",{class:!0});var re=a(v);ee(y.$$.fragment,re),k=_(re),P=t(re,"P",{});var Be=a(P);W=c(Be,"Download all files of a repo."),Be.forEach(o),z=_(re),u=t(re,"P",{});var We=a(u);O=c(We,`Downloads a whole snapshot of a repo\u2019s files at the specified revision. This
is useful when you want all files from a repo, because you don\u2019t know which
ones you will need a priori. All files are nested inside a folder in order
to keep their actual filename relative to that folder.`),We.forEach(o),q=_(re),C=t(re,"P",{});var ze=a(C);Q=c(ze,`An alternative would be to just clone a repo but this would require that the
user always has git and git-lfs installed, and properly configured.`),ze.forEach(o),X=_(re),ee(V.$$.fragment,re),re.forEach(o),H=_(r),A=t(r,"DIV",{class:!0});var ce=a(A);ee(B.$$.fragment,ce),G=_(ce),M=t(ce,"P",{});var Ge=a(M);Y=c(Ge,`Download from a given URL and cache it if it\u2019s not already present in the
local cache.`),Ge.forEach(o),Ne=_(ce),pe=t(ce,"P",{});var Me=a(pe);De=c(Me,`Given a URL, this function looks for the corresponding file in the local
cache. If it\u2019s not there, download it. Then return the path to the cached
file.`),Me.forEach(o),Oe=_(ce),ee(le.$$.fragment,ce),ce.forEach(o),$e=_(r),R=t(r,"DIV",{class:!0});var J=a(R);ee(he.$$.fragment,J),qe=_(J),me=t(J,"P",{});var Je=a(me);Le=c(Je,"Construct the URL of a file from the given information."),Je.forEach(o),Ie=_(J),_e=t(J,"P",{});var Ke=a(_e);Pe=c(Ke,`The resolved address can either be a huggingface.co-hosted url, or a link to
Cloudfront (a Content Delivery Network, or CDN) for large files which are
more than a few MBs.`),Ke.forEach(o),Ce=_(J),ee(se.$$.fragment,J),Ae=_(J),ee(de.$$.fragment,J),Ue=_(J),be=t(J,"P",{});var Qe=a(be);Fe=c(Qe,"References:"),Qe.forEach(o),Se=_(J),ve=t(J,"UL",{});var Xe=a(ve);ge=t(Xe,"LI",{});var Ve=a(ge);je=c(Ve,"[1] "),fe=t(Ve,"A",{href:!0,rel:!0});var Ye=a(fe);Re=c(Ye,"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),Ye.forEach(o),Ve.forEach(o),Xe.forEach(o),J.forEach(o),this.h()},h(){$(h,"name","hf:doc:metadata"),$(h,"content",JSON.stringify(po)),$(i,"id","huggingface_hub.hf_hub_download"),$(i,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),$(i,"href","#huggingface_hub.hf_hub_download"),$(p,"class","relative group"),$(T,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),$(v,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),$(A,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),$(fe,"href","https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),$(fe,"rel","nofollow"),$(R,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(r,L){e(document.head,h),x(r,D,L),x(r,p,L),e(p,i),e(i,f),oe(l,f,null),e(p,g),e(p,U),e(U,F),x(r,w,L),x(r,T,L),oe(N,T,null),e(T,S),e(T,E),e(E,s),e(T,b),oe(I,T,null),x(r,j,L),x(r,v,L),oe(y,v,null),e(v,k),e(v,P),e(P,W),e(v,z),e(v,u),e(u,O),e(v,q),e(v,C),e(C,Q),e(v,X),oe(V,v,null),x(r,H,L),x(r,A,L),oe(B,A,null),e(A,G),e(A,M),e(M,Y),e(A,Ne),e(A,pe),e(pe,De),e(A,Oe),oe(le,A,null),x(r,$e,L),x(r,R,L),oe(he,R,null),e(R,qe),e(R,me),e(me,Le),e(R,Ie),e(R,_e),e(_e,Pe),e(R,Ce),oe(se,R,null),e(R,Ae),oe(de,R,null),e(R,Ue),e(R,be),e(be,Fe),e(R,Se),e(R,ve),e(ve,ge),e(ge,je),e(ge,fe),e(fe,Re),xe=!0},p(r,[L]){const ue={};L&2&&(ue.$$scope={dirty:L,ctx:r}),I.$set(ue);const we={};L&2&&(we.$$scope={dirty:L,ctx:r}),V.$set(we);const ye={};L&2&&(ye.$$scope={dirty:L,ctx:r}),le.$set(ye);const Ee={};L&2&&(Ee.$$scope={dirty:L,ctx:r}),se.$set(Ee);const ie={};L&2&&(ie.$$scope={dirty:L,ctx:r}),de.$set(ie)},i(r){xe||(ne(l.$$.fragment,r),ne(N.$$.fragment,r),ne(I.$$.fragment,r),ne(y.$$.fragment,r),ne(V.$$.fragment,r),ne(B.$$.fragment,r),ne(le.$$.fragment,r),ne(he.$$.fragment,r),ne(se.$$.fragment,r),ne(de.$$.fragment,r),xe=!0)},o(r){te(l.$$.fragment,r),te(N.$$.fragment,r),te(I.$$.fragment,r),te(y.$$.fragment,r),te(V.$$.fragment,r),te(B.$$.fragment,r),te(le.$$.fragment,r),te(he.$$.fragment,r),te(se.$$.fragment,r),te(de.$$.fragment,r),xe=!1},d(r){o(h),r&&o(D),r&&o(p),ae(l),r&&o(w),r&&o(T),ae(N),ae(I),r&&o(j),r&&o(v),ae(y),ae(V),r&&o(H),r&&o(A),ae(B),ae(le),r&&o($e),r&&o(R),ae(he),ae(se),ae(de)}}}const po={local:"huggingface_hub.hf_hub_download",title:"Downloading files"};function mo(K){return to(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class $o extends Ze{constructor(h){super();eo(this,h,mo,go,oo,{})}}export{$o as default,po as metadata};
