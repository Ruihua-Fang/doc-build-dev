import{S as to,i as ao,s as ro,e as t,k as u,w as K,t as s,M as io,c as a,d as o,m as p,a as r,x as Q,h as l,b as G,F as e,g as x,y as X,q as Y,o as Z,B as ee,v as so}from"../../chunks/vendor-7b1da053.js";import{T as xe}from"../../chunks/Tip-41a95816.js";import{D as Te}from"../../chunks/Docstring-f1352b16.js";import{C as lo}from"../../chunks/CodeBlock-5f39b59e.js";import{I as co}from"../../chunks/IconCopyLink-d24e9a6f.js";function ho(M){let f,A,m,i,g,_,I,U,E,T,w,k,b,y,c,$,O,v,h,P,S;return{c(){f=t("p"),A=s("Raises the following errors:"),m=u(),i=t("ul"),g=t("li"),_=t("code"),I=s("EnvironmentError"),U=s(" if "),E=t("code"),T=s("use_auth_token=True"),w=s(" and the token cannot be found."),k=u(),b=t("li"),y=t("code"),c=s("OSError"),$=s(" if ETag cannot be determined."),O=u(),v=t("li"),h=t("code"),P=s("ValueError"),S=s(" if the file cannot be downloaded and cannot be found locally.")},l(d){f=a(d,"P",{});var N=r(f);A=l(N,"Raises the following errors:"),N.forEach(o),m=p(d),i=a(d,"UL",{});var D=r(i);g=a(D,"LI",{});var L=r(g);_=a(L,"CODE",{});var W=r(_);I=l(W,"EnvironmentError"),W.forEach(o),U=l(L," if "),E=a(L,"CODE",{});var B=r(E);T=l(B,"use_auth_token=True"),B.forEach(o),w=l(L," and the token cannot be found."),L.forEach(o),k=p(D),b=a(D,"LI",{});var j=r(b);y=a(j,"CODE",{});var z=r(y);c=l(z,"OSError"),z.forEach(o),$=l(j," if ETag cannot be determined."),j.forEach(o),O=p(D),v=a(D,"LI",{});var H=r(v);h=a(H,"CODE",{});var F=r(h);P=l(F,"ValueError"),F.forEach(o),S=l(H," if the file cannot be downloaded and cannot be found locally."),H.forEach(o),D.forEach(o)},m(d,N){x(d,f,N),e(f,A),x(d,m,N),x(d,i,N),e(i,g),e(g,_),e(_,I),e(g,U),e(g,E),e(E,T),e(g,w),e(i,k),e(i,b),e(b,y),e(y,c),e(b,$),e(i,O),e(i,v),e(v,h),e(h,P),e(v,S)},d(d){d&&o(f),d&&o(m),d&&o(i)}}}function fo(M){let f,A,m,i,g,_,I,U,E,T,w,k,b,y,c,$,O,v,h,P,S;return{c(){f=t("p"),A=s("Raises the following errors:"),m=u(),i=t("ul"),g=t("li"),_=t("code"),I=s("EnvironmentError"),U=s(" if "),E=t("code"),T=s("use_auth_token=True"),w=s(" and the token cannot be found."),k=u(),b=t("li"),y=t("code"),c=s("OSError"),$=s(" if ETag cannot be determined."),O=u(),v=t("li"),h=t("code"),P=s("ValueError"),S=s(" if the file cannot be downloaded and cannot be found locally.")},l(d){f=a(d,"P",{});var N=r(f);A=l(N,"Raises the following errors:"),N.forEach(o),m=p(d),i=a(d,"UL",{});var D=r(i);g=a(D,"LI",{});var L=r(g);_=a(L,"CODE",{});var W=r(_);I=l(W,"EnvironmentError"),W.forEach(o),U=l(L," if "),E=a(L,"CODE",{});var B=r(E);T=l(B,"use_auth_token=True"),B.forEach(o),w=l(L," and the token cannot be found."),L.forEach(o),k=p(D),b=a(D,"LI",{});var j=r(b);y=a(j,"CODE",{});var z=r(y);c=l(z,"OSError"),z.forEach(o),$=l(j," if ETag cannot be determined."),j.forEach(o),O=p(D),v=a(D,"LI",{});var H=r(v);h=a(H,"CODE",{});var F=r(h);P=l(F,"ValueError"),F.forEach(o),S=l(H," if the file cannot be downloaded and cannot be found locally."),H.forEach(o),D.forEach(o)},m(d,N){x(d,f,N),e(f,A),x(d,m,N),x(d,i,N),e(i,g),e(g,_),e(_,I),e(g,U),e(g,E),e(E,T),e(g,w),e(i,k),e(i,b),e(b,y),e(y,c),e(b,$),e(i,O),e(i,v),e(v,h),e(h,P),e(v,S)},d(d){d&&o(f),d&&o(m),d&&o(i)}}}function go(M){let f,A,m,i,g,_,I,U,E,T,w,k,b,y,c,$,O,v,h,P,S;return{c(){f=t("p"),A=s("Raises the following errors:"),m=u(),i=t("ul"),g=t("li"),_=t("code"),I=s("EnvironmentError"),U=s(" if "),E=t("code"),T=s("use_auth_token=True"),w=s(" and the token cannot be found."),k=u(),b=t("li"),y=t("code"),c=s("OSError"),$=s(" if ETag cannot be determined."),O=u(),v=t("li"),h=t("code"),P=s("ValueError"),S=s(" if the file cannot be downloaded and cannot be found locally.")},l(d){f=a(d,"P",{});var N=r(f);A=l(N,"Raises the following errors:"),N.forEach(o),m=p(d),i=a(d,"UL",{});var D=r(i);g=a(D,"LI",{});var L=r(g);_=a(L,"CODE",{});var W=r(_);I=l(W,"EnvironmentError"),W.forEach(o),U=l(L," if "),E=a(L,"CODE",{});var B=r(E);T=l(B,"use_auth_token=True"),B.forEach(o),w=l(L," and the token cannot be found."),L.forEach(o),k=p(D),b=a(D,"LI",{});var j=r(b);y=a(j,"CODE",{});var z=r(y);c=l(z,"OSError"),z.forEach(o),$=l(j," if ETag cannot be determined."),j.forEach(o),O=p(D),v=a(D,"LI",{});var H=r(v);h=a(H,"CODE",{});var F=r(h);P=l(F,"ValueError"),F.forEach(o),S=l(H," if the file cannot be downloaded and cannot be found locally."),H.forEach(o),D.forEach(o)},m(d,N){x(d,f,N),e(f,A),x(d,m,N),x(d,i,N),e(i,g),e(g,_),e(_,I),e(g,U),e(g,E),e(E,T),e(g,w),e(i,k),e(i,b),e(b,y),e(y,c),e(b,$),e(i,O),e(i,v),e(v,h),e(h,P),e(v,S)},d(d){d&&o(f),d&&o(m),d&&o(i)}}}function uo(M){let f,A,m,i,g,_,I,U,E,T,w,k,b,y;return{c(){f=t("p"),A=s("Notes:"),m=u(),i=t("p"),g=s(`Cloudfront is replicated over the globe so downloads are way faster for
the end user (and it also lowers our bandwidth costs).`),_=u(),I=t("p"),U=s(`Cloudfront aggressively caches files by default (default TTL is 24
hours), however this is not an issue here because we implement a
git-based versioning system on huggingface.co, which means that we
store the files on S3/Cloudfront in a content-addressable way (i.e.,
the file name is its hash). Using content-addressable filenames means
cache can\u2019t ever be stale.`),E=u(),T=t("p"),w=s(`In terms of client-side caching from this library, we base our caching
on the objects\u2019 entity tag (`),k=t("code"),b=s("ETag"),y=s(`), which is an identifier of a
specific version of a resource [1]_. An object\u2019s ETag is: its git-sha1
if stored in git, or its sha256 if stored in git-lfs.`)},l(c){f=a(c,"P",{});var $=r(f);A=l($,"Notes:"),$.forEach(o),m=p(c),i=a(c,"P",{});var O=r(i);g=l(O,`Cloudfront is replicated over the globe so downloads are way faster for
the end user (and it also lowers our bandwidth costs).`),O.forEach(o),_=p(c),I=a(c,"P",{});var v=r(I);U=l(v,`Cloudfront aggressively caches files by default (default TTL is 24
hours), however this is not an issue here because we implement a
git-based versioning system on huggingface.co, which means that we
store the files on S3/Cloudfront in a content-addressable way (i.e.,
the file name is its hash). Using content-addressable filenames means
cache can\u2019t ever be stale.`),v.forEach(o),E=p(c),T=a(c,"P",{});var h=r(T);w=l(h,`In terms of client-side caching from this library, we base our caching
on the objects\u2019 entity tag (`),k=a(h,"CODE",{});var P=r(k);b=l(P,"ETag"),P.forEach(o),y=l(h,`), which is an identifier of a
specific version of a resource [1]_. An object\u2019s ETag is: its git-sha1
if stored in git, or its sha256 if stored in git-lfs.`),h.forEach(o)},m(c,$){x(c,f,$),e(f,A),x(c,m,$),x(c,i,$),e(i,g),x(c,_,$),x(c,I,$),e(I,U),x(c,E,$),x(c,T,$),e(T,w),e(T,k),e(k,b),e(T,y)},d(c){c&&o(f),c&&o(m),c&&o(i),c&&o(_),c&&o(I),c&&o(E),c&&o(T)}}}function po(M){let f,A,m,i,g,_,I,U,E,T,w,k,b,y,c,$,O,v,h,P,S,d,N,D,L,W,B,j,z,H,F,ye,V,ae,ke,he,Ne,De,fe,Oe,Le,oe,Ee,C,re,Ie,ge,Pe,qe,ue,Ue,Ce,pe,Ae,je,ie,Fe,ne,Re,_e,Se,He,me,de,Ve,se,We,$e;return _=new co({}),k=new Te({props:{name:"huggingface_hub.hf_hub_download",anchor:"huggingface_hub.hf_hub_download",parameters:[{name:"repo_id",val:": str"},{name:"filename",val:": str"},{name:"subfolder",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"force_download",val:": typing.Optional[bool] = False"},{name:"force_filename",val:": typing.Optional[str] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/file_download.py#L632",parametersDescription:[{anchor:"huggingface_hub.hf_hub_download.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A user or an organization name and a repo name separated by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.hf_hub_download.filename",description:`<strong>filename</strong> (<code>str</code>) &#x2014;
The name of the file in the repo.`,name:"filename"},{anchor:"huggingface_hub.hf_hub_download.subfolder",description:`<strong>subfolder</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional value corresponding to a folder inside the model repo.`,name:"subfolder"},{anchor:"huggingface_hub.hf_hub_download.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Set to <code>&quot;dataset&quot;</code> or <code>&quot;space&quot;</code> if uploading to a dataset
or space, <code>None</code> or <code>&quot;model&quot;</code> if uploading to a model.
Default is <code>None</code>.`,name:"repo_type"},{anchor:"huggingface_hub.hf_hub_download.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"},{anchor:"huggingface_hub.hf_hub_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.hf_hub_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.hf_hub_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.hf_hub_download.user_agent",description:`<strong>user_agent</strong> (<code>dict</code>, <code>str</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.hf_hub_download.force_download",description:`<strong>force_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the file should be downloaded even if it already exists in
the local cache.`,name:"force_download"},{anchor:"huggingface_hub.hf_hub_download.force_filename",description:`<strong>force_filename</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Use this name instead of a generated file name.`,name:"force_filename"},{anchor:"huggingface_hub.hf_hub_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.hf_hub_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em>, defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.hf_hub_download.resume_download",description:`<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, resume a previously interrupted download.`,name:"resume_download"},{anchor:"huggingface_hub.hf_hub_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code>, <code>bool</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.hf_hub_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"}],returnDescription:`
<p>Local path (string) of file or if networking is off, last version of
file cached on disk.</p>
`}}),O=new xe({props:{$$slots:{default:[ho]},$$scope:{ctx:M}}}),P=new Te({props:{name:"huggingface_hub.snapshot_download",anchor:"huggingface_hub.snapshot_download",parameters:[{name:"repo_id",val:": str"},{name:"revision",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"},{name:"allow_regex",val:": typing.Union[typing.List[str], str, NoneType] = None"},{name:"ignore_regex",val:": typing.Union[typing.List[str], str, NoneType] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/snapshot_download.py#L21",parametersDescription:[{anchor:"huggingface_hub.snapshot_download.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A user or an organization name and a repo name separated by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.snapshot_download.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"},{anchor:"huggingface_hub.snapshot_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.snapshot_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.snapshot_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.snapshot_download.user_agent",description:`<strong>user_agent</strong> (<code>str</code>, <code>dict</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.snapshot_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.snapshot_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em>, defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.snapshot_download.resume_download",description:"<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False) -- If </code>True`, resume a previously interrupted download.",name:"resume_download"},{anchor:"huggingface_hub.snapshot_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code>, <code>bool</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.snapshot_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"},{anchor:"huggingface_hub.snapshot_download.allow_regex",description:`<strong>allow_regex</strong> (<code>list of str</code>, <code>str</code>, <em>optional</em>) &#x2014;
If provided, only files matching this regex are downloaded.`,name:"allow_regex"},{anchor:"huggingface_hub.snapshot_download.ignore_regex",description:`<strong>ignore_regex</strong> (<code>list of str</code>, <code>str</code>, <em>optional</em>) &#x2014;
If provided, files matching this regex are not downloaded.`,name:"ignore_regex"}],returnDescription:`
<p>Local folder path (string) of repo snapshot</p>
`}}),F=new xe({props:{$$slots:{default:[fo]},$$scope:{ctx:M}}}),ae=new Te({props:{name:"huggingface_hub.cached_download",anchor:"huggingface_hub.cached_download",parameters:[{name:"url",val:": str"},{name:"library_name",val:": typing.Optional[str] = None"},{name:"library_version",val:": typing.Optional[str] = None"},{name:"cache_dir",val:": typing.Union[str, pathlib.Path, NoneType] = None"},{name:"user_agent",val:": typing.Union[typing.Dict, str, NoneType] = None"},{name:"force_download",val:": typing.Optional[bool] = False"},{name:"force_filename",val:": typing.Optional[str] = None"},{name:"proxies",val:": typing.Optional[typing.Dict] = None"},{name:"etag_timeout",val:": typing.Optional[float] = 10"},{name:"resume_download",val:": typing.Optional[bool] = False"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"local_files_only",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/file_download.py#L392",parametersDescription:[{anchor:"huggingface_hub.cached_download.url",description:`<strong>url</strong> (<code>str</code>) &#x2014;
The path to the file to be downloaded.`,name:"url"},{anchor:"huggingface_hub.cached_download.library_name",description:`<strong>library_name</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The name of the library to which the object corresponds.`,name:"library_name"},{anchor:"huggingface_hub.cached_download.library_version",description:`<strong>library_version</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The version of the library.`,name:"library_version"},{anchor:"huggingface_hub.cached_download.cache_dir",description:`<strong>cache_dir</strong> (<code>str</code>, <code>Path</code>, <em>optional</em>) &#x2014;
Path to the folder where cached files are stored.`,name:"cache_dir"},{anchor:"huggingface_hub.cached_download.user_agent",description:`<strong>user_agent</strong> (<code>dict</code>, <code>str</code>, <em>optional</em>) &#x2014;
The user-agent info in the form of a dictionary or a string.`,name:"user_agent"},{anchor:"huggingface_hub.cached_download.force_download",description:`<strong>force_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether the file should be downloaded even if it already exists in
the local cache.`,name:"force_download"},{anchor:"huggingface_hub.cached_download.force_filename",description:`<strong>force_filename</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Use this name instead of a generated file name.`,name:"force_filename"},{anchor:"huggingface_hub.cached_download.proxies",description:`<strong>proxies</strong> (<code>dict</code>, <em>optional</em>) &#x2014;
Dictionary mapping protocol to the URL of the proxy passed to
<code>requests.request</code>.`,name:"proxies"},{anchor:"huggingface_hub.cached_download.etag_timeout",description:`<strong>etag_timeout</strong> (<code>float</code>, <em>optional</em> defaults to <code>10</code>) &#x2014;
When fetching ETag, how many seconds to wait for the server to send
data before giving up which is passed to <code>requests.request</code>.`,name:"etag_timeout"},{anchor:"huggingface_hub.cached_download.resume_download",description:`<strong>resume_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, resume a previously interrupted download.`,name:"resume_download"},{anchor:"huggingface_hub.cached_download.use_auth_token",description:`<strong>use_auth_token</strong> (<code>bool</code>, <code>str</code>, <em>optional</em>) &#x2014;
A token to be used for the download.<ul>
<li>If <code>True</code>, the token is read from the HuggingFace config
folder.</li>
<li>If a string, it&#x2019;s used as the authentication token.</li>
</ul>`,name:"use_auth_token"},{anchor:"huggingface_hub.cached_download.local_files_only",description:`<strong>local_files_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, avoid downloading the file and return the path to the
local cached file if it exists.`,name:"local_files_only"}],returnDescription:`
<p>Local path (string) of file or if networking is off, last version of
file cached on disk.</p>
`}}),oe=new xe({props:{$$slots:{default:[go]},$$scope:{ctx:M}}}),re=new Te({props:{name:"huggingface_hub.hf_hub_url",anchor:"huggingface_hub.hf_hub_url",parameters:[{name:"repo_id",val:": str"},{name:"filename",val:": str"},{name:"subfolder",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/file_download.py#L108",parametersDescription:[{anchor:"huggingface_hub.hf_hub_url.repo_id",description:`<strong>repo_id</strong> (<code>str</code>) &#x2014;
A namespace (user or an organization) name and a repo name
separated by a <code>/</code>.`,name:"repo_id"},{anchor:"huggingface_hub.hf_hub_url.filename",description:`<strong>filename</strong> (<code>str</code>) &#x2014;
The name of the file in the repo.`,name:"filename"},{anchor:"huggingface_hub.hf_hub_url.subfolder",description:`<strong>subfolder</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional value corresponding to a folder inside the repo.`,name:"subfolder"},{anchor:"huggingface_hub.hf_hub_url.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Set to <code>&quot;dataset&quot;</code> or <code>&quot;space&quot;</code> if uploading to a dataset
or space, <code>None</code> or <code>&quot;model&quot;</code> if uploading to a model.
Default is <code>None</code>.`,name:"repo_type"},{anchor:"huggingface_hub.hf_hub_url.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
An optional Git revision id which can be a branch name, a tag, or a
commit hash.`,name:"revision"}]}}),ie=new lo({props:{code:`from huggingface_hub import hf_hub_url
hf_hub_url(
   repo_id="julien-c/EsperBERTo-small", filename="pytorch_model.bin"
)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> huggingface_hub <span class="hljs-keyword">import</span> hf_hub_url
<span class="hljs-meta">&gt;&gt;&gt; </span>hf_hub_url(
<span class="hljs-meta">... </span>   repo_id=<span class="hljs-string">&quot;julien-c/EsperBERTo-small&quot;</span>, filename=<span class="hljs-string">&quot;pytorch_model.bin&quot;</span>
<span class="hljs-meta">... </span>)
<span class="hljs-string">&#x27;https://huggingface.co/julien-c/EsperBERTo-small/resolve/main/pytorch_model.bin&#x27;</span>`}}),ne=new xe({props:{$$slots:{default:[uo]},$$scope:{ctx:M}}}),{c(){f=t("meta"),A=u(),m=t("h1"),i=t("a"),g=t("span"),K(_.$$.fragment),I=u(),U=t("span"),E=s("Downloading files"),T=u(),w=t("div"),K(k.$$.fragment),b=u(),y=t("p"),c=s("Download a given file if it\u2019s not already present in the local cache."),$=u(),K(O.$$.fragment),v=u(),h=t("div"),K(P.$$.fragment),S=u(),d=t("p"),N=s("Download all files of a repo."),D=u(),L=t("p"),W=s(`Downloads a whole snapshot of a repo\u2019s files at the specified revision.
This is useful when you want all files from a repo, because you don\u2019t know
which ones you will need a priori.
All files are nested inside a folder in order to keep their actual filename
relative to that folder.`),B=u(),j=t("p"),z=s(`An alternative would be to just clone a repo but this would require that
the user always has git and git-lfs installed, and properly configured.`),H=u(),K(F.$$.fragment),ye=u(),V=t("div"),K(ae.$$.fragment),ke=u(),he=t("p"),Ne=s("Download from a given URL and cache it if it\u2019s not already present in the local cache."),De=u(),fe=t("p"),Oe=s(`Given a URL, this function looks for the corresponding file in the local
cache. If it\u2019s not there, download it. Then return the path to the cached
file.`),Le=u(),K(oe.$$.fragment),Ee=u(),C=t("div"),K(re.$$.fragment),Ie=u(),ge=t("p"),Pe=s("Construct the URL of a file from the given information."),qe=u(),ue=t("p"),Ue=s(`The resolved address can either be a huggingface.co-hosted url, or a link
to Cloudfront (a Content Delivery Network, or CDN) for large files which
are more than a few MBs.`),Ce=u(),pe=t("p"),Ae=s("Example:"),je=u(),K(ie.$$.fragment),Fe=u(),K(ne.$$.fragment),Re=u(),_e=t("p"),Se=s("References:"),He=u(),me=t("ul"),de=t("li"),Ve=s("[1] "),se=t("a"),We=s("https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),this.h()},l(n){const q=io('[data-svelte="svelte-1phssyn"]',document.head);f=a(q,"META",{name:!0,content:!0}),q.forEach(o),A=p(n),m=a(n,"H1",{class:!0});var le=r(m);i=a(le,"A",{id:!0,class:!0,href:!0});var be=r(i);g=a(be,"SPAN",{});var ve=r(g);Q(_.$$.fragment,ve),ve.forEach(o),be.forEach(o),I=p(le),U=a(le,"SPAN",{});var we=r(U);E=l(we,"Downloading files"),we.forEach(o),le.forEach(o),T=p(n),w=a(n,"DIV",{class:!0});var ce=r(w);Q(k.$$.fragment,ce),b=p(ce),y=a(ce,"P",{});var ze=r(y);c=l(ze,"Download a given file if it\u2019s not already present in the local cache."),ze.forEach(o),$=p(ce),Q(O.$$.fragment,ce),ce.forEach(o),v=p(n),h=a(n,"DIV",{class:!0});var J=r(h);Q(P.$$.fragment,J),S=p(J),d=a(J,"P",{});var Ge=r(d);N=l(Ge,"Download all files of a repo."),Ge.forEach(o),D=p(J),L=a(J,"P",{});var Me=r(L);W=l(Me,`Downloads a whole snapshot of a repo\u2019s files at the specified revision.
This is useful when you want all files from a repo, because you don\u2019t know
which ones you will need a priori.
All files are nested inside a folder in order to keep their actual filename
relative to that folder.`),Me.forEach(o),B=p(J),j=a(J,"P",{});var Je=r(j);z=l(Je,`An alternative would be to just clone a repo but this would require that
the user always has git and git-lfs installed, and properly configured.`),Je.forEach(o),H=p(J),Q(F.$$.fragment,J),J.forEach(o),ye=p(n),V=a(n,"DIV",{class:!0});var te=r(V);Q(ae.$$.fragment,te),ke=p(te),he=a(te,"P",{});var Ke=r(he);Ne=l(Ke,"Download from a given URL and cache it if it\u2019s not already present in the local cache."),Ke.forEach(o),De=p(te),fe=a(te,"P",{});var Qe=r(fe);Oe=l(Qe,`Given a URL, this function looks for the corresponding file in the local
cache. If it\u2019s not there, download it. Then return the path to the cached
file.`),Qe.forEach(o),Le=p(te),Q(oe.$$.fragment,te),te.forEach(o),Ee=p(n),C=a(n,"DIV",{class:!0});var R=r(C);Q(re.$$.fragment,R),Ie=p(R),ge=a(R,"P",{});var Xe=r(ge);Pe=l(Xe,"Construct the URL of a file from the given information."),Xe.forEach(o),qe=p(R),ue=a(R,"P",{});var Ye=r(ue);Ue=l(Ye,`The resolved address can either be a huggingface.co-hosted url, or a link
to Cloudfront (a Content Delivery Network, or CDN) for large files which
are more than a few MBs.`),Ye.forEach(o),Ce=p(R),pe=a(R,"P",{});var Ze=r(pe);Ae=l(Ze,"Example:"),Ze.forEach(o),je=p(R),Q(ie.$$.fragment,R),Fe=p(R),Q(ne.$$.fragment,R),Re=p(R),_e=a(R,"P",{});var eo=r(_e);Se=l(eo,"References:"),eo.forEach(o),He=p(R),me=a(R,"UL",{});var oo=r(me);de=a(oo,"LI",{});var Be=r(de);Ve=l(Be,"[1] "),se=a(Be,"A",{href:!0,rel:!0});var no=r(se);We=l(no,"https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),no.forEach(o),Be.forEach(o),oo.forEach(o),R.forEach(o),this.h()},h(){G(f,"name","hf:doc:metadata"),G(f,"content",JSON.stringify(_o)),G(i,"id","huggingface_hub.hf_hub_download"),G(i,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),G(i,"href","#huggingface_hub.hf_hub_download"),G(m,"class","relative group"),G(w,"class","docstring"),G(h,"class","docstring"),G(V,"class","docstring"),G(se,"href","https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag"),G(se,"rel","nofollow"),G(C,"class","docstring")},m(n,q){e(document.head,f),x(n,A,q),x(n,m,q),e(m,i),e(i,g),X(_,g,null),e(m,I),e(m,U),e(U,E),x(n,T,q),x(n,w,q),X(k,w,null),e(w,b),e(w,y),e(y,c),e(w,$),X(O,w,null),x(n,v,q),x(n,h,q),X(P,h,null),e(h,S),e(h,d),e(d,N),e(h,D),e(h,L),e(L,W),e(h,B),e(h,j),e(j,z),e(h,H),X(F,h,null),x(n,ye,q),x(n,V,q),X(ae,V,null),e(V,ke),e(V,he),e(he,Ne),e(V,De),e(V,fe),e(fe,Oe),e(V,Le),X(oe,V,null),x(n,Ee,q),x(n,C,q),X(re,C,null),e(C,Ie),e(C,ge),e(ge,Pe),e(C,qe),e(C,ue),e(ue,Ue),e(C,Ce),e(C,pe),e(pe,Ae),e(C,je),X(ie,C,null),e(C,Fe),X(ne,C,null),e(C,Re),e(C,_e),e(_e,Se),e(C,He),e(C,me),e(me,de),e(de,Ve),e(de,se),e(se,We),$e=!0},p(n,[q]){const le={};q&2&&(le.$$scope={dirty:q,ctx:n}),O.$set(le);const be={};q&2&&(be.$$scope={dirty:q,ctx:n}),F.$set(be);const ve={};q&2&&(ve.$$scope={dirty:q,ctx:n}),oe.$set(ve);const we={};q&2&&(we.$$scope={dirty:q,ctx:n}),ne.$set(we)},i(n){$e||(Y(_.$$.fragment,n),Y(k.$$.fragment,n),Y(O.$$.fragment,n),Y(P.$$.fragment,n),Y(F.$$.fragment,n),Y(ae.$$.fragment,n),Y(oe.$$.fragment,n),Y(re.$$.fragment,n),Y(ie.$$.fragment,n),Y(ne.$$.fragment,n),$e=!0)},o(n){Z(_.$$.fragment,n),Z(k.$$.fragment,n),Z(O.$$.fragment,n),Z(P.$$.fragment,n),Z(F.$$.fragment,n),Z(ae.$$.fragment,n),Z(oe.$$.fragment,n),Z(re.$$.fragment,n),Z(ie.$$.fragment,n),Z(ne.$$.fragment,n),$e=!1},d(n){o(f),n&&o(A),n&&o(m),ee(_),n&&o(T),n&&o(w),ee(k),ee(O),n&&o(v),n&&o(h),ee(P),ee(F),n&&o(ye),n&&o(V),ee(ae),ee(oe),n&&o(Ee),n&&o(C),ee(re),ee(ie),ee(ne)}}}const _o={local:"huggingface_hub.hf_hub_download",title:"Downloading files"};function mo(M){return so(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class $o extends to{constructor(f){super();ao(this,f,mo,po,ro,{})}}export{$o as default,_o as metadata};
