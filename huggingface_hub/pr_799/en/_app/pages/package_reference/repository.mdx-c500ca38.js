import{S as eg,i as tg,s as og,e as r,k as c,w as u,t as s,M as rg,c as a,d as o,m as l,a as n,x as d,h as i,b as p,F as e,g as $,y as f,L as ag,q as m,o as _,B as b,v as ng}from"../../chunks/vendor-7b1da053.js";import{D as y}from"../../chunks/Docstring-f1352b16.js";import{C as sg}from"../../chunks/CodeBlock-5f39b59e.js";import{I as Ea}from"../../chunks/IconCopyLink-d24e9a6f.js";function ig(bc){let H,vr,S,oe,Ut,He,ka,Mt,Da,yr,E,Ra,Wt,xa,Ta,Bt,Pa,Ia,Gt,Oa,Ca,$r,re,La,zt,Fa,Na,wr,j,ae,Jt,Se,Va,je,Ha,Kt,Sa,ja,Er,g,Ae,Aa,Qt,qa,Ua,Xt,Ma,Wa,k,qe,Ba,Yt,Ga,za,A,Ja,Zt,Ka,Qa,eo,Xa,Ya,Za,D,to,en,tn,oo,on,rn,ro,an,nn,ao,sn,cn,ln,ne,Ue,gn,no,hn,pn,R,Me,un,so,dn,fn,io,mn,_n,co,bn,vn,se,We,yn,lo,$n,wn,ie,Be,En,q,kn,go,Dn,Rn,ho,xn,Tn,Pn,C,Ge,In,po,On,Cn,uo,Ln,Fn,x,ze,Nn,U,Vn,fo,Hn,Sn,mo,jn,An,qn,_o,Un,Mn,Je,Wn,ce,Ke,Bn,bo,Gn,zn,L,Qe,Jn,vo,Kn,Qn,I,Xn,yo,Yn,Zn,$o,es,ts,wo,os,rs,as,F,Xe,ns,Eo,ss,is,M,cs,ko,ls,gs,Do,hs,ps,us,le,Ye,ds,Ro,fs,ms,ge,Ze,_s,xo,bs,vs,he,et,ys,It,$s,To,ws,Es,pe,tt,ks,Po,Ds,Rs,ue,ot,xs,Io,Ts,Ps,de,rt,Is,Oo,Os,Cs,N,at,Ls,Co,Fs,Ns,W,Vs,Lo,Hs,Ss,Fo,js,As,qs,fe,nt,Us,No,Ms,Ws,me,st,Bs,Vo,Gs,zs,_e,it,Js,Ho,Ks,Qs,be,ct,Xs,So,Ys,Zs,V,lt,ei,jo,ti,oi,O,ri,Ao,ai,ni,qo,si,ii,Uo,ci,li,gi,ve,gt,hi,Mo,pi,ui,ye,ht,di,Wo,fi,mi,$e,pt,_i,Bo,bi,vi,we,ut,yi,Go,$i,wi,Ee,dt,Ei,zo,ki,kr,B,ke,Jo,ft,Di,Ko,Ri,Dr,G,mt,xi,Qo,Ti,Rr,z,_t,Pi,Xo,Ii,xr,J,bt,Oi,Yo,Ci,Tr,K,vt,Li,Zo,Fi,Pr,Q,yt,Ni,er,Vi,Ir,X,$t,Hi,tr,Si,Or,Y,wt,ji,or,Ai,Cr,Z,De,rr,Et,qi,ar,Ui,Lr,Re,Mi,nr,Wi,Bi,Fr,T,sr,ir,Gi,zi,cr,lr,Ji,Ki,gr,hr,Qi,Xi,kt,Yi,pr,Zi,ec,Nr,Ot,tc,Vr,w,Dt,oc,ur,rc,ac,dr,nc,sc,xe,Rt,ic,fr,cc,lc,Te,xt,gc,mr,hc,pc,Pe,Tt,uc,_r,dc,Hr,ee,Pt,fc,br,mc,Sr;return He=new Ea({}),Se=new Ea({}),Ae=new y({props:{name:"class huggingface_hub.Repository",anchor:"huggingface_hub.Repository",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L411"}}),qe=new y({props:{name:"__init__",anchor:"huggingface_hub.Repository.__init__",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L421",parametersDescription:[{anchor:"huggingface_hub.Repository.__init__.local_dir",description:`<strong>local_dir</strong> (<code>str</code>) &#x2014;
path (e.g. <code>&apos;my_trained_model/&apos;</code>) to the local directory, where the <code>Repository</code> will be initalized.`,name:"local_dir"},{anchor:"huggingface_hub.Repository.__init__.clone_from",description:`<strong>clone_from</strong> (<code>str</code>, <em>optional</em>) &#x2014;
repository url (e.g. <code>&apos;https://huggingface.co/philschmid/playground-tests&apos;</code>).`,name:"clone_from"},{anchor:"huggingface_hub.Repository.__init__.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
To set when creating a repo: et to &#x201C;dataset&#x201D; or &#x201C;space&#x201D; if creating a dataset or space, default is model.`,name:"repo_type"},{anchor:"huggingface_hub.Repository.__init__.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code> or <code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
huggingface_token can be extract from <code>HfApi().login(username, password)</code> and is used to authenticate against the hub
(useful from Google Colab for instance).`,name:"use_auth_token"},{anchor:"huggingface_hub.Repository.__init__.git_user",description:`<strong>git_user</strong> (<code>str</code>, <em>optional</em>) &#x2014;
will override the <code>git config user.name</code> for committing and pushing files to the hub.`,name:"git_user"},{anchor:"huggingface_hub.Repository.__init__.git_email",description:`<strong>git_email</strong> (<code>str</code>, <em>optional</em>) &#x2014;
will override the <code>git config user.email</code> for committing and pushing files to the hub.`,name:"git_email"},{anchor:"huggingface_hub.Repository.__init__.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Revision to checkout after initializing the repository. If the revision doesn&#x2019;t exist, a
branch will be created with that revision name from the default branch&#x2019;s current HEAD.`,name:"revision"},{anchor:"huggingface_hub.Repository.__init__.private",description:`<strong>private</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
whether the repository is private or not.`,name:"private"},{anchor:"huggingface_hub.Repository.__init__.skip_lfs_files",description:`<strong>skip_lfs_files</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
whether to skip git-LFS files or not.`,name:"skip_lfs_files"}]}}),Ue=new y({props:{name:"current_branch",anchor:"huggingface_hub.Repository.current_branch",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L516",returnDescription:`
<p>Current checked out branch.</p>
`,returnType:`
<p><code>str</code></p>
`}}),Me=new y({props:{name:"add_tag",anchor:"huggingface_hub.Repository.add_tag",parameters:[{name:"tag_name",val:": str"},{name:"message",val:": str = None"},{name:"remote",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L1330",parametersDescription:[{anchor:"huggingface_hub.Repository.add_tag.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The name of the tag to be added.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.add_tag.message",description:`<strong>message</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The message that accompanies the tag. The tag will turn into an annotated tag if a message
is passed.`,name:"message"},{anchor:"huggingface_hub.Repository.add_tag.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The remote on which to add the tag.`,name:"remote"}]}}),We=new y({props:{name:"auto_track_large_files",anchor:"huggingface_hub.Repository.auto_track_large_files",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L947",parametersDescription:[{anchor:"huggingface_hub.Repository.auto_track_large_files.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to track files that are above 10MBs.`,name:"pattern"}],returnDescription:`
<p>List of filenames that are now tracked due to their size.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),Be=new y({props:{name:"check_git_versions",anchor:"huggingface_hub.Repository.check_git_versions",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L539"}}),Ge=new y({props:{name:"clone_from",anchor:"huggingface_hub.Repository.clone_from",parameters:[{name:"repo_url",val:": str"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L575",parametersDescription:[{anchor:"huggingface_hub.Repository.clone_from.repo_url",description:`<strong>repo_url</strong> (<code>str</code>) &#x2014;
The URL from which to clone the repository`,name:"repo_url"},{anchor:"huggingface_hub.Repository.clone_from.use_auth_token",description:`<strong>use_auth_token</strong> (<code>Union[str, bool]</code>, <em>optional</em>) &#x2014;
Whether to use the authentication token. It can be:<ul>
<li>a string which is the token itself</li>
<li><code>False</code>, which would not use the authentication token</li>
<li><code>True</code>, which would fetch the authentication token from the local folder and use it (you should
be logged in for this to work).</li>
<li><code>None</code>, which would retrieve the value of <code>self.huggingface_token</code>.</li>
</ul>`,name:"use_auth_token"}]}}),ze=new y({props:{name:"commit",anchor:"huggingface_hub.Repository.commit",parameters:[{name:"commit_message",val:": str"},{name:"branch",val:": typing.Optional[str] = None"},{name:"track_large_files",val:": typing.Optional[bool] = True"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L1431",parametersDescription:[{anchor:"huggingface_hub.Repository.commit.commit_message",description:`<strong>commit_message</strong> (<code>str</code>) &#x2014;
Message to use for the commit.`,name:"commit_message"},{anchor:"huggingface_hub.Repository.commit.branch",description:`<strong>branch</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The branch on which the commit will appear. This branch will be checked-out before any operation.`,name:"branch"},{anchor:"huggingface_hub.Repository.commit.track_large_files",description:`<strong>track_large_files</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to automatically track large files or not. Will do so by default.`,name:"track_large_files"},{anchor:"huggingface_hub.Repository.commit.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the <code>git push</code> has finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.commit.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether to automatically prune files once they have been pushed to the remote.`,name:"auto_lfs_prune"}]}}),Je=new sg({props:{code:`with Repository("text-files", clone_from="<user>/text-files", use_auth_token=True).commit("My first file :)"):
    with open("file.txt", "w+") as f:
        f.write(json.dumps({"hey": 8}))

import torch
model = torch.nn.Transformer()
with Repository("torch-model", clone_from="<user>/torch-model", use_auth_token=True).commit("My cool model :)"):
    torch.save(model.state_dict(), "model.pt")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Repository(<span class="hljs-string">&quot;text-files&quot;</span>, clone_from=<span class="hljs-string">&quot;&lt;user&gt;/text-files&quot;</span>, use_auth_token=<span class="hljs-literal">True</span>).commit(<span class="hljs-string">&quot;My first file :)&quot;</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>) <span class="hljs-keyword">as</span> f:
<span class="hljs-meta">... </span>        f.write(json.dumps({<span class="hljs-string">&quot;hey&quot;</span>: <span class="hljs-number">8</span>}))

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span>model = torch.nn.Transformer()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Repository(<span class="hljs-string">&quot;torch-model&quot;</span>, clone_from=<span class="hljs-string">&quot;&lt;user&gt;/torch-model&quot;</span>, use_auth_token=<span class="hljs-literal">True</span>).commit(<span class="hljs-string">&quot;My cool model :)&quot;</span>):
<span class="hljs-meta">... </span>    torch.save(model.state_dict(), <span class="hljs-string">&quot;model.pt&quot;</span>)`}}),Ke=new y({props:{name:"delete_tag",anchor:"huggingface_hub.Repository.delete_tag",parameters:[{name:"tag_name",val:": str"},{name:"remote",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L1279",parametersDescription:[{anchor:"huggingface_hub.Repository.delete_tag.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The tag name to delete.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.delete_tag.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The remote on which to delete the tag.`,name:"remote"}],returnDescription:`
<p><code>True</code> if deleted, <code>False</code> if the tag didn\u2019t exist.
If remote is not passed, will just be updated locally</p>
`,returnType:`
<p><code>bool</code></p>
`}}),Qe=new y({props:{name:"git_add",anchor:"huggingface_hub.Repository.git_add",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"},{name:"auto_lfs_track",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L1037",parametersDescription:[{anchor:"huggingface_hub.Repository.git_add.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to add files to staging.`,name:"pattern"},{anchor:"huggingface_hub.Repository.git_add.auto_lfs_track",description:`<strong>auto_lfs_track</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically track large files with git-lfs. Any file over 10MB in size will be
automatically tracked.`,name:"auto_lfs_track"}]}}),Xe=new y({props:{name:"git_checkout",anchor:"huggingface_hub.Repository.git_checkout",parameters:[{name:"revision",val:": str"},{name:"create_branch_ok",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L1188",parametersDescription:[{anchor:"huggingface_hub.Repository.git_checkout.revision",description:`<strong>revision</strong> (<code>str</code>) &#x2014;
The revision to checkout.`,name:"revision"},{anchor:"huggingface_hub.Repository.git_checkout.create_branch_ok",description:`<strong>create_branch_ok</strong> (<code>str</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether creating a branch named with the <code>revision</code> passed at the current checked-out reference
if <code>revision</code> isn&#x2019;t an existing revision is allowed.`,name:"create_branch_ok"}]}}),Ye=new y({props:{name:"git_commit",anchor:"huggingface_hub.Repository.git_commit",parameters:[{name:"commit_message",val:": str = 'commit files to HF hub'"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L1073",parametersDescription:[{anchor:"huggingface_hub.Repository.git_commit.commit_message",description:`<strong>commit_message</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201C;commit files to HF hub&#x201D;) &#x2014;
The message attributed to the commit.`,name:"commit_message"}]}}),Ze=new y({props:{name:"git_config_username_and_email",anchor:"huggingface_hub.Repository.git_config_username_and_email",parameters:[{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L718",parametersDescription:[{anchor:"huggingface_hub.Repository.git_config_username_and_email.git_user",description:`<strong>git_user</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The username to register through <code>git</code>.`,name:"git_user"},{anchor:"huggingface_hub.Repository.git_config_username_and_email.git_email",description:`<strong>git_email</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The email to register through <code>git</code>.`,name:"git_email"}]}}),et=new y({props:{name:"git_credential_helper_store",anchor:"huggingface_hub.Repository.git_credential_helper_store",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L752"}}),tt=new y({props:{name:"git_head_commit_url",anchor:"huggingface_hub.Repository.git_head_commit_url",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L810",returnDescription:`
<p>The URL to the current checked-out commit.</p>
`,returnType:`
<p><code>str</code></p>
`}}),ot=new y({props:{name:"git_head_hash",anchor:"huggingface_hub.Repository.git_head_hash",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L768",returnDescription:`
<p>The current checked out commit SHA.</p>
`,returnType:`
<p><code>str</code></p>
`}}),rt=new y({props:{name:"git_pull",anchor:"huggingface_hub.Repository.git_pull",parameters:[{name:"rebase",val:": typing.Optional[bool] = False"},{name:"lfs",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L1008",parametersDescription:[{anchor:"huggingface_hub.Repository.git_pull.rebase",description:`<strong>rebase</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to rebase the current branch on top of the upstream branch after fetching.`,name:"rebase"},{anchor:"huggingface_hub.Repository.git_pull.lfs",description:`<strong>lfs</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to fetch the LFS files too. This option only changes the behavior when a repository
was cloned without fetching the LFS files; calling <code>repo.git_pull(lfs=True)</code> will then fetch
the LFS file from the remote repository.`,name:"lfs"}]}}),at=new y({props:{name:"git_push",anchor:"huggingface_hub.Repository.git_push",parameters:[{name:"upstream",val:": typing.Optional[str] = None"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L1097",parametersDescription:[{anchor:"huggingface_hub.Repository.git_push.upstream",description:`<strong>upstream</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Upstream to which this should push. If not specified, will push
to the lastly defined upstream or to the default one (<code>origin main</code>).`,name:"upstream"},{anchor:"huggingface_hub.Repository.git_push.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the push has finished.
Setting this to <code>False</code> will return an <code>CommandInProgress</code> object
which has an <code>is_done</code> property. This property will be set to
<code>True</code> when the push is finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.git_push.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically prune files once they have been pushed to the remote.`,name:"auto_lfs_prune"}]}}),nt=new y({props:{name:"git_remote_url",anchor:"huggingface_hub.Repository.git_remote_url",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L788",returnDescription:`
<p>The URL of the <code>origin</code> remote.</p>
`,returnType:`
<p><code>str</code></p>
`}}),st=new y({props:{name:"is_repo_clean",anchor:"huggingface_hub.Repository.is_repo_clean",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L1377",returnDescription:`
<p><code>True</code> if the git status is clean, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),it=new y({props:{name:"lfs_enable_largefiles",anchor:"huggingface_hub.Repository.lfs_enable_largefiles",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L923"}}),ct=new y({props:{name:"lfs_prune",anchor:"huggingface_hub.Repository.lfs_prune",parameters:[{name:"recent",val:" = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L982",parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_prune.recent",description:`<strong>recent</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to prune files even if they were referenced by recent commits. See the following <a href="https://github.com/git-lfs/git-lfs/blob/f3d43f0428a84fc4f1e5405b76b5a73ec2437e65/docs/man/git-lfs-prune.1.ronn#recent-files" rel="nofollow">link</a>
for more information.`,name:"recent"}]}}),lt=new y({props:{name:"lfs_track",anchor:"huggingface_hub.Repository.lfs_track",parameters:[{name:"patterns",val:": typing.Union[str, typing.List[str]]"},{name:"filename",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L868",parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_track.patterns",description:`<strong>patterns</strong> (<code>Union[str, List[str]]</code>) &#x2014;
The pattern, or list of patterns, to track with git-lfs.`,name:"patterns"},{anchor:"huggingface_hub.Repository.lfs_track.filename",description:`<strong>filename</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to use the patterns as literal filenames.`,name:"filename"}]}}),gt=new y({props:{name:"lfs_untrack",anchor:"huggingface_hub.Repository.lfs_untrack",parameters:[{name:"patterns",val:": typing.Union[str, typing.List[str]]"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L900",parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_untrack.patterns",description:`<strong>patterns</strong> (<code>Union[str, List[str]]</code>) &#x2014;
The pattern, or list of patterns, to untrack with git-lfs.`,name:"patterns"}]}}),ht=new y({props:{name:"list_deleted_files",anchor:"huggingface_hub.Repository.list_deleted_files",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L824",returnDescription:`
<p>A list of files that have been deleted in the working directory or index.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),pt=new y({props:{name:"push_to_hub",anchor:"huggingface_hub.Repository.push_to_hub",parameters:[{name:"commit_message",val:": typing.Optional[str] = 'commit files to HF hub'"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"clean_ok",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L1398",parametersDescription:[{anchor:"huggingface_hub.Repository.push_to_hub.commit_message",description:`<strong>commit_message</strong> (<code>str</code>) &#x2014;
Message to use for the commit.`,name:"commit_message"},{anchor:"huggingface_hub.Repository.push_to_hub.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the <code>git push</code> has finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.push_to_hub.clean_ok",description:`<strong>clean_ok</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
If True, this function will return None if the repo is untouched.
Default behavior is to fail because the git command fails.`,name:"clean_ok"},{anchor:"huggingface_hub.Repository.push_to_hub.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically prune files once they have been pushed to the remote.`,name:"auto_lfs_prune"}]}}),ut=new y({props:{name:"tag_exists",anchor:"huggingface_hub.Repository.tag_exists",parameters:[{name:"tag_name",val:": str"},{name:"remote",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L1235",parametersDescription:[{anchor:"huggingface_hub.Repository.tag_exists.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The name of the tag to check.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.tag_exists.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Whether to check if the tag exists on a remote. This parameter should be the identifier
of the remote.`,name:"remote"}],returnDescription:`
<p>\`Whether the tag exists.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),dt=new y({props:{name:"wait_for_commands",anchor:"huggingface_hub.Repository.wait_for_commands",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L1548"}}),ft=new Ea({}),mt=new y({props:{name:"huggingface_hub.repository.is_git_repo",anchor:"huggingface_hub.repository.is_git_repo",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L101",parametersDescription:[{anchor:"huggingface_hub.repository.is_git_repo.folder",description:`<strong>folder</strong> (<code>str</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],returnDescription:`
<p><code>True</code> if the repository is part of a repository, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),_t=new y({props:{name:"huggingface_hub.repository.is_local_clone",anchor:"huggingface_hub.repository.is_local_clone",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"},{name:"remote_url",val:": str"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L119",parametersDescription:[{anchor:"huggingface_hub.repository.is_local_clone.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"},{anchor:"huggingface_hub.repository.is_local_clone.remote_url",description:`<strong>remote_url</strong> (<code>str</code>) &#x2014;
The url of a git repository.`,name:"remote_url"}],returnDescription:`
<p><code>True</code> if the repository is a local clone of the remote repository specified, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),bt=new y({props:{name:"huggingface_hub.repository.is_tracked_with_lfs",anchor:"huggingface_hub.repository.is_tracked_with_lfs",parameters:[{name:"filename",val:": typing.Union[str, pathlib.Path]"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L150",parametersDescription:[{anchor:"huggingface_hub.repository.is_tracked_with_lfs.filename",description:`<strong>filename</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The filename to check.`,name:"filename"}],returnDescription:`
<p><code>True</code> if the file passed is tracked with git-lfs, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),vt=new y({props:{name:"huggingface_hub.repository.is_git_ignored",anchor:"huggingface_hub.repository.is_git_ignored",parameters:[{name:"filename",val:": typing.Union[str, pathlib.Path]"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L193",parametersDescription:[{anchor:"huggingface_hub.repository.is_git_ignored.filename",description:`<strong>filename</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The filename to check.`,name:"filename"}],returnDescription:`
<p><code>True</code> if the file passed is ignored by <code>git</code>, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),yt=new y({props:{name:"huggingface_hub.repository.files_to_be_staged",anchor:"huggingface_hub.repository.files_to_be_staged",parameters:[{name:"pattern",val:": str"},{name:"folder",val:": typing.Union[str, pathlib.Path]"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L223",parametersDescription:[{anchor:"huggingface_hub.repository.files_to_be_staged.pattern",description:`<strong>pattern</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The pattern of filenames to check. Put <code>.</code> to get all files.`,name:"pattern"},{anchor:"huggingface_hub.repository.files_to_be_staged.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],returnDescription:`
<p>List of files that are to be staged.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),$t=new y({props:{name:"huggingface_hub.repository.is_tracked_upstream",anchor:"huggingface_hub.repository.is_tracked_upstream",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L255",parametersDescription:[{anchor:"huggingface_hub.repository.is_tracked_upstream.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],returnDescription:`
<p><code>True</code> if the current checked-out branch is tracked upstream, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),wt=new y({props:{name:"huggingface_hub.repository.commits_to_push",anchor:"huggingface_hub.repository.commits_to_push",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"},{name:"upstream",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L284",parametersDescription:[{anchor:"huggingface_hub.repository.commits_to_push.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"},{anchor:"huggingface_hub.repository.commits_to_push.upstream",description:"<strong>upstream</strong> (<code>str</code>, <em>optional</em>) &#x2014;",name:"upstream"},{anchor:"huggingface_hub.repository.commits_to_push.The",description:"<strong>The</strong> name of the upstream repository with which the comparison should be made. &#x2014;",name:"The"}],returnDescription:`
<p>Number of commits that would be pushed upstream were a <code>git push</code> to proceed.</p>
`,returnType:`
<p><code>int</code></p>
`}}),Et=new Ea({}),Dt=new y({props:{name:"class huggingface_hub.Repository",anchor:"huggingface_hub.Repository",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L411"}}),Rt=new y({props:{name:"commands_failed",anchor:"huggingface_hub.Repository.commands_failed",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L1534"}}),xt=new y({props:{name:"commands_in_progress",anchor:"huggingface_hub.Repository.commands_in_progress",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L1541"}}),Tt=new y({props:{name:"wait_for_commands",anchor:"huggingface_hub.Repository.wait_for_commands",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L1548"}}),Pt=new y({props:{name:"class huggingface_hub.repository.CommandInProgress",anchor:"huggingface_hub.repository.CommandInProgress",parameters:[{name:"title",val:": str"},{name:"is_done_method",val:": typing.Callable"},{name:"status_method",val:": typing.Callable"},{name:"process",val:": Popen"},{name:"post_method",val:": typing.Optional[typing.Callable] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_799/src/huggingface_hub/repository.py#L25"}}),{c(){H=r("meta"),vr=c(),S=r("h1"),oe=r("a"),Ut=r("span"),u(He.$$.fragment),ka=c(),Mt=r("span"),Da=s("Managing local and online repositories"),yr=c(),E=r("p"),Ra=s("The "),Wt=r("code"),xa=s("Repository"),Ta=s(" class is a helper class that wraps "),Bt=r("code"),Pa=s("git"),Ia=s(" and "),Gt=r("code"),Oa=s("git-lfs"),Ca=s(` commands. It provides tooling adapted
for managing repositories which can be very large.`),$r=c(),re=r("p"),La=s("It is the recommended tool as soon as any "),zt=r("code"),Fa=s("git"),Na=s(` operation is involved, or when collaboration will be a point
of focus with the repository itself.`),wr=c(),j=r("h2"),ae=r("a"),Jt=r("span"),u(Se.$$.fragment),Va=c(),je=r("span"),Ha=s("The "),Kt=r("code"),Sa=s("Repository"),ja=s(" class"),Er=c(),g=r("div"),u(Ae.$$.fragment),Aa=c(),Qt=r("p"),qa=s("Helper class to wrap the git and git-lfs commands."),Ua=c(),Xt=r("p"),Ma=s(`The aim is to facilitate interacting with huggingface.co hosted model or dataset repos,
though not a lot here (if any) is actually specific to huggingface.co.`),Wa=c(),k=r("div"),u(qe.$$.fragment),Ba=c(),Yt=r("p"),Ga=s("Instantiate a local clone of a git repo."),za=c(),A=r("p"),Ja=s("If specifying a "),Zt=r("code"),Ka=s("clone_from"),Qa=s(`, it will clone an existing remote repository, for instance one
that was previously created using `),eo=r("code"),Xa=s("HfApi().create_repo(repo_id=repo_name)"),Ya=s("."),Za=c(),D=r("p"),to=r("code"),en=s("Repository"),tn=s(" uses the local git credentials by default, but if required, the "),oo=r("code"),on=s("huggingface_token"),rn=s(`
as well as the git `),ro=r("code"),an=s("user"),nn=s(" and the "),ao=r("code"),sn=s("email"),cn=s(" can be explicitly specified."),ln=c(),ne=r("div"),u(Ue.$$.fragment),gn=c(),no=r("p"),hn=s("Returns the current checked out branch."),pn=c(),R=r("div"),u(Me.$$.fragment),un=c(),so=r("p"),dn=s("Add a tag at the current head and push it"),fn=c(),io=r("p"),mn=s("If remote is None, will just be updated locally"),_n=c(),co=r("p"),bn=s(`If no message is provided, the tag will be lightweight.
if a message is provided, the tag will be annotated.`),vn=c(),se=r("div"),u(We.$$.fragment),yn=c(),lo=r("p"),$n=s("Automatically track large files (files that weigh more than 10MBs) with git-lfs."),wn=c(),ie=r("div"),u(Be.$$.fragment),En=c(),q=r("p"),kn=s("Checks that "),go=r("code"),Dn=s("git"),Rn=s(" and "),ho=r("code"),xn=s("git-lfs"),Tn=s(" can be run."),Pn=c(),C=r("div"),u(Ge.$$.fragment),In=c(),po=r("p"),On=s("Clone from a remote. If the folder already exists, will try to clone the repository within it."),Cn=c(),uo=r("p"),Ln=s("If this folder is a git repository with linked history, will try to update the repository."),Fn=c(),x=r("div"),u(ze.$$.fragment),Nn=c(),U=r("p"),Vn=s(`Context manager utility to handle committing to a repository. This automatically tracks large files (>10Mb)
with git-lfs. Set the `),fo=r("code"),Hn=s("track_large_files"),Sn=s(" argument to "),mo=r("code"),jn=s("False"),An=s(" if you wish to ignore that behavior."),qn=c(),_o=r("p"),Un=s("Examples:"),Mn=c(),u(Je.$$.fragment),Wn=c(),ce=r("div"),u(Ke.$$.fragment),Bn=c(),bo=r("p"),Gn=s("Delete a tag, both local and remote, if it exists"),zn=c(),L=r("div"),u(Qe.$$.fragment),Jn=c(),vo=r("p"),Kn=s("git add"),Qn=c(),I=r("p"),Xn=s("Setting the "),yo=r("code"),Yn=s("auto_lfs_track"),Zn=s(" parameter to "),$o=r("code"),es=s("True"),ts=s(` will automatically track files that are larger
than 10MB with `),wo=r("code"),os=s("git-lfs"),rs=s("."),as=c(),F=r("div"),u(Xe.$$.fragment),ns=c(),Eo=r("p"),ss=s("git checkout a given revision"),is=c(),M=r("p"),cs=s("Specifying "),ko=r("code"),ls=s("create_branch_ok"),gs=s(" to "),Do=r("code"),hs=s("True"),ps=s(` will create the branch to the given revision if that revision
doesn\u2019t exist.`),us=c(),le=r("div"),u(Ye.$$.fragment),ds=c(),Ro=r("p"),fs=s("git commit"),ms=c(),ge=r("div"),u(Ze.$$.fragment),_s=c(),xo=r("p"),bs=s("Sets git username and email (only in the current repo)."),vs=c(),he=r("div"),u(et.$$.fragment),ys=c(),It=r("p"),$s=s("Sets the git credential helper to "),To=r("code"),ws=s("store"),Es=c(),pe=r("div"),u(tt.$$.fragment),ks=c(),Po=r("p"),Ds=s(`Get URL to last commit on HEAD. We assume it\u2019s been pushed, and the url scheme is
the same one as for GitHub or HuggingFace.`),Rs=c(),ue=r("div"),u(ot.$$.fragment),xs=c(),Io=r("p"),Ts=s("Get commit sha on top of HEAD."),Ps=c(),de=r("div"),u(rt.$$.fragment),Is=c(),Oo=r("p"),Os=s("git pull"),Cs=c(),N=r("div"),u(at.$$.fragment),Ls=c(),Co=r("p"),Fs=s("git push"),Ns=c(),W=r("p"),Vs=s("If used without setting "),Lo=r("code"),Hs=s("blocking"),Ss=s(`, will return url to commit on remote repo.
If used with `),Fo=r("code"),js=s("blocking=True"),As=s(`, will return a tuple containing the url to commit
and the command object to follow for information about the process.`),qs=c(),fe=r("div"),u(nt.$$.fragment),Us=c(),No=r("p"),Ms=s("Get URL to origin remote."),Ws=c(),me=r("div"),u(st.$$.fragment),Bs=c(),Vo=r("p"),Gs=s("Return whether or not the git status is clean or not"),zs=c(),_e=r("div"),u(it.$$.fragment),Js=c(),Ho=r("p"),Ks=s("HF-specific. This enables upload support of files >5GB."),Qs=c(),be=r("div"),u(ct.$$.fragment),Xs=c(),So=r("p"),Ys=s("git lfs prune"),Zs=c(),V=r("div"),u(lt.$$.fragment),ei=c(),jo=r("p"),ti=s("Tell git-lfs to track files according to a pattern."),oi=c(),O=r("p"),ri=s("Setting the "),Ao=r("code"),ai=s("filename"),ni=s(" argument to "),qo=r("code"),si=s("True"),ii=s(` will treat the arguments as literal filenames,
not as patterns. Any special glob characters in the filename will be escaped when
writing to the `),Uo=r("code"),ci=s(".gitattributes"),li=s(" file."),gi=c(),ve=r("div"),u(gt.$$.fragment),hi=c(),Mo=r("p"),pi=s("Tell git-lfs to untrack those files."),ui=c(),ye=r("div"),u(ht.$$.fragment),di=c(),Wo=r("p"),fi=s("Returns a list of the files that are deleted in the working directory or index."),mi=c(),$e=r("div"),u(pt.$$.fragment),_i=c(),Bo=r("p"),bi=s(`Helper to add, commit, and push files to remote repository on the HuggingFace Hub.
Will automatically track large files (>10MB).`),vi=c(),we=r("div"),u(ut.$$.fragment),yi=c(),Go=r("p"),$i=s("Check if a tag exists or not."),wi=c(),Ee=r("div"),u(dt.$$.fragment),Ei=c(),zo=r("p"),ki=s("Blocking method: blocks all subsequent execution until all commands have been processed."),kr=c(),B=r("h2"),ke=r("a"),Jo=r("span"),u(ft.$$.fragment),Di=c(),Ko=r("span"),Ri=s("Helper methods"),Dr=c(),G=r("div"),u(mt.$$.fragment),xi=c(),Qo=r("p"),Ti=s("Check if the folder is the root or part of a git repository"),Rr=c(),z=r("div"),u(_t.$$.fragment),Pi=c(),Xo=r("p"),Ii=s("Check if the folder is a local clone of the remote_url"),xr=c(),J=r("div"),u(bt.$$.fragment),Oi=c(),Yo=r("p"),Ci=s("Check if the file passed is tracked with git-lfs."),Tr=c(),K=r("div"),u(vt.$$.fragment),Li=c(),Zo=r("p"),Fi=s("Check if file is git-ignored. Supports nested .gitignore files."),Pr=c(),Q=r("div"),u(yt.$$.fragment),Ni=c(),er=r("p"),Vi=s("Returns a list of filenames that are to be staged."),Ir=c(),X=r("div"),u($t.$$.fragment),Hi=c(),tr=r("p"),Si=s("Check if the current checked-out branch is tracked upstream."),Or=c(),Y=r("div"),u(wt.$$.fragment),ji=c(),or=r("p"),Ai=s("Check the number of commits that would be pushed upstream"),Cr=c(),Z=r("h2"),De=r("a"),rr=r("span"),u(Et.$$.fragment),qi=c(),ar=r("span"),Ui=s("Following asynchronous commands"),Lr=c(),Re=r("p"),Mi=s("The "),nr=r("code"),Wi=s("Repository"),Bi=s(" utility offers several methods which can be launched asynchronously:"),Fr=c(),T=r("ul"),sr=r("li"),ir=r("code"),Gi=s("git_push"),zi=c(),cr=r("li"),lr=r("code"),Ji=s("git_pull"),Ki=c(),gr=r("li"),hr=r("code"),Qi=s("push_to_hub"),Xi=c(),kt=r("li"),Yi=s("The "),pr=r("code"),Zi=s("commit"),ec=s(" context manager"),Nr=c(),Ot=r("p"),tc=s("See below for utilities to manage such asynchronous methods."),Vr=c(),w=r("div"),u(Dt.$$.fragment),oc=c(),ur=r("p"),rc=s("Helper class to wrap the git and git-lfs commands."),ac=c(),dr=r("p"),nc=s(`The aim is to facilitate interacting with huggingface.co hosted model or dataset repos,
though not a lot here (if any) is actually specific to huggingface.co.`),sc=c(),xe=r("div"),u(Rt.$$.fragment),ic=c(),fr=r("p"),cc=s("Returns the asynchronous commands that failed."),lc=c(),Te=r("div"),u(xt.$$.fragment),gc=c(),mr=r("p"),hc=s("Returns the asynchronous commands that are currently in progress."),pc=c(),Pe=r("div"),u(Tt.$$.fragment),uc=c(),_r=r("p"),dc=s("Blocking method: blocks all subsequent execution until all commands have been processed."),Hr=c(),ee=r("div"),u(Pt.$$.fragment),fc=c(),br=r("p"),mc=s("Utility to follow commands launched asynchronously."),this.h()},l(t){const v=rg('[data-svelte="svelte-1phssyn"]',document.head);H=a(v,"META",{name:!0,content:!0}),v.forEach(o),vr=l(t),S=a(t,"H1",{class:!0});var jr=n(S);oe=a(jr,"A",{id:!0,class:!0,href:!0});var vc=n(oe);Ut=a(vc,"SPAN",{});var yc=n(Ut);d(He.$$.fragment,yc),yc.forEach(o),vc.forEach(o),ka=l(jr),Mt=a(jr,"SPAN",{});var $c=n(Mt);Da=i($c,"Managing local and online repositories"),$c.forEach(o),jr.forEach(o),yr=l(t),E=a(t,"P",{});var Ie=n(E);Ra=i(Ie,"The "),Wt=a(Ie,"CODE",{});var wc=n(Wt);xa=i(wc,"Repository"),wc.forEach(o),Ta=i(Ie," class is a helper class that wraps "),Bt=a(Ie,"CODE",{});var Ec=n(Bt);Pa=i(Ec,"git"),Ec.forEach(o),Ia=i(Ie," and "),Gt=a(Ie,"CODE",{});var kc=n(Gt);Oa=i(kc,"git-lfs"),kc.forEach(o),Ca=i(Ie,` commands. It provides tooling adapted
for managing repositories which can be very large.`),Ie.forEach(o),$r=l(t),re=a(t,"P",{});var Ar=n(re);La=i(Ar,"It is the recommended tool as soon as any "),zt=a(Ar,"CODE",{});var Dc=n(zt);Fa=i(Dc,"git"),Dc.forEach(o),Na=i(Ar,` operation is involved, or when collaboration will be a point
of focus with the repository itself.`),Ar.forEach(o),wr=l(t),j=a(t,"H2",{class:!0});var qr=n(j);ae=a(qr,"A",{id:!0,class:!0,href:!0});var Rc=n(ae);Jt=a(Rc,"SPAN",{});var xc=n(Jt);d(Se.$$.fragment,xc),xc.forEach(o),Rc.forEach(o),Va=l(qr),je=a(qr,"SPAN",{});var Ur=n(je);Ha=i(Ur,"The "),Kt=a(Ur,"CODE",{});var Tc=n(Kt);Sa=i(Tc,"Repository"),Tc.forEach(o),ja=i(Ur," class"),Ur.forEach(o),qr.forEach(o),Er=l(t),g=a(t,"DIV",{class:!0});var h=n(g);d(Ae.$$.fragment,h),Aa=l(h),Qt=a(h,"P",{});var Pc=n(Qt);qa=i(Pc,"Helper class to wrap the git and git-lfs commands."),Pc.forEach(o),Ua=l(h),Xt=a(h,"P",{});var Ic=n(Xt);Ma=i(Ic,`The aim is to facilitate interacting with huggingface.co hosted model or dataset repos,
though not a lot here (if any) is actually specific to huggingface.co.`),Ic.forEach(o),Wa=l(h),k=a(h,"DIV",{class:!0});var Oe=n(k);d(qe.$$.fragment,Oe),Ba=l(Oe),Yt=a(Oe,"P",{});var Oc=n(Yt);Ga=i(Oc,"Instantiate a local clone of a git repo."),Oc.forEach(o),za=l(Oe),A=a(Oe,"P",{});var Ct=n(A);Ja=i(Ct,"If specifying a "),Zt=a(Ct,"CODE",{});var Cc=n(Zt);Ka=i(Cc,"clone_from"),Cc.forEach(o),Qa=i(Ct,`, it will clone an existing remote repository, for instance one
that was previously created using `),eo=a(Ct,"CODE",{});var Lc=n(eo);Xa=i(Lc,"HfApi().create_repo(repo_id=repo_name)"),Lc.forEach(o),Ya=i(Ct,"."),Ct.forEach(o),Za=l(Oe),D=a(Oe,"P",{});var te=n(D);to=a(te,"CODE",{});var Fc=n(to);en=i(Fc,"Repository"),Fc.forEach(o),tn=i(te," uses the local git credentials by default, but if required, the "),oo=a(te,"CODE",{});var Nc=n(oo);on=i(Nc,"huggingface_token"),Nc.forEach(o),rn=i(te,`
as well as the git `),ro=a(te,"CODE",{});var Vc=n(ro);an=i(Vc,"user"),Vc.forEach(o),nn=i(te," and the "),ao=a(te,"CODE",{});var Hc=n(ao);sn=i(Hc,"email"),Hc.forEach(o),cn=i(te," can be explicitly specified."),te.forEach(o),Oe.forEach(o),ln=l(h),ne=a(h,"DIV",{class:!0});var Mr=n(ne);d(Ue.$$.fragment,Mr),gn=l(Mr),no=a(Mr,"P",{});var Sc=n(no);hn=i(Sc,"Returns the current checked out branch."),Sc.forEach(o),Mr.forEach(o),pn=l(h),R=a(h,"DIV",{class:!0});var Ce=n(R);d(Me.$$.fragment,Ce),un=l(Ce),so=a(Ce,"P",{});var jc=n(so);dn=i(jc,"Add a tag at the current head and push it"),jc.forEach(o),fn=l(Ce),io=a(Ce,"P",{});var Ac=n(io);mn=i(Ac,"If remote is None, will just be updated locally"),Ac.forEach(o),_n=l(Ce),co=a(Ce,"P",{});var qc=n(co);bn=i(qc,`If no message is provided, the tag will be lightweight.
if a message is provided, the tag will be annotated.`),qc.forEach(o),Ce.forEach(o),vn=l(h),se=a(h,"DIV",{class:!0});var Wr=n(se);d(We.$$.fragment,Wr),yn=l(Wr),lo=a(Wr,"P",{});var Uc=n(lo);$n=i(Uc,"Automatically track large files (files that weigh more than 10MBs) with git-lfs."),Uc.forEach(o),Wr.forEach(o),wn=l(h),ie=a(h,"DIV",{class:!0});var Br=n(ie);d(Be.$$.fragment,Br),En=l(Br),q=a(Br,"P",{});var Lt=n(q);kn=i(Lt,"Checks that "),go=a(Lt,"CODE",{});var Mc=n(go);Dn=i(Mc,"git"),Mc.forEach(o),Rn=i(Lt," and "),ho=a(Lt,"CODE",{});var Wc=n(ho);xn=i(Wc,"git-lfs"),Wc.forEach(o),Tn=i(Lt," can be run."),Lt.forEach(o),Br.forEach(o),Pn=l(h),C=a(h,"DIV",{class:!0});var Ft=n(C);d(Ge.$$.fragment,Ft),In=l(Ft),po=a(Ft,"P",{});var Bc=n(po);On=i(Bc,"Clone from a remote. If the folder already exists, will try to clone the repository within it."),Bc.forEach(o),Cn=l(Ft),uo=a(Ft,"P",{});var Gc=n(uo);Ln=i(Gc,"If this folder is a git repository with linked history, will try to update the repository."),Gc.forEach(o),Ft.forEach(o),Fn=l(h),x=a(h,"DIV",{class:!0});var Le=n(x);d(ze.$$.fragment,Le),Nn=l(Le),U=a(Le,"P",{});var Nt=n(U);Vn=i(Nt,`Context manager utility to handle committing to a repository. This automatically tracks large files (>10Mb)
with git-lfs. Set the `),fo=a(Nt,"CODE",{});var zc=n(fo);Hn=i(zc,"track_large_files"),zc.forEach(o),Sn=i(Nt," argument to "),mo=a(Nt,"CODE",{});var Jc=n(mo);jn=i(Jc,"False"),Jc.forEach(o),An=i(Nt," if you wish to ignore that behavior."),Nt.forEach(o),qn=l(Le),_o=a(Le,"P",{});var Kc=n(_o);Un=i(Kc,"Examples:"),Kc.forEach(o),Mn=l(Le),d(Je.$$.fragment,Le),Le.forEach(o),Wn=l(h),ce=a(h,"DIV",{class:!0});var Gr=n(ce);d(Ke.$$.fragment,Gr),Bn=l(Gr),bo=a(Gr,"P",{});var Qc=n(bo);Gn=i(Qc,"Delete a tag, both local and remote, if it exists"),Qc.forEach(o),Gr.forEach(o),zn=l(h),L=a(h,"DIV",{class:!0});var Vt=n(L);d(Qe.$$.fragment,Vt),Jn=l(Vt),vo=a(Vt,"P",{});var Xc=n(vo);Kn=i(Xc,"git add"),Xc.forEach(o),Qn=l(Vt),I=a(Vt,"P",{});var Fe=n(I);Xn=i(Fe,"Setting the "),yo=a(Fe,"CODE",{});var Yc=n(yo);Yn=i(Yc,"auto_lfs_track"),Yc.forEach(o),Zn=i(Fe," parameter to "),$o=a(Fe,"CODE",{});var Zc=n($o);es=i(Zc,"True"),Zc.forEach(o),ts=i(Fe,` will automatically track files that are larger
than 10MB with `),wo=a(Fe,"CODE",{});var el=n(wo);os=i(el,"git-lfs"),el.forEach(o),rs=i(Fe,"."),Fe.forEach(o),Vt.forEach(o),as=l(h),F=a(h,"DIV",{class:!0});var Ht=n(F);d(Xe.$$.fragment,Ht),ns=l(Ht),Eo=a(Ht,"P",{});var tl=n(Eo);ss=i(tl,"git checkout a given revision"),tl.forEach(o),is=l(Ht),M=a(Ht,"P",{});var St=n(M);cs=i(St,"Specifying "),ko=a(St,"CODE",{});var ol=n(ko);ls=i(ol,"create_branch_ok"),ol.forEach(o),gs=i(St," to "),Do=a(St,"CODE",{});var rl=n(Do);hs=i(rl,"True"),rl.forEach(o),ps=i(St,` will create the branch to the given revision if that revision
doesn\u2019t exist.`),St.forEach(o),Ht.forEach(o),us=l(h),le=a(h,"DIV",{class:!0});var zr=n(le);d(Ye.$$.fragment,zr),ds=l(zr),Ro=a(zr,"P",{});var al=n(Ro);fs=i(al,"git commit"),al.forEach(o),zr.forEach(o),ms=l(h),ge=a(h,"DIV",{class:!0});var Jr=n(ge);d(Ze.$$.fragment,Jr),_s=l(Jr),xo=a(Jr,"P",{});var nl=n(xo);bs=i(nl,"Sets git username and email (only in the current repo)."),nl.forEach(o),Jr.forEach(o),vs=l(h),he=a(h,"DIV",{class:!0});var Kr=n(he);d(et.$$.fragment,Kr),ys=l(Kr),It=a(Kr,"P",{});var _c=n(It);$s=i(_c,"Sets the git credential helper to "),To=a(_c,"CODE",{});var sl=n(To);ws=i(sl,"store"),sl.forEach(o),_c.forEach(o),Kr.forEach(o),Es=l(h),pe=a(h,"DIV",{class:!0});var Qr=n(pe);d(tt.$$.fragment,Qr),ks=l(Qr),Po=a(Qr,"P",{});var il=n(Po);Ds=i(il,`Get URL to last commit on HEAD. We assume it\u2019s been pushed, and the url scheme is
the same one as for GitHub or HuggingFace.`),il.forEach(o),Qr.forEach(o),Rs=l(h),ue=a(h,"DIV",{class:!0});var Xr=n(ue);d(ot.$$.fragment,Xr),xs=l(Xr),Io=a(Xr,"P",{});var cl=n(Io);Ts=i(cl,"Get commit sha on top of HEAD."),cl.forEach(o),Xr.forEach(o),Ps=l(h),de=a(h,"DIV",{class:!0});var Yr=n(de);d(rt.$$.fragment,Yr),Is=l(Yr),Oo=a(Yr,"P",{});var ll=n(Oo);Os=i(ll,"git pull"),ll.forEach(o),Yr.forEach(o),Cs=l(h),N=a(h,"DIV",{class:!0});var jt=n(N);d(at.$$.fragment,jt),Ls=l(jt),Co=a(jt,"P",{});var gl=n(Co);Fs=i(gl,"git push"),gl.forEach(o),Ns=l(jt),W=a(jt,"P",{});var At=n(W);Vs=i(At,"If used without setting "),Lo=a(At,"CODE",{});var hl=n(Lo);Hs=i(hl,"blocking"),hl.forEach(o),Ss=i(At,`, will return url to commit on remote repo.
If used with `),Fo=a(At,"CODE",{});var pl=n(Fo);js=i(pl,"blocking=True"),pl.forEach(o),As=i(At,`, will return a tuple containing the url to commit
and the command object to follow for information about the process.`),At.forEach(o),jt.forEach(o),qs=l(h),fe=a(h,"DIV",{class:!0});var Zr=n(fe);d(nt.$$.fragment,Zr),Us=l(Zr),No=a(Zr,"P",{});var ul=n(No);Ms=i(ul,"Get URL to origin remote."),ul.forEach(o),Zr.forEach(o),Ws=l(h),me=a(h,"DIV",{class:!0});var ea=n(me);d(st.$$.fragment,ea),Bs=l(ea),Vo=a(ea,"P",{});var dl=n(Vo);Gs=i(dl,"Return whether or not the git status is clean or not"),dl.forEach(o),ea.forEach(o),zs=l(h),_e=a(h,"DIV",{class:!0});var ta=n(_e);d(it.$$.fragment,ta),Js=l(ta),Ho=a(ta,"P",{});var fl=n(Ho);Ks=i(fl,"HF-specific. This enables upload support of files >5GB."),fl.forEach(o),ta.forEach(o),Qs=l(h),be=a(h,"DIV",{class:!0});var oa=n(be);d(ct.$$.fragment,oa),Xs=l(oa),So=a(oa,"P",{});var ml=n(So);Ys=i(ml,"git lfs prune"),ml.forEach(o),oa.forEach(o),Zs=l(h),V=a(h,"DIV",{class:!0});var qt=n(V);d(lt.$$.fragment,qt),ei=l(qt),jo=a(qt,"P",{});var _l=n(jo);ti=i(_l,"Tell git-lfs to track files according to a pattern."),_l.forEach(o),oi=l(qt),O=a(qt,"P",{});var Ne=n(O);ri=i(Ne,"Setting the "),Ao=a(Ne,"CODE",{});var bl=n(Ao);ai=i(bl,"filename"),bl.forEach(o),ni=i(Ne," argument to "),qo=a(Ne,"CODE",{});var vl=n(qo);si=i(vl,"True"),vl.forEach(o),ii=i(Ne,` will treat the arguments as literal filenames,
not as patterns. Any special glob characters in the filename will be escaped when
writing to the `),Uo=a(Ne,"CODE",{});var yl=n(Uo);ci=i(yl,".gitattributes"),yl.forEach(o),li=i(Ne," file."),Ne.forEach(o),qt.forEach(o),gi=l(h),ve=a(h,"DIV",{class:!0});var ra=n(ve);d(gt.$$.fragment,ra),hi=l(ra),Mo=a(ra,"P",{});var $l=n(Mo);pi=i($l,"Tell git-lfs to untrack those files."),$l.forEach(o),ra.forEach(o),ui=l(h),ye=a(h,"DIV",{class:!0});var aa=n(ye);d(ht.$$.fragment,aa),di=l(aa),Wo=a(aa,"P",{});var wl=n(Wo);fi=i(wl,"Returns a list of the files that are deleted in the working directory or index."),wl.forEach(o),aa.forEach(o),mi=l(h),$e=a(h,"DIV",{class:!0});var na=n($e);d(pt.$$.fragment,na),_i=l(na),Bo=a(na,"P",{});var El=n(Bo);bi=i(El,`Helper to add, commit, and push files to remote repository on the HuggingFace Hub.
Will automatically track large files (>10MB).`),El.forEach(o),na.forEach(o),vi=l(h),we=a(h,"DIV",{class:!0});var sa=n(we);d(ut.$$.fragment,sa),yi=l(sa),Go=a(sa,"P",{});var kl=n(Go);$i=i(kl,"Check if a tag exists or not."),kl.forEach(o),sa.forEach(o),wi=l(h),Ee=a(h,"DIV",{class:!0});var ia=n(Ee);d(dt.$$.fragment,ia),Ei=l(ia),zo=a(ia,"P",{});var Dl=n(zo);ki=i(Dl,"Blocking method: blocks all subsequent execution until all commands have been processed."),Dl.forEach(o),ia.forEach(o),h.forEach(o),kr=l(t),B=a(t,"H2",{class:!0});var ca=n(B);ke=a(ca,"A",{id:!0,class:!0,href:!0});var Rl=n(ke);Jo=a(Rl,"SPAN",{});var xl=n(Jo);d(ft.$$.fragment,xl),xl.forEach(o),Rl.forEach(o),Di=l(ca),Ko=a(ca,"SPAN",{});var Tl=n(Ko);Ri=i(Tl,"Helper methods"),Tl.forEach(o),ca.forEach(o),Dr=l(t),G=a(t,"DIV",{class:!0});var la=n(G);d(mt.$$.fragment,la),xi=l(la),Qo=a(la,"P",{});var Pl=n(Qo);Ti=i(Pl,"Check if the folder is the root or part of a git repository"),Pl.forEach(o),la.forEach(o),Rr=l(t),z=a(t,"DIV",{class:!0});var ga=n(z);d(_t.$$.fragment,ga),Pi=l(ga),Xo=a(ga,"P",{});var Il=n(Xo);Ii=i(Il,"Check if the folder is a local clone of the remote_url"),Il.forEach(o),ga.forEach(o),xr=l(t),J=a(t,"DIV",{class:!0});var ha=n(J);d(bt.$$.fragment,ha),Oi=l(ha),Yo=a(ha,"P",{});var Ol=n(Yo);Ci=i(Ol,"Check if the file passed is tracked with git-lfs."),Ol.forEach(o),ha.forEach(o),Tr=l(t),K=a(t,"DIV",{class:!0});var pa=n(K);d(vt.$$.fragment,pa),Li=l(pa),Zo=a(pa,"P",{});var Cl=n(Zo);Fi=i(Cl,"Check if file is git-ignored. Supports nested .gitignore files."),Cl.forEach(o),pa.forEach(o),Pr=l(t),Q=a(t,"DIV",{class:!0});var ua=n(Q);d(yt.$$.fragment,ua),Ni=l(ua),er=a(ua,"P",{});var Ll=n(er);Vi=i(Ll,"Returns a list of filenames that are to be staged."),Ll.forEach(o),ua.forEach(o),Ir=l(t),X=a(t,"DIV",{class:!0});var da=n(X);d($t.$$.fragment,da),Hi=l(da),tr=a(da,"P",{});var Fl=n(tr);Si=i(Fl,"Check if the current checked-out branch is tracked upstream."),Fl.forEach(o),da.forEach(o),Or=l(t),Y=a(t,"DIV",{class:!0});var fa=n(Y);d(wt.$$.fragment,fa),ji=l(fa),or=a(fa,"P",{});var Nl=n(or);Ai=i(Nl,"Check the number of commits that would be pushed upstream"),Nl.forEach(o),fa.forEach(o),Cr=l(t),Z=a(t,"H2",{class:!0});var ma=n(Z);De=a(ma,"A",{id:!0,class:!0,href:!0});var Vl=n(De);rr=a(Vl,"SPAN",{});var Hl=n(rr);d(Et.$$.fragment,Hl),Hl.forEach(o),Vl.forEach(o),qi=l(ma),ar=a(ma,"SPAN",{});var Sl=n(ar);Ui=i(Sl,"Following asynchronous commands"),Sl.forEach(o),ma.forEach(o),Lr=l(t),Re=a(t,"P",{});var _a=n(Re);Mi=i(_a,"The "),nr=a(_a,"CODE",{});var jl=n(nr);Wi=i(jl,"Repository"),jl.forEach(o),Bi=i(_a," utility offers several methods which can be launched asynchronously:"),_a.forEach(o),Fr=l(t),T=a(t,"UL",{});var Ve=n(T);sr=a(Ve,"LI",{});var Al=n(sr);ir=a(Al,"CODE",{});var ql=n(ir);Gi=i(ql,"git_push"),ql.forEach(o),Al.forEach(o),zi=l(Ve),cr=a(Ve,"LI",{});var Ul=n(cr);lr=a(Ul,"CODE",{});var Ml=n(lr);Ji=i(Ml,"git_pull"),Ml.forEach(o),Ul.forEach(o),Ki=l(Ve),gr=a(Ve,"LI",{});var Wl=n(gr);hr=a(Wl,"CODE",{});var Bl=n(hr);Qi=i(Bl,"push_to_hub"),Bl.forEach(o),Wl.forEach(o),Xi=l(Ve),kt=a(Ve,"LI",{});var ba=n(kt);Yi=i(ba,"The "),pr=a(ba,"CODE",{});var Gl=n(pr);Zi=i(Gl,"commit"),Gl.forEach(o),ec=i(ba," context manager"),ba.forEach(o),Ve.forEach(o),Nr=l(t),Ot=a(t,"P",{});var zl=n(Ot);tc=i(zl,"See below for utilities to manage such asynchronous methods."),zl.forEach(o),Vr=l(t),w=a(t,"DIV",{class:!0});var P=n(w);d(Dt.$$.fragment,P),oc=l(P),ur=a(P,"P",{});var Jl=n(ur);rc=i(Jl,"Helper class to wrap the git and git-lfs commands."),Jl.forEach(o),ac=l(P),dr=a(P,"P",{});var Kl=n(dr);nc=i(Kl,`The aim is to facilitate interacting with huggingface.co hosted model or dataset repos,
though not a lot here (if any) is actually specific to huggingface.co.`),Kl.forEach(o),sc=l(P),xe=a(P,"DIV",{class:!0});var va=n(xe);d(Rt.$$.fragment,va),ic=l(va),fr=a(va,"P",{});var Ql=n(fr);cc=i(Ql,"Returns the asynchronous commands that failed."),Ql.forEach(o),va.forEach(o),lc=l(P),Te=a(P,"DIV",{class:!0});var ya=n(Te);d(xt.$$.fragment,ya),gc=l(ya),mr=a(ya,"P",{});var Xl=n(mr);hc=i(Xl,"Returns the asynchronous commands that are currently in progress."),Xl.forEach(o),ya.forEach(o),pc=l(P),Pe=a(P,"DIV",{class:!0});var $a=n(Pe);d(Tt.$$.fragment,$a),uc=l($a),_r=a($a,"P",{});var Yl=n(_r);dc=i(Yl,"Blocking method: blocks all subsequent execution until all commands have been processed."),Yl.forEach(o),$a.forEach(o),P.forEach(o),Hr=l(t),ee=a(t,"DIV",{class:!0});var wa=n(ee);d(Pt.$$.fragment,wa),fc=l(wa),br=a(wa,"P",{});var Zl=n(br);mc=i(Zl,"Utility to follow commands launched asynchronously."),Zl.forEach(o),wa.forEach(o),this.h()},h(){p(H,"name","hf:doc:metadata"),p(H,"content",JSON.stringify(cg)),p(oe,"id","managing-local-and-online-repositories"),p(oe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(oe,"href","#managing-local-and-online-repositories"),p(S,"class","relative group"),p(ae,"id","huggingface_hub.Repository"),p(ae,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(ae,"href","#huggingface_hub.Repository"),p(j,"class","relative group"),p(k,"class","docstring"),p(ne,"class","docstring"),p(R,"class","docstring"),p(se,"class","docstring"),p(ie,"class","docstring"),p(C,"class","docstring"),p(x,"class","docstring"),p(ce,"class","docstring"),p(L,"class","docstring"),p(F,"class","docstring"),p(le,"class","docstring"),p(ge,"class","docstring"),p(he,"class","docstring"),p(pe,"class","docstring"),p(ue,"class","docstring"),p(de,"class","docstring"),p(N,"class","docstring"),p(fe,"class","docstring"),p(me,"class","docstring"),p(_e,"class","docstring"),p(be,"class","docstring"),p(V,"class","docstring"),p(ve,"class","docstring"),p(ye,"class","docstring"),p($e,"class","docstring"),p(we,"class","docstring"),p(Ee,"class","docstring"),p(g,"class","docstring"),p(ke,"id","huggingface_hub.repository.is_git_repo"),p(ke,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(ke,"href","#huggingface_hub.repository.is_git_repo"),p(B,"class","relative group"),p(G,"class","docstring"),p(z,"class","docstring"),p(J,"class","docstring"),p(K,"class","docstring"),p(Q,"class","docstring"),p(X,"class","docstring"),p(Y,"class","docstring"),p(De,"id","huggingface_hub.Repository"),p(De,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(De,"href","#huggingface_hub.Repository"),p(Z,"class","relative group"),p(xe,"class","docstring"),p(Te,"class","docstring"),p(Pe,"class","docstring"),p(w,"class","docstring"),p(ee,"class","docstring")},m(t,v){e(document.head,H),$(t,vr,v),$(t,S,v),e(S,oe),e(oe,Ut),f(He,Ut,null),e(S,ka),e(S,Mt),e(Mt,Da),$(t,yr,v),$(t,E,v),e(E,Ra),e(E,Wt),e(Wt,xa),e(E,Ta),e(E,Bt),e(Bt,Pa),e(E,Ia),e(E,Gt),e(Gt,Oa),e(E,Ca),$(t,$r,v),$(t,re,v),e(re,La),e(re,zt),e(zt,Fa),e(re,Na),$(t,wr,v),$(t,j,v),e(j,ae),e(ae,Jt),f(Se,Jt,null),e(j,Va),e(j,je),e(je,Ha),e(je,Kt),e(Kt,Sa),e(je,ja),$(t,Er,v),$(t,g,v),f(Ae,g,null),e(g,Aa),e(g,Qt),e(Qt,qa),e(g,Ua),e(g,Xt),e(Xt,Ma),e(g,Wa),e(g,k),f(qe,k,null),e(k,Ba),e(k,Yt),e(Yt,Ga),e(k,za),e(k,A),e(A,Ja),e(A,Zt),e(Zt,Ka),e(A,Qa),e(A,eo),e(eo,Xa),e(A,Ya),e(k,Za),e(k,D),e(D,to),e(to,en),e(D,tn),e(D,oo),e(oo,on),e(D,rn),e(D,ro),e(ro,an),e(D,nn),e(D,ao),e(ao,sn),e(D,cn),e(g,ln),e(g,ne),f(Ue,ne,null),e(ne,gn),e(ne,no),e(no,hn),e(g,pn),e(g,R),f(Me,R,null),e(R,un),e(R,so),e(so,dn),e(R,fn),e(R,io),e(io,mn),e(R,_n),e(R,co),e(co,bn),e(g,vn),e(g,se),f(We,se,null),e(se,yn),e(se,lo),e(lo,$n),e(g,wn),e(g,ie),f(Be,ie,null),e(ie,En),e(ie,q),e(q,kn),e(q,go),e(go,Dn),e(q,Rn),e(q,ho),e(ho,xn),e(q,Tn),e(g,Pn),e(g,C),f(Ge,C,null),e(C,In),e(C,po),e(po,On),e(C,Cn),e(C,uo),e(uo,Ln),e(g,Fn),e(g,x),f(ze,x,null),e(x,Nn),e(x,U),e(U,Vn),e(U,fo),e(fo,Hn),e(U,Sn),e(U,mo),e(mo,jn),e(U,An),e(x,qn),e(x,_o),e(_o,Un),e(x,Mn),f(Je,x,null),e(g,Wn),e(g,ce),f(Ke,ce,null),e(ce,Bn),e(ce,bo),e(bo,Gn),e(g,zn),e(g,L),f(Qe,L,null),e(L,Jn),e(L,vo),e(vo,Kn),e(L,Qn),e(L,I),e(I,Xn),e(I,yo),e(yo,Yn),e(I,Zn),e(I,$o),e($o,es),e(I,ts),e(I,wo),e(wo,os),e(I,rs),e(g,as),e(g,F),f(Xe,F,null),e(F,ns),e(F,Eo),e(Eo,ss),e(F,is),e(F,M),e(M,cs),e(M,ko),e(ko,ls),e(M,gs),e(M,Do),e(Do,hs),e(M,ps),e(g,us),e(g,le),f(Ye,le,null),e(le,ds),e(le,Ro),e(Ro,fs),e(g,ms),e(g,ge),f(Ze,ge,null),e(ge,_s),e(ge,xo),e(xo,bs),e(g,vs),e(g,he),f(et,he,null),e(he,ys),e(he,It),e(It,$s),e(It,To),e(To,ws),e(g,Es),e(g,pe),f(tt,pe,null),e(pe,ks),e(pe,Po),e(Po,Ds),e(g,Rs),e(g,ue),f(ot,ue,null),e(ue,xs),e(ue,Io),e(Io,Ts),e(g,Ps),e(g,de),f(rt,de,null),e(de,Is),e(de,Oo),e(Oo,Os),e(g,Cs),e(g,N),f(at,N,null),e(N,Ls),e(N,Co),e(Co,Fs),e(N,Ns),e(N,W),e(W,Vs),e(W,Lo),e(Lo,Hs),e(W,Ss),e(W,Fo),e(Fo,js),e(W,As),e(g,qs),e(g,fe),f(nt,fe,null),e(fe,Us),e(fe,No),e(No,Ms),e(g,Ws),e(g,me),f(st,me,null),e(me,Bs),e(me,Vo),e(Vo,Gs),e(g,zs),e(g,_e),f(it,_e,null),e(_e,Js),e(_e,Ho),e(Ho,Ks),e(g,Qs),e(g,be),f(ct,be,null),e(be,Xs),e(be,So),e(So,Ys),e(g,Zs),e(g,V),f(lt,V,null),e(V,ei),e(V,jo),e(jo,ti),e(V,oi),e(V,O),e(O,ri),e(O,Ao),e(Ao,ai),e(O,ni),e(O,qo),e(qo,si),e(O,ii),e(O,Uo),e(Uo,ci),e(O,li),e(g,gi),e(g,ve),f(gt,ve,null),e(ve,hi),e(ve,Mo),e(Mo,pi),e(g,ui),e(g,ye),f(ht,ye,null),e(ye,di),e(ye,Wo),e(Wo,fi),e(g,mi),e(g,$e),f(pt,$e,null),e($e,_i),e($e,Bo),e(Bo,bi),e(g,vi),e(g,we),f(ut,we,null),e(we,yi),e(we,Go),e(Go,$i),e(g,wi),e(g,Ee),f(dt,Ee,null),e(Ee,Ei),e(Ee,zo),e(zo,ki),$(t,kr,v),$(t,B,v),e(B,ke),e(ke,Jo),f(ft,Jo,null),e(B,Di),e(B,Ko),e(Ko,Ri),$(t,Dr,v),$(t,G,v),f(mt,G,null),e(G,xi),e(G,Qo),e(Qo,Ti),$(t,Rr,v),$(t,z,v),f(_t,z,null),e(z,Pi),e(z,Xo),e(Xo,Ii),$(t,xr,v),$(t,J,v),f(bt,J,null),e(J,Oi),e(J,Yo),e(Yo,Ci),$(t,Tr,v),$(t,K,v),f(vt,K,null),e(K,Li),e(K,Zo),e(Zo,Fi),$(t,Pr,v),$(t,Q,v),f(yt,Q,null),e(Q,Ni),e(Q,er),e(er,Vi),$(t,Ir,v),$(t,X,v),f($t,X,null),e(X,Hi),e(X,tr),e(tr,Si),$(t,Or,v),$(t,Y,v),f(wt,Y,null),e(Y,ji),e(Y,or),e(or,Ai),$(t,Cr,v),$(t,Z,v),e(Z,De),e(De,rr),f(Et,rr,null),e(Z,qi),e(Z,ar),e(ar,Ui),$(t,Lr,v),$(t,Re,v),e(Re,Mi),e(Re,nr),e(nr,Wi),e(Re,Bi),$(t,Fr,v),$(t,T,v),e(T,sr),e(sr,ir),e(ir,Gi),e(T,zi),e(T,cr),e(cr,lr),e(lr,Ji),e(T,Ki),e(T,gr),e(gr,hr),e(hr,Qi),e(T,Xi),e(T,kt),e(kt,Yi),e(kt,pr),e(pr,Zi),e(kt,ec),$(t,Nr,v),$(t,Ot,v),e(Ot,tc),$(t,Vr,v),$(t,w,v),f(Dt,w,null),e(w,oc),e(w,ur),e(ur,rc),e(w,ac),e(w,dr),e(dr,nc),e(w,sc),e(w,xe),f(Rt,xe,null),e(xe,ic),e(xe,fr),e(fr,cc),e(w,lc),e(w,Te),f(xt,Te,null),e(Te,gc),e(Te,mr),e(mr,hc),e(w,pc),e(w,Pe),f(Tt,Pe,null),e(Pe,uc),e(Pe,_r),e(_r,dc),$(t,Hr,v),$(t,ee,v),f(Pt,ee,null),e(ee,fc),e(ee,br),e(br,mc),Sr=!0},p:ag,i(t){Sr||(m(He.$$.fragment,t),m(Se.$$.fragment,t),m(Ae.$$.fragment,t),m(qe.$$.fragment,t),m(Ue.$$.fragment,t),m(Me.$$.fragment,t),m(We.$$.fragment,t),m(Be.$$.fragment,t),m(Ge.$$.fragment,t),m(ze.$$.fragment,t),m(Je.$$.fragment,t),m(Ke.$$.fragment,t),m(Qe.$$.fragment,t),m(Xe.$$.fragment,t),m(Ye.$$.fragment,t),m(Ze.$$.fragment,t),m(et.$$.fragment,t),m(tt.$$.fragment,t),m(ot.$$.fragment,t),m(rt.$$.fragment,t),m(at.$$.fragment,t),m(nt.$$.fragment,t),m(st.$$.fragment,t),m(it.$$.fragment,t),m(ct.$$.fragment,t),m(lt.$$.fragment,t),m(gt.$$.fragment,t),m(ht.$$.fragment,t),m(pt.$$.fragment,t),m(ut.$$.fragment,t),m(dt.$$.fragment,t),m(ft.$$.fragment,t),m(mt.$$.fragment,t),m(_t.$$.fragment,t),m(bt.$$.fragment,t),m(vt.$$.fragment,t),m(yt.$$.fragment,t),m($t.$$.fragment,t),m(wt.$$.fragment,t),m(Et.$$.fragment,t),m(Dt.$$.fragment,t),m(Rt.$$.fragment,t),m(xt.$$.fragment,t),m(Tt.$$.fragment,t),m(Pt.$$.fragment,t),Sr=!0)},o(t){_(He.$$.fragment,t),_(Se.$$.fragment,t),_(Ae.$$.fragment,t),_(qe.$$.fragment,t),_(Ue.$$.fragment,t),_(Me.$$.fragment,t),_(We.$$.fragment,t),_(Be.$$.fragment,t),_(Ge.$$.fragment,t),_(ze.$$.fragment,t),_(Je.$$.fragment,t),_(Ke.$$.fragment,t),_(Qe.$$.fragment,t),_(Xe.$$.fragment,t),_(Ye.$$.fragment,t),_(Ze.$$.fragment,t),_(et.$$.fragment,t),_(tt.$$.fragment,t),_(ot.$$.fragment,t),_(rt.$$.fragment,t),_(at.$$.fragment,t),_(nt.$$.fragment,t),_(st.$$.fragment,t),_(it.$$.fragment,t),_(ct.$$.fragment,t),_(lt.$$.fragment,t),_(gt.$$.fragment,t),_(ht.$$.fragment,t),_(pt.$$.fragment,t),_(ut.$$.fragment,t),_(dt.$$.fragment,t),_(ft.$$.fragment,t),_(mt.$$.fragment,t),_(_t.$$.fragment,t),_(bt.$$.fragment,t),_(vt.$$.fragment,t),_(yt.$$.fragment,t),_($t.$$.fragment,t),_(wt.$$.fragment,t),_(Et.$$.fragment,t),_(Dt.$$.fragment,t),_(Rt.$$.fragment,t),_(xt.$$.fragment,t),_(Tt.$$.fragment,t),_(Pt.$$.fragment,t),Sr=!1},d(t){o(H),t&&o(vr),t&&o(S),b(He),t&&o(yr),t&&o(E),t&&o($r),t&&o(re),t&&o(wr),t&&o(j),b(Se),t&&o(Er),t&&o(g),b(Ae),b(qe),b(Ue),b(Me),b(We),b(Be),b(Ge),b(ze),b(Je),b(Ke),b(Qe),b(Xe),b(Ye),b(Ze),b(et),b(tt),b(ot),b(rt),b(at),b(nt),b(st),b(it),b(ct),b(lt),b(gt),b(ht),b(pt),b(ut),b(dt),t&&o(kr),t&&o(B),b(ft),t&&o(Dr),t&&o(G),b(mt),t&&o(Rr),t&&o(z),b(_t),t&&o(xr),t&&o(J),b(bt),t&&o(Tr),t&&o(K),b(vt),t&&o(Pr),t&&o(Q),b(yt),t&&o(Ir),t&&o(X),b($t),t&&o(Or),t&&o(Y),b(wt),t&&o(Cr),t&&o(Z),b(Et),t&&o(Lr),t&&o(Re),t&&o(Fr),t&&o(T),t&&o(Nr),t&&o(Ot),t&&o(Vr),t&&o(w),b(Dt),b(Rt),b(xt),b(Tt),t&&o(Hr),t&&o(ee),b(Pt)}}}const cg={local:"managing-local-and-online-repositories",sections:[{local:"huggingface_hub.Repository",title:"The `Repository` class"},{local:"huggingface_hub.repository.is_git_repo",title:"Helper methods"},{local:"huggingface_hub.Repository",title:"Following asynchronous commands"}],title:"Managing local and online repositories"};function lg(bc){return ng(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class dg extends eg{constructor(H){super();tg(this,H,lg,ig,og,{})}}export{dg as default,cg as metadata};
