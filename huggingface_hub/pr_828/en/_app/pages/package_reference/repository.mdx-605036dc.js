import{S as cg,i as lg,s as gg,e as r,k as c,w as u,t as s,M as hg,c as n,d as o,m as l,a,x as d,h as i,b as p,F as e,g as $,y as f,L as pg,q as m,o as _,B as b,v as ug}from"../../chunks/vendor-d3924577.js";import{D as v}from"../../chunks/Docstring-8a91f8bd.js";import{C as dg}from"../../chunks/CodeBlock-ff545b14.js";import{I as xn}from"../../chunks/IconCopyLink-f94c3d80.js";function fg(Ec){let V,kr,A,oe,Wt,Ve,Tn,Bt,Pn,Er,k,In,Gt,On,Ln,zt,Cn,Fn,Jt,Nn,jn,Dr,re,Hn,Kt,Vn,An,Rr,S,ne,Qt,Ae,Sn,Xt,qn,xr,g,Se,Un,Yt,Mn,Wn,Zt,Bn,Gn,E,qe,zn,eo,Jn,Kn,q,Qn,to,Xn,Yn,oo,Zn,ea,ta,D,ro,oa,ra,no,na,aa,ao,sa,ia,so,ca,la,ga,ae,Ue,ha,io,pa,ua,R,Me,da,co,fa,ma,lo,_a,ba,go,ya,va,se,We,$a,ho,wa,ka,ie,Be,Ea,po,Da,Ra,ce,Ge,xa,U,Ta,uo,Pa,Ia,fo,Oa,La,Ca,C,ze,Fa,mo,Na,ja,_o,Ha,Va,x,Je,Aa,M,Sa,bo,qa,Ua,yo,Ma,Wa,Ba,vo,Ga,za,Ke,Ja,le,Qe,Ka,$o,Qa,Xa,F,Xe,Ya,wo,Za,es,I,ts,ko,os,rs,Eo,ns,as,Do,ss,is,cs,N,Ye,ls,Ro,gs,hs,W,ps,xo,us,ds,To,fs,ms,_s,ge,Ze,bs,Po,ys,vs,he,et,$s,Io,ws,ks,pe,tt,Es,Ot,Ds,Oo,Rs,xs,ue,ot,Ts,Lo,Ps,Is,de,rt,Os,Co,Ls,Cs,fe,nt,Fs,Fo,Ns,js,j,at,Hs,No,Vs,As,B,Ss,jo,qs,Us,Ho,Ms,Ws,Bs,me,st,Gs,Vo,zs,Js,_e,it,Ks,Ao,Qs,Xs,be,ct,Ys,So,Zs,ei,ye,lt,ti,qo,oi,ri,H,gt,ni,Uo,ai,si,O,ii,Mo,ci,li,Wo,gi,hi,Bo,pi,ui,di,ve,ht,fi,Go,mi,_i,$e,pt,bi,zo,yi,vi,we,ut,$i,Jo,wi,ki,ke,dt,Ei,Ko,Di,Ri,Ee,ft,xi,Qo,Ti,Tr,G,De,Xo,mt,Pi,Yo,Ii,Pr,z,_t,Oi,Zo,Li,Ir,J,bt,Ci,er,Fi,Or,K,yt,Ni,tr,ji,Lr,Q,vt,Hi,or,Vi,Cr,X,$t,Ai,rr,Si,Fr,Y,wt,qi,nr,Ui,Nr,L,kt,Mi,ar,Wi,Bi,sr,Gi,jr,Z,Re,ir,Et,zi,cr,Ji,Hr,xe,Ki,lr,Qi,Xi,Vr,T,gr,hr,Yi,Zi,pr,ur,ec,tc,dr,fr,oc,rc,Dt,nc,mr,ac,sc,Ar,Lt,ic,Sr,w,Rt,cc,_r,lc,gc,br,hc,pc,Te,xt,uc,yr,dc,fc,Pe,Tt,mc,vr,_c,bc,Ie,Pt,yc,$r,vc,qr,ee,It,$c,wr,wc,Ur;return Ve=new xn({}),Ae=new xn({}),Se=new v({props:{name:"class huggingface_hub.Repository",anchor:"huggingface_hub.Repository",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L444"}}),qe=new v({props:{name:"__init__",anchor:"huggingface_hub.Repository.__init__",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L455",parametersDescription:[{anchor:"huggingface_hub.Repository.__init__.local_dir",description:`<strong>local_dir</strong> (<code>str</code>) &#x2014;
path (e.g. <code>&apos;my_trained_model/&apos;</code>) to the local directory, where
the <code>Repository</code> will be initalized.`,name:"local_dir"},{anchor:"huggingface_hub.Repository.__init__.clone_from",description:`<strong>clone_from</strong> (<code>str</code>, <em>optional</em>) &#x2014;
repository url (e.g.
<code>&apos;https://huggingface.co/philschmid/playground-tests&apos;</code>).`,name:"clone_from"},{anchor:"huggingface_hub.Repository.__init__.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
To set when creating a repo: et to &#x201C;dataset&#x201D; or &#x201C;space&#x201D; if
creating a dataset or space, default is model.`,name:"repo_type"},{anchor:"huggingface_hub.Repository.__init__.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code> or <code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
huggingface_token can be extract from <code>HfApi().login(username, password)</code> and is used to authenticate against the hub (useful
from Google Colab for instance).`,name:"use_auth_token"},{anchor:"huggingface_hub.Repository.__init__.git_user",description:`<strong>git_user</strong> (<code>str</code>, <em>optional</em>) &#x2014;
will override the <code>git config user.name</code> for committing and
pushing files to the hub.`,name:"git_user"},{anchor:"huggingface_hub.Repository.__init__.git_email",description:`<strong>git_email</strong> (<code>str</code>, <em>optional</em>) &#x2014;
will override the <code>git config user.email</code> for committing and
pushing files to the hub.`,name:"git_email"},{anchor:"huggingface_hub.Repository.__init__.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Revision to checkout after initializing the repository. If the
revision doesn&#x2019;t exist, a branch will be created with that
revision name from the default branch&#x2019;s current HEAD.`,name:"revision"},{anchor:"huggingface_hub.Repository.__init__.private",description:`<strong>private</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
whether the repository is private or not.`,name:"private"},{anchor:"huggingface_hub.Repository.__init__.skip_lfs_files",description:`<strong>skip_lfs_files</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
whether to skip git-LFS files or not.`,name:"skip_lfs_files"},{anchor:"huggingface_hub.Repository.__init__.client",description:`<strong>client</strong> (<code>HfApi</code>, <em>optional</em>) &#x2014;
Instance of HfApi to use when calling the HF Hub API. A new
instance will be created if this is left to <code>None</code>.`,name:"client"}]}}),Ue=new v({props:{name:"current_branch",anchor:"huggingface_hub.Repository.current_branch",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L564",returnDescription:`
<p>Current checked out branch.</p>
`,returnType:`
<p><code>str</code></p>
`}}),Me=new v({props:{name:"add_tag",anchor:"huggingface_hub.Repository.add_tag",parameters:[{name:"tag_name",val:": str"},{name:"message",val:": str = None"},{name:"remote",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1447",parametersDescription:[{anchor:"huggingface_hub.Repository.add_tag.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The name of the tag to be added.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.add_tag.message",description:`<strong>message</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The message that accompanies the tag. The tag will turn into an
annotated tag if a message is passed.`,name:"message"},{anchor:"huggingface_hub.Repository.add_tag.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The remote on which to add the tag.`,name:"remote"}]}}),We=new v({props:{name:"auto_track_binary_files",anchor:"huggingface_hub.Repository.auto_track_binary_files",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1005",parametersDescription:[{anchor:"huggingface_hub.Repository.auto_track_binary_files.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to track files that are binary.`,name:"pattern"}],returnDescription:`
<p>List of filenames that are now tracked due to being
binary files</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),Be=new v({props:{name:"auto_track_large_files",anchor:"huggingface_hub.Repository.auto_track_large_files",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1048",parametersDescription:[{anchor:"huggingface_hub.Repository.auto_track_large_files.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to track files that are above 10MBs.`,name:"pattern"}],returnDescription:`
<p>List of filenames that are now tracked due to their
size.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),Ge=new v({props:{name:"check_git_versions",anchor:"huggingface_hub.Repository.check_git_versions",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L587"}}),ze=new v({props:{name:"clone_from",anchor:"huggingface_hub.Repository.clone_from",parameters:[{name:"repo_url",val:": str"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L623",parametersDescription:[{anchor:"huggingface_hub.Repository.clone_from.repo_url",description:`<strong>repo_url</strong> (<code>str</code>) &#x2014;
The URL from which to clone the repository`,name:"repo_url"},{anchor:"huggingface_hub.Repository.clone_from.use_auth_token",description:`<strong>use_auth_token</strong> (<code>Union[str, bool]</code>, <em>optional</em>) &#x2014;
Whether to use the authentication token. It can be:<ul>
<li>a string which is the token itself</li>
<li><code>False</code>, which would not use the authentication token</li>
<li><code>True</code>, which would fetch the authentication token from the
local folder and use it (you should be logged in for this to
work).</li>
<li><code>None</code>, which would retrieve the value of
<code>self.huggingface_token</code>.</li>
</ul>`,name:"use_auth_token"}]}}),Je=new v({props:{name:"commit",anchor:"huggingface_hub.Repository.commit",parameters:[{name:"commit_message",val:": str"},{name:"branch",val:": typing.Optional[str] = None"},{name:"track_large_files",val:": typing.Optional[bool] = True"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1551",parametersDescription:[{anchor:"huggingface_hub.Repository.commit.commit_message",description:`<strong>commit_message</strong> (<code>str</code>) &#x2014;
Message to use for the commit.`,name:"commit_message"},{anchor:"huggingface_hub.Repository.commit.branch",description:`<strong>branch</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The branch on which the commit will appear. This branch will be
checked-out before any operation.`,name:"branch"},{anchor:"huggingface_hub.Repository.commit.track_large_files",description:`<strong>track_large_files</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to automatically track large files or not. Will do so by
default.`,name:"track_large_files"},{anchor:"huggingface_hub.Repository.commit.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the <code>git push</code> has
finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.commit.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}]}}),Ke=new dg({props:{code:`with Repository(
    "text-files",
    clone_from="<user>/text-files",
    use_auth_token=True,
).commit("My first file :)"):
    with open("file.txt", "w+") as f:
        f.write(json.dumps({"hey": 8}))

import torch

model = torch.nn.Transformer()
with Repository(
    "torch-model",
    clone_from="<user>/torch-model",
    use_auth_token=True,
).commit("My cool model :)"):
    torch.save(model.state_dict(), "model.pt")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Repository(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;text-files&quot;</span>,
<span class="hljs-meta">... </span>    clone_from=<span class="hljs-string">&quot;&lt;user&gt;/text-files&quot;</span>,
<span class="hljs-meta">... </span>    use_auth_token=<span class="hljs-literal">True</span>,
<span class="hljs-meta">&gt;&gt;&gt; </span>).commit(<span class="hljs-string">&quot;My first file :)&quot;</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>) <span class="hljs-keyword">as</span> f:
<span class="hljs-meta">... </span>        f.write(json.dumps({<span class="hljs-string">&quot;hey&quot;</span>: <span class="hljs-number">8</span>}))

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>model = torch.nn.Transformer()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Repository(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;torch-model&quot;</span>,
<span class="hljs-meta">... </span>    clone_from=<span class="hljs-string">&quot;&lt;user&gt;/torch-model&quot;</span>,
<span class="hljs-meta">... </span>    use_auth_token=<span class="hljs-literal">True</span>,
<span class="hljs-meta">&gt;&gt;&gt; </span>).commit(<span class="hljs-string">&quot;My cool model :)&quot;</span>):
<span class="hljs-meta">... </span>    torch.save(model.state_dict(), <span class="hljs-string">&quot;model.pt&quot;</span>)`}}),Qe=new v({props:{name:"delete_tag",anchor:"huggingface_hub.Repository.delete_tag",parameters:[{name:"tag_name",val:": str"},{name:"remote",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1396",parametersDescription:[{anchor:"huggingface_hub.Repository.delete_tag.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The tag name to delete.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.delete_tag.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The remote on which to delete the tag.`,name:"remote"}],returnDescription:`
<p><code>True</code> if deleted, <code>False</code> if the tag didn\u2019t exist.
If remote is not passed, will just be updated locally</p>
`,returnType:`
<p><code>bool</code></p>
`}}),Xe=new v({props:{name:"git_add",anchor:"huggingface_hub.Repository.git_add",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"},{name:"auto_lfs_track",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1144",parametersDescription:[{anchor:"huggingface_hub.Repository.git_add.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to add files to staging.`,name:"pattern"},{anchor:"huggingface_hub.Repository.git_add.auto_lfs_track",description:`<strong>auto_lfs_track</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically track large and binary files with
git-lfs. Any file over 10MB in size, or in binary format, will
be automatically tracked.`,name:"auto_lfs_track"}]}}),Ye=new v({props:{name:"git_checkout",anchor:"huggingface_hub.Repository.git_checkout",parameters:[{name:"revision",val:": str"},{name:"create_branch_ok",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1304",parametersDescription:[{anchor:"huggingface_hub.Repository.git_checkout.revision",description:`<strong>revision</strong> (<code>str</code>) &#x2014;
The revision to checkout.`,name:"revision"},{anchor:"huggingface_hub.Repository.git_checkout.create_branch_ok",description:`<strong>create_branch_ok</strong> (<code>str</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether creating a branch named with the <code>revision</code> passed at
the current checked-out reference if <code>revision</code> isn&#x2019;t an
existing revision is allowed.`,name:"create_branch_ok"}]}}),Ze=new v({props:{name:"git_commit",anchor:"huggingface_hub.Repository.git_commit",parameters:[{name:"commit_message",val:": str = 'commit files to HF hub'"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1186",parametersDescription:[{anchor:"huggingface_hub.Repository.git_commit.commit_message",description:`<strong>commit_message</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201C;commit files to HF hub&#x201D;) &#x2014;
The message attributed to the commit.`,name:"commit_message"}]}}),et=new v({props:{name:"git_config_username_and_email",anchor:"huggingface_hub.Repository.git_config_username_and_email",parameters:[{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L774",parametersDescription:[{anchor:"huggingface_hub.Repository.git_config_username_and_email.git_user",description:`<strong>git_user</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The username to register through <code>git</code>.`,name:"git_user"},{anchor:"huggingface_hub.Repository.git_config_username_and_email.git_email",description:`<strong>git_email</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The email to register through <code>git</code>.`,name:"git_email"}]}}),tt=new v({props:{name:"git_credential_helper_store",anchor:"huggingface_hub.Repository.git_credential_helper_store",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L808"}}),ot=new v({props:{name:"git_head_commit_url",anchor:"huggingface_hub.Repository.git_head_commit_url",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L866",returnDescription:`
<p>The URL to the current checked-out commit.</p>
`,returnType:`
<p><code>str</code></p>
`}}),rt=new v({props:{name:"git_head_hash",anchor:"huggingface_hub.Repository.git_head_hash",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L824",returnDescription:`
<p>The current checked out commit SHA.</p>
`,returnType:`
<p><code>str</code></p>
`}}),nt=new v({props:{name:"git_pull",anchor:"huggingface_hub.Repository.git_pull",parameters:[{name:"rebase",val:": typing.Optional[bool] = False"},{name:"lfs",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1113",parametersDescription:[{anchor:"huggingface_hub.Repository.git_pull.rebase",description:`<strong>rebase</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to rebase the current branch on top of the upstream
branch after fetching.`,name:"rebase"},{anchor:"huggingface_hub.Repository.git_pull.lfs",description:`<strong>lfs</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to fetch the LFS files too. This option only changes the
behavior when a repository was cloned without fetching the LFS
files; calling <code>repo.git_pull(lfs=True)</code> will then fetch the LFS
file from the remote repository.`,name:"lfs"}]}}),at=new v({props:{name:"git_push",anchor:"huggingface_hub.Repository.git_push",parameters:[{name:"upstream",val:": typing.Optional[str] = None"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1210",parametersDescription:[{anchor:"huggingface_hub.Repository.git_push.upstream",description:`<strong>upstream</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Upstream to which this should push. If not specified, will push
to the lastly defined upstream or to the default one (<code>origin main</code>).`,name:"upstream"},{anchor:"huggingface_hub.Repository.git_push.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the push has
finished. Setting this to <code>False</code> will return an
<code>CommandInProgress</code> object which has an <code>is_done</code> property. This
property will be set to <code>True</code> when the push is finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.git_push.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}]}}),st=new v({props:{name:"git_remote_url",anchor:"huggingface_hub.Repository.git_remote_url",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L844",returnDescription:`
<p>The URL of the <code>origin</code> remote.</p>
`,returnType:`
<p><code>str</code></p>
`}}),it=new v({props:{name:"is_repo_clean",anchor:"huggingface_hub.Repository.is_repo_clean",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1494",returnDescription:`
<p><code>True</code> if the git status is clean, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),ct=new v({props:{name:"lfs_enable_largefiles",anchor:"huggingface_hub.Repository.lfs_enable_largefiles",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L981"}}),lt=new v({props:{name:"lfs_prune",anchor:"huggingface_hub.Repository.lfs_prune",parameters:[{name:"recent",val:" = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1085",parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_prune.recent",description:`<strong>recent</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to prune files even if they were referenced by recent
commits. See the following
<a href="https://github.com/git-lfs/git-lfs/blob/f3d43f0428a84fc4f1e5405b76b5a73ec2437e65/docs/man/git-lfs-prune.1.ronn#recent-files" rel="nofollow">link</a>
for more information.`,name:"recent"}]}}),gt=new v({props:{name:"lfs_track",anchor:"huggingface_hub.Repository.lfs_track",parameters:[{name:"patterns",val:": typing.Union[str, typing.List[str]]"},{name:"filename",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L926",parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_track.patterns",description:`<strong>patterns</strong> (<code>Union[str, List[str]]</code>) &#x2014;
The pattern, or list of patterns, to track with git-lfs.`,name:"patterns"},{anchor:"huggingface_hub.Repository.lfs_track.filename",description:`<strong>filename</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to use the patterns as literal filenames.`,name:"filename"}]}}),ht=new v({props:{name:"lfs_untrack",anchor:"huggingface_hub.Repository.lfs_untrack",parameters:[{name:"patterns",val:": typing.Union[str, typing.List[str]]"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L958",parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_untrack.patterns",description:`<strong>patterns</strong> (<code>Union[str, List[str]]</code>) &#x2014;
The pattern, or list of patterns, to untrack with git-lfs.`,name:"patterns"}]}}),pt=new v({props:{name:"list_deleted_files",anchor:"huggingface_hub.Repository.list_deleted_files",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L880",returnDescription:`
<p>A list of files that have been deleted in the working
directory or index.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),ut=new v({props:{name:"push_to_hub",anchor:"huggingface_hub.Repository.push_to_hub",parameters:[{name:"commit_message",val:": typing.Optional[str] = 'commit files to HF hub'"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"clean_ok",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1515",parametersDescription:[{anchor:"huggingface_hub.Repository.push_to_hub.commit_message",description:`<strong>commit_message</strong> (<code>str</code>) &#x2014;
Message to use for the commit.`,name:"commit_message"},{anchor:"huggingface_hub.Repository.push_to_hub.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the <code>git push</code> has
finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.push_to_hub.clean_ok",description:`<strong>clean_ok</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
If True, this function will return None if the repo is
untouched. Default behavior is to fail because the git command
fails.`,name:"clean_ok"},{anchor:"huggingface_hub.Repository.push_to_hub.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}]}}),dt=new v({props:{name:"tag_exists",anchor:"huggingface_hub.Repository.tag_exists",parameters:[{name:"tag_name",val:": str"},{name:"remote",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1352",parametersDescription:[{anchor:"huggingface_hub.Repository.tag_exists.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The name of the tag to check.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.tag_exists.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Whether to check if the tag exists on a remote. This parameter
should be the identifier of the remote.`,name:"remote"}],returnDescription:`
<p>Whether the tag exists.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),ft=new v({props:{name:"wait_for_commands",anchor:"huggingface_hub.Repository.wait_for_commands",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1683"}}),mt=new xn({}),_t=new v({props:{name:"huggingface_hub.repository.is_git_repo",anchor:"huggingface_hub.repository.is_git_repo",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L103",parametersDescription:[{anchor:"huggingface_hub.repository.is_git_repo.folder",description:`<strong>folder</strong> (<code>str</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],returnDescription:`
<p><code>True</code> if the repository is part of a repository, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),bt=new v({props:{name:"huggingface_hub.repository.is_local_clone",anchor:"huggingface_hub.repository.is_local_clone",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"},{name:"remote_url",val:": str"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L122",parametersDescription:[{anchor:"huggingface_hub.repository.is_local_clone.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"},{anchor:"huggingface_hub.repository.is_local_clone.remote_url",description:`<strong>remote_url</strong> (<code>str</code>) &#x2014;
The url of a git repository.`,name:"remote_url"}],returnDescription:`
<p><code>True</code> if the repository is a local clone of the remote
repository specified, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),yt=new v({props:{name:"huggingface_hub.repository.is_tracked_with_lfs",anchor:"huggingface_hub.repository.is_tracked_with_lfs",parameters:[{name:"filename",val:": typing.Union[str, pathlib.Path]"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L154",parametersDescription:[{anchor:"huggingface_hub.repository.is_tracked_with_lfs.filename",description:`<strong>filename</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The filename to check.`,name:"filename"}],returnDescription:`
<p><code>True</code> if the file passed is tracked with git-lfs, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),vt=new v({props:{name:"huggingface_hub.repository.is_git_ignored",anchor:"huggingface_hub.repository.is_git_ignored",parameters:[{name:"filename",val:": typing.Union[str, pathlib.Path]"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L198",parametersDescription:[{anchor:"huggingface_hub.repository.is_git_ignored.filename",description:`<strong>filename</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The filename to check.`,name:"filename"}],returnDescription:`
<p><code>True</code> if the file passed is ignored by <code>git</code>, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),$t=new v({props:{name:"huggingface_hub.repository.files_to_be_staged",anchor:"huggingface_hub.repository.files_to_be_staged",parameters:[{name:"pattern",val:": str"},{name:"folder",val:": typing.Union[str, pathlib.Path]"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L250",parametersDescription:[{anchor:"huggingface_hub.repository.files_to_be_staged.pattern",description:`<strong>pattern</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The pattern of filenames to check. Put <code>.</code> to get all files.`,name:"pattern"},{anchor:"huggingface_hub.repository.files_to_be_staged.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],returnDescription:`
<p>List of files that are to be staged.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),wt=new v({props:{name:"huggingface_hub.repository.is_tracked_upstream",anchor:"huggingface_hub.repository.is_tracked_upstream",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L282",parametersDescription:[{anchor:"huggingface_hub.repository.is_tracked_upstream.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],returnDescription:`
<p><code>True</code> if the current checked-out branch is tracked upstream,
<code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),kt=new v({props:{name:"huggingface_hub.repository.commits_to_push",anchor:"huggingface_hub.repository.commits_to_push",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"},{name:"upstream",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L312",parametersDescription:[{anchor:"huggingface_hub.repository.commits_to_push.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"},{anchor:"huggingface_hub.repository.commits_to_push.upstream",description:"<strong>upstream</strong> (<code>str</code>, <em>optional</em>) &#x2014;",name:"upstream"}],returnDescription:`
<p>Number of commits that would be pushed upstream were a <code>git push</code> to proceed.</p>
`,returnType:`
<p><code>int</code></p>
`}}),Et=new xn({}),Rt=new v({props:{name:"class huggingface_hub.Repository",anchor:"huggingface_hub.Repository",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L444"}}),xt=new v({props:{name:"commands_failed",anchor:"huggingface_hub.Repository.commands_failed",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1669"}}),Tt=new v({props:{name:"commands_in_progress",anchor:"huggingface_hub.Repository.commands_in_progress",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1676"}}),Pt=new v({props:{name:"wait_for_commands",anchor:"huggingface_hub.Repository.wait_for_commands",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1683"}}),It=new v({props:{name:"class huggingface_hub.repository.CommandInProgress",anchor:"huggingface_hub.repository.CommandInProgress",parameters:[{name:"title",val:": str"},{name:"is_done_method",val:": typing.Callable"},{name:"status_method",val:": typing.Callable"},{name:"process",val:": Popen"},{name:"post_method",val:": typing.Optional[typing.Callable] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L26"}}),{c(){V=r("meta"),kr=c(),A=r("h1"),oe=r("a"),Wt=r("span"),u(Ve.$$.fragment),Tn=c(),Bt=r("span"),Pn=s("Managing local and online repositories"),Er=c(),k=r("p"),In=s("The "),Gt=r("code"),On=s("Repository"),Ln=s(" class is a helper class that wraps "),zt=r("code"),Cn=s("git"),Fn=s(" and "),Jt=r("code"),Nn=s("git-lfs"),jn=s(` commands. It provides tooling adapted
for managing repositories which can be very large.`),Dr=c(),re=r("p"),Hn=s("It is the recommended tool as soon as any "),Kt=r("code"),Vn=s("git"),An=s(` operation is involved, or when collaboration will be a point
of focus with the repository itself.`),Rr=c(),S=r("h2"),ne=r("a"),Qt=r("span"),u(Ae.$$.fragment),Sn=c(),Xt=r("span"),qn=s("The Repository class"),xr=c(),g=r("div"),u(Se.$$.fragment),Un=c(),Yt=r("p"),Mn=s("Helper class to wrap the git and git-lfs commands."),Wn=c(),Zt=r("p"),Bn=s(`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),Gn=c(),E=r("div"),u(qe.$$.fragment),zn=c(),eo=r("p"),Jn=s("Instantiate a local clone of a git repo."),Kn=c(),q=r("p"),Qn=s("If specifying a "),to=r("code"),Xn=s("clone_from"),Yn=s(`, it will clone an existing remote
repository, for instance one that was previously created using
`),oo=r("code"),Zn=s("HfApi().create_repo(repo_id=repo_name)"),ea=s("."),ta=c(),D=r("p"),ro=r("code"),oa=s("Repository"),ra=s(` uses the local git credentials by default, but if required,
the `),no=r("code"),na=s("huggingface_token"),aa=s(" as well as the git "),ao=r("code"),sa=s("user"),ia=s(" and the "),so=r("code"),ca=s("email"),la=s(` can be
explicitly specified.`),ga=c(),ae=r("div"),u(Ue.$$.fragment),ha=c(),io=r("p"),pa=s("Returns the current checked out branch."),ua=c(),R=r("div"),u(Me.$$.fragment),da=c(),co=r("p"),fa=s("Add a tag at the current head and push it"),ma=c(),lo=r("p"),_a=s("If remote is None, will just be updated locally"),ba=c(),go=r("p"),ya=s(`If no message is provided, the tag will be lightweight. if a message is
provided, the tag will be annotated.`),va=c(),se=r("div"),u(We.$$.fragment),$a=c(),ho=r("p"),wa=s("Automatically track binary files with git-lfs."),ka=c(),ie=r("div"),u(Be.$$.fragment),Ea=c(),po=r("p"),Da=s(`Automatically track large files (files that weigh more than 10MBs) with
git-lfs.`),Ra=c(),ce=r("div"),u(Ge.$$.fragment),xa=c(),U=r("p"),Ta=s("Checks that "),uo=r("code"),Pa=s("git"),Ia=s(" and "),fo=r("code"),Oa=s("git-lfs"),La=s(" can be run."),Ca=c(),C=r("div"),u(ze.$$.fragment),Fa=c(),mo=r("p"),Na=s(`Clone from a remote. If the folder already exists, will try to clone the
repository within it.`),ja=c(),_o=r("p"),Ha=s(`If this folder is a git repository with linked history, will try to
update the repository.`),Va=c(),x=r("div"),u(Je.$$.fragment),Aa=c(),M=r("p"),Sa=s(`Context manager utility to handle committing to a repository. This
automatically tracks large files (>10Mb) with git-lfs. Set the
`),bo=r("code"),qa=s("track_large_files"),Ua=s(" argument to "),yo=r("code"),Ma=s("False"),Wa=s(` if you wish to ignore that
behavior.`),Ba=c(),vo=r("p"),Ga=s("Examples:"),za=c(),u(Ke.$$.fragment),Ja=c(),le=r("div"),u(Qe.$$.fragment),Ka=c(),$o=r("p"),Qa=s("Delete a tag, both local and remote, if it exists"),Xa=c(),F=r("div"),u(Xe.$$.fragment),Ya=c(),wo=r("p"),Za=s("git add"),es=c(),I=r("p"),ts=s("Setting the "),ko=r("code"),os=s("auto_lfs_track"),rs=s(" parameter to "),Eo=r("code"),ns=s("True"),as=s(` will automatically
track files that are larger than 10MB with `),Do=r("code"),ss=s("git-lfs"),is=s("."),cs=c(),N=r("div"),u(Ye.$$.fragment),ls=c(),Ro=r("p"),gs=s("git checkout a given revision"),hs=c(),W=r("p"),ps=s("Specifying "),xo=r("code"),us=s("create_branch_ok"),ds=s(" to "),To=r("code"),fs=s("True"),ms=s(` will create the branch to the
given revision if that revision doesn\u2019t exist.`),_s=c(),ge=r("div"),u(Ze.$$.fragment),bs=c(),Po=r("p"),ys=s("git commit"),vs=c(),he=r("div"),u(et.$$.fragment),$s=c(),Io=r("p"),ws=s("Sets git username and email (only in the current repo)."),ks=c(),pe=r("div"),u(tt.$$.fragment),Es=c(),Ot=r("p"),Ds=s("Sets the git credential helper to "),Oo=r("code"),Rs=s("store"),xs=c(),ue=r("div"),u(ot.$$.fragment),Ts=c(),Lo=r("p"),Ps=s(`Get URL to last commit on HEAD. We assume it\u2019s been pushed, and the url
scheme is the same one as for GitHub or HuggingFace.`),Is=c(),de=r("div"),u(rt.$$.fragment),Os=c(),Co=r("p"),Ls=s("Get commit sha on top of HEAD."),Cs=c(),fe=r("div"),u(nt.$$.fragment),Fs=c(),Fo=r("p"),Ns=s("git pull"),js=c(),j=r("div"),u(at.$$.fragment),Hs=c(),No=r("p"),Vs=s("git push"),As=c(),B=r("p"),Ss=s("If used without setting "),jo=r("code"),qs=s("blocking"),Us=s(`, will return url to commit on remote
repo. If used with `),Ho=r("code"),Ms=s("blocking=True"),Ws=s(`, will return a tuple containing the
url to commit and the command object to follow for information about the
process.`),Bs=c(),me=r("div"),u(st.$$.fragment),Gs=c(),Vo=r("p"),zs=s("Get URL to origin remote."),Js=c(),_e=r("div"),u(it.$$.fragment),Ks=c(),Ao=r("p"),Qs=s("Return whether or not the git status is clean or not"),Xs=c(),be=r("div"),u(ct.$$.fragment),Ys=c(),So=r("p"),Zs=s("HF-specific. This enables upload support of files >5GB."),ei=c(),ye=r("div"),u(lt.$$.fragment),ti=c(),qo=r("p"),oi=s("git lfs prune"),ri=c(),H=r("div"),u(gt.$$.fragment),ni=c(),Uo=r("p"),ai=s("Tell git-lfs to track files according to a pattern."),si=c(),O=r("p"),ii=s("Setting the "),Mo=r("code"),ci=s("filename"),li=s(" argument to "),Wo=r("code"),gi=s("True"),hi=s(` will treat the arguments as
literal filenames, not as patterns. Any special glob characters in the
filename will be escaped when writing to the `),Bo=r("code"),pi=s(".gitattributes"),ui=s(" file."),di=c(),ve=r("div"),u(ht.$$.fragment),fi=c(),Go=r("p"),mi=s("Tell git-lfs to untrack those files."),_i=c(),$e=r("div"),u(pt.$$.fragment),bi=c(),zo=r("p"),yi=s(`Returns a list of the files that are deleted in the working directory or
index.`),vi=c(),we=r("div"),u(ut.$$.fragment),$i=c(),Jo=r("p"),wi=s(`Helper to add, commit, and push files to remote repository on the
HuggingFace Hub. Will automatically track large files (>10MB).`),ki=c(),ke=r("div"),u(dt.$$.fragment),Ei=c(),Ko=r("p"),Di=s("Check if a tag exists or not."),Ri=c(),Ee=r("div"),u(ft.$$.fragment),xi=c(),Qo=r("p"),Ti=s(`Blocking method: blocks all subsequent execution until all commands have
been processed.`),Tr=c(),G=r("h2"),De=r("a"),Xo=r("span"),u(mt.$$.fragment),Pi=c(),Yo=r("span"),Ii=s("Helper methods"),Pr=c(),z=r("div"),u(_t.$$.fragment),Oi=c(),Zo=r("p"),Li=s("Check if the folder is the root or part of a git repository"),Ir=c(),J=r("div"),u(bt.$$.fragment),Ci=c(),er=r("p"),Fi=s("Check if the folder is a local clone of the remote_url"),Or=c(),K=r("div"),u(yt.$$.fragment),Ni=c(),tr=r("p"),ji=s("Check if the file passed is tracked with git-lfs."),Lr=c(),Q=r("div"),u(vt.$$.fragment),Hi=c(),or=r("p"),Vi=s("Check if file is git-ignored. Supports nested .gitignore files."),Cr=c(),X=r("div"),u($t.$$.fragment),Ai=c(),rr=r("p"),Si=s("Returns a list of filenames that are to be staged."),Fr=c(),Y=r("div"),u(wt.$$.fragment),qi=c(),nr=r("p"),Ui=s("Check if the current checked-out branch is tracked upstream."),Nr=c(),L=r("div"),u(kt.$$.fragment),Mi=c(),ar=r("p"),Wi=s("Check the number of commits that would be pushed upstream"),Bi=c(),sr=r("p"),Gi=s(`The name of the upstream repository with which the comparison should be
made.`),jr=c(),Z=r("h2"),Re=r("a"),ir=r("span"),u(Et.$$.fragment),zi=c(),cr=r("span"),Ji=s("Following asynchronous commands"),Hr=c(),xe=r("p"),Ki=s("The "),lr=r("code"),Qi=s("Repository"),Xi=s(" utility offers several methods which can be launched asynchronously:"),Vr=c(),T=r("ul"),gr=r("li"),hr=r("code"),Yi=s("git_push"),Zi=c(),pr=r("li"),ur=r("code"),ec=s("git_pull"),tc=c(),dr=r("li"),fr=r("code"),oc=s("push_to_hub"),rc=c(),Dt=r("li"),nc=s("The "),mr=r("code"),ac=s("commit"),sc=s(" context manager"),Ar=c(),Lt=r("p"),ic=s("See below for utilities to manage such asynchronous methods."),Sr=c(),w=r("div"),u(Rt.$$.fragment),cc=c(),_r=r("p"),lc=s("Helper class to wrap the git and git-lfs commands."),gc=c(),br=r("p"),hc=s(`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),pc=c(),Te=r("div"),u(xt.$$.fragment),uc=c(),yr=r("p"),dc=s("Returns the asynchronous commands that failed."),fc=c(),Pe=r("div"),u(Tt.$$.fragment),mc=c(),vr=r("p"),_c=s("Returns the asynchronous commands that are currently in progress."),bc=c(),Ie=r("div"),u(Pt.$$.fragment),yc=c(),$r=r("p"),vc=s(`Blocking method: blocks all subsequent execution until all commands have
been processed.`),qr=c(),ee=r("div"),u(It.$$.fragment),$c=c(),wr=r("p"),wc=s("Utility to follow commands launched asynchronously."),this.h()},l(t){const y=hg('[data-svelte="svelte-1phssyn"]',document.head);V=n(y,"META",{name:!0,content:!0}),y.forEach(o),kr=l(t),A=n(t,"H1",{class:!0});var Mr=a(A);oe=n(Mr,"A",{id:!0,class:!0,href:!0});var Dc=a(oe);Wt=n(Dc,"SPAN",{});var Rc=a(Wt);d(Ve.$$.fragment,Rc),Rc.forEach(o),Dc.forEach(o),Tn=l(Mr),Bt=n(Mr,"SPAN",{});var xc=a(Bt);Pn=i(xc,"Managing local and online repositories"),xc.forEach(o),Mr.forEach(o),Er=l(t),k=n(t,"P",{});var Oe=a(k);In=i(Oe,"The "),Gt=n(Oe,"CODE",{});var Tc=a(Gt);On=i(Tc,"Repository"),Tc.forEach(o),Ln=i(Oe," class is a helper class that wraps "),zt=n(Oe,"CODE",{});var Pc=a(zt);Cn=i(Pc,"git"),Pc.forEach(o),Fn=i(Oe," and "),Jt=n(Oe,"CODE",{});var Ic=a(Jt);Nn=i(Ic,"git-lfs"),Ic.forEach(o),jn=i(Oe,` commands. It provides tooling adapted
for managing repositories which can be very large.`),Oe.forEach(o),Dr=l(t),re=n(t,"P",{});var Wr=a(re);Hn=i(Wr,"It is the recommended tool as soon as any "),Kt=n(Wr,"CODE",{});var Oc=a(Kt);Vn=i(Oc,"git"),Oc.forEach(o),An=i(Wr,` operation is involved, or when collaboration will be a point
of focus with the repository itself.`),Wr.forEach(o),Rr=l(t),S=n(t,"H2",{class:!0});var Br=a(S);ne=n(Br,"A",{id:!0,class:!0,href:!0});var Lc=a(ne);Qt=n(Lc,"SPAN",{});var Cc=a(Qt);d(Ae.$$.fragment,Cc),Cc.forEach(o),Lc.forEach(o),Sn=l(Br),Xt=n(Br,"SPAN",{});var Fc=a(Xt);qn=i(Fc,"The Repository class"),Fc.forEach(o),Br.forEach(o),xr=l(t),g=n(t,"DIV",{class:!0});var h=a(g);d(Se.$$.fragment,h),Un=l(h),Yt=n(h,"P",{});var Nc=a(Yt);Mn=i(Nc,"Helper class to wrap the git and git-lfs commands."),Nc.forEach(o),Wn=l(h),Zt=n(h,"P",{});var jc=a(Zt);Bn=i(jc,`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),jc.forEach(o),Gn=l(h),E=n(h,"DIV",{class:!0});var Le=a(E);d(qe.$$.fragment,Le),zn=l(Le),eo=n(Le,"P",{});var Hc=a(eo);Jn=i(Hc,"Instantiate a local clone of a git repo."),Hc.forEach(o),Kn=l(Le),q=n(Le,"P",{});var Ct=a(q);Qn=i(Ct,"If specifying a "),to=n(Ct,"CODE",{});var Vc=a(to);Xn=i(Vc,"clone_from"),Vc.forEach(o),Yn=i(Ct,`, it will clone an existing remote
repository, for instance one that was previously created using
`),oo=n(Ct,"CODE",{});var Ac=a(oo);Zn=i(Ac,"HfApi().create_repo(repo_id=repo_name)"),Ac.forEach(o),ea=i(Ct,"."),Ct.forEach(o),ta=l(Le),D=n(Le,"P",{});var te=a(D);ro=n(te,"CODE",{});var Sc=a(ro);oa=i(Sc,"Repository"),Sc.forEach(o),ra=i(te,` uses the local git credentials by default, but if required,
the `),no=n(te,"CODE",{});var qc=a(no);na=i(qc,"huggingface_token"),qc.forEach(o),aa=i(te," as well as the git "),ao=n(te,"CODE",{});var Uc=a(ao);sa=i(Uc,"user"),Uc.forEach(o),ia=i(te," and the "),so=n(te,"CODE",{});var Mc=a(so);ca=i(Mc,"email"),Mc.forEach(o),la=i(te,` can be
explicitly specified.`),te.forEach(o),Le.forEach(o),ga=l(h),ae=n(h,"DIV",{class:!0});var Gr=a(ae);d(Ue.$$.fragment,Gr),ha=l(Gr),io=n(Gr,"P",{});var Wc=a(io);pa=i(Wc,"Returns the current checked out branch."),Wc.forEach(o),Gr.forEach(o),ua=l(h),R=n(h,"DIV",{class:!0});var Ce=a(R);d(Me.$$.fragment,Ce),da=l(Ce),co=n(Ce,"P",{});var Bc=a(co);fa=i(Bc,"Add a tag at the current head and push it"),Bc.forEach(o),ma=l(Ce),lo=n(Ce,"P",{});var Gc=a(lo);_a=i(Gc,"If remote is None, will just be updated locally"),Gc.forEach(o),ba=l(Ce),go=n(Ce,"P",{});var zc=a(go);ya=i(zc,`If no message is provided, the tag will be lightweight. if a message is
provided, the tag will be annotated.`),zc.forEach(o),Ce.forEach(o),va=l(h),se=n(h,"DIV",{class:!0});var zr=a(se);d(We.$$.fragment,zr),$a=l(zr),ho=n(zr,"P",{});var Jc=a(ho);wa=i(Jc,"Automatically track binary files with git-lfs."),Jc.forEach(o),zr.forEach(o),ka=l(h),ie=n(h,"DIV",{class:!0});var Jr=a(ie);d(Be.$$.fragment,Jr),Ea=l(Jr),po=n(Jr,"P",{});var Kc=a(po);Da=i(Kc,`Automatically track large files (files that weigh more than 10MBs) with
git-lfs.`),Kc.forEach(o),Jr.forEach(o),Ra=l(h),ce=n(h,"DIV",{class:!0});var Kr=a(ce);d(Ge.$$.fragment,Kr),xa=l(Kr),U=n(Kr,"P",{});var Ft=a(U);Ta=i(Ft,"Checks that "),uo=n(Ft,"CODE",{});var Qc=a(uo);Pa=i(Qc,"git"),Qc.forEach(o),Ia=i(Ft," and "),fo=n(Ft,"CODE",{});var Xc=a(fo);Oa=i(Xc,"git-lfs"),Xc.forEach(o),La=i(Ft," can be run."),Ft.forEach(o),Kr.forEach(o),Ca=l(h),C=n(h,"DIV",{class:!0});var Nt=a(C);d(ze.$$.fragment,Nt),Fa=l(Nt),mo=n(Nt,"P",{});var Yc=a(mo);Na=i(Yc,`Clone from a remote. If the folder already exists, will try to clone the
repository within it.`),Yc.forEach(o),ja=l(Nt),_o=n(Nt,"P",{});var Zc=a(_o);Ha=i(Zc,`If this folder is a git repository with linked history, will try to
update the repository.`),Zc.forEach(o),Nt.forEach(o),Va=l(h),x=n(h,"DIV",{class:!0});var Fe=a(x);d(Je.$$.fragment,Fe),Aa=l(Fe),M=n(Fe,"P",{});var jt=a(M);Sa=i(jt,`Context manager utility to handle committing to a repository. This
automatically tracks large files (>10Mb) with git-lfs. Set the
`),bo=n(jt,"CODE",{});var el=a(bo);qa=i(el,"track_large_files"),el.forEach(o),Ua=i(jt," argument to "),yo=n(jt,"CODE",{});var tl=a(yo);Ma=i(tl,"False"),tl.forEach(o),Wa=i(jt,` if you wish to ignore that
behavior.`),jt.forEach(o),Ba=l(Fe),vo=n(Fe,"P",{});var ol=a(vo);Ga=i(ol,"Examples:"),ol.forEach(o),za=l(Fe),d(Ke.$$.fragment,Fe),Fe.forEach(o),Ja=l(h),le=n(h,"DIV",{class:!0});var Qr=a(le);d(Qe.$$.fragment,Qr),Ka=l(Qr),$o=n(Qr,"P",{});var rl=a($o);Qa=i(rl,"Delete a tag, both local and remote, if it exists"),rl.forEach(o),Qr.forEach(o),Xa=l(h),F=n(h,"DIV",{class:!0});var Ht=a(F);d(Xe.$$.fragment,Ht),Ya=l(Ht),wo=n(Ht,"P",{});var nl=a(wo);Za=i(nl,"git add"),nl.forEach(o),es=l(Ht),I=n(Ht,"P",{});var Ne=a(I);ts=i(Ne,"Setting the "),ko=n(Ne,"CODE",{});var al=a(ko);os=i(al,"auto_lfs_track"),al.forEach(o),rs=i(Ne," parameter to "),Eo=n(Ne,"CODE",{});var sl=a(Eo);ns=i(sl,"True"),sl.forEach(o),as=i(Ne,` will automatically
track files that are larger than 10MB with `),Do=n(Ne,"CODE",{});var il=a(Do);ss=i(il,"git-lfs"),il.forEach(o),is=i(Ne,"."),Ne.forEach(o),Ht.forEach(o),cs=l(h),N=n(h,"DIV",{class:!0});var Vt=a(N);d(Ye.$$.fragment,Vt),ls=l(Vt),Ro=n(Vt,"P",{});var cl=a(Ro);gs=i(cl,"git checkout a given revision"),cl.forEach(o),hs=l(Vt),W=n(Vt,"P",{});var At=a(W);ps=i(At,"Specifying "),xo=n(At,"CODE",{});var ll=a(xo);us=i(ll,"create_branch_ok"),ll.forEach(o),ds=i(At," to "),To=n(At,"CODE",{});var gl=a(To);fs=i(gl,"True"),gl.forEach(o),ms=i(At,` will create the branch to the
given revision if that revision doesn\u2019t exist.`),At.forEach(o),Vt.forEach(o),_s=l(h),ge=n(h,"DIV",{class:!0});var Xr=a(ge);d(Ze.$$.fragment,Xr),bs=l(Xr),Po=n(Xr,"P",{});var hl=a(Po);ys=i(hl,"git commit"),hl.forEach(o),Xr.forEach(o),vs=l(h),he=n(h,"DIV",{class:!0});var Yr=a(he);d(et.$$.fragment,Yr),$s=l(Yr),Io=n(Yr,"P",{});var pl=a(Io);ws=i(pl,"Sets git username and email (only in the current repo)."),pl.forEach(o),Yr.forEach(o),ks=l(h),pe=n(h,"DIV",{class:!0});var Zr=a(pe);d(tt.$$.fragment,Zr),Es=l(Zr),Ot=n(Zr,"P",{});var kc=a(Ot);Ds=i(kc,"Sets the git credential helper to "),Oo=n(kc,"CODE",{});var ul=a(Oo);Rs=i(ul,"store"),ul.forEach(o),kc.forEach(o),Zr.forEach(o),xs=l(h),ue=n(h,"DIV",{class:!0});var en=a(ue);d(ot.$$.fragment,en),Ts=l(en),Lo=n(en,"P",{});var dl=a(Lo);Ps=i(dl,`Get URL to last commit on HEAD. We assume it\u2019s been pushed, and the url
scheme is the same one as for GitHub or HuggingFace.`),dl.forEach(o),en.forEach(o),Is=l(h),de=n(h,"DIV",{class:!0});var tn=a(de);d(rt.$$.fragment,tn),Os=l(tn),Co=n(tn,"P",{});var fl=a(Co);Ls=i(fl,"Get commit sha on top of HEAD."),fl.forEach(o),tn.forEach(o),Cs=l(h),fe=n(h,"DIV",{class:!0});var on=a(fe);d(nt.$$.fragment,on),Fs=l(on),Fo=n(on,"P",{});var ml=a(Fo);Ns=i(ml,"git pull"),ml.forEach(o),on.forEach(o),js=l(h),j=n(h,"DIV",{class:!0});var St=a(j);d(at.$$.fragment,St),Hs=l(St),No=n(St,"P",{});var _l=a(No);Vs=i(_l,"git push"),_l.forEach(o),As=l(St),B=n(St,"P",{});var qt=a(B);Ss=i(qt,"If used without setting "),jo=n(qt,"CODE",{});var bl=a(jo);qs=i(bl,"blocking"),bl.forEach(o),Us=i(qt,`, will return url to commit on remote
repo. If used with `),Ho=n(qt,"CODE",{});var yl=a(Ho);Ms=i(yl,"blocking=True"),yl.forEach(o),Ws=i(qt,`, will return a tuple containing the
url to commit and the command object to follow for information about the
process.`),qt.forEach(o),St.forEach(o),Bs=l(h),me=n(h,"DIV",{class:!0});var rn=a(me);d(st.$$.fragment,rn),Gs=l(rn),Vo=n(rn,"P",{});var vl=a(Vo);zs=i(vl,"Get URL to origin remote."),vl.forEach(o),rn.forEach(o),Js=l(h),_e=n(h,"DIV",{class:!0});var nn=a(_e);d(it.$$.fragment,nn),Ks=l(nn),Ao=n(nn,"P",{});var $l=a(Ao);Qs=i($l,"Return whether or not the git status is clean or not"),$l.forEach(o),nn.forEach(o),Xs=l(h),be=n(h,"DIV",{class:!0});var an=a(be);d(ct.$$.fragment,an),Ys=l(an),So=n(an,"P",{});var wl=a(So);Zs=i(wl,"HF-specific. This enables upload support of files >5GB."),wl.forEach(o),an.forEach(o),ei=l(h),ye=n(h,"DIV",{class:!0});var sn=a(ye);d(lt.$$.fragment,sn),ti=l(sn),qo=n(sn,"P",{});var kl=a(qo);oi=i(kl,"git lfs prune"),kl.forEach(o),sn.forEach(o),ri=l(h),H=n(h,"DIV",{class:!0});var Ut=a(H);d(gt.$$.fragment,Ut),ni=l(Ut),Uo=n(Ut,"P",{});var El=a(Uo);ai=i(El,"Tell git-lfs to track files according to a pattern."),El.forEach(o),si=l(Ut),O=n(Ut,"P",{});var je=a(O);ii=i(je,"Setting the "),Mo=n(je,"CODE",{});var Dl=a(Mo);ci=i(Dl,"filename"),Dl.forEach(o),li=i(je," argument to "),Wo=n(je,"CODE",{});var Rl=a(Wo);gi=i(Rl,"True"),Rl.forEach(o),hi=i(je,` will treat the arguments as
literal filenames, not as patterns. Any special glob characters in the
filename will be escaped when writing to the `),Bo=n(je,"CODE",{});var xl=a(Bo);pi=i(xl,".gitattributes"),xl.forEach(o),ui=i(je," file."),je.forEach(o),Ut.forEach(o),di=l(h),ve=n(h,"DIV",{class:!0});var cn=a(ve);d(ht.$$.fragment,cn),fi=l(cn),Go=n(cn,"P",{});var Tl=a(Go);mi=i(Tl,"Tell git-lfs to untrack those files."),Tl.forEach(o),cn.forEach(o),_i=l(h),$e=n(h,"DIV",{class:!0});var ln=a($e);d(pt.$$.fragment,ln),bi=l(ln),zo=n(ln,"P",{});var Pl=a(zo);yi=i(Pl,`Returns a list of the files that are deleted in the working directory or
index.`),Pl.forEach(o),ln.forEach(o),vi=l(h),we=n(h,"DIV",{class:!0});var gn=a(we);d(ut.$$.fragment,gn),$i=l(gn),Jo=n(gn,"P",{});var Il=a(Jo);wi=i(Il,`Helper to add, commit, and push files to remote repository on the
HuggingFace Hub. Will automatically track large files (>10MB).`),Il.forEach(o),gn.forEach(o),ki=l(h),ke=n(h,"DIV",{class:!0});var hn=a(ke);d(dt.$$.fragment,hn),Ei=l(hn),Ko=n(hn,"P",{});var Ol=a(Ko);Di=i(Ol,"Check if a tag exists or not."),Ol.forEach(o),hn.forEach(o),Ri=l(h),Ee=n(h,"DIV",{class:!0});var pn=a(Ee);d(ft.$$.fragment,pn),xi=l(pn),Qo=n(pn,"P",{});var Ll=a(Qo);Ti=i(Ll,`Blocking method: blocks all subsequent execution until all commands have
been processed.`),Ll.forEach(o),pn.forEach(o),h.forEach(o),Tr=l(t),G=n(t,"H2",{class:!0});var un=a(G);De=n(un,"A",{id:!0,class:!0,href:!0});var Cl=a(De);Xo=n(Cl,"SPAN",{});var Fl=a(Xo);d(mt.$$.fragment,Fl),Fl.forEach(o),Cl.forEach(o),Pi=l(un),Yo=n(un,"SPAN",{});var Nl=a(Yo);Ii=i(Nl,"Helper methods"),Nl.forEach(o),un.forEach(o),Pr=l(t),z=n(t,"DIV",{class:!0});var dn=a(z);d(_t.$$.fragment,dn),Oi=l(dn),Zo=n(dn,"P",{});var jl=a(Zo);Li=i(jl,"Check if the folder is the root or part of a git repository"),jl.forEach(o),dn.forEach(o),Ir=l(t),J=n(t,"DIV",{class:!0});var fn=a(J);d(bt.$$.fragment,fn),Ci=l(fn),er=n(fn,"P",{});var Hl=a(er);Fi=i(Hl,"Check if the folder is a local clone of the remote_url"),Hl.forEach(o),fn.forEach(o),Or=l(t),K=n(t,"DIV",{class:!0});var mn=a(K);d(yt.$$.fragment,mn),Ni=l(mn),tr=n(mn,"P",{});var Vl=a(tr);ji=i(Vl,"Check if the file passed is tracked with git-lfs."),Vl.forEach(o),mn.forEach(o),Lr=l(t),Q=n(t,"DIV",{class:!0});var _n=a(Q);d(vt.$$.fragment,_n),Hi=l(_n),or=n(_n,"P",{});var Al=a(or);Vi=i(Al,"Check if file is git-ignored. Supports nested .gitignore files."),Al.forEach(o),_n.forEach(o),Cr=l(t),X=n(t,"DIV",{class:!0});var bn=a(X);d($t.$$.fragment,bn),Ai=l(bn),rr=n(bn,"P",{});var Sl=a(rr);Si=i(Sl,"Returns a list of filenames that are to be staged."),Sl.forEach(o),bn.forEach(o),Fr=l(t),Y=n(t,"DIV",{class:!0});var yn=a(Y);d(wt.$$.fragment,yn),qi=l(yn),nr=n(yn,"P",{});var ql=a(nr);Ui=i(ql,"Check if the current checked-out branch is tracked upstream."),ql.forEach(o),yn.forEach(o),Nr=l(t),L=n(t,"DIV",{class:!0});var Mt=a(L);d(kt.$$.fragment,Mt),Mi=l(Mt),ar=n(Mt,"P",{});var Ul=a(ar);Wi=i(Ul,"Check the number of commits that would be pushed upstream"),Ul.forEach(o),Bi=l(Mt),sr=n(Mt,"P",{});var Ml=a(sr);Gi=i(Ml,`The name of the upstream repository with which the comparison should be
made.`),Ml.forEach(o),Mt.forEach(o),jr=l(t),Z=n(t,"H2",{class:!0});var vn=a(Z);Re=n(vn,"A",{id:!0,class:!0,href:!0});var Wl=a(Re);ir=n(Wl,"SPAN",{});var Bl=a(ir);d(Et.$$.fragment,Bl),Bl.forEach(o),Wl.forEach(o),zi=l(vn),cr=n(vn,"SPAN",{});var Gl=a(cr);Ji=i(Gl,"Following asynchronous commands"),Gl.forEach(o),vn.forEach(o),Hr=l(t),xe=n(t,"P",{});var $n=a(xe);Ki=i($n,"The "),lr=n($n,"CODE",{});var zl=a(lr);Qi=i(zl,"Repository"),zl.forEach(o),Xi=i($n," utility offers several methods which can be launched asynchronously:"),$n.forEach(o),Vr=l(t),T=n(t,"UL",{});var He=a(T);gr=n(He,"LI",{});var Jl=a(gr);hr=n(Jl,"CODE",{});var Kl=a(hr);Yi=i(Kl,"git_push"),Kl.forEach(o),Jl.forEach(o),Zi=l(He),pr=n(He,"LI",{});var Ql=a(pr);ur=n(Ql,"CODE",{});var Xl=a(ur);ec=i(Xl,"git_pull"),Xl.forEach(o),Ql.forEach(o),tc=l(He),dr=n(He,"LI",{});var Yl=a(dr);fr=n(Yl,"CODE",{});var Zl=a(fr);oc=i(Zl,"push_to_hub"),Zl.forEach(o),Yl.forEach(o),rc=l(He),Dt=n(He,"LI",{});var wn=a(Dt);nc=i(wn,"The "),mr=n(wn,"CODE",{});var eg=a(mr);ac=i(eg,"commit"),eg.forEach(o),sc=i(wn," context manager"),wn.forEach(o),He.forEach(o),Ar=l(t),Lt=n(t,"P",{});var tg=a(Lt);ic=i(tg,"See below for utilities to manage such asynchronous methods."),tg.forEach(o),Sr=l(t),w=n(t,"DIV",{class:!0});var P=a(w);d(Rt.$$.fragment,P),cc=l(P),_r=n(P,"P",{});var og=a(_r);lc=i(og,"Helper class to wrap the git and git-lfs commands."),og.forEach(o),gc=l(P),br=n(P,"P",{});var rg=a(br);hc=i(rg,`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),rg.forEach(o),pc=l(P),Te=n(P,"DIV",{class:!0});var kn=a(Te);d(xt.$$.fragment,kn),uc=l(kn),yr=n(kn,"P",{});var ng=a(yr);dc=i(ng,"Returns the asynchronous commands that failed."),ng.forEach(o),kn.forEach(o),fc=l(P),Pe=n(P,"DIV",{class:!0});var En=a(Pe);d(Tt.$$.fragment,En),mc=l(En),vr=n(En,"P",{});var ag=a(vr);_c=i(ag,"Returns the asynchronous commands that are currently in progress."),ag.forEach(o),En.forEach(o),bc=l(P),Ie=n(P,"DIV",{class:!0});var Dn=a(Ie);d(Pt.$$.fragment,Dn),yc=l(Dn),$r=n(Dn,"P",{});var sg=a($r);vc=i(sg,`Blocking method: blocks all subsequent execution until all commands have
been processed.`),sg.forEach(o),Dn.forEach(o),P.forEach(o),qr=l(t),ee=n(t,"DIV",{class:!0});var Rn=a(ee);d(It.$$.fragment,Rn),$c=l(Rn),wr=n(Rn,"P",{});var ig=a(wr);wc=i(ig,"Utility to follow commands launched asynchronously."),ig.forEach(o),Rn.forEach(o),this.h()},h(){p(V,"name","hf:doc:metadata"),p(V,"content",JSON.stringify(mg)),p(oe,"id","managing-local-and-online-repositories"),p(oe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(oe,"href","#managing-local-and-online-repositories"),p(A,"class","relative group"),p(ne,"id","huggingface_hub.Repository"),p(ne,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(ne,"href","#huggingface_hub.Repository"),p(S,"class","relative group"),p(E,"class","docstring"),p(ae,"class","docstring"),p(R,"class","docstring"),p(se,"class","docstring"),p(ie,"class","docstring"),p(ce,"class","docstring"),p(C,"class","docstring"),p(x,"class","docstring"),p(le,"class","docstring"),p(F,"class","docstring"),p(N,"class","docstring"),p(ge,"class","docstring"),p(he,"class","docstring"),p(pe,"class","docstring"),p(ue,"class","docstring"),p(de,"class","docstring"),p(fe,"class","docstring"),p(j,"class","docstring"),p(me,"class","docstring"),p(_e,"class","docstring"),p(be,"class","docstring"),p(ye,"class","docstring"),p(H,"class","docstring"),p(ve,"class","docstring"),p($e,"class","docstring"),p(we,"class","docstring"),p(ke,"class","docstring"),p(Ee,"class","docstring"),p(g,"class","docstring"),p(De,"id","huggingface_hub.repository.is_git_repo"),p(De,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(De,"href","#huggingface_hub.repository.is_git_repo"),p(G,"class","relative group"),p(z,"class","docstring"),p(J,"class","docstring"),p(K,"class","docstring"),p(Q,"class","docstring"),p(X,"class","docstring"),p(Y,"class","docstring"),p(L,"class","docstring"),p(Re,"id","huggingface_hub.Repository"),p(Re,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(Re,"href","#huggingface_hub.Repository"),p(Z,"class","relative group"),p(Te,"class","docstring"),p(Pe,"class","docstring"),p(Ie,"class","docstring"),p(w,"class","docstring"),p(ee,"class","docstring")},m(t,y){e(document.head,V),$(t,kr,y),$(t,A,y),e(A,oe),e(oe,Wt),f(Ve,Wt,null),e(A,Tn),e(A,Bt),e(Bt,Pn),$(t,Er,y),$(t,k,y),e(k,In),e(k,Gt),e(Gt,On),e(k,Ln),e(k,zt),e(zt,Cn),e(k,Fn),e(k,Jt),e(Jt,Nn),e(k,jn),$(t,Dr,y),$(t,re,y),e(re,Hn),e(re,Kt),e(Kt,Vn),e(re,An),$(t,Rr,y),$(t,S,y),e(S,ne),e(ne,Qt),f(Ae,Qt,null),e(S,Sn),e(S,Xt),e(Xt,qn),$(t,xr,y),$(t,g,y),f(Se,g,null),e(g,Un),e(g,Yt),e(Yt,Mn),e(g,Wn),e(g,Zt),e(Zt,Bn),e(g,Gn),e(g,E),f(qe,E,null),e(E,zn),e(E,eo),e(eo,Jn),e(E,Kn),e(E,q),e(q,Qn),e(q,to),e(to,Xn),e(q,Yn),e(q,oo),e(oo,Zn),e(q,ea),e(E,ta),e(E,D),e(D,ro),e(ro,oa),e(D,ra),e(D,no),e(no,na),e(D,aa),e(D,ao),e(ao,sa),e(D,ia),e(D,so),e(so,ca),e(D,la),e(g,ga),e(g,ae),f(Ue,ae,null),e(ae,ha),e(ae,io),e(io,pa),e(g,ua),e(g,R),f(Me,R,null),e(R,da),e(R,co),e(co,fa),e(R,ma),e(R,lo),e(lo,_a),e(R,ba),e(R,go),e(go,ya),e(g,va),e(g,se),f(We,se,null),e(se,$a),e(se,ho),e(ho,wa),e(g,ka),e(g,ie),f(Be,ie,null),e(ie,Ea),e(ie,po),e(po,Da),e(g,Ra),e(g,ce),f(Ge,ce,null),e(ce,xa),e(ce,U),e(U,Ta),e(U,uo),e(uo,Pa),e(U,Ia),e(U,fo),e(fo,Oa),e(U,La),e(g,Ca),e(g,C),f(ze,C,null),e(C,Fa),e(C,mo),e(mo,Na),e(C,ja),e(C,_o),e(_o,Ha),e(g,Va),e(g,x),f(Je,x,null),e(x,Aa),e(x,M),e(M,Sa),e(M,bo),e(bo,qa),e(M,Ua),e(M,yo),e(yo,Ma),e(M,Wa),e(x,Ba),e(x,vo),e(vo,Ga),e(x,za),f(Ke,x,null),e(g,Ja),e(g,le),f(Qe,le,null),e(le,Ka),e(le,$o),e($o,Qa),e(g,Xa),e(g,F),f(Xe,F,null),e(F,Ya),e(F,wo),e(wo,Za),e(F,es),e(F,I),e(I,ts),e(I,ko),e(ko,os),e(I,rs),e(I,Eo),e(Eo,ns),e(I,as),e(I,Do),e(Do,ss),e(I,is),e(g,cs),e(g,N),f(Ye,N,null),e(N,ls),e(N,Ro),e(Ro,gs),e(N,hs),e(N,W),e(W,ps),e(W,xo),e(xo,us),e(W,ds),e(W,To),e(To,fs),e(W,ms),e(g,_s),e(g,ge),f(Ze,ge,null),e(ge,bs),e(ge,Po),e(Po,ys),e(g,vs),e(g,he),f(et,he,null),e(he,$s),e(he,Io),e(Io,ws),e(g,ks),e(g,pe),f(tt,pe,null),e(pe,Es),e(pe,Ot),e(Ot,Ds),e(Ot,Oo),e(Oo,Rs),e(g,xs),e(g,ue),f(ot,ue,null),e(ue,Ts),e(ue,Lo),e(Lo,Ps),e(g,Is),e(g,de),f(rt,de,null),e(de,Os),e(de,Co),e(Co,Ls),e(g,Cs),e(g,fe),f(nt,fe,null),e(fe,Fs),e(fe,Fo),e(Fo,Ns),e(g,js),e(g,j),f(at,j,null),e(j,Hs),e(j,No),e(No,Vs),e(j,As),e(j,B),e(B,Ss),e(B,jo),e(jo,qs),e(B,Us),e(B,Ho),e(Ho,Ms),e(B,Ws),e(g,Bs),e(g,me),f(st,me,null),e(me,Gs),e(me,Vo),e(Vo,zs),e(g,Js),e(g,_e),f(it,_e,null),e(_e,Ks),e(_e,Ao),e(Ao,Qs),e(g,Xs),e(g,be),f(ct,be,null),e(be,Ys),e(be,So),e(So,Zs),e(g,ei),e(g,ye),f(lt,ye,null),e(ye,ti),e(ye,qo),e(qo,oi),e(g,ri),e(g,H),f(gt,H,null),e(H,ni),e(H,Uo),e(Uo,ai),e(H,si),e(H,O),e(O,ii),e(O,Mo),e(Mo,ci),e(O,li),e(O,Wo),e(Wo,gi),e(O,hi),e(O,Bo),e(Bo,pi),e(O,ui),e(g,di),e(g,ve),f(ht,ve,null),e(ve,fi),e(ve,Go),e(Go,mi),e(g,_i),e(g,$e),f(pt,$e,null),e($e,bi),e($e,zo),e(zo,yi),e(g,vi),e(g,we),f(ut,we,null),e(we,$i),e(we,Jo),e(Jo,wi),e(g,ki),e(g,ke),f(dt,ke,null),e(ke,Ei),e(ke,Ko),e(Ko,Di),e(g,Ri),e(g,Ee),f(ft,Ee,null),e(Ee,xi),e(Ee,Qo),e(Qo,Ti),$(t,Tr,y),$(t,G,y),e(G,De),e(De,Xo),f(mt,Xo,null),e(G,Pi),e(G,Yo),e(Yo,Ii),$(t,Pr,y),$(t,z,y),f(_t,z,null),e(z,Oi),e(z,Zo),e(Zo,Li),$(t,Ir,y),$(t,J,y),f(bt,J,null),e(J,Ci),e(J,er),e(er,Fi),$(t,Or,y),$(t,K,y),f(yt,K,null),e(K,Ni),e(K,tr),e(tr,ji),$(t,Lr,y),$(t,Q,y),f(vt,Q,null),e(Q,Hi),e(Q,or),e(or,Vi),$(t,Cr,y),$(t,X,y),f($t,X,null),e(X,Ai),e(X,rr),e(rr,Si),$(t,Fr,y),$(t,Y,y),f(wt,Y,null),e(Y,qi),e(Y,nr),e(nr,Ui),$(t,Nr,y),$(t,L,y),f(kt,L,null),e(L,Mi),e(L,ar),e(ar,Wi),e(L,Bi),e(L,sr),e(sr,Gi),$(t,jr,y),$(t,Z,y),e(Z,Re),e(Re,ir),f(Et,ir,null),e(Z,zi),e(Z,cr),e(cr,Ji),$(t,Hr,y),$(t,xe,y),e(xe,Ki),e(xe,lr),e(lr,Qi),e(xe,Xi),$(t,Vr,y),$(t,T,y),e(T,gr),e(gr,hr),e(hr,Yi),e(T,Zi),e(T,pr),e(pr,ur),e(ur,ec),e(T,tc),e(T,dr),e(dr,fr),e(fr,oc),e(T,rc),e(T,Dt),e(Dt,nc),e(Dt,mr),e(mr,ac),e(Dt,sc),$(t,Ar,y),$(t,Lt,y),e(Lt,ic),$(t,Sr,y),$(t,w,y),f(Rt,w,null),e(w,cc),e(w,_r),e(_r,lc),e(w,gc),e(w,br),e(br,hc),e(w,pc),e(w,Te),f(xt,Te,null),e(Te,uc),e(Te,yr),e(yr,dc),e(w,fc),e(w,Pe),f(Tt,Pe,null),e(Pe,mc),e(Pe,vr),e(vr,_c),e(w,bc),e(w,Ie),f(Pt,Ie,null),e(Ie,yc),e(Ie,$r),e($r,vc),$(t,qr,y),$(t,ee,y),f(It,ee,null),e(ee,$c),e(ee,wr),e(wr,wc),Ur=!0},p:pg,i(t){Ur||(m(Ve.$$.fragment,t),m(Ae.$$.fragment,t),m(Se.$$.fragment,t),m(qe.$$.fragment,t),m(Ue.$$.fragment,t),m(Me.$$.fragment,t),m(We.$$.fragment,t),m(Be.$$.fragment,t),m(Ge.$$.fragment,t),m(ze.$$.fragment,t),m(Je.$$.fragment,t),m(Ke.$$.fragment,t),m(Qe.$$.fragment,t),m(Xe.$$.fragment,t),m(Ye.$$.fragment,t),m(Ze.$$.fragment,t),m(et.$$.fragment,t),m(tt.$$.fragment,t),m(ot.$$.fragment,t),m(rt.$$.fragment,t),m(nt.$$.fragment,t),m(at.$$.fragment,t),m(st.$$.fragment,t),m(it.$$.fragment,t),m(ct.$$.fragment,t),m(lt.$$.fragment,t),m(gt.$$.fragment,t),m(ht.$$.fragment,t),m(pt.$$.fragment,t),m(ut.$$.fragment,t),m(dt.$$.fragment,t),m(ft.$$.fragment,t),m(mt.$$.fragment,t),m(_t.$$.fragment,t),m(bt.$$.fragment,t),m(yt.$$.fragment,t),m(vt.$$.fragment,t),m($t.$$.fragment,t),m(wt.$$.fragment,t),m(kt.$$.fragment,t),m(Et.$$.fragment,t),m(Rt.$$.fragment,t),m(xt.$$.fragment,t),m(Tt.$$.fragment,t),m(Pt.$$.fragment,t),m(It.$$.fragment,t),Ur=!0)},o(t){_(Ve.$$.fragment,t),_(Ae.$$.fragment,t),_(Se.$$.fragment,t),_(qe.$$.fragment,t),_(Ue.$$.fragment,t),_(Me.$$.fragment,t),_(We.$$.fragment,t),_(Be.$$.fragment,t),_(Ge.$$.fragment,t),_(ze.$$.fragment,t),_(Je.$$.fragment,t),_(Ke.$$.fragment,t),_(Qe.$$.fragment,t),_(Xe.$$.fragment,t),_(Ye.$$.fragment,t),_(Ze.$$.fragment,t),_(et.$$.fragment,t),_(tt.$$.fragment,t),_(ot.$$.fragment,t),_(rt.$$.fragment,t),_(nt.$$.fragment,t),_(at.$$.fragment,t),_(st.$$.fragment,t),_(it.$$.fragment,t),_(ct.$$.fragment,t),_(lt.$$.fragment,t),_(gt.$$.fragment,t),_(ht.$$.fragment,t),_(pt.$$.fragment,t),_(ut.$$.fragment,t),_(dt.$$.fragment,t),_(ft.$$.fragment,t),_(mt.$$.fragment,t),_(_t.$$.fragment,t),_(bt.$$.fragment,t),_(yt.$$.fragment,t),_(vt.$$.fragment,t),_($t.$$.fragment,t),_(wt.$$.fragment,t),_(kt.$$.fragment,t),_(Et.$$.fragment,t),_(Rt.$$.fragment,t),_(xt.$$.fragment,t),_(Tt.$$.fragment,t),_(Pt.$$.fragment,t),_(It.$$.fragment,t),Ur=!1},d(t){o(V),t&&o(kr),t&&o(A),b(Ve),t&&o(Er),t&&o(k),t&&o(Dr),t&&o(re),t&&o(Rr),t&&o(S),b(Ae),t&&o(xr),t&&o(g),b(Se),b(qe),b(Ue),b(Me),b(We),b(Be),b(Ge),b(ze),b(Je),b(Ke),b(Qe),b(Xe),b(Ye),b(Ze),b(et),b(tt),b(ot),b(rt),b(nt),b(at),b(st),b(it),b(ct),b(lt),b(gt),b(ht),b(pt),b(ut),b(dt),b(ft),t&&o(Tr),t&&o(G),b(mt),t&&o(Pr),t&&o(z),b(_t),t&&o(Ir),t&&o(J),b(bt),t&&o(Or),t&&o(K),b(yt),t&&o(Lr),t&&o(Q),b(vt),t&&o(Cr),t&&o(X),b($t),t&&o(Fr),t&&o(Y),b(wt),t&&o(Nr),t&&o(L),b(kt),t&&o(jr),t&&o(Z),b(Et),t&&o(Hr),t&&o(xe),t&&o(Vr),t&&o(T),t&&o(Ar),t&&o(Lt),t&&o(Sr),t&&o(w),b(Rt),b(xt),b(Tt),b(Pt),t&&o(qr),t&&o(ee),b(It)}}}const mg={local:"managing-local-and-online-repositories",sections:[{local:"huggingface_hub.Repository",title:"The Repository class"},{local:"huggingface_hub.repository.is_git_repo",title:"Helper methods"},{local:"huggingface_hub.Repository",title:"Following asynchronous commands"}],title:"Managing local and online repositories"};function _g(Ec){return ug(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class wg extends cg{constructor(V){super();lg(this,V,_g,fg,gg,{})}}export{wg as default,mg as metadata};
