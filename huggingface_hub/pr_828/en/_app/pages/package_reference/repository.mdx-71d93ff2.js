import{S as lg,i as cg,s as gg,e as r,k as l,w as d,t as s,M as hg,c as n,d as o,m as c,a,x as u,h as i,b as p,F as e,g as $,y as m,L as pg,q as f,o as _,B as b,v as dg}from"../../chunks/vendor-d3924577.js";import{D as v}from"../../chunks/Docstring-a36c2bf7.js";import{C as ug}from"../../chunks/CodeBlock-ff545b14.js";import{I as Rn}from"../../chunks/IconCopyLink-f94c3d80.js";function mg(El){let V,kr,A,oe,Wt,Ve,Tn,Bt,Pn,Er,k,In,Gt,On,Ln,zt,Cn,Fn,Jt,Nn,jn,xr,re,Hn,Kt,Vn,An,Dr,S,ne,Qt,Ae,Sn,Xt,qn,Rr,g,Se,Un,Yt,Mn,Wn,Zt,Bn,Gn,E,qe,zn,eo,Jn,Kn,q,Qn,to,Xn,Yn,oo,Zn,ea,ta,x,ro,oa,ra,no,na,aa,ao,sa,ia,so,la,ca,ga,ae,Ue,ha,io,pa,da,D,Me,ua,lo,ma,fa,co,_a,ba,go,ya,va,se,We,$a,ho,wa,ka,ie,Be,Ea,po,xa,Da,le,Ge,Ra,U,Ta,uo,Pa,Ia,mo,Oa,La,Ca,C,ze,Fa,fo,Na,ja,_o,Ha,Va,R,Je,Aa,M,Sa,bo,qa,Ua,yo,Ma,Wa,Ba,vo,Ga,za,Ke,Ja,ce,Qe,Ka,$o,Qa,Xa,F,Xe,Ya,wo,Za,es,I,ts,ko,os,rs,Eo,ns,as,xo,ss,is,ls,N,Ye,cs,Do,gs,hs,W,ps,Ro,ds,us,To,ms,fs,_s,ge,Ze,bs,Po,ys,vs,he,et,$s,Io,ws,ks,pe,tt,Es,Ot,xs,Oo,Ds,Rs,de,ot,Ts,Lo,Ps,Is,ue,rt,Os,Co,Ls,Cs,me,nt,Fs,Fo,Ns,js,j,at,Hs,No,Vs,As,B,Ss,jo,qs,Us,Ho,Ms,Ws,Bs,fe,st,Gs,Vo,zs,Js,_e,it,Ks,Ao,Qs,Xs,be,lt,Ys,So,Zs,ei,ye,ct,ti,qo,oi,ri,H,gt,ni,Uo,ai,si,O,ii,Mo,li,ci,Wo,gi,hi,Bo,pi,di,ui,ve,ht,mi,Go,fi,_i,$e,pt,bi,zo,yi,vi,we,dt,$i,Jo,wi,ki,ke,ut,Ei,Ko,xi,Di,Ee,mt,Ri,Qo,Ti,Tr,G,xe,Xo,ft,Pi,Yo,Ii,Pr,z,_t,Oi,Zo,Li,Ir,J,bt,Ci,er,Fi,Or,K,yt,Ni,tr,ji,Lr,Q,vt,Hi,or,Vi,Cr,X,$t,Ai,rr,Si,Fr,Y,wt,qi,nr,Ui,Nr,L,kt,Mi,ar,Wi,Bi,sr,Gi,jr,Z,De,ir,Et,zi,lr,Ji,Hr,Re,Ki,cr,Qi,Xi,Vr,T,gr,hr,Yi,Zi,pr,dr,el,tl,ur,mr,ol,rl,xt,nl,fr,al,sl,Ar,Lt,il,Sr,w,Dt,ll,_r,cl,gl,br,hl,pl,Te,Rt,dl,yr,ul,ml,Pe,Tt,fl,vr,_l,bl,Ie,Pt,yl,$r,vl,qr,ee,It,$l,wr,wl,Ur;return Ve=new Rn({}),Ae=new Rn({}),Se=new v({props:{name:"class huggingface_hub.Repository",anchor:"huggingface_hub.Repository",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L448"}}),qe=new v({props:{name:"__init__",anchor:"huggingface_hub.Repository.__init__",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.__init__.local_dir",description:`<strong>local_dir</strong> (<code>str</code>) &#x2014;
path (e.g. <code>&apos;my_trained_model/&apos;</code>) to the local directory, where
the <code>Repository</code> will be initalized.`,name:"local_dir"},{anchor:"huggingface_hub.Repository.__init__.clone_from",description:`<strong>clone_from</strong> (<code>str</code>, <em>optional</em>) &#x2014;
repository url (e.g.
<code>&apos;https://huggingface.co/philschmid/playground-tests&apos;</code>).`,name:"clone_from"},{anchor:"huggingface_hub.Repository.__init__.repo_type",description:`<strong>repo_type</strong> (<code>str</code>, <em>optional</em>) &#x2014;
To set when creating a repo: et to &#x201C;dataset&#x201D; or &#x201C;space&#x201D; if
creating a dataset or space, default is model.`,name:"repo_type"},{anchor:"huggingface_hub.Repository.__init__.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code> or <code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
huggingface_token can be extract from <code>HfApi().login(username, password)</code> and is used to authenticate against the hub (useful
from Google Colab for instance).`,name:"use_auth_token"},{anchor:"huggingface_hub.Repository.__init__.git_user",description:`<strong>git_user</strong> (<code>str</code>, <em>optional</em>) &#x2014;
will override the <code>git config user.name</code> for committing and
pushing files to the hub.`,name:"git_user"},{anchor:"huggingface_hub.Repository.__init__.git_email",description:`<strong>git_email</strong> (<code>str</code>, <em>optional</em>) &#x2014;
will override the <code>git config user.email</code> for committing and
pushing files to the hub.`,name:"git_email"},{anchor:"huggingface_hub.Repository.__init__.revision",description:`<strong>revision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Revision to checkout after initializing the repository. If the
revision doesn&#x2019;t exist, a branch will be created with that
revision name from the default branch&#x2019;s current HEAD.`,name:"revision"},{anchor:"huggingface_hub.Repository.__init__.private",description:`<strong>private</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
whether the repository is private or not.`,name:"private"},{anchor:"huggingface_hub.Repository.__init__.skip_lfs_files",description:`<strong>skip_lfs_files</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
whether to skip git-LFS files or not.`,name:"skip_lfs_files"},{anchor:"huggingface_hub.Repository.__init__.client",description:`<strong>client</strong> (<code>HfApi</code>, <em>optional</em>) &#x2014;
Instance of HfApi to use when calling the HF Hub API. A new
instance will be created if this is left to <code>None</code>.`,name:"client"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L459"}}),Ue=new v({props:{name:"current_branch",anchor:"huggingface_hub.Repository.current_branch",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L568",returnDescription:`
<p>Current checked out branch.</p>
`,returnType:`
<p><code>str</code></p>
`}}),Me=new v({props:{name:"add_tag",anchor:"huggingface_hub.Repository.add_tag",parameters:[{name:"tag_name",val:": str"},{name:"message",val:": str = None"},{name:"remote",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.add_tag.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The name of the tag to be added.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.add_tag.message",description:`<strong>message</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The message that accompanies the tag. The tag will turn into an
annotated tag if a message is passed.`,name:"message"},{anchor:"huggingface_hub.Repository.add_tag.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The remote on which to add the tag.`,name:"remote"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1451"}}),We=new v({props:{name:"auto_track_binary_files",anchor:"huggingface_hub.Repository.auto_track_binary_files",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"}],parametersDescription:[{anchor:"huggingface_hub.Repository.auto_track_binary_files.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to track files that are binary.`,name:"pattern"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1009",returnDescription:`
<p>List of filenames that are now tracked due to being
binary files</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),Be=new v({props:{name:"auto_track_large_files",anchor:"huggingface_hub.Repository.auto_track_large_files",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"}],parametersDescription:[{anchor:"huggingface_hub.Repository.auto_track_large_files.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to track files that are above 10MBs.`,name:"pattern"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1052",returnDescription:`
<p>List of filenames that are now tracked due to their
size.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),Ge=new v({props:{name:"check_git_versions",anchor:"huggingface_hub.Repository.check_git_versions",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L591"}}),ze=new v({props:{name:"clone_from",anchor:"huggingface_hub.Repository.clone_from",parameters:[{name:"repo_url",val:": str"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.clone_from.repo_url",description:`<strong>repo_url</strong> (<code>str</code>) &#x2014;
The URL from which to clone the repository`,name:"repo_url"},{anchor:"huggingface_hub.Repository.clone_from.use_auth_token",description:`<strong>use_auth_token</strong> (<code>Union[str, bool]</code>, <em>optional</em>) &#x2014;
Whether to use the authentication token. It can be:<ul>
<li>a string which is the token itself</li>
<li><code>False</code>, which would not use the authentication token</li>
<li><code>True</code>, which would fetch the authentication token from the
local folder and use it (you should be logged in for this to
work).</li>
<li><code>None</code>, which would retrieve the value of
<code>self.huggingface_token</code>.</li>
</ul>`,name:"use_auth_token"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L627"}}),Je=new v({props:{name:"commit",anchor:"huggingface_hub.Repository.commit",parameters:[{name:"commit_message",val:": str"},{name:"branch",val:": typing.Optional[str] = None"},{name:"track_large_files",val:": typing.Optional[bool] = True"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.commit.commit_message",description:`<strong>commit_message</strong> (<code>str</code>) &#x2014;
Message to use for the commit.`,name:"commit_message"},{anchor:"huggingface_hub.Repository.commit.branch",description:`<strong>branch</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The branch on which the commit will appear. This branch will be
checked-out before any operation.`,name:"branch"},{anchor:"huggingface_hub.Repository.commit.track_large_files",description:`<strong>track_large_files</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to automatically track large files or not. Will do so by
default.`,name:"track_large_files"},{anchor:"huggingface_hub.Repository.commit.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the <code>git push</code> has
finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.commit.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, defaults to <code>True</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1555"}}),Ke=new ug({props:{code:`with Repository(
    "text-files",
    clone_from="<user>/text-files",
    use_auth_token=True,
).commit("My first file :)"):
    with open("file.txt", "w+") as f:
        f.write(json.dumps({"hey": 8}))

import torch

model = torch.nn.Transformer()
with Repository(
    "torch-model",
    clone_from="<user>/torch-model",
    use_auth_token=True,
).commit("My cool model :)"):
    torch.save(model.state_dict(), "model.pt")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Repository(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;text-files&quot;</span>,
<span class="hljs-meta">... </span>    clone_from=<span class="hljs-string">&quot;&lt;user&gt;/text-files&quot;</span>,
<span class="hljs-meta">... </span>    use_auth_token=<span class="hljs-literal">True</span>,
<span class="hljs-meta">&gt;&gt;&gt; </span>).commit(<span class="hljs-string">&quot;My first file :)&quot;</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>) <span class="hljs-keyword">as</span> f:
<span class="hljs-meta">... </span>        f.write(json.dumps({<span class="hljs-string">&quot;hey&quot;</span>: <span class="hljs-number">8</span>}))

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>model = torch.nn.Transformer()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> Repository(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;torch-model&quot;</span>,
<span class="hljs-meta">... </span>    clone_from=<span class="hljs-string">&quot;&lt;user&gt;/torch-model&quot;</span>,
<span class="hljs-meta">... </span>    use_auth_token=<span class="hljs-literal">True</span>,
<span class="hljs-meta">&gt;&gt;&gt; </span>).commit(<span class="hljs-string">&quot;My cool model :)&quot;</span>):
<span class="hljs-meta">... </span>    torch.save(model.state_dict(), <span class="hljs-string">&quot;model.pt&quot;</span>)`}}),Qe=new v({props:{name:"delete_tag",anchor:"huggingface_hub.Repository.delete_tag",parameters:[{name:"tag_name",val:": str"},{name:"remote",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.delete_tag.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The tag name to delete.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.delete_tag.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The remote on which to delete the tag.`,name:"remote"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1400",returnDescription:`
<p><code>True</code> if deleted, <code>False</code> if the tag didn\u2019t exist.
If remote is not passed, will just be updated locally</p>
`,returnType:`
<p><code>bool</code></p>
`}}),Xe=new v({props:{name:"git_add",anchor:"huggingface_hub.Repository.git_add",parameters:[{name:"pattern",val:": typing.Optional[str] = '.'"},{name:"auto_lfs_track",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_add.pattern",description:`<strong>pattern</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201D;.&#x201C;) &#x2014;
The pattern with which to add files to staging.`,name:"pattern"},{anchor:"huggingface_hub.Repository.git_add.auto_lfs_track",description:`<strong>auto_lfs_track</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically track large and binary files with
git-lfs. Any file over 10MB in size, or in binary format, will
be automatically tracked.`,name:"auto_lfs_track"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1148"}}),Ye=new v({props:{name:"git_checkout",anchor:"huggingface_hub.Repository.git_checkout",parameters:[{name:"revision",val:": str"},{name:"create_branch_ok",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_checkout.revision",description:`<strong>revision</strong> (<code>str</code>) &#x2014;
The revision to checkout.`,name:"revision"},{anchor:"huggingface_hub.Repository.git_checkout.create_branch_ok",description:`<strong>create_branch_ok</strong> (<code>str</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether creating a branch named with the <code>revision</code> passed at
the current checked-out reference if <code>revision</code> isn&#x2019;t an
existing revision is allowed.`,name:"create_branch_ok"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1308"}}),Ze=new v({props:{name:"git_commit",anchor:"huggingface_hub.Repository.git_commit",parameters:[{name:"commit_message",val:": str = 'commit files to HF hub'"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_commit.commit_message",description:`<strong>commit_message</strong> (<code>str</code>, <em>optional</em>, defaults to &#x201C;commit files to HF hub&#x201D;) &#x2014;
The message attributed to the commit.`,name:"commit_message"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1190"}}),et=new v({props:{name:"git_config_username_and_email",anchor:"huggingface_hub.Repository.git_config_username_and_email",parameters:[{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_config_username_and_email.git_user",description:`<strong>git_user</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The username to register through <code>git</code>.`,name:"git_user"},{anchor:"huggingface_hub.Repository.git_config_username_and_email.git_email",description:`<strong>git_email</strong> (<code>str</code>, <em>optional</em>) &#x2014;
The email to register through <code>git</code>.`,name:"git_email"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L778"}}),tt=new v({props:{name:"git_credential_helper_store",anchor:"huggingface_hub.Repository.git_credential_helper_store",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L812"}}),ot=new v({props:{name:"git_head_commit_url",anchor:"huggingface_hub.Repository.git_head_commit_url",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L870",returnDescription:`
<p>The URL to the current checked-out commit.</p>
`,returnType:`
<p><code>str</code></p>
`}}),rt=new v({props:{name:"git_head_hash",anchor:"huggingface_hub.Repository.git_head_hash",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L828",returnDescription:`
<p>The current checked out commit SHA.</p>
`,returnType:`
<p><code>str</code></p>
`}}),nt=new v({props:{name:"git_pull",anchor:"huggingface_hub.Repository.git_pull",parameters:[{name:"rebase",val:": typing.Optional[bool] = False"},{name:"lfs",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_pull.rebase",description:`<strong>rebase</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to rebase the current branch on top of the upstream
branch after fetching.`,name:"rebase"},{anchor:"huggingface_hub.Repository.git_pull.lfs",description:`<strong>lfs</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to fetch the LFS files too. This option only changes the
behavior when a repository was cloned without fetching the LFS
files; calling <code>repo.git_pull(lfs=True)</code> will then fetch the LFS
file from the remote repository.`,name:"lfs"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1117"}}),at=new v({props:{name:"git_push",anchor:"huggingface_hub.Repository.git_push",parameters:[{name:"upstream",val:": typing.Optional[str] = None"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.git_push.upstream",description:`<strong>upstream</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Upstream to which this should push. If not specified, will push
to the lastly defined upstream or to the default one (<code>origin main</code>).`,name:"upstream"},{anchor:"huggingface_hub.Repository.git_push.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the push has
finished. Setting this to <code>False</code> will return an
<code>CommandInProgress</code> object which has an <code>is_done</code> property. This
property will be set to <code>True</code> when the push is finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.git_push.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1214"}}),st=new v({props:{name:"git_remote_url",anchor:"huggingface_hub.Repository.git_remote_url",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L848",returnDescription:`
<p>The URL of the <code>origin</code> remote.</p>
`,returnType:`
<p><code>str</code></p>
`}}),it=new v({props:{name:"is_repo_clean",anchor:"huggingface_hub.Repository.is_repo_clean",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1498",returnDescription:`
<p><code>True</code> if the git status is clean, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),lt=new v({props:{name:"lfs_enable_largefiles",anchor:"huggingface_hub.Repository.lfs_enable_largefiles",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L985"}}),ct=new v({props:{name:"lfs_prune",anchor:"huggingface_hub.Repository.lfs_prune",parameters:[{name:"recent",val:" = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_prune.recent",description:`<strong>recent</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to prune files even if they were referenced by recent
commits. See the following
<a href="https://github.com/git-lfs/git-lfs/blob/f3d43f0428a84fc4f1e5405b76b5a73ec2437e65/docs/man/git-lfs-prune.1.ronn#recent-files" rel="nofollow">link</a>
for more information.`,name:"recent"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1089"}}),gt=new v({props:{name:"lfs_track",anchor:"huggingface_hub.Repository.lfs_track",parameters:[{name:"patterns",val:": typing.Union[str, typing.List[str]]"},{name:"filename",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_track.patterns",description:`<strong>patterns</strong> (<code>Union[str, List[str]]</code>) &#x2014;
The pattern, or list of patterns, to track with git-lfs.`,name:"patterns"},{anchor:"huggingface_hub.Repository.lfs_track.filename",description:`<strong>filename</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to use the patterns as literal filenames.`,name:"filename"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L930"}}),ht=new v({props:{name:"lfs_untrack",anchor:"huggingface_hub.Repository.lfs_untrack",parameters:[{name:"patterns",val:": typing.Union[str, typing.List[str]]"}],parametersDescription:[{anchor:"huggingface_hub.Repository.lfs_untrack.patterns",description:`<strong>patterns</strong> (<code>Union[str, List[str]]</code>) &#x2014;
The pattern, or list of patterns, to untrack with git-lfs.`,name:"patterns"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L962"}}),pt=new v({props:{name:"list_deleted_files",anchor:"huggingface_hub.Repository.list_deleted_files",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L884",returnDescription:`
<p>A list of files that have been deleted in the working
directory or index.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),dt=new v({props:{name:"push_to_hub",anchor:"huggingface_hub.Repository.push_to_hub",parameters:[{name:"commit_message",val:": typing.Optional[str] = 'commit files to HF hub'"},{name:"blocking",val:": typing.Optional[bool] = True"},{name:"clean_ok",val:": typing.Optional[bool] = True"},{name:"auto_lfs_prune",val:": typing.Optional[bool] = False"}],parametersDescription:[{anchor:"huggingface_hub.Repository.push_to_hub.commit_message",description:`<strong>commit_message</strong> (<code>str</code>) &#x2014;
Message to use for the commit.`,name:"commit_message"},{anchor:"huggingface_hub.Repository.push_to_hub.blocking",description:`<strong>blocking</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether the function should return only when the <code>git push</code> has
finished.`,name:"blocking"},{anchor:"huggingface_hub.Repository.push_to_hub.clean_ok",description:`<strong>clean_ok</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
If True, this function will return None if the repo is
untouched. Default behavior is to fail because the git command
fails.`,name:"clean_ok"},{anchor:"huggingface_hub.Repository.push_to_hub.auto_lfs_prune",description:`<strong>auto_lfs_prune</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to automatically prune files once they have been pushed
to the remote.`,name:"auto_lfs_prune"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1519"}}),ut=new v({props:{name:"tag_exists",anchor:"huggingface_hub.Repository.tag_exists",parameters:[{name:"tag_name",val:": str"},{name:"remote",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.Repository.tag_exists.tag_name",description:`<strong>tag_name</strong> (<code>str</code>) &#x2014;
The name of the tag to check.`,name:"tag_name"},{anchor:"huggingface_hub.Repository.tag_exists.remote",description:`<strong>remote</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Whether to check if the tag exists on a remote. This parameter
should be the identifier of the remote.`,name:"remote"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1356",returnDescription:`
<p>Whether the tag exists.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),mt=new v({props:{name:"wait_for_commands",anchor:"huggingface_hub.Repository.wait_for_commands",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1687"}}),ft=new Rn({}),_t=new v({props:{name:"huggingface_hub.repository.is_git_repo",anchor:"huggingface_hub.repository.is_git_repo",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_git_repo.folder",description:`<strong>folder</strong> (<code>str</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L103",returnDescription:`
<p><code>True</code> if the repository is part of a repository, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),bt=new v({props:{name:"huggingface_hub.repository.is_local_clone",anchor:"huggingface_hub.repository.is_local_clone",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"},{name:"remote_url",val:": str"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_local_clone.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"},{anchor:"huggingface_hub.repository.is_local_clone.remote_url",description:`<strong>remote_url</strong> (<code>str</code>) &#x2014;
The url of a git repository.`,name:"remote_url"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L122",returnDescription:`
<p><code>True</code> if the repository is a local clone of the remote
repository specified, <code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),yt=new v({props:{name:"huggingface_hub.repository.is_tracked_with_lfs",anchor:"huggingface_hub.repository.is_tracked_with_lfs",parameters:[{name:"filename",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_tracked_with_lfs.filename",description:`<strong>filename</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The filename to check.`,name:"filename"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L154",returnDescription:`
<p><code>True</code> if the file passed is tracked with git-lfs, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),vt=new v({props:{name:"huggingface_hub.repository.is_git_ignored",anchor:"huggingface_hub.repository.is_git_ignored",parameters:[{name:"filename",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_git_ignored.filename",description:`<strong>filename</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The filename to check.`,name:"filename"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L198",returnDescription:`
<p><code>True</code> if the file passed is ignored by <code>git</code>, <code>False</code>
otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),$t=new v({props:{name:"huggingface_hub.repository.files_to_be_staged",anchor:"huggingface_hub.repository.files_to_be_staged",parameters:[{name:"pattern",val:": str"},{name:"folder",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.files_to_be_staged.pattern",description:`<strong>pattern</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The pattern of filenames to check. Put <code>.</code> to get all files.`,name:"pattern"},{anchor:"huggingface_hub.repository.files_to_be_staged.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L254",returnDescription:`
<p>List of files that are to be staged.</p>
`,returnType:`
<p><code>List[str]</code></p>
`}}),wt=new v({props:{name:"huggingface_hub.repository.is_tracked_upstream",anchor:"huggingface_hub.repository.is_tracked_upstream",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"}],parametersDescription:[{anchor:"huggingface_hub.repository.is_tracked_upstream.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L286",returnDescription:`
<p><code>True</code> if the current checked-out branch is tracked upstream,
<code>False</code> otherwise.</p>
`,returnType:`
<p><code>bool</code></p>
`}}),kt=new v({props:{name:"huggingface_hub.repository.commits_to_push",anchor:"huggingface_hub.repository.commits_to_push",parameters:[{name:"folder",val:": typing.Union[str, pathlib.Path]"},{name:"upstream",val:": typing.Optional[str] = None"}],parametersDescription:[{anchor:"huggingface_hub.repository.commits_to_push.folder",description:`<strong>folder</strong> (<code>str</code> or <code>Path</code>) &#x2014;
The folder in which to run the command.`,name:"folder"},{anchor:"huggingface_hub.repository.commits_to_push.upstream",description:"<strong>upstream</strong> (<code>str</code>, <em>optional</em>) &#x2014;",name:"upstream"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L316",returnDescription:`
<p>Number of commits that would be pushed upstream were a <code>git push</code> to proceed.</p>
`,returnType:`
<p><code>int</code></p>
`}}),Et=new Rn({}),Dt=new v({props:{name:"class huggingface_hub.Repository",anchor:"huggingface_hub.Repository",parameters:[{name:"local_dir",val:": str"},{name:"clone_from",val:": typing.Optional[str] = None"},{name:"repo_type",val:": typing.Optional[str] = None"},{name:"use_auth_token",val:": typing.Union[bool, str] = True"},{name:"git_user",val:": typing.Optional[str] = None"},{name:"git_email",val:": typing.Optional[str] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"private",val:": bool = False"},{name:"skip_lfs_files",val:": bool = False"},{name:"client",val:": typing.Optional[huggingface_hub.hf_api.HfApi] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L448"}}),Rt=new v({props:{name:"commands_failed",anchor:"huggingface_hub.Repository.commands_failed",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1673"}}),Tt=new v({props:{name:"commands_in_progress",anchor:"huggingface_hub.Repository.commands_in_progress",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1680"}}),Pt=new v({props:{name:"wait_for_commands",anchor:"huggingface_hub.Repository.wait_for_commands",parameters:[],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L1687"}}),It=new v({props:{name:"class huggingface_hub.repository.CommandInProgress",anchor:"huggingface_hub.repository.CommandInProgress",parameters:[{name:"title",val:": str"},{name:"is_done_method",val:": typing.Callable"},{name:"status_method",val:": typing.Callable"},{name:"process",val:": Popen"},{name:"post_method",val:": typing.Optional[typing.Callable] = None"}],source:"https://github.com/huggingface/huggingface_hub/blob/pr_828/src/huggingface_hub/repository.py#L26"}}),{c(){V=r("meta"),kr=l(),A=r("h1"),oe=r("a"),Wt=r("span"),d(Ve.$$.fragment),Tn=l(),Bt=r("span"),Pn=s("Managing local and online repositories"),Er=l(),k=r("p"),In=s("The "),Gt=r("code"),On=s("Repository"),Ln=s(" class is a helper class that wraps "),zt=r("code"),Cn=s("git"),Fn=s(" and "),Jt=r("code"),Nn=s("git-lfs"),jn=s(` commands. It provides tooling adapted
for managing repositories which can be very large.`),xr=l(),re=r("p"),Hn=s("It is the recommended tool as soon as any "),Kt=r("code"),Vn=s("git"),An=s(` operation is involved, or when collaboration will be a point
of focus with the repository itself.`),Dr=l(),S=r("h2"),ne=r("a"),Qt=r("span"),d(Ae.$$.fragment),Sn=l(),Xt=r("span"),qn=s("The Repository class"),Rr=l(),g=r("div"),d(Se.$$.fragment),Un=l(),Yt=r("p"),Mn=s("Helper class to wrap the git and git-lfs commands."),Wn=l(),Zt=r("p"),Bn=s(`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),Gn=l(),E=r("div"),d(qe.$$.fragment),zn=l(),eo=r("p"),Jn=s("Instantiate a local clone of a git repo."),Kn=l(),q=r("p"),Qn=s("If specifying a "),to=r("code"),Xn=s("clone_from"),Yn=s(`, it will clone an existing remote
repository, for instance one that was previously created using
`),oo=r("code"),Zn=s("HfApi().create_repo(repo_id=repo_name)"),ea=s("."),ta=l(),x=r("p"),ro=r("code"),oa=s("Repository"),ra=s(` uses the local git credentials by default, but if required,
the `),no=r("code"),na=s("huggingface_token"),aa=s(" as well as the git "),ao=r("code"),sa=s("user"),ia=s(" and the "),so=r("code"),la=s("email"),ca=s(` can be
explicitly specified.`),ga=l(),ae=r("div"),d(Ue.$$.fragment),ha=l(),io=r("p"),pa=s("Returns the current checked out branch."),da=l(),D=r("div"),d(Me.$$.fragment),ua=l(),lo=r("p"),ma=s("Add a tag at the current head and push it"),fa=l(),co=r("p"),_a=s("If remote is None, will just be updated locally"),ba=l(),go=r("p"),ya=s(`If no message is provided, the tag will be lightweight. if a message is
provided, the tag will be annotated.`),va=l(),se=r("div"),d(We.$$.fragment),$a=l(),ho=r("p"),wa=s("Automatically track binary files with git-lfs."),ka=l(),ie=r("div"),d(Be.$$.fragment),Ea=l(),po=r("p"),xa=s(`Automatically track large files (files that weigh more than 10MBs) with
git-lfs.`),Da=l(),le=r("div"),d(Ge.$$.fragment),Ra=l(),U=r("p"),Ta=s("Checks that "),uo=r("code"),Pa=s("git"),Ia=s(" and "),mo=r("code"),Oa=s("git-lfs"),La=s(" can be run."),Ca=l(),C=r("div"),d(ze.$$.fragment),Fa=l(),fo=r("p"),Na=s(`Clone from a remote. If the folder already exists, will try to clone the
repository within it.`),ja=l(),_o=r("p"),Ha=s(`If this folder is a git repository with linked history, will try to
update the repository.`),Va=l(),R=r("div"),d(Je.$$.fragment),Aa=l(),M=r("p"),Sa=s(`Context manager utility to handle committing to a repository. This
automatically tracks large files (>10Mb) with git-lfs. Set the
`),bo=r("code"),qa=s("track_large_files"),Ua=s(" argument to "),yo=r("code"),Ma=s("False"),Wa=s(` if you wish to ignore that
behavior.`),Ba=l(),vo=r("p"),Ga=s("Examples:"),za=l(),d(Ke.$$.fragment),Ja=l(),ce=r("div"),d(Qe.$$.fragment),Ka=l(),$o=r("p"),Qa=s("Delete a tag, both local and remote, if it exists"),Xa=l(),F=r("div"),d(Xe.$$.fragment),Ya=l(),wo=r("p"),Za=s("git add"),es=l(),I=r("p"),ts=s("Setting the "),ko=r("code"),os=s("auto_lfs_track"),rs=s(" parameter to "),Eo=r("code"),ns=s("True"),as=s(` will automatically
track files that are larger than 10MB with `),xo=r("code"),ss=s("git-lfs"),is=s("."),ls=l(),N=r("div"),d(Ye.$$.fragment),cs=l(),Do=r("p"),gs=s("git checkout a given revision"),hs=l(),W=r("p"),ps=s("Specifying "),Ro=r("code"),ds=s("create_branch_ok"),us=s(" to "),To=r("code"),ms=s("True"),fs=s(` will create the branch to the
given revision if that revision doesn\u2019t exist.`),_s=l(),ge=r("div"),d(Ze.$$.fragment),bs=l(),Po=r("p"),ys=s("git commit"),vs=l(),he=r("div"),d(et.$$.fragment),$s=l(),Io=r("p"),ws=s("Sets git username and email (only in the current repo)."),ks=l(),pe=r("div"),d(tt.$$.fragment),Es=l(),Ot=r("p"),xs=s("Sets the git credential helper to "),Oo=r("code"),Ds=s("store"),Rs=l(),de=r("div"),d(ot.$$.fragment),Ts=l(),Lo=r("p"),Ps=s(`Get URL to last commit on HEAD. We assume it\u2019s been pushed, and the url
scheme is the same one as for GitHub or HuggingFace.`),Is=l(),ue=r("div"),d(rt.$$.fragment),Os=l(),Co=r("p"),Ls=s("Get commit sha on top of HEAD."),Cs=l(),me=r("div"),d(nt.$$.fragment),Fs=l(),Fo=r("p"),Ns=s("git pull"),js=l(),j=r("div"),d(at.$$.fragment),Hs=l(),No=r("p"),Vs=s("git push"),As=l(),B=r("p"),Ss=s("If used without setting "),jo=r("code"),qs=s("blocking"),Us=s(`, will return url to commit on remote
repo. If used with `),Ho=r("code"),Ms=s("blocking=True"),Ws=s(`, will return a tuple containing the
url to commit and the command object to follow for information about the
process.`),Bs=l(),fe=r("div"),d(st.$$.fragment),Gs=l(),Vo=r("p"),zs=s("Get URL to origin remote."),Js=l(),_e=r("div"),d(it.$$.fragment),Ks=l(),Ao=r("p"),Qs=s("Return whether or not the git status is clean or not"),Xs=l(),be=r("div"),d(lt.$$.fragment),Ys=l(),So=r("p"),Zs=s("HF-specific. This enables upload support of files >5GB."),ei=l(),ye=r("div"),d(ct.$$.fragment),ti=l(),qo=r("p"),oi=s("git lfs prune"),ri=l(),H=r("div"),d(gt.$$.fragment),ni=l(),Uo=r("p"),ai=s("Tell git-lfs to track files according to a pattern."),si=l(),O=r("p"),ii=s("Setting the "),Mo=r("code"),li=s("filename"),ci=s(" argument to "),Wo=r("code"),gi=s("True"),hi=s(` will treat the arguments as
literal filenames, not as patterns. Any special glob characters in the
filename will be escaped when writing to the `),Bo=r("code"),pi=s(".gitattributes"),di=s(" file."),ui=l(),ve=r("div"),d(ht.$$.fragment),mi=l(),Go=r("p"),fi=s("Tell git-lfs to untrack those files."),_i=l(),$e=r("div"),d(pt.$$.fragment),bi=l(),zo=r("p"),yi=s(`Returns a list of the files that are deleted in the working directory or
index.`),vi=l(),we=r("div"),d(dt.$$.fragment),$i=l(),Jo=r("p"),wi=s(`Helper to add, commit, and push files to remote repository on the
HuggingFace Hub. Will automatically track large files (>10MB).`),ki=l(),ke=r("div"),d(ut.$$.fragment),Ei=l(),Ko=r("p"),xi=s("Check if a tag exists or not."),Di=l(),Ee=r("div"),d(mt.$$.fragment),Ri=l(),Qo=r("p"),Ti=s(`Blocking method: blocks all subsequent execution until all commands have
been processed.`),Tr=l(),G=r("h2"),xe=r("a"),Xo=r("span"),d(ft.$$.fragment),Pi=l(),Yo=r("span"),Ii=s("Helper methods"),Pr=l(),z=r("div"),d(_t.$$.fragment),Oi=l(),Zo=r("p"),Li=s("Check if the folder is the root or part of a git repository"),Ir=l(),J=r("div"),d(bt.$$.fragment),Ci=l(),er=r("p"),Fi=s("Check if the folder is a local clone of the remote_url"),Or=l(),K=r("div"),d(yt.$$.fragment),Ni=l(),tr=r("p"),ji=s("Check if the file passed is tracked with git-lfs."),Lr=l(),Q=r("div"),d(vt.$$.fragment),Hi=l(),or=r("p"),Vi=s("Check if file is git-ignored. Supports nested .gitignore files."),Cr=l(),X=r("div"),d($t.$$.fragment),Ai=l(),rr=r("p"),Si=s("Returns a list of filenames that are to be staged."),Fr=l(),Y=r("div"),d(wt.$$.fragment),qi=l(),nr=r("p"),Ui=s("Check if the current checked-out branch is tracked upstream."),Nr=l(),L=r("div"),d(kt.$$.fragment),Mi=l(),ar=r("p"),Wi=s("Check the number of commits that would be pushed upstream"),Bi=l(),sr=r("p"),Gi=s(`The name of the upstream repository with which the comparison should be
made.`),jr=l(),Z=r("h2"),De=r("a"),ir=r("span"),d(Et.$$.fragment),zi=l(),lr=r("span"),Ji=s("Following asynchronous commands"),Hr=l(),Re=r("p"),Ki=s("The "),cr=r("code"),Qi=s("Repository"),Xi=s(" utility offers several methods which can be launched asynchronously:"),Vr=l(),T=r("ul"),gr=r("li"),hr=r("code"),Yi=s("git_push"),Zi=l(),pr=r("li"),dr=r("code"),el=s("git_pull"),tl=l(),ur=r("li"),mr=r("code"),ol=s("push_to_hub"),rl=l(),xt=r("li"),nl=s("The "),fr=r("code"),al=s("commit"),sl=s(" context manager"),Ar=l(),Lt=r("p"),il=s("See below for utilities to manage such asynchronous methods."),Sr=l(),w=r("div"),d(Dt.$$.fragment),ll=l(),_r=r("p"),cl=s("Helper class to wrap the git and git-lfs commands."),gl=l(),br=r("p"),hl=s(`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),pl=l(),Te=r("div"),d(Rt.$$.fragment),dl=l(),yr=r("p"),ul=s("Returns the asynchronous commands that failed."),ml=l(),Pe=r("div"),d(Tt.$$.fragment),fl=l(),vr=r("p"),_l=s("Returns the asynchronous commands that are currently in progress."),bl=l(),Ie=r("div"),d(Pt.$$.fragment),yl=l(),$r=r("p"),vl=s(`Blocking method: blocks all subsequent execution until all commands have
been processed.`),qr=l(),ee=r("div"),d(It.$$.fragment),$l=l(),wr=r("p"),wl=s("Utility to follow commands launched asynchronously."),this.h()},l(t){const y=hg('[data-svelte="svelte-1phssyn"]',document.head);V=n(y,"META",{name:!0,content:!0}),y.forEach(o),kr=c(t),A=n(t,"H1",{class:!0});var Mr=a(A);oe=n(Mr,"A",{id:!0,class:!0,href:!0});var xl=a(oe);Wt=n(xl,"SPAN",{});var Dl=a(Wt);u(Ve.$$.fragment,Dl),Dl.forEach(o),xl.forEach(o),Tn=c(Mr),Bt=n(Mr,"SPAN",{});var Rl=a(Bt);Pn=i(Rl,"Managing local and online repositories"),Rl.forEach(o),Mr.forEach(o),Er=c(t),k=n(t,"P",{});var Oe=a(k);In=i(Oe,"The "),Gt=n(Oe,"CODE",{});var Tl=a(Gt);On=i(Tl,"Repository"),Tl.forEach(o),Ln=i(Oe," class is a helper class that wraps "),zt=n(Oe,"CODE",{});var Pl=a(zt);Cn=i(Pl,"git"),Pl.forEach(o),Fn=i(Oe," and "),Jt=n(Oe,"CODE",{});var Il=a(Jt);Nn=i(Il,"git-lfs"),Il.forEach(o),jn=i(Oe,` commands. It provides tooling adapted
for managing repositories which can be very large.`),Oe.forEach(o),xr=c(t),re=n(t,"P",{});var Wr=a(re);Hn=i(Wr,"It is the recommended tool as soon as any "),Kt=n(Wr,"CODE",{});var Ol=a(Kt);Vn=i(Ol,"git"),Ol.forEach(o),An=i(Wr,` operation is involved, or when collaboration will be a point
of focus with the repository itself.`),Wr.forEach(o),Dr=c(t),S=n(t,"H2",{class:!0});var Br=a(S);ne=n(Br,"A",{id:!0,class:!0,href:!0});var Ll=a(ne);Qt=n(Ll,"SPAN",{});var Cl=a(Qt);u(Ae.$$.fragment,Cl),Cl.forEach(o),Ll.forEach(o),Sn=c(Br),Xt=n(Br,"SPAN",{});var Fl=a(Xt);qn=i(Fl,"The Repository class"),Fl.forEach(o),Br.forEach(o),Rr=c(t),g=n(t,"DIV",{class:!0});var h=a(g);u(Se.$$.fragment,h),Un=c(h),Yt=n(h,"P",{});var Nl=a(Yt);Mn=i(Nl,"Helper class to wrap the git and git-lfs commands."),Nl.forEach(o),Wn=c(h),Zt=n(h,"P",{});var jl=a(Zt);Bn=i(jl,`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),jl.forEach(o),Gn=c(h),E=n(h,"DIV",{class:!0});var Le=a(E);u(qe.$$.fragment,Le),zn=c(Le),eo=n(Le,"P",{});var Hl=a(eo);Jn=i(Hl,"Instantiate a local clone of a git repo."),Hl.forEach(o),Kn=c(Le),q=n(Le,"P",{});var Ct=a(q);Qn=i(Ct,"If specifying a "),to=n(Ct,"CODE",{});var Vl=a(to);Xn=i(Vl,"clone_from"),Vl.forEach(o),Yn=i(Ct,`, it will clone an existing remote
repository, for instance one that was previously created using
`),oo=n(Ct,"CODE",{});var Al=a(oo);Zn=i(Al,"HfApi().create_repo(repo_id=repo_name)"),Al.forEach(o),ea=i(Ct,"."),Ct.forEach(o),ta=c(Le),x=n(Le,"P",{});var te=a(x);ro=n(te,"CODE",{});var Sl=a(ro);oa=i(Sl,"Repository"),Sl.forEach(o),ra=i(te,` uses the local git credentials by default, but if required,
the `),no=n(te,"CODE",{});var ql=a(no);na=i(ql,"huggingface_token"),ql.forEach(o),aa=i(te," as well as the git "),ao=n(te,"CODE",{});var Ul=a(ao);sa=i(Ul,"user"),Ul.forEach(o),ia=i(te," and the "),so=n(te,"CODE",{});var Ml=a(so);la=i(Ml,"email"),Ml.forEach(o),ca=i(te,` can be
explicitly specified.`),te.forEach(o),Le.forEach(o),ga=c(h),ae=n(h,"DIV",{class:!0});var Gr=a(ae);u(Ue.$$.fragment,Gr),ha=c(Gr),io=n(Gr,"P",{});var Wl=a(io);pa=i(Wl,"Returns the current checked out branch."),Wl.forEach(o),Gr.forEach(o),da=c(h),D=n(h,"DIV",{class:!0});var Ce=a(D);u(Me.$$.fragment,Ce),ua=c(Ce),lo=n(Ce,"P",{});var Bl=a(lo);ma=i(Bl,"Add a tag at the current head and push it"),Bl.forEach(o),fa=c(Ce),co=n(Ce,"P",{});var Gl=a(co);_a=i(Gl,"If remote is None, will just be updated locally"),Gl.forEach(o),ba=c(Ce),go=n(Ce,"P",{});var zl=a(go);ya=i(zl,`If no message is provided, the tag will be lightweight. if a message is
provided, the tag will be annotated.`),zl.forEach(o),Ce.forEach(o),va=c(h),se=n(h,"DIV",{class:!0});var zr=a(se);u(We.$$.fragment,zr),$a=c(zr),ho=n(zr,"P",{});var Jl=a(ho);wa=i(Jl,"Automatically track binary files with git-lfs."),Jl.forEach(o),zr.forEach(o),ka=c(h),ie=n(h,"DIV",{class:!0});var Jr=a(ie);u(Be.$$.fragment,Jr),Ea=c(Jr),po=n(Jr,"P",{});var Kl=a(po);xa=i(Kl,`Automatically track large files (files that weigh more than 10MBs) with
git-lfs.`),Kl.forEach(o),Jr.forEach(o),Da=c(h),le=n(h,"DIV",{class:!0});var Kr=a(le);u(Ge.$$.fragment,Kr),Ra=c(Kr),U=n(Kr,"P",{});var Ft=a(U);Ta=i(Ft,"Checks that "),uo=n(Ft,"CODE",{});var Ql=a(uo);Pa=i(Ql,"git"),Ql.forEach(o),Ia=i(Ft," and "),mo=n(Ft,"CODE",{});var Xl=a(mo);Oa=i(Xl,"git-lfs"),Xl.forEach(o),La=i(Ft," can be run."),Ft.forEach(o),Kr.forEach(o),Ca=c(h),C=n(h,"DIV",{class:!0});var Nt=a(C);u(ze.$$.fragment,Nt),Fa=c(Nt),fo=n(Nt,"P",{});var Yl=a(fo);Na=i(Yl,`Clone from a remote. If the folder already exists, will try to clone the
repository within it.`),Yl.forEach(o),ja=c(Nt),_o=n(Nt,"P",{});var Zl=a(_o);Ha=i(Zl,`If this folder is a git repository with linked history, will try to
update the repository.`),Zl.forEach(o),Nt.forEach(o),Va=c(h),R=n(h,"DIV",{class:!0});var Fe=a(R);u(Je.$$.fragment,Fe),Aa=c(Fe),M=n(Fe,"P",{});var jt=a(M);Sa=i(jt,`Context manager utility to handle committing to a repository. This
automatically tracks large files (>10Mb) with git-lfs. Set the
`),bo=n(jt,"CODE",{});var ec=a(bo);qa=i(ec,"track_large_files"),ec.forEach(o),Ua=i(jt," argument to "),yo=n(jt,"CODE",{});var tc=a(yo);Ma=i(tc,"False"),tc.forEach(o),Wa=i(jt,` if you wish to ignore that
behavior.`),jt.forEach(o),Ba=c(Fe),vo=n(Fe,"P",{});var oc=a(vo);Ga=i(oc,"Examples:"),oc.forEach(o),za=c(Fe),u(Ke.$$.fragment,Fe),Fe.forEach(o),Ja=c(h),ce=n(h,"DIV",{class:!0});var Qr=a(ce);u(Qe.$$.fragment,Qr),Ka=c(Qr),$o=n(Qr,"P",{});var rc=a($o);Qa=i(rc,"Delete a tag, both local and remote, if it exists"),rc.forEach(o),Qr.forEach(o),Xa=c(h),F=n(h,"DIV",{class:!0});var Ht=a(F);u(Xe.$$.fragment,Ht),Ya=c(Ht),wo=n(Ht,"P",{});var nc=a(wo);Za=i(nc,"git add"),nc.forEach(o),es=c(Ht),I=n(Ht,"P",{});var Ne=a(I);ts=i(Ne,"Setting the "),ko=n(Ne,"CODE",{});var ac=a(ko);os=i(ac,"auto_lfs_track"),ac.forEach(o),rs=i(Ne," parameter to "),Eo=n(Ne,"CODE",{});var sc=a(Eo);ns=i(sc,"True"),sc.forEach(o),as=i(Ne,` will automatically
track files that are larger than 10MB with `),xo=n(Ne,"CODE",{});var ic=a(xo);ss=i(ic,"git-lfs"),ic.forEach(o),is=i(Ne,"."),Ne.forEach(o),Ht.forEach(o),ls=c(h),N=n(h,"DIV",{class:!0});var Vt=a(N);u(Ye.$$.fragment,Vt),cs=c(Vt),Do=n(Vt,"P",{});var lc=a(Do);gs=i(lc,"git checkout a given revision"),lc.forEach(o),hs=c(Vt),W=n(Vt,"P",{});var At=a(W);ps=i(At,"Specifying "),Ro=n(At,"CODE",{});var cc=a(Ro);ds=i(cc,"create_branch_ok"),cc.forEach(o),us=i(At," to "),To=n(At,"CODE",{});var gc=a(To);ms=i(gc,"True"),gc.forEach(o),fs=i(At,` will create the branch to the
given revision if that revision doesn\u2019t exist.`),At.forEach(o),Vt.forEach(o),_s=c(h),ge=n(h,"DIV",{class:!0});var Xr=a(ge);u(Ze.$$.fragment,Xr),bs=c(Xr),Po=n(Xr,"P",{});var hc=a(Po);ys=i(hc,"git commit"),hc.forEach(o),Xr.forEach(o),vs=c(h),he=n(h,"DIV",{class:!0});var Yr=a(he);u(et.$$.fragment,Yr),$s=c(Yr),Io=n(Yr,"P",{});var pc=a(Io);ws=i(pc,"Sets git username and email (only in the current repo)."),pc.forEach(o),Yr.forEach(o),ks=c(h),pe=n(h,"DIV",{class:!0});var Zr=a(pe);u(tt.$$.fragment,Zr),Es=c(Zr),Ot=n(Zr,"P",{});var kl=a(Ot);xs=i(kl,"Sets the git credential helper to "),Oo=n(kl,"CODE",{});var dc=a(Oo);Ds=i(dc,"store"),dc.forEach(o),kl.forEach(o),Zr.forEach(o),Rs=c(h),de=n(h,"DIV",{class:!0});var en=a(de);u(ot.$$.fragment,en),Ts=c(en),Lo=n(en,"P",{});var uc=a(Lo);Ps=i(uc,`Get URL to last commit on HEAD. We assume it\u2019s been pushed, and the url
scheme is the same one as for GitHub or HuggingFace.`),uc.forEach(o),en.forEach(o),Is=c(h),ue=n(h,"DIV",{class:!0});var tn=a(ue);u(rt.$$.fragment,tn),Os=c(tn),Co=n(tn,"P",{});var mc=a(Co);Ls=i(mc,"Get commit sha on top of HEAD."),mc.forEach(o),tn.forEach(o),Cs=c(h),me=n(h,"DIV",{class:!0});var on=a(me);u(nt.$$.fragment,on),Fs=c(on),Fo=n(on,"P",{});var fc=a(Fo);Ns=i(fc,"git pull"),fc.forEach(o),on.forEach(o),js=c(h),j=n(h,"DIV",{class:!0});var St=a(j);u(at.$$.fragment,St),Hs=c(St),No=n(St,"P",{});var _c=a(No);Vs=i(_c,"git push"),_c.forEach(o),As=c(St),B=n(St,"P",{});var qt=a(B);Ss=i(qt,"If used without setting "),jo=n(qt,"CODE",{});var bc=a(jo);qs=i(bc,"blocking"),bc.forEach(o),Us=i(qt,`, will return url to commit on remote
repo. If used with `),Ho=n(qt,"CODE",{});var yc=a(Ho);Ms=i(yc,"blocking=True"),yc.forEach(o),Ws=i(qt,`, will return a tuple containing the
url to commit and the command object to follow for information about the
process.`),qt.forEach(o),St.forEach(o),Bs=c(h),fe=n(h,"DIV",{class:!0});var rn=a(fe);u(st.$$.fragment,rn),Gs=c(rn),Vo=n(rn,"P",{});var vc=a(Vo);zs=i(vc,"Get URL to origin remote."),vc.forEach(o),rn.forEach(o),Js=c(h),_e=n(h,"DIV",{class:!0});var nn=a(_e);u(it.$$.fragment,nn),Ks=c(nn),Ao=n(nn,"P",{});var $c=a(Ao);Qs=i($c,"Return whether or not the git status is clean or not"),$c.forEach(o),nn.forEach(o),Xs=c(h),be=n(h,"DIV",{class:!0});var an=a(be);u(lt.$$.fragment,an),Ys=c(an),So=n(an,"P",{});var wc=a(So);Zs=i(wc,"HF-specific. This enables upload support of files >5GB."),wc.forEach(o),an.forEach(o),ei=c(h),ye=n(h,"DIV",{class:!0});var sn=a(ye);u(ct.$$.fragment,sn),ti=c(sn),qo=n(sn,"P",{});var kc=a(qo);oi=i(kc,"git lfs prune"),kc.forEach(o),sn.forEach(o),ri=c(h),H=n(h,"DIV",{class:!0});var Ut=a(H);u(gt.$$.fragment,Ut),ni=c(Ut),Uo=n(Ut,"P",{});var Ec=a(Uo);ai=i(Ec,"Tell git-lfs to track files according to a pattern."),Ec.forEach(o),si=c(Ut),O=n(Ut,"P",{});var je=a(O);ii=i(je,"Setting the "),Mo=n(je,"CODE",{});var xc=a(Mo);li=i(xc,"filename"),xc.forEach(o),ci=i(je," argument to "),Wo=n(je,"CODE",{});var Dc=a(Wo);gi=i(Dc,"True"),Dc.forEach(o),hi=i(je,` will treat the arguments as
literal filenames, not as patterns. Any special glob characters in the
filename will be escaped when writing to the `),Bo=n(je,"CODE",{});var Rc=a(Bo);pi=i(Rc,".gitattributes"),Rc.forEach(o),di=i(je," file."),je.forEach(o),Ut.forEach(o),ui=c(h),ve=n(h,"DIV",{class:!0});var ln=a(ve);u(ht.$$.fragment,ln),mi=c(ln),Go=n(ln,"P",{});var Tc=a(Go);fi=i(Tc,"Tell git-lfs to untrack those files."),Tc.forEach(o),ln.forEach(o),_i=c(h),$e=n(h,"DIV",{class:!0});var cn=a($e);u(pt.$$.fragment,cn),bi=c(cn),zo=n(cn,"P",{});var Pc=a(zo);yi=i(Pc,`Returns a list of the files that are deleted in the working directory or
index.`),Pc.forEach(o),cn.forEach(o),vi=c(h),we=n(h,"DIV",{class:!0});var gn=a(we);u(dt.$$.fragment,gn),$i=c(gn),Jo=n(gn,"P",{});var Ic=a(Jo);wi=i(Ic,`Helper to add, commit, and push files to remote repository on the
HuggingFace Hub. Will automatically track large files (>10MB).`),Ic.forEach(o),gn.forEach(o),ki=c(h),ke=n(h,"DIV",{class:!0});var hn=a(ke);u(ut.$$.fragment,hn),Ei=c(hn),Ko=n(hn,"P",{});var Oc=a(Ko);xi=i(Oc,"Check if a tag exists or not."),Oc.forEach(o),hn.forEach(o),Di=c(h),Ee=n(h,"DIV",{class:!0});var pn=a(Ee);u(mt.$$.fragment,pn),Ri=c(pn),Qo=n(pn,"P",{});var Lc=a(Qo);Ti=i(Lc,`Blocking method: blocks all subsequent execution until all commands have
been processed.`),Lc.forEach(o),pn.forEach(o),h.forEach(o),Tr=c(t),G=n(t,"H2",{class:!0});var dn=a(G);xe=n(dn,"A",{id:!0,class:!0,href:!0});var Cc=a(xe);Xo=n(Cc,"SPAN",{});var Fc=a(Xo);u(ft.$$.fragment,Fc),Fc.forEach(o),Cc.forEach(o),Pi=c(dn),Yo=n(dn,"SPAN",{});var Nc=a(Yo);Ii=i(Nc,"Helper methods"),Nc.forEach(o),dn.forEach(o),Pr=c(t),z=n(t,"DIV",{class:!0});var un=a(z);u(_t.$$.fragment,un),Oi=c(un),Zo=n(un,"P",{});var jc=a(Zo);Li=i(jc,"Check if the folder is the root or part of a git repository"),jc.forEach(o),un.forEach(o),Ir=c(t),J=n(t,"DIV",{class:!0});var mn=a(J);u(bt.$$.fragment,mn),Ci=c(mn),er=n(mn,"P",{});var Hc=a(er);Fi=i(Hc,"Check if the folder is a local clone of the remote_url"),Hc.forEach(o),mn.forEach(o),Or=c(t),K=n(t,"DIV",{class:!0});var fn=a(K);u(yt.$$.fragment,fn),Ni=c(fn),tr=n(fn,"P",{});var Vc=a(tr);ji=i(Vc,"Check if the file passed is tracked with git-lfs."),Vc.forEach(o),fn.forEach(o),Lr=c(t),Q=n(t,"DIV",{class:!0});var _n=a(Q);u(vt.$$.fragment,_n),Hi=c(_n),or=n(_n,"P",{});var Ac=a(or);Vi=i(Ac,"Check if file is git-ignored. Supports nested .gitignore files."),Ac.forEach(o),_n.forEach(o),Cr=c(t),X=n(t,"DIV",{class:!0});var bn=a(X);u($t.$$.fragment,bn),Ai=c(bn),rr=n(bn,"P",{});var Sc=a(rr);Si=i(Sc,"Returns a list of filenames that are to be staged."),Sc.forEach(o),bn.forEach(o),Fr=c(t),Y=n(t,"DIV",{class:!0});var yn=a(Y);u(wt.$$.fragment,yn),qi=c(yn),nr=n(yn,"P",{});var qc=a(nr);Ui=i(qc,"Check if the current checked-out branch is tracked upstream."),qc.forEach(o),yn.forEach(o),Nr=c(t),L=n(t,"DIV",{class:!0});var Mt=a(L);u(kt.$$.fragment,Mt),Mi=c(Mt),ar=n(Mt,"P",{});var Uc=a(ar);Wi=i(Uc,"Check the number of commits that would be pushed upstream"),Uc.forEach(o),Bi=c(Mt),sr=n(Mt,"P",{});var Mc=a(sr);Gi=i(Mc,`The name of the upstream repository with which the comparison should be
made.`),Mc.forEach(o),Mt.forEach(o),jr=c(t),Z=n(t,"H2",{class:!0});var vn=a(Z);De=n(vn,"A",{id:!0,class:!0,href:!0});var Wc=a(De);ir=n(Wc,"SPAN",{});var Bc=a(ir);u(Et.$$.fragment,Bc),Bc.forEach(o),Wc.forEach(o),zi=c(vn),lr=n(vn,"SPAN",{});var Gc=a(lr);Ji=i(Gc,"Following asynchronous commands"),Gc.forEach(o),vn.forEach(o),Hr=c(t),Re=n(t,"P",{});var $n=a(Re);Ki=i($n,"The "),cr=n($n,"CODE",{});var zc=a(cr);Qi=i(zc,"Repository"),zc.forEach(o),Xi=i($n," utility offers several methods which can be launched asynchronously:"),$n.forEach(o),Vr=c(t),T=n(t,"UL",{});var He=a(T);gr=n(He,"LI",{});var Jc=a(gr);hr=n(Jc,"CODE",{});var Kc=a(hr);Yi=i(Kc,"git_push"),Kc.forEach(o),Jc.forEach(o),Zi=c(He),pr=n(He,"LI",{});var Qc=a(pr);dr=n(Qc,"CODE",{});var Xc=a(dr);el=i(Xc,"git_pull"),Xc.forEach(o),Qc.forEach(o),tl=c(He),ur=n(He,"LI",{});var Yc=a(ur);mr=n(Yc,"CODE",{});var Zc=a(mr);ol=i(Zc,"push_to_hub"),Zc.forEach(o),Yc.forEach(o),rl=c(He),xt=n(He,"LI",{});var wn=a(xt);nl=i(wn,"The "),fr=n(wn,"CODE",{});var eg=a(fr);al=i(eg,"commit"),eg.forEach(o),sl=i(wn," context manager"),wn.forEach(o),He.forEach(o),Ar=c(t),Lt=n(t,"P",{});var tg=a(Lt);il=i(tg,"See below for utilities to manage such asynchronous methods."),tg.forEach(o),Sr=c(t),w=n(t,"DIV",{class:!0});var P=a(w);u(Dt.$$.fragment,P),ll=c(P),_r=n(P,"P",{});var og=a(_r);cl=i(og,"Helper class to wrap the git and git-lfs commands."),og.forEach(o),gl=c(P),br=n(P,"P",{});var rg=a(br);hl=i(rg,`The aim is to facilitate interacting with huggingface.co hosted model or
dataset repos, though not a lot here (if any) is actually specific to
huggingface.co.`),rg.forEach(o),pl=c(P),Te=n(P,"DIV",{class:!0});var kn=a(Te);u(Rt.$$.fragment,kn),dl=c(kn),yr=n(kn,"P",{});var ng=a(yr);ul=i(ng,"Returns the asynchronous commands that failed."),ng.forEach(o),kn.forEach(o),ml=c(P),Pe=n(P,"DIV",{class:!0});var En=a(Pe);u(Tt.$$.fragment,En),fl=c(En),vr=n(En,"P",{});var ag=a(vr);_l=i(ag,"Returns the asynchronous commands that are currently in progress."),ag.forEach(o),En.forEach(o),bl=c(P),Ie=n(P,"DIV",{class:!0});var xn=a(Ie);u(Pt.$$.fragment,xn),yl=c(xn),$r=n(xn,"P",{});var sg=a($r);vl=i(sg,`Blocking method: blocks all subsequent execution until all commands have
been processed.`),sg.forEach(o),xn.forEach(o),P.forEach(o),qr=c(t),ee=n(t,"DIV",{class:!0});var Dn=a(ee);u(It.$$.fragment,Dn),$l=c(Dn),wr=n(Dn,"P",{});var ig=a(wr);wl=i(ig,"Utility to follow commands launched asynchronously."),ig.forEach(o),Dn.forEach(o),this.h()},h(){p(V,"name","hf:doc:metadata"),p(V,"content",JSON.stringify(fg)),p(oe,"id","managing-local-and-online-repositories"),p(oe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(oe,"href","#managing-local-and-online-repositories"),p(A,"class","relative group"),p(ne,"id","huggingface_hub.Repository"),p(ne,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(ne,"href","#huggingface_hub.Repository"),p(S,"class","relative group"),p(E,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ae,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(D,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ie,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(le,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(C,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(R,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ce,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(F,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ge,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(he,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(de,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ue,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(me,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(j,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(fe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(_e,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(be,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ye,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(H,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ve,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p($e,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(we,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ke,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(g,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(xe,"id","huggingface_hub.repository.is_git_repo"),p(xe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(xe,"href","#huggingface_hub.repository.is_git_repo"),p(G,"class","relative group"),p(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(J,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(K,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(X,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Y,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(L,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(De,"id","huggingface_hub.Repository"),p(De,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),p(De,"href","#huggingface_hub.Repository"),p(Z,"class","relative group"),p(Te,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(Ie,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(w,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),p(ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,y){e(document.head,V),$(t,kr,y),$(t,A,y),e(A,oe),e(oe,Wt),m(Ve,Wt,null),e(A,Tn),e(A,Bt),e(Bt,Pn),$(t,Er,y),$(t,k,y),e(k,In),e(k,Gt),e(Gt,On),e(k,Ln),e(k,zt),e(zt,Cn),e(k,Fn),e(k,Jt),e(Jt,Nn),e(k,jn),$(t,xr,y),$(t,re,y),e(re,Hn),e(re,Kt),e(Kt,Vn),e(re,An),$(t,Dr,y),$(t,S,y),e(S,ne),e(ne,Qt),m(Ae,Qt,null),e(S,Sn),e(S,Xt),e(Xt,qn),$(t,Rr,y),$(t,g,y),m(Se,g,null),e(g,Un),e(g,Yt),e(Yt,Mn),e(g,Wn),e(g,Zt),e(Zt,Bn),e(g,Gn),e(g,E),m(qe,E,null),e(E,zn),e(E,eo),e(eo,Jn),e(E,Kn),e(E,q),e(q,Qn),e(q,to),e(to,Xn),e(q,Yn),e(q,oo),e(oo,Zn),e(q,ea),e(E,ta),e(E,x),e(x,ro),e(ro,oa),e(x,ra),e(x,no),e(no,na),e(x,aa),e(x,ao),e(ao,sa),e(x,ia),e(x,so),e(so,la),e(x,ca),e(g,ga),e(g,ae),m(Ue,ae,null),e(ae,ha),e(ae,io),e(io,pa),e(g,da),e(g,D),m(Me,D,null),e(D,ua),e(D,lo),e(lo,ma),e(D,fa),e(D,co),e(co,_a),e(D,ba),e(D,go),e(go,ya),e(g,va),e(g,se),m(We,se,null),e(se,$a),e(se,ho),e(ho,wa),e(g,ka),e(g,ie),m(Be,ie,null),e(ie,Ea),e(ie,po),e(po,xa),e(g,Da),e(g,le),m(Ge,le,null),e(le,Ra),e(le,U),e(U,Ta),e(U,uo),e(uo,Pa),e(U,Ia),e(U,mo),e(mo,Oa),e(U,La),e(g,Ca),e(g,C),m(ze,C,null),e(C,Fa),e(C,fo),e(fo,Na),e(C,ja),e(C,_o),e(_o,Ha),e(g,Va),e(g,R),m(Je,R,null),e(R,Aa),e(R,M),e(M,Sa),e(M,bo),e(bo,qa),e(M,Ua),e(M,yo),e(yo,Ma),e(M,Wa),e(R,Ba),e(R,vo),e(vo,Ga),e(R,za),m(Ke,R,null),e(g,Ja),e(g,ce),m(Qe,ce,null),e(ce,Ka),e(ce,$o),e($o,Qa),e(g,Xa),e(g,F),m(Xe,F,null),e(F,Ya),e(F,wo),e(wo,Za),e(F,es),e(F,I),e(I,ts),e(I,ko),e(ko,os),e(I,rs),e(I,Eo),e(Eo,ns),e(I,as),e(I,xo),e(xo,ss),e(I,is),e(g,ls),e(g,N),m(Ye,N,null),e(N,cs),e(N,Do),e(Do,gs),e(N,hs),e(N,W),e(W,ps),e(W,Ro),e(Ro,ds),e(W,us),e(W,To),e(To,ms),e(W,fs),e(g,_s),e(g,ge),m(Ze,ge,null),e(ge,bs),e(ge,Po),e(Po,ys),e(g,vs),e(g,he),m(et,he,null),e(he,$s),e(he,Io),e(Io,ws),e(g,ks),e(g,pe),m(tt,pe,null),e(pe,Es),e(pe,Ot),e(Ot,xs),e(Ot,Oo),e(Oo,Ds),e(g,Rs),e(g,de),m(ot,de,null),e(de,Ts),e(de,Lo),e(Lo,Ps),e(g,Is),e(g,ue),m(rt,ue,null),e(ue,Os),e(ue,Co),e(Co,Ls),e(g,Cs),e(g,me),m(nt,me,null),e(me,Fs),e(me,Fo),e(Fo,Ns),e(g,js),e(g,j),m(at,j,null),e(j,Hs),e(j,No),e(No,Vs),e(j,As),e(j,B),e(B,Ss),e(B,jo),e(jo,qs),e(B,Us),e(B,Ho),e(Ho,Ms),e(B,Ws),e(g,Bs),e(g,fe),m(st,fe,null),e(fe,Gs),e(fe,Vo),e(Vo,zs),e(g,Js),e(g,_e),m(it,_e,null),e(_e,Ks),e(_e,Ao),e(Ao,Qs),e(g,Xs),e(g,be),m(lt,be,null),e(be,Ys),e(be,So),e(So,Zs),e(g,ei),e(g,ye),m(ct,ye,null),e(ye,ti),e(ye,qo),e(qo,oi),e(g,ri),e(g,H),m(gt,H,null),e(H,ni),e(H,Uo),e(Uo,ai),e(H,si),e(H,O),e(O,ii),e(O,Mo),e(Mo,li),e(O,ci),e(O,Wo),e(Wo,gi),e(O,hi),e(O,Bo),e(Bo,pi),e(O,di),e(g,ui),e(g,ve),m(ht,ve,null),e(ve,mi),e(ve,Go),e(Go,fi),e(g,_i),e(g,$e),m(pt,$e,null),e($e,bi),e($e,zo),e(zo,yi),e(g,vi),e(g,we),m(dt,we,null),e(we,$i),e(we,Jo),e(Jo,wi),e(g,ki),e(g,ke),m(ut,ke,null),e(ke,Ei),e(ke,Ko),e(Ko,xi),e(g,Di),e(g,Ee),m(mt,Ee,null),e(Ee,Ri),e(Ee,Qo),e(Qo,Ti),$(t,Tr,y),$(t,G,y),e(G,xe),e(xe,Xo),m(ft,Xo,null),e(G,Pi),e(G,Yo),e(Yo,Ii),$(t,Pr,y),$(t,z,y),m(_t,z,null),e(z,Oi),e(z,Zo),e(Zo,Li),$(t,Ir,y),$(t,J,y),m(bt,J,null),e(J,Ci),e(J,er),e(er,Fi),$(t,Or,y),$(t,K,y),m(yt,K,null),e(K,Ni),e(K,tr),e(tr,ji),$(t,Lr,y),$(t,Q,y),m(vt,Q,null),e(Q,Hi),e(Q,or),e(or,Vi),$(t,Cr,y),$(t,X,y),m($t,X,null),e(X,Ai),e(X,rr),e(rr,Si),$(t,Fr,y),$(t,Y,y),m(wt,Y,null),e(Y,qi),e(Y,nr),e(nr,Ui),$(t,Nr,y),$(t,L,y),m(kt,L,null),e(L,Mi),e(L,ar),e(ar,Wi),e(L,Bi),e(L,sr),e(sr,Gi),$(t,jr,y),$(t,Z,y),e(Z,De),e(De,ir),m(Et,ir,null),e(Z,zi),e(Z,lr),e(lr,Ji),$(t,Hr,y),$(t,Re,y),e(Re,Ki),e(Re,cr),e(cr,Qi),e(Re,Xi),$(t,Vr,y),$(t,T,y),e(T,gr),e(gr,hr),e(hr,Yi),e(T,Zi),e(T,pr),e(pr,dr),e(dr,el),e(T,tl),e(T,ur),e(ur,mr),e(mr,ol),e(T,rl),e(T,xt),e(xt,nl),e(xt,fr),e(fr,al),e(xt,sl),$(t,Ar,y),$(t,Lt,y),e(Lt,il),$(t,Sr,y),$(t,w,y),m(Dt,w,null),e(w,ll),e(w,_r),e(_r,cl),e(w,gl),e(w,br),e(br,hl),e(w,pl),e(w,Te),m(Rt,Te,null),e(Te,dl),e(Te,yr),e(yr,ul),e(w,ml),e(w,Pe),m(Tt,Pe,null),e(Pe,fl),e(Pe,vr),e(vr,_l),e(w,bl),e(w,Ie),m(Pt,Ie,null),e(Ie,yl),e(Ie,$r),e($r,vl),$(t,qr,y),$(t,ee,y),m(It,ee,null),e(ee,$l),e(ee,wr),e(wr,wl),Ur=!0},p:pg,i(t){Ur||(f(Ve.$$.fragment,t),f(Ae.$$.fragment,t),f(Se.$$.fragment,t),f(qe.$$.fragment,t),f(Ue.$$.fragment,t),f(Me.$$.fragment,t),f(We.$$.fragment,t),f(Be.$$.fragment,t),f(Ge.$$.fragment,t),f(ze.$$.fragment,t),f(Je.$$.fragment,t),f(Ke.$$.fragment,t),f(Qe.$$.fragment,t),f(Xe.$$.fragment,t),f(Ye.$$.fragment,t),f(Ze.$$.fragment,t),f(et.$$.fragment,t),f(tt.$$.fragment,t),f(ot.$$.fragment,t),f(rt.$$.fragment,t),f(nt.$$.fragment,t),f(at.$$.fragment,t),f(st.$$.fragment,t),f(it.$$.fragment,t),f(lt.$$.fragment,t),f(ct.$$.fragment,t),f(gt.$$.fragment,t),f(ht.$$.fragment,t),f(pt.$$.fragment,t),f(dt.$$.fragment,t),f(ut.$$.fragment,t),f(mt.$$.fragment,t),f(ft.$$.fragment,t),f(_t.$$.fragment,t),f(bt.$$.fragment,t),f(yt.$$.fragment,t),f(vt.$$.fragment,t),f($t.$$.fragment,t),f(wt.$$.fragment,t),f(kt.$$.fragment,t),f(Et.$$.fragment,t),f(Dt.$$.fragment,t),f(Rt.$$.fragment,t),f(Tt.$$.fragment,t),f(Pt.$$.fragment,t),f(It.$$.fragment,t),Ur=!0)},o(t){_(Ve.$$.fragment,t),_(Ae.$$.fragment,t),_(Se.$$.fragment,t),_(qe.$$.fragment,t),_(Ue.$$.fragment,t),_(Me.$$.fragment,t),_(We.$$.fragment,t),_(Be.$$.fragment,t),_(Ge.$$.fragment,t),_(ze.$$.fragment,t),_(Je.$$.fragment,t),_(Ke.$$.fragment,t),_(Qe.$$.fragment,t),_(Xe.$$.fragment,t),_(Ye.$$.fragment,t),_(Ze.$$.fragment,t),_(et.$$.fragment,t),_(tt.$$.fragment,t),_(ot.$$.fragment,t),_(rt.$$.fragment,t),_(nt.$$.fragment,t),_(at.$$.fragment,t),_(st.$$.fragment,t),_(it.$$.fragment,t),_(lt.$$.fragment,t),_(ct.$$.fragment,t),_(gt.$$.fragment,t),_(ht.$$.fragment,t),_(pt.$$.fragment,t),_(dt.$$.fragment,t),_(ut.$$.fragment,t),_(mt.$$.fragment,t),_(ft.$$.fragment,t),_(_t.$$.fragment,t),_(bt.$$.fragment,t),_(yt.$$.fragment,t),_(vt.$$.fragment,t),_($t.$$.fragment,t),_(wt.$$.fragment,t),_(kt.$$.fragment,t),_(Et.$$.fragment,t),_(Dt.$$.fragment,t),_(Rt.$$.fragment,t),_(Tt.$$.fragment,t),_(Pt.$$.fragment,t),_(It.$$.fragment,t),Ur=!1},d(t){o(V),t&&o(kr),t&&o(A),b(Ve),t&&o(Er),t&&o(k),t&&o(xr),t&&o(re),t&&o(Dr),t&&o(S),b(Ae),t&&o(Rr),t&&o(g),b(Se),b(qe),b(Ue),b(Me),b(We),b(Be),b(Ge),b(ze),b(Je),b(Ke),b(Qe),b(Xe),b(Ye),b(Ze),b(et),b(tt),b(ot),b(rt),b(nt),b(at),b(st),b(it),b(lt),b(ct),b(gt),b(ht),b(pt),b(dt),b(ut),b(mt),t&&o(Tr),t&&o(G),b(ft),t&&o(Pr),t&&o(z),b(_t),t&&o(Ir),t&&o(J),b(bt),t&&o(Or),t&&o(K),b(yt),t&&o(Lr),t&&o(Q),b(vt),t&&o(Cr),t&&o(X),b($t),t&&o(Fr),t&&o(Y),b(wt),t&&o(Nr),t&&o(L),b(kt),t&&o(jr),t&&o(Z),b(Et),t&&o(Hr),t&&o(Re),t&&o(Vr),t&&o(T),t&&o(Ar),t&&o(Lt),t&&o(Sr),t&&o(w),b(Dt),b(Rt),b(Tt),b(Pt),t&&o(qr),t&&o(ee),b(It)}}}const fg={local:"managing-local-and-online-repositories",sections:[{local:"huggingface_hub.Repository",title:"The Repository class"},{local:"huggingface_hub.repository.is_git_repo",title:"Helper methods"},{local:"huggingface_hub.Repository",title:"Following asynchronous commands"}],title:"Managing local and online repositories"};function _g(El){return dg(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class wg extends lg{constructor(V){super();cg(this,V,_g,mg,gg,{})}}export{wg as default,fg as metadata};
