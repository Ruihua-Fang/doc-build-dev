import{S as Jl,i as Xl,s as Kl,e as a,k as d,w as _,t as o,M as Ql,c as r,d as s,m as c,x as E,a as l,h as n,b as v,F as t,g as u,y as q,q as $,o as b,B as g,v as Zl}from"../../chunks/vendor-1e8b365d.js";import{T as Yl}from"../../chunks/Tip-62b14c6e.js";import{Y as ei}from"../../chunks/Youtube-c2a8cc39.js";import{I as qr}from"../../chunks/IconCopyLink-483c28ba.js";import{C as B}from"../../chunks/CodeBlock-e5764662.js";import{D as ti}from"../../chunks/DocNotebookDropdown-37d928d3.js";import{F as si}from"../../chunks/FrameworkSwitchCourse-7f8f0f31.js";function oi(Ce){let p,S,f,M,T,C,G,y,A,j,te,U,ee,ue;return{c(){p=a("p"),S=o("\u{1F4A1} Si vous voulez t\xE9l\xE9charger automatiquement votre mod\xE8le sur le "),f=a("em"),M=o("Hub"),T=o(" pendant l\u2019entra\xEEnement, passez "),C=a("code"),G=o("push_to_hub=True"),y=o(" dans le "),A=a("code"),j=o("TrainingArguments"),te=o(". Nous en apprendrons plus \xE0 ce sujet au "),U=a("a"),ee=o("Chapitre 4"),ue=o("."),this.h()},l(R){p=r(R,"P",{});var w=l(p);S=n(w,"\u{1F4A1} Si vous voulez t\xE9l\xE9charger automatiquement votre mod\xE8le sur le "),f=r(w,"EM",{});var h=l(f);M=n(h,"Hub"),h.forEach(s),T=n(w," pendant l\u2019entra\xEEnement, passez "),C=r(w,"CODE",{});var Ge=l(C);G=n(Ge,"push_to_hub=True"),Ge.forEach(s),y=n(w," dans le "),A=r(w,"CODE",{});var de=l(A);j=n(de,"TrainingArguments"),de.forEach(s),te=n(w,". Nous en apprendrons plus \xE0 ce sujet au "),U=r(w,"A",{href:!0});var Re=l(U);ee=n(Re,"Chapitre 4"),Re.forEach(s),ue=n(w,"."),w.forEach(s),this.h()},h(){v(U,"href","/course/fr/chapter4/3")},m(R,w){u(R,p,w),t(p,S),t(p,f),t(f,M),t(p,T),t(p,C),t(C,G),t(p,y),t(p,A),t(A,j),t(p,te),t(p,U),t(U,ee),t(p,ue)},d(R){R&&s(p)}}}function ni(Ce){let p,S,f,M,T,C,G,y;return{c(){p=a("p"),S=o("\u270F\uFE0F "),f=a("strong"),M=o("Essayez"),T=d(),C=a("em"),G=o("Finetunez"),y=o(" un mod\xE8le sur le jeu de donn\xE9es GLUE SST-2, en utilisant le traitement des donn\xE9es que vous avez fait dans la section 2.")},l(A){p=r(A,"P",{});var j=l(p);S=n(j,"\u270F\uFE0F "),f=r(j,"STRONG",{});var te=l(f);M=n(te,"Essayez"),te.forEach(s),T=c(j),C=r(j,"EM",{});var U=l(C);G=n(U,"Finetunez"),U.forEach(s),y=n(j," un mod\xE8le sur le jeu de donn\xE9es GLUE SST-2, en utilisant le traitement des donn\xE9es que vous avez fait dans la section 2."),j.forEach(s)},m(A,j){u(A,p,j),t(p,S),t(p,f),t(f,M),t(p,T),t(p,C),t(C,G),t(p,y)},d(A){A&&s(p)}}}function ai(Ce){let p,S,f,M,T,C,G,y,A,j,te,U,ee,ue,R,w,h,Ge,de,Re,io,et,uo,co,tt,po,mo,st,fo,vo,ot,ho,_o,ke,Eo,qo,Es,Be,$o,qs,je,$s,re,ce,nt,ze,bo,at,go,bs,P,Co,rt,ko,jo,lt,zo,To,it,wo,Po,ut,Do,xo,dt,Oo,yo,gs,Te,Cs,pe,ks,se,Ao,Ve,Lo,So,ct,Mo,Uo,js,we,zs,me,No,We,Fo,Io,Ts,D,Go,pt,Ro,Bo,mt,Vo,Wo,ft,Ho,Yo,vt,Jo,Xo,ht,Ko,Qo,ws,Pe,Ps,x,Zo,_t,en,tn,Et,sn,on,qt,nn,an,$t,rn,ln,bt,un,dn,Ds,V,cn,gt,pn,mn,Ct,fn,vn,kt,hn,_n,xs,De,Os,fe,En,jt,qn,$n,ys,ve,L,bn,zt,gn,Cn,Tt,kn,jn,wt,zn,Tn,Pt,wn,Pn,Dt,Dn,xn,On,le,yn,xt,An,Ln,Ot,Sn,Mn,As,ie,he,yt,xe,Un,At,Nn,Ls,z,Fn,Lt,In,Gn,St,Rn,Bn,Mt,Vn,Wn,Ut,Hn,Yn,Nt,Jn,Xn,Ft,Kn,Qn,Ss,Oe,Ms,ye,Us,m,Zn,It,ea,ta,Gt,sa,oa,Rt,na,aa,Bt,ra,la,Vt,ia,ua,Wt,da,ca,Ht,pa,ma,Yt,fa,va,Jt,ha,_a,Ns,N,Ea,Xt,qa,$a,Kt,ba,ga,He,Ca,ka,Qt,ja,za,Fs,Ae,Is,O,Ta,Zt,wa,Pa,es,Da,xa,ts,Oa,ya,ss,Aa,La,os,Sa,Ma,Gs,Le,Rs,Se,Bs,W,Ua,Me,Na,Fa,ns,Ia,Ga,as,Ra,Ba,Vs,_e,Va,rs,Wa,Ha,Ws,Ue,Hs,oe,Ya,ls,Ja,Xa,is,Ka,Qa,Ys,Ne,Js,H,Za,us,er,tr,ds,sr,or,cs,nr,ar,Xs,Fe,Ks,Ye,rr,Qs,ne,lr,ps,ir,ur,ms,dr,cr,Zs,Y,pr,fs,mr,fr,vs,vr,hr,Je,_r,Er,eo,Ee,to;return f=new si({props:{fw:Ce[0]}}),y=new qr({}),ee=new ti({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Google Colab",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/course/chapter3/section3.ipynb"},{label:"Aws Studio",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/course/chapter3/section3.ipynb"}]}}),R=new ei({props:{id:"nvBXf7s7vTI"}}),je=new B({props:{code:`from datasets import load_dataset
from transformers import AutoTokenizer, DataCollatorWithPadding

raw_datasets = load_dataset("glue", "mrpc")
checkpoint = "bert-base-uncased"
tokenizer = AutoTokenizer.from_pretrained(checkpoint)


def tokenize_function(example):
    return tokenizer(example["sentence1"], example["sentence2"], truncation=True)


tokenized_datasets = raw_datasets.map(tokenize_function, batched=True)
data_collator = DataCollatorWithPadding(tokenizer=tokenizer)`,highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset
<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, DataCollatorWithPadding

raw_datasets = load_dataset(<span class="hljs-string">&quot;glue&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>)
checkpoint = <span class="hljs-string">&quot;bert-base-uncased&quot;</span>
tokenizer = AutoTokenizer.from_pretrained(checkpoint)


<span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_function</span>(<span class="hljs-params">example</span>):
    <span class="hljs-keyword">return</span> tokenizer(example[<span class="hljs-string">&quot;sentence1&quot;</span>], example[<span class="hljs-string">&quot;sentence2&quot;</span>], truncation=<span class="hljs-literal">True</span>)


tokenized_datasets = raw_datasets.<span class="hljs-built_in">map</span>(tokenize_function, batched=<span class="hljs-literal">True</span>)
data_collator = DataCollatorWithPadding(tokenizer=tokenizer)`}}),ze=new qr({}),Te=new B({props:{code:`from transformers import TrainingArguments

training_args = TrainingArguments("test-trainer")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments

training_args = TrainingArguments(<span class="hljs-string">&quot;test-trainer&quot;</span>)`}}),pe=new Yl({props:{$$slots:{default:[oi]},$$scope:{ctx:Ce}}}),we=new B({props:{code:`from transformers import AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSequenceClassification

model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=<span class="hljs-number">2</span>)`}}),Pe=new B({props:{code:`from transformers import Trainer

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets["train"],
    eval_dataset=tokenized_datasets["validation"],
    data_collator=data_collator,
    tokenizer=tokenizer,
)`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Trainer

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>],
    eval_dataset=tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>],
    data_collator=data_collator,
    tokenizer=tokenizer,
)`}}),De=new B({props:{code:"trainer.train()",highlighted:"trainer.train()"}}),xe=new qr({}),Oe=new B({props:{code:`predictions = trainer.predict(tokenized_datasets["validation"])
print(predictions.predictions.shape, predictions.label_ids.shape)`,highlighted:`predictions = trainer.predict(tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>])
<span class="hljs-built_in">print</span>(predictions.predictions.shape, predictions.label_ids.shape)`}}),ye=new B({props:{code:"(408, 2) (408,)",highlighted:'(<span class="hljs-number">408</span>, <span class="hljs-number">2</span>) (<span class="hljs-number">408</span>,)'}}),Ae=new B({props:{code:`import numpy as np

preds = np.argmax(predictions.predictions, axis=-1)`,highlighted:`<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np

preds = np.argmax(predictions.predictions, axis=-<span class="hljs-number">1</span>)`}}),Le=new B({props:{code:`from datasets import load_metric

metric = load_metric("glue", "mrpc")
metric.compute(predictions=preds, references=predictions.label_ids)`,highlighted:`<span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_metric

metric = load_metric(<span class="hljs-string">&quot;glue&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>)
metric.compute(predictions=preds, references=predictions.label_ids)`}}),Se=new B({props:{code:"{'accuracy': 0.8578431372549019, 'f1': 0.8996539792387542}",highlighted:'{<span class="hljs-string">&#x27;accuracy&#x27;</span>: <span class="hljs-number">0.8578431372549019</span>, <span class="hljs-string">&#x27;f1&#x27;</span>: <span class="hljs-number">0.8996539792387542</span>}'}}),Ue=new B({props:{code:`def compute_metrics(eval_preds):
    metric = load_metric("glue", "mrpc")
    logits, labels = eval_preds
    predictions = np.argmax(logits, axis=-1)
    return metric.compute(predictions=predictions, references=labels)`,highlighted:`<span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_metrics</span>(<span class="hljs-params">eval_preds</span>):
    metric = load_metric(<span class="hljs-string">&quot;glue&quot;</span>, <span class="hljs-string">&quot;mrpc&quot;</span>)
    logits, labels = eval_preds
    predictions = np.argmax(logits, axis=-<span class="hljs-number">1</span>)
    <span class="hljs-keyword">return</span> metric.compute(predictions=predictions, references=labels)`}}),Ne=new B({props:{code:`training_args = TrainingArguments("test-trainer", evaluation_strategy="epoch")
model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=2)

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets["train"],
    eval_dataset=tokenized_datasets["validation"],
    data_collator=data_collator,
    tokenizer=tokenizer,
    compute_metrics=compute_metrics,
)`,highlighted:`training_args = TrainingArguments(<span class="hljs-string">&quot;test-trainer&quot;</span>, evaluation_strategy=<span class="hljs-string">&quot;epoch&quot;</span>)
model = AutoModelForSequenceClassification.from_pretrained(checkpoint, num_labels=<span class="hljs-number">2</span>)

trainer = Trainer(
    model,
    training_args,
    train_dataset=tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>],
    eval_dataset=tokenized_datasets[<span class="hljs-string">&quot;validation&quot;</span>],
    data_collator=data_collator,
    tokenizer=tokenizer,
    compute_metrics=compute_metrics,
)`}}),Fe=new B({props:{code:"trainer.train()",highlighted:'trainer.trai<span class="hljs-meta">n</span>()'}}),Ee=new Yl({props:{$$slots:{default:[ni]},$$scope:{ctx:Ce}}}),{c(){p=a("meta"),S=d(),_(f.$$.fragment),M=d(),T=a("h1"),C=a("a"),G=a("span"),_(y.$$.fragment),A=d(),j=a("span"),te=o("*Finetuner* un mod\xE8le avec l'API Trainer"),U=d(),_(ee.$$.fragment),ue=d(),_(R.$$.fragment),w=d(),h=a("p"),Ge=o("\u{1F917} "),de=a("em"),Re=o("Transformers"),io=o(" fournit une classe "),et=a("code"),uo=o("Trainer"),co=o(" pour vous aider \xE0 "),tt=a("em"),po=o("finetuner"),mo=o(" n\u2019importe lequel des mod\xE8les pr\xE9-entra\xEEn\xE9s qu\u2019il fournit sur votre jeu de donn\xE9es. Une fois que vous avez fait tout le travail de pr\xE9traitement des donn\xE9es dans la derni\xE8re section, il ne vous reste que quelques \xE9tapes pour d\xE9finir le "),st=a("code"),fo=o("Trainer"),vo=o(". La partie la plus difficile sera probablement de pr\xE9parer l\u2019environnement pour ex\xE9cuter "),ot=a("code"),ho=o("Trainer.train()"),_o=o(", car elle fonctionnera tr\xE8s lentement sur un CPU. Si vous n\u2019avez pas de GPU, vous pouvez avoir acc\xE8s \xE0 des GPUs ou TPUs gratuits sur "),ke=a("a"),Eo=o("Google Colab"),qo=o("."),Es=d(),Be=a("p"),$o=o("Les exemples de code ci-dessous supposent que vous avez d\xE9j\xE0 ex\xE9cut\xE9 les exemples de la section pr\xE9c\xE9dente. Voici un bref r\xE9sum\xE9 de ce dont vous avez besoin :"),qs=d(),_(je.$$.fragment),$s=d(),re=a("h3"),ce=a("a"),nt=a("span"),_(ze.$$.fragment),bo=d(),at=a("span"),go=o("Entra\xEEnement"),bs=d(),P=a("p"),Co=o("La premi\xE8re \xE9tape avant de pouvoir d\xE9finir notre "),rt=a("code"),ko=o("Trainer"),jo=o(" est de d\xE9finir une classe "),lt=a("code"),zo=o("TrainingArguments"),To=o(" qui contiendra tous les hyperparam\xE8tres que le "),it=a("code"),wo=o("Trainer"),Po=o(" utilisera pour l\u2019entra\xEEnement et l\u2019\xE9valuation. Le seul argument que vous devez fournir est un r\xE9pertoire o\xF9 le mod\xE8le entra\xEEn\xE9 sera sauvegard\xE9, ainsi que les "),ut=a("em"),Do=o("checkpoints"),xo=o(". Pour tout le reste, vous pouvez laisser les valeurs par d\xE9faut, qui devraient fonctionner assez bien pour un "),dt=a("em"),Oo=o("finetuning"),yo=o(" de base."),gs=d(),_(Te.$$.fragment),Cs=d(),_(pe.$$.fragment),ks=d(),se=a("p"),Ao=o("La deuxi\xE8me \xE9tape consiste \xE0 d\xE9finir notre mod\xE8le. Comme dans le "),Ve=a("a"),Lo=o("chapitre pr\xE9c\xE9dent"),So=o(", nous utiliserons la classe "),ct=a("code"),Mo=o("AutoModelForSequenceClassification"),Uo=o(", avec deux labels :"),js=d(),_(we.$$.fragment),zs=d(),me=a("p"),No=o("Vous remarquerez que contrairement au "),We=a("a"),Fo=o("Chapitre 2"),Io=o(", vous obtenez un message d\u2019avertissement apr\xE8s l\u2019instanciation de ce mod\xE8le pr\xE9-entra\xEEn\xE9. C\u2019est parce que BERT n\u2019a pas \xE9t\xE9 pr\xE9-entra\xEEn\xE9 \xE0 la classification de paires de phrases, donc la t\xEAte du mod\xE8le pr\xE9-entra\xEEn\xE9 a \xE9t\xE9 supprim\xE9e et une nouvelle t\xEAte adapt\xE9e \xE0 la classification de s\xE9quences a \xE9t\xE9 ajout\xE9e \xE0 la place. Les messages d\u2019avertissement indiquent que certains poids n\u2019ont pas \xE9t\xE9 utilis\xE9s (ceux correspondant \xE0 la t\xEAte de pr\xE9-entra\xEEnement abandonn\xE9e) et que d\u2019autres ont \xE9t\xE9 initialis\xE9s de mani\xE8re al\xE9atoire (ceux pour la nouvelle t\xEAte). Il conclut en vous encourageant \xE0 entra\xEEner le mod\xE8le, ce qui est exactement ce que nous allons faire maintenant."),Ts=d(),D=a("p"),Go=o("Une fois que nous avons notre mod\xE8le, nous pouvons d\xE9finir un "),pt=a("code"),Ro=o("Trainer"),Bo=o(" en lui passant tous les objets construits jusqu\u2019\xE0 pr\xE9sent : le "),mt=a("code"),Vo=o("model"),Wo=o(", le "),ft=a("code"),Ho=o("training_args"),Yo=o(", les jeux de donn\xE9es d\u2019entra\xEEnement et de validation, notre "),vt=a("code"),Jo=o("data_collator"),Xo=o(", et notre "),ht=a("code"),Ko=o("tokenizer"),Qo=o(" :"),ws=d(),_(Pe.$$.fragment),Ps=d(),x=a("p"),Zo=o("Notez que lorsque vous passez le "),_t=a("code"),en=o("tokenizer"),tn=o(" comme nous l\u2019avons fait ici, le "),Et=a("code"),sn=o("data_collator"),on=o(" par d\xE9faut utilis\xE9 par le "),qt=a("code"),nn=o("Trainer"),an=o(" sera un "),$t=a("code"),rn=o("DataCollatorWithPadding"),ln=o(" comme d\xE9fini pr\xE9c\xE9demment. Ainsi, vous pouvez sauter la ligne "),bt=a("code"),un=o("data_collator=data_collator"),dn=o(" dans cet appel. Il \xE9tait quand m\xEAme important de vous montrer cette partie du traitement dans la section 2 !"),Ds=d(),V=a("p"),cn=o("Pour "),gt=a("em"),pn=o("finetuner"),mn=o(" le mod\xE8le sur notre jeu de donn\xE9es, il suffit d\u2019appeler la m\xE9thode "),Ct=a("code"),fn=o("train()"),vn=o(" de notre "),kt=a("code"),hn=o("Trainer"),_n=o(" :"),xs=d(),_(De.$$.fragment),Os=d(),fe=a("p"),En=o("Cela lancera le "),jt=a("em"),qn=o("finetuning"),$n=o(" (qui devrait prendre quelques minutes sur un GPU) et indiquera la perte d\u2019entra\xEEnement tous les 500 pas. Cependant, elle ne vous dira pas si votre mod\xE8le fonctionne bien (ou mal). Ceci est d\xFB au fait que :"),ys=d(),ve=a("ol"),L=a("li"),bn=o("nous n\u2019avons pas dit au "),zt=a("code"),gn=o("Trainer"),Cn=o(" d\u2019\xE9valuer pendant l\u2019entra\xEEnement en r\xE9glant "),Tt=a("code"),kn=o("evaluation_strategy"),jn=o(" \xE0 soit "),wt=a("code"),zn=o('"steps"'),Tn=o(" (\xE9valuer chaque "),Pt=a("code"),wn=o("eval_steps"),Pn=o(") ou "),Dt=a("code"),Dn=o('"epoch"'),xn=o(" (\xE9valuer \xE0 la fin de chaque epoch)."),On=d(),le=a("li"),yn=o("nous n\u2019avons pas fourni au "),xt=a("code"),An=o("Trainer"),Ln=o(" une fonction "),Ot=a("code"),Sn=o("compute_metrics()"),Mn=o(" pour calculer une m\xE9trique pendant ladite \xE9valuation (sinon l\u2019\xE9valuation aurait juste affich\xE9 la perte, qui n\u2019est pas un nombre tr\xE8s intuitif)."),As=d(),ie=a("h3"),he=a("a"),yt=a("span"),_(xe.$$.fragment),Un=d(),At=a("span"),Nn=o("Evaluation"),Ls=d(),z=a("p"),Fn=o("Voyons comment nous pouvons construire une fonction "),Lt=a("code"),In=o("compute_metrics()"),Gn=o(" utile et l\u2019utiliser la prochaine fois que nous entra\xEEnons. La fonction doit prendre un objet "),St=a("code"),Rn=o("EvalPrediction"),Bn=o(" (qui est un "),Mt=a("em"),Vn=o("tuple"),Wn=o(" nomm\xE9 avec un champ "),Ut=a("code"),Hn=o("predictions"),Yn=o(" et un champ "),Nt=a("code"),Jn=o("label_ids"),Xn=o(") et retournera un dictionnaire de cha\xEEnes de caract\xE8res vers des flottants (les cha\xEEnes de caract\xE8res \xE9tant les noms des m\xE9triques retourn\xE9es, et les flottants leurs valeurs). Pour obtenir des pr\xE9dictions de notre mod\xE8le, nous pouvons utiliser la commande "),Ft=a("code"),Kn=o("Trainer.predict()"),Qn=o(" :"),Ss=d(),_(Oe.$$.fragment),Ms=d(),_(ye.$$.fragment),Us=d(),m=a("p"),Zn=o("La sortie de la m\xE9thode "),It=a("code"),ea=o("predict()"),ta=o(" est un autre "),Gt=a("em"),sa=o("tuple"),oa=o(" nomm\xE9 avec trois champs : "),Rt=a("code"),na=o("predictions"),aa=o(", "),Bt=a("code"),ra=o("label_ids"),la=o(", et "),Vt=a("code"),ia=o("metrics"),ua=o(". Le champ "),Wt=a("code"),da=o("metrics"),ca=o(" contiendra juste la perte sur le jeu de donn\xE9es pass\xE9, ainsi que quelques mesures de temps (combien de temps il a fallu pour pr\xE9dire, au total et en moyenne). Une fois que nous aurons compl\xE9t\xE9 notre fonction "),Ht=a("code"),pa=o("compute_metrics()"),ma=o(" et que nous l\u2019aurons pass\xE9 au "),Yt=a("code"),fa=o("Trainer"),va=o(", ce champ contiendra \xE9galement les m\xE9triques retourn\xE9es par "),Jt=a("code"),ha=o("compute_metrics()"),_a=o("."),Ns=d(),N=a("p"),Ea=o("Comme vous pouvez le voir, "),Xt=a("code"),qa=o("predictions"),$a=o(" est un tableau bidimensionnel de forme 408 x 2 (408 \xE9tant le nombre d\u2019\xE9l\xE9ments dans le jeu de donn\xE9es que nous avons utilis\xE9). Ce sont les logits pour chaque \xE9l\xE9ment du jeu de donn\xE9es que nous avons pass\xE9 \xE0 "),Kt=a("code"),ba=o("predict()"),ga=o(" (comme vous l\u2019avez vu dans le "),He=a("a"),Ca=o("chapitre pr\xE9c\xE9dent"),ka=o(", tous les "),Qt=a("em"),ja=o("transformers"),za=o(" retournent des logits). Pour les transformer en pr\xE9dictions que nous pouvons comparer \xE0 nos \xE9tiquettes, nous devons prendre l\u2019indice avec la valeur maximale sur le second axe :"),Fs=d(),_(Ae.$$.fragment),Is=d(),O=a("p"),Ta=o("Nous pouvons maintenant comparer ces "),Zt=a("code"),wa=o("preds"),Pa=o(" aux \xE9tiquettes. Pour construire notre fonction "),es=a("code"),Da=o("compute_metric()"),xa=o(", nous allons nous appuyer sur les m\xE9triques de la biblioth\xE8que \u{1F917} "),ts=a("em"),Oa=o("Datasets"),ya=o(". Nous pouvons charger les m\xE9triques associ\xE9es au jeu de donn\xE9es MRPC aussi facilement que nous avons charg\xE9 le jeu de donn\xE9es, cette fois avec la fonction "),ss=a("code"),Aa=o("load_metric()"),La=o(". L\u2019objet retourn\xE9 poss\xE8de une m\xE9thode "),os=a("code"),Sa=o("compute()"),Ma=o(" que nous pouvons utiliser pour effectuer le calcul de la m\xE9trique :"),Gs=d(),_(Le.$$.fragment),Rs=d(),_(Se.$$.fragment),Bs=d(),W=a("p"),Ua=o("Les r\xE9sultats exacts que vous obtiendrez peuvent varier, car l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le peut modifier les m\xE9triques obtenues. Ici, nous pouvons voir que notre mod\xE8le a une pr\xE9cision de 85,78% sur l\u2019ensemble de validation et un score F1 de 89,97. Ce sont les deux m\xE9triques utilis\xE9es pour \xE9valuer les r\xE9sultats sur le jeu de donn\xE9es MRPC pour le benchmark GLUE. Le tableau du papier de "),Me=a("a"),Na=o("BERT"),Fa=o(" indique un score F1 de 88,9 pour le mod\xE8le de base. Il s\u2019agissait du mod\xE8le "),ns=a("code"),Ia=o("uncased"),Ga=o(" alors que nous utilisons actuellement le mod\xE8le "),as=a("code"),Ra=o("cased"),Ba=o(", ce qui explique le meilleur r\xE9sultat."),Vs=d(),_e=a("p"),Va=o("En regroupant le tout, nous obtenons notre fonction "),rs=a("code"),Wa=o("compute_metrics()"),Ha=o(" :"),Ws=d(),_(Ue.$$.fragment),Hs=d(),oe=a("p"),Ya=o("Et pour le voir utilis\xE9 en action pour rapporter les m\xE9triques \xE0 la fin de chaque \xE9poque, voici comment nous d\xE9finissons un nouveau "),ls=a("code"),Ja=o("Trainer"),Xa=o(" avec cette fonction "),is=a("code"),Ka=o("compute_metrics()"),Qa=o(" :"),Ys=d(),_(Ne.$$.fragment),Js=d(),H=a("p"),Za=o("Notez que nous cr\xE9ons un nouveau "),us=a("code"),er=o("TrainingArguments"),tr=o(" avec sa "),ds=a("code"),sr=o("evaluation_strategy"),or=o(" d\xE9finie sur "),cs=a("code"),nr=o('"epoch"'),ar=o(" et un nouveau mod\xE8le. Sinon, nous ne ferions que continuer l\u2019entra\xEEnement du mod\xE8le que nous avons d\xE9j\xE0 entra\xEEn\xE9. Pour lancer un nouveau cycle d\u2019entra\xEEnement, nous ex\xE9cutons :"),Xs=d(),_(Fe.$$.fragment),Ks=d(),Ye=a("p"),rr=o("Cette fois, il indiquera la perte et les mesures de validation \xE0 la fin de chaque \xE9poque, en plus de la perte d\u2019entra\xEEnement. Encore une fois, le score exact de pr\xE9cision/F1 que vous atteignez peut \xEAtre un peu diff\xE9rent de ce que nous avons trouv\xE9, en raison de l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le, mais il devrait \xEAtre dans la m\xEAme fourchette."),Qs=d(),ne=a("p"),lr=o("Le "),ps=a("code"),ir=o("Trainer"),ur=o(" fonctionnera sur plusieurs GPUs ou TPUs et fournit beaucoup d\u2019options, comme l\u2019entra\xEEnement en pr\xE9cision mixte (utilisez "),ms=a("code"),dr=o("fp16 = True"),cr=o(" dans vos arguments d\u2019entra\xEEnement). Nous passerons en revue tout ce qu\u2019il supporte dans le chapitre 10."),Zs=d(),Y=a("p"),pr=o("Ceci conclut l\u2019introduction au "),fs=a("em"),mr=o("fine-tuning"),fr=o(" en utilisant l\u2019API "),vs=a("code"),vr=o("Trainer"),hr=o(". Un exemple d\u2019utilisation pour les t\xE2ches de NLP les plus communes es donn\xE9 dans le "),Je=a("a"),_r=o("Chapitre 7"),Er=o(", mais pour l\u2019instant regardons comment faire la m\xEAme chose en PyTorch pur."),eo=d(),_(Ee.$$.fragment),this.h()},l(e){const i=Ql('[data-svelte="svelte-1phssyn"]',document.head);p=r(i,"META",{name:!0,content:!0}),i.forEach(s),S=c(e),E(f.$$.fragment,e),M=c(e),T=r(e,"H1",{class:!0});var Ie=l(T);C=r(Ie,"A",{id:!0,class:!0,href:!0});var hs=l(C);G=r(hs,"SPAN",{});var _s=l(G);E(y.$$.fragment,_s),_s.forEach(s),hs.forEach(s),A=c(Ie),j=r(Ie,"SPAN",{});var $r=l(j);te=n($r,"*Finetuner* un mod\xE8le avec l'API Trainer"),$r.forEach(s),Ie.forEach(s),U=c(e),E(ee.$$.fragment,e),ue=c(e),E(R.$$.fragment,e),w=c(e),h=r(e,"P",{});var F=l(h);Ge=n(F,"\u{1F917} "),de=r(F,"EM",{});var br=l(de);Re=n(br,"Transformers"),br.forEach(s),io=n(F," fournit une classe "),et=r(F,"CODE",{});var gr=l(et);uo=n(gr,"Trainer"),gr.forEach(s),co=n(F," pour vous aider \xE0 "),tt=r(F,"EM",{});var Cr=l(tt);po=n(Cr,"finetuner"),Cr.forEach(s),mo=n(F," n\u2019importe lequel des mod\xE8les pr\xE9-entra\xEEn\xE9s qu\u2019il fournit sur votre jeu de donn\xE9es. Une fois que vous avez fait tout le travail de pr\xE9traitement des donn\xE9es dans la derni\xE8re section, il ne vous reste que quelques \xE9tapes pour d\xE9finir le "),st=r(F,"CODE",{});var kr=l(st);fo=n(kr,"Trainer"),kr.forEach(s),vo=n(F,". La partie la plus difficile sera probablement de pr\xE9parer l\u2019environnement pour ex\xE9cuter "),ot=r(F,"CODE",{});var jr=l(ot);ho=n(jr,"Trainer.train()"),jr.forEach(s),_o=n(F,", car elle fonctionnera tr\xE8s lentement sur un CPU. Si vous n\u2019avez pas de GPU, vous pouvez avoir acc\xE8s \xE0 des GPUs ou TPUs gratuits sur "),ke=r(F,"A",{href:!0,rel:!0});var zr=l(ke);Eo=n(zr,"Google Colab"),zr.forEach(s),qo=n(F,"."),F.forEach(s),Es=c(e),Be=r(e,"P",{});var Tr=l(Be);$o=n(Tr,"Les exemples de code ci-dessous supposent que vous avez d\xE9j\xE0 ex\xE9cut\xE9 les exemples de la section pr\xE9c\xE9dente. Voici un bref r\xE9sum\xE9 de ce dont vous avez besoin :"),Tr.forEach(s),qs=c(e),E(je.$$.fragment,e),$s=c(e),re=r(e,"H3",{class:!0});var so=l(re);ce=r(so,"A",{id:!0,class:!0,href:!0});var wr=l(ce);nt=r(wr,"SPAN",{});var Pr=l(nt);E(ze.$$.fragment,Pr),Pr.forEach(s),wr.forEach(s),bo=c(so),at=r(so,"SPAN",{});var Dr=l(at);go=n(Dr,"Entra\xEEnement"),Dr.forEach(s),so.forEach(s),bs=c(e),P=r(e,"P",{});var J=l(P);Co=n(J,"La premi\xE8re \xE9tape avant de pouvoir d\xE9finir notre "),rt=r(J,"CODE",{});var xr=l(rt);ko=n(xr,"Trainer"),xr.forEach(s),jo=n(J," est de d\xE9finir une classe "),lt=r(J,"CODE",{});var Or=l(lt);zo=n(Or,"TrainingArguments"),Or.forEach(s),To=n(J," qui contiendra tous les hyperparam\xE8tres que le "),it=r(J,"CODE",{});var yr=l(it);wo=n(yr,"Trainer"),yr.forEach(s),Po=n(J," utilisera pour l\u2019entra\xEEnement et l\u2019\xE9valuation. Le seul argument que vous devez fournir est un r\xE9pertoire o\xF9 le mod\xE8le entra\xEEn\xE9 sera sauvegard\xE9, ainsi que les "),ut=r(J,"EM",{});var Ar=l(ut);Do=n(Ar,"checkpoints"),Ar.forEach(s),xo=n(J,". Pour tout le reste, vous pouvez laisser les valeurs par d\xE9faut, qui devraient fonctionner assez bien pour un "),dt=r(J,"EM",{});var Lr=l(dt);Oo=n(Lr,"finetuning"),Lr.forEach(s),yo=n(J," de base."),J.forEach(s),gs=c(e),E(Te.$$.fragment,e),Cs=c(e),E(pe.$$.fragment,e),ks=c(e),se=r(e,"P",{});var Xe=l(se);Ao=n(Xe,"La deuxi\xE8me \xE9tape consiste \xE0 d\xE9finir notre mod\xE8le. Comme dans le "),Ve=r(Xe,"A",{href:!0});var Sr=l(Ve);Lo=n(Sr,"chapitre pr\xE9c\xE9dent"),Sr.forEach(s),So=n(Xe,", nous utiliserons la classe "),ct=r(Xe,"CODE",{});var Mr=l(ct);Mo=n(Mr,"AutoModelForSequenceClassification"),Mr.forEach(s),Uo=n(Xe,", avec deux labels :"),Xe.forEach(s),js=c(e),E(we.$$.fragment,e),zs=c(e),me=r(e,"P",{});var oo=l(me);No=n(oo,"Vous remarquerez que contrairement au "),We=r(oo,"A",{href:!0});var Ur=l(We);Fo=n(Ur,"Chapitre 2"),Ur.forEach(s),Io=n(oo,", vous obtenez un message d\u2019avertissement apr\xE8s l\u2019instanciation de ce mod\xE8le pr\xE9-entra\xEEn\xE9. C\u2019est parce que BERT n\u2019a pas \xE9t\xE9 pr\xE9-entra\xEEn\xE9 \xE0 la classification de paires de phrases, donc la t\xEAte du mod\xE8le pr\xE9-entra\xEEn\xE9 a \xE9t\xE9 supprim\xE9e et une nouvelle t\xEAte adapt\xE9e \xE0 la classification de s\xE9quences a \xE9t\xE9 ajout\xE9e \xE0 la place. Les messages d\u2019avertissement indiquent que certains poids n\u2019ont pas \xE9t\xE9 utilis\xE9s (ceux correspondant \xE0 la t\xEAte de pr\xE9-entra\xEEnement abandonn\xE9e) et que d\u2019autres ont \xE9t\xE9 initialis\xE9s de mani\xE8re al\xE9atoire (ceux pour la nouvelle t\xEAte). Il conclut en vous encourageant \xE0 entra\xEEner le mod\xE8le, ce qui est exactement ce que nous allons faire maintenant."),oo.forEach(s),Ts=c(e),D=r(e,"P",{});var X=l(D);Go=n(X,"Une fois que nous avons notre mod\xE8le, nous pouvons d\xE9finir un "),pt=r(X,"CODE",{});var Nr=l(pt);Ro=n(Nr,"Trainer"),Nr.forEach(s),Bo=n(X," en lui passant tous les objets construits jusqu\u2019\xE0 pr\xE9sent : le "),mt=r(X,"CODE",{});var Fr=l(mt);Vo=n(Fr,"model"),Fr.forEach(s),Wo=n(X,", le "),ft=r(X,"CODE",{});var Ir=l(ft);Ho=n(Ir,"training_args"),Ir.forEach(s),Yo=n(X,", les jeux de donn\xE9es d\u2019entra\xEEnement et de validation, notre "),vt=r(X,"CODE",{});var Gr=l(vt);Jo=n(Gr,"data_collator"),Gr.forEach(s),Xo=n(X,", et notre "),ht=r(X,"CODE",{});var Rr=l(ht);Ko=n(Rr,"tokenizer"),Rr.forEach(s),Qo=n(X," :"),X.forEach(s),ws=c(e),E(Pe.$$.fragment,e),Ps=c(e),x=r(e,"P",{});var K=l(x);Zo=n(K,"Notez que lorsque vous passez le "),_t=r(K,"CODE",{});var Br=l(_t);en=n(Br,"tokenizer"),Br.forEach(s),tn=n(K," comme nous l\u2019avons fait ici, le "),Et=r(K,"CODE",{});var Vr=l(Et);sn=n(Vr,"data_collator"),Vr.forEach(s),on=n(K," par d\xE9faut utilis\xE9 par le "),qt=r(K,"CODE",{});var Wr=l(qt);nn=n(Wr,"Trainer"),Wr.forEach(s),an=n(K," sera un "),$t=r(K,"CODE",{});var Hr=l($t);rn=n(Hr,"DataCollatorWithPadding"),Hr.forEach(s),ln=n(K," comme d\xE9fini pr\xE9c\xE9demment. Ainsi, vous pouvez sauter la ligne "),bt=r(K,"CODE",{});var Yr=l(bt);un=n(Yr,"data_collator=data_collator"),Yr.forEach(s),dn=n(K," dans cet appel. Il \xE9tait quand m\xEAme important de vous montrer cette partie du traitement dans la section 2 !"),K.forEach(s),Ds=c(e),V=r(e,"P",{});var qe=l(V);cn=n(qe,"Pour "),gt=r(qe,"EM",{});var Jr=l(gt);pn=n(Jr,"finetuner"),Jr.forEach(s),mn=n(qe," le mod\xE8le sur notre jeu de donn\xE9es, il suffit d\u2019appeler la m\xE9thode "),Ct=r(qe,"CODE",{});var Xr=l(Ct);fn=n(Xr,"train()"),Xr.forEach(s),vn=n(qe," de notre "),kt=r(qe,"CODE",{});var Kr=l(kt);hn=n(Kr,"Trainer"),Kr.forEach(s),_n=n(qe," :"),qe.forEach(s),xs=c(e),E(De.$$.fragment,e),Os=c(e),fe=r(e,"P",{});var no=l(fe);En=n(no,"Cela lancera le "),jt=r(no,"EM",{});var Qr=l(jt);qn=n(Qr,"finetuning"),Qr.forEach(s),$n=n(no," (qui devrait prendre quelques minutes sur un GPU) et indiquera la perte d\u2019entra\xEEnement tous les 500 pas. Cependant, elle ne vous dira pas si votre mod\xE8le fonctionne bien (ou mal). Ceci est d\xFB au fait que :"),no.forEach(s),ys=c(e),ve=r(e,"OL",{});var ao=l(ve);L=r(ao,"LI",{});var Q=l(L);bn=n(Q,"nous n\u2019avons pas dit au "),zt=r(Q,"CODE",{});var Zr=l(zt);gn=n(Zr,"Trainer"),Zr.forEach(s),Cn=n(Q," d\u2019\xE9valuer pendant l\u2019entra\xEEnement en r\xE9glant "),Tt=r(Q,"CODE",{});var el=l(Tt);kn=n(el,"evaluation_strategy"),el.forEach(s),jn=n(Q," \xE0 soit "),wt=r(Q,"CODE",{});var tl=l(wt);zn=n(tl,'"steps"'),tl.forEach(s),Tn=n(Q," (\xE9valuer chaque "),Pt=r(Q,"CODE",{});var sl=l(Pt);wn=n(sl,"eval_steps"),sl.forEach(s),Pn=n(Q,") ou "),Dt=r(Q,"CODE",{});var ol=l(Dt);Dn=n(ol,'"epoch"'),ol.forEach(s),xn=n(Q," (\xE9valuer \xE0 la fin de chaque epoch)."),Q.forEach(s),On=c(ao),le=r(ao,"LI",{});var Ke=l(le);yn=n(Ke,"nous n\u2019avons pas fourni au "),xt=r(Ke,"CODE",{});var nl=l(xt);An=n(nl,"Trainer"),nl.forEach(s),Ln=n(Ke," une fonction "),Ot=r(Ke,"CODE",{});var al=l(Ot);Sn=n(al,"compute_metrics()"),al.forEach(s),Mn=n(Ke," pour calculer une m\xE9trique pendant ladite \xE9valuation (sinon l\u2019\xE9valuation aurait juste affich\xE9 la perte, qui n\u2019est pas un nombre tr\xE8s intuitif)."),Ke.forEach(s),ao.forEach(s),As=c(e),ie=r(e,"H3",{class:!0});var ro=l(ie);he=r(ro,"A",{id:!0,class:!0,href:!0});var rl=l(he);yt=r(rl,"SPAN",{});var ll=l(yt);E(xe.$$.fragment,ll),ll.forEach(s),rl.forEach(s),Un=c(ro),At=r(ro,"SPAN",{});var il=l(At);Nn=n(il,"Evaluation"),il.forEach(s),ro.forEach(s),Ls=c(e),z=r(e,"P",{});var I=l(z);Fn=n(I,"Voyons comment nous pouvons construire une fonction "),Lt=r(I,"CODE",{});var ul=l(Lt);In=n(ul,"compute_metrics()"),ul.forEach(s),Gn=n(I," utile et l\u2019utiliser la prochaine fois que nous entra\xEEnons. La fonction doit prendre un objet "),St=r(I,"CODE",{});var dl=l(St);Rn=n(dl,"EvalPrediction"),dl.forEach(s),Bn=n(I," (qui est un "),Mt=r(I,"EM",{});var cl=l(Mt);Vn=n(cl,"tuple"),cl.forEach(s),Wn=n(I," nomm\xE9 avec un champ "),Ut=r(I,"CODE",{});var pl=l(Ut);Hn=n(pl,"predictions"),pl.forEach(s),Yn=n(I," et un champ "),Nt=r(I,"CODE",{});var ml=l(Nt);Jn=n(ml,"label_ids"),ml.forEach(s),Xn=n(I,") et retournera un dictionnaire de cha\xEEnes de caract\xE8res vers des flottants (les cha\xEEnes de caract\xE8res \xE9tant les noms des m\xE9triques retourn\xE9es, et les flottants leurs valeurs). Pour obtenir des pr\xE9dictions de notre mod\xE8le, nous pouvons utiliser la commande "),Ft=r(I,"CODE",{});var fl=l(Ft);Kn=n(fl,"Trainer.predict()"),fl.forEach(s),Qn=n(I," :"),I.forEach(s),Ss=c(e),E(Oe.$$.fragment,e),Ms=c(e),E(ye.$$.fragment,e),Us=c(e),m=r(e,"P",{});var k=l(m);Zn=n(k,"La sortie de la m\xE9thode "),It=r(k,"CODE",{});var vl=l(It);ea=n(vl,"predict()"),vl.forEach(s),ta=n(k," est un autre "),Gt=r(k,"EM",{});var hl=l(Gt);sa=n(hl,"tuple"),hl.forEach(s),oa=n(k," nomm\xE9 avec trois champs : "),Rt=r(k,"CODE",{});var _l=l(Rt);na=n(_l,"predictions"),_l.forEach(s),aa=n(k,", "),Bt=r(k,"CODE",{});var El=l(Bt);ra=n(El,"label_ids"),El.forEach(s),la=n(k,", et "),Vt=r(k,"CODE",{});var ql=l(Vt);ia=n(ql,"metrics"),ql.forEach(s),ua=n(k,". Le champ "),Wt=r(k,"CODE",{});var $l=l(Wt);da=n($l,"metrics"),$l.forEach(s),ca=n(k," contiendra juste la perte sur le jeu de donn\xE9es pass\xE9, ainsi que quelques mesures de temps (combien de temps il a fallu pour pr\xE9dire, au total et en moyenne). Une fois que nous aurons compl\xE9t\xE9 notre fonction "),Ht=r(k,"CODE",{});var bl=l(Ht);pa=n(bl,"compute_metrics()"),bl.forEach(s),ma=n(k," et que nous l\u2019aurons pass\xE9 au "),Yt=r(k,"CODE",{});var gl=l(Yt);fa=n(gl,"Trainer"),gl.forEach(s),va=n(k,", ce champ contiendra \xE9galement les m\xE9triques retourn\xE9es par "),Jt=r(k,"CODE",{});var Cl=l(Jt);ha=n(Cl,"compute_metrics()"),Cl.forEach(s),_a=n(k,"."),k.forEach(s),Ns=c(e),N=r(e,"P",{});var ae=l(N);Ea=n(ae,"Comme vous pouvez le voir, "),Xt=r(ae,"CODE",{});var kl=l(Xt);qa=n(kl,"predictions"),kl.forEach(s),$a=n(ae," est un tableau bidimensionnel de forme 408 x 2 (408 \xE9tant le nombre d\u2019\xE9l\xE9ments dans le jeu de donn\xE9es que nous avons utilis\xE9). Ce sont les logits pour chaque \xE9l\xE9ment du jeu de donn\xE9es que nous avons pass\xE9 \xE0 "),Kt=r(ae,"CODE",{});var jl=l(Kt);ba=n(jl,"predict()"),jl.forEach(s),ga=n(ae," (comme vous l\u2019avez vu dans le "),He=r(ae,"A",{href:!0});var zl=l(He);Ca=n(zl,"chapitre pr\xE9c\xE9dent"),zl.forEach(s),ka=n(ae,", tous les "),Qt=r(ae,"EM",{});var Tl=l(Qt);ja=n(Tl,"transformers"),Tl.forEach(s),za=n(ae," retournent des logits). Pour les transformer en pr\xE9dictions que nous pouvons comparer \xE0 nos \xE9tiquettes, nous devons prendre l\u2019indice avec la valeur maximale sur le second axe :"),ae.forEach(s),Fs=c(e),E(Ae.$$.fragment,e),Is=c(e),O=r(e,"P",{});var Z=l(O);Ta=n(Z,"Nous pouvons maintenant comparer ces "),Zt=r(Z,"CODE",{});var wl=l(Zt);wa=n(wl,"preds"),wl.forEach(s),Pa=n(Z," aux \xE9tiquettes. Pour construire notre fonction "),es=r(Z,"CODE",{});var Pl=l(es);Da=n(Pl,"compute_metric()"),Pl.forEach(s),xa=n(Z,", nous allons nous appuyer sur les m\xE9triques de la biblioth\xE8que \u{1F917} "),ts=r(Z,"EM",{});var Dl=l(ts);Oa=n(Dl,"Datasets"),Dl.forEach(s),ya=n(Z,". Nous pouvons charger les m\xE9triques associ\xE9es au jeu de donn\xE9es MRPC aussi facilement que nous avons charg\xE9 le jeu de donn\xE9es, cette fois avec la fonction "),ss=r(Z,"CODE",{});var xl=l(ss);Aa=n(xl,"load_metric()"),xl.forEach(s),La=n(Z,". L\u2019objet retourn\xE9 poss\xE8de une m\xE9thode "),os=r(Z,"CODE",{});var Ol=l(os);Sa=n(Ol,"compute()"),Ol.forEach(s),Ma=n(Z," que nous pouvons utiliser pour effectuer le calcul de la m\xE9trique :"),Z.forEach(s),Gs=c(e),E(Le.$$.fragment,e),Rs=c(e),E(Se.$$.fragment,e),Bs=c(e),W=r(e,"P",{});var $e=l(W);Ua=n($e,"Les r\xE9sultats exacts que vous obtiendrez peuvent varier, car l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le peut modifier les m\xE9triques obtenues. Ici, nous pouvons voir que notre mod\xE8le a une pr\xE9cision de 85,78% sur l\u2019ensemble de validation et un score F1 de 89,97. Ce sont les deux m\xE9triques utilis\xE9es pour \xE9valuer les r\xE9sultats sur le jeu de donn\xE9es MRPC pour le benchmark GLUE. Le tableau du papier de "),Me=r($e,"A",{href:!0,rel:!0});var yl=l(Me);Na=n(yl,"BERT"),yl.forEach(s),Fa=n($e," indique un score F1 de 88,9 pour le mod\xE8le de base. Il s\u2019agissait du mod\xE8le "),ns=r($e,"CODE",{});var Al=l(ns);Ia=n(Al,"uncased"),Al.forEach(s),Ga=n($e," alors que nous utilisons actuellement le mod\xE8le "),as=r($e,"CODE",{});var Ll=l(as);Ra=n(Ll,"cased"),Ll.forEach(s),Ba=n($e,", ce qui explique le meilleur r\xE9sultat."),$e.forEach(s),Vs=c(e),_e=r(e,"P",{});var lo=l(_e);Va=n(lo,"En regroupant le tout, nous obtenons notre fonction "),rs=r(lo,"CODE",{});var Sl=l(rs);Wa=n(Sl,"compute_metrics()"),Sl.forEach(s),Ha=n(lo," :"),lo.forEach(s),Ws=c(e),E(Ue.$$.fragment,e),Hs=c(e),oe=r(e,"P",{});var Qe=l(oe);Ya=n(Qe,"Et pour le voir utilis\xE9 en action pour rapporter les m\xE9triques \xE0 la fin de chaque \xE9poque, voici comment nous d\xE9finissons un nouveau "),ls=r(Qe,"CODE",{});var Ml=l(ls);Ja=n(Ml,"Trainer"),Ml.forEach(s),Xa=n(Qe," avec cette fonction "),is=r(Qe,"CODE",{});var Ul=l(is);Ka=n(Ul,"compute_metrics()"),Ul.forEach(s),Qa=n(Qe," :"),Qe.forEach(s),Ys=c(e),E(Ne.$$.fragment,e),Js=c(e),H=r(e,"P",{});var be=l(H);Za=n(be,"Notez que nous cr\xE9ons un nouveau "),us=r(be,"CODE",{});var Nl=l(us);er=n(Nl,"TrainingArguments"),Nl.forEach(s),tr=n(be," avec sa "),ds=r(be,"CODE",{});var Fl=l(ds);sr=n(Fl,"evaluation_strategy"),Fl.forEach(s),or=n(be," d\xE9finie sur "),cs=r(be,"CODE",{});var Il=l(cs);nr=n(Il,'"epoch"'),Il.forEach(s),ar=n(be," et un nouveau mod\xE8le. Sinon, nous ne ferions que continuer l\u2019entra\xEEnement du mod\xE8le que nous avons d\xE9j\xE0 entra\xEEn\xE9. Pour lancer un nouveau cycle d\u2019entra\xEEnement, nous ex\xE9cutons :"),be.forEach(s),Xs=c(e),E(Fe.$$.fragment,e),Ks=c(e),Ye=r(e,"P",{});var Gl=l(Ye);rr=n(Gl,"Cette fois, il indiquera la perte et les mesures de validation \xE0 la fin de chaque \xE9poque, en plus de la perte d\u2019entra\xEEnement. Encore une fois, le score exact de pr\xE9cision/F1 que vous atteignez peut \xEAtre un peu diff\xE9rent de ce que nous avons trouv\xE9, en raison de l\u2019initialisation al\xE9atoire de la t\xEAte du mod\xE8le, mais il devrait \xEAtre dans la m\xEAme fourchette."),Gl.forEach(s),Qs=c(e),ne=r(e,"P",{});var Ze=l(ne);lr=n(Ze,"Le "),ps=r(Ze,"CODE",{});var Rl=l(ps);ir=n(Rl,"Trainer"),Rl.forEach(s),ur=n(Ze," fonctionnera sur plusieurs GPUs ou TPUs et fournit beaucoup d\u2019options, comme l\u2019entra\xEEnement en pr\xE9cision mixte (utilisez "),ms=r(Ze,"CODE",{});var Bl=l(ms);dr=n(Bl,"fp16 = True"),Bl.forEach(s),cr=n(Ze," dans vos arguments d\u2019entra\xEEnement). Nous passerons en revue tout ce qu\u2019il supporte dans le chapitre 10."),Ze.forEach(s),Zs=c(e),Y=r(e,"P",{});var ge=l(Y);pr=n(ge,"Ceci conclut l\u2019introduction au "),fs=r(ge,"EM",{});var Vl=l(fs);mr=n(Vl,"fine-tuning"),Vl.forEach(s),fr=n(ge," en utilisant l\u2019API "),vs=r(ge,"CODE",{});var Wl=l(vs);vr=n(Wl,"Trainer"),Wl.forEach(s),hr=n(ge,". Un exemple d\u2019utilisation pour les t\xE2ches de NLP les plus communes es donn\xE9 dans le "),Je=r(ge,"A",{href:!0});var Hl=l(Je);_r=n(Hl,"Chapitre 7"),Hl.forEach(s),Er=n(ge,", mais pour l\u2019instant regardons comment faire la m\xEAme chose en PyTorch pur."),ge.forEach(s),eo=c(e),E(Ee.$$.fragment,e),this.h()},h(){v(p,"name","hf:doc:metadata"),v(p,"content",JSON.stringify(ri)),v(C,"id","finetuner-un-modle-avec-lapi-trainer"),v(C,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(C,"href","#finetuner-un-modle-avec-lapi-trainer"),v(T,"class","relative group"),v(ke,"href","https://colab.research.google.com/"),v(ke,"rel","nofollow"),v(ce,"id","entranement"),v(ce,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(ce,"href","#entranement"),v(re,"class","relative group"),v(Ve,"href","/course/fr/chapter2"),v(We,"href","/course/fr/chapter2"),v(he,"id","evaluation"),v(he,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),v(he,"href","#evaluation"),v(ie,"class","relative group"),v(He,"href","/course/fr/chapter2"),v(Me,"href","https://arxiv.org/pdf/1810.04805.pdf"),v(Me,"rel","nofollow"),v(Je,"href","/course/fr/chapter7")},m(e,i){t(document.head,p),u(e,S,i),q(f,e,i),u(e,M,i),u(e,T,i),t(T,C),t(C,G),q(y,G,null),t(T,A),t(T,j),t(j,te),u(e,U,i),q(ee,e,i),u(e,ue,i),q(R,e,i),u(e,w,i),u(e,h,i),t(h,Ge),t(h,de),t(de,Re),t(h,io),t(h,et),t(et,uo),t(h,co),t(h,tt),t(tt,po),t(h,mo),t(h,st),t(st,fo),t(h,vo),t(h,ot),t(ot,ho),t(h,_o),t(h,ke),t(ke,Eo),t(h,qo),u(e,Es,i),u(e,Be,i),t(Be,$o),u(e,qs,i),q(je,e,i),u(e,$s,i),u(e,re,i),t(re,ce),t(ce,nt),q(ze,nt,null),t(re,bo),t(re,at),t(at,go),u(e,bs,i),u(e,P,i),t(P,Co),t(P,rt),t(rt,ko),t(P,jo),t(P,lt),t(lt,zo),t(P,To),t(P,it),t(it,wo),t(P,Po),t(P,ut),t(ut,Do),t(P,xo),t(P,dt),t(dt,Oo),t(P,yo),u(e,gs,i),q(Te,e,i),u(e,Cs,i),q(pe,e,i),u(e,ks,i),u(e,se,i),t(se,Ao),t(se,Ve),t(Ve,Lo),t(se,So),t(se,ct),t(ct,Mo),t(se,Uo),u(e,js,i),q(we,e,i),u(e,zs,i),u(e,me,i),t(me,No),t(me,We),t(We,Fo),t(me,Io),u(e,Ts,i),u(e,D,i),t(D,Go),t(D,pt),t(pt,Ro),t(D,Bo),t(D,mt),t(mt,Vo),t(D,Wo),t(D,ft),t(ft,Ho),t(D,Yo),t(D,vt),t(vt,Jo),t(D,Xo),t(D,ht),t(ht,Ko),t(D,Qo),u(e,ws,i),q(Pe,e,i),u(e,Ps,i),u(e,x,i),t(x,Zo),t(x,_t),t(_t,en),t(x,tn),t(x,Et),t(Et,sn),t(x,on),t(x,qt),t(qt,nn),t(x,an),t(x,$t),t($t,rn),t(x,ln),t(x,bt),t(bt,un),t(x,dn),u(e,Ds,i),u(e,V,i),t(V,cn),t(V,gt),t(gt,pn),t(V,mn),t(V,Ct),t(Ct,fn),t(V,vn),t(V,kt),t(kt,hn),t(V,_n),u(e,xs,i),q(De,e,i),u(e,Os,i),u(e,fe,i),t(fe,En),t(fe,jt),t(jt,qn),t(fe,$n),u(e,ys,i),u(e,ve,i),t(ve,L),t(L,bn),t(L,zt),t(zt,gn),t(L,Cn),t(L,Tt),t(Tt,kn),t(L,jn),t(L,wt),t(wt,zn),t(L,Tn),t(L,Pt),t(Pt,wn),t(L,Pn),t(L,Dt),t(Dt,Dn),t(L,xn),t(ve,On),t(ve,le),t(le,yn),t(le,xt),t(xt,An),t(le,Ln),t(le,Ot),t(Ot,Sn),t(le,Mn),u(e,As,i),u(e,ie,i),t(ie,he),t(he,yt),q(xe,yt,null),t(ie,Un),t(ie,At),t(At,Nn),u(e,Ls,i),u(e,z,i),t(z,Fn),t(z,Lt),t(Lt,In),t(z,Gn),t(z,St),t(St,Rn),t(z,Bn),t(z,Mt),t(Mt,Vn),t(z,Wn),t(z,Ut),t(Ut,Hn),t(z,Yn),t(z,Nt),t(Nt,Jn),t(z,Xn),t(z,Ft),t(Ft,Kn),t(z,Qn),u(e,Ss,i),q(Oe,e,i),u(e,Ms,i),q(ye,e,i),u(e,Us,i),u(e,m,i),t(m,Zn),t(m,It),t(It,ea),t(m,ta),t(m,Gt),t(Gt,sa),t(m,oa),t(m,Rt),t(Rt,na),t(m,aa),t(m,Bt),t(Bt,ra),t(m,la),t(m,Vt),t(Vt,ia),t(m,ua),t(m,Wt),t(Wt,da),t(m,ca),t(m,Ht),t(Ht,pa),t(m,ma),t(m,Yt),t(Yt,fa),t(m,va),t(m,Jt),t(Jt,ha),t(m,_a),u(e,Ns,i),u(e,N,i),t(N,Ea),t(N,Xt),t(Xt,qa),t(N,$a),t(N,Kt),t(Kt,ba),t(N,ga),t(N,He),t(He,Ca),t(N,ka),t(N,Qt),t(Qt,ja),t(N,za),u(e,Fs,i),q(Ae,e,i),u(e,Is,i),u(e,O,i),t(O,Ta),t(O,Zt),t(Zt,wa),t(O,Pa),t(O,es),t(es,Da),t(O,xa),t(O,ts),t(ts,Oa),t(O,ya),t(O,ss),t(ss,Aa),t(O,La),t(O,os),t(os,Sa),t(O,Ma),u(e,Gs,i),q(Le,e,i),u(e,Rs,i),q(Se,e,i),u(e,Bs,i),u(e,W,i),t(W,Ua),t(W,Me),t(Me,Na),t(W,Fa),t(W,ns),t(ns,Ia),t(W,Ga),t(W,as),t(as,Ra),t(W,Ba),u(e,Vs,i),u(e,_e,i),t(_e,Va),t(_e,rs),t(rs,Wa),t(_e,Ha),u(e,Ws,i),q(Ue,e,i),u(e,Hs,i),u(e,oe,i),t(oe,Ya),t(oe,ls),t(ls,Ja),t(oe,Xa),t(oe,is),t(is,Ka),t(oe,Qa),u(e,Ys,i),q(Ne,e,i),u(e,Js,i),u(e,H,i),t(H,Za),t(H,us),t(us,er),t(H,tr),t(H,ds),t(ds,sr),t(H,or),t(H,cs),t(cs,nr),t(H,ar),u(e,Xs,i),q(Fe,e,i),u(e,Ks,i),u(e,Ye,i),t(Ye,rr),u(e,Qs,i),u(e,ne,i),t(ne,lr),t(ne,ps),t(ps,ir),t(ne,ur),t(ne,ms),t(ms,dr),t(ne,cr),u(e,Zs,i),u(e,Y,i),t(Y,pr),t(Y,fs),t(fs,mr),t(Y,fr),t(Y,vs),t(vs,vr),t(Y,hr),t(Y,Je),t(Je,_r),t(Y,Er),u(e,eo,i),q(Ee,e,i),to=!0},p(e,[i]){const Ie={};i&1&&(Ie.fw=e[0]),f.$set(Ie);const hs={};i&2&&(hs.$$scope={dirty:i,ctx:e}),pe.$set(hs);const _s={};i&2&&(_s.$$scope={dirty:i,ctx:e}),Ee.$set(_s)},i(e){to||($(f.$$.fragment,e),$(y.$$.fragment,e),$(ee.$$.fragment,e),$(R.$$.fragment,e),$(je.$$.fragment,e),$(ze.$$.fragment,e),$(Te.$$.fragment,e),$(pe.$$.fragment,e),$(we.$$.fragment,e),$(Pe.$$.fragment,e),$(De.$$.fragment,e),$(xe.$$.fragment,e),$(Oe.$$.fragment,e),$(ye.$$.fragment,e),$(Ae.$$.fragment,e),$(Le.$$.fragment,e),$(Se.$$.fragment,e),$(Ue.$$.fragment,e),$(Ne.$$.fragment,e),$(Fe.$$.fragment,e),$(Ee.$$.fragment,e),to=!0)},o(e){b(f.$$.fragment,e),b(y.$$.fragment,e),b(ee.$$.fragment,e),b(R.$$.fragment,e),b(je.$$.fragment,e),b(ze.$$.fragment,e),b(Te.$$.fragment,e),b(pe.$$.fragment,e),b(we.$$.fragment,e),b(Pe.$$.fragment,e),b(De.$$.fragment,e),b(xe.$$.fragment,e),b(Oe.$$.fragment,e),b(ye.$$.fragment,e),b(Ae.$$.fragment,e),b(Le.$$.fragment,e),b(Se.$$.fragment,e),b(Ue.$$.fragment,e),b(Ne.$$.fragment,e),b(Fe.$$.fragment,e),b(Ee.$$.fragment,e),to=!1},d(e){s(p),e&&s(S),g(f,e),e&&s(M),e&&s(T),g(y),e&&s(U),g(ee,e),e&&s(ue),g(R,e),e&&s(w),e&&s(h),e&&s(Es),e&&s(Be),e&&s(qs),g(je,e),e&&s($s),e&&s(re),g(ze),e&&s(bs),e&&s(P),e&&s(gs),g(Te,e),e&&s(Cs),g(pe,e),e&&s(ks),e&&s(se),e&&s(js),g(we,e),e&&s(zs),e&&s(me),e&&s(Ts),e&&s(D),e&&s(ws),g(Pe,e),e&&s(Ps),e&&s(x),e&&s(Ds),e&&s(V),e&&s(xs),g(De,e),e&&s(Os),e&&s(fe),e&&s(ys),e&&s(ve),e&&s(As),e&&s(ie),g(xe),e&&s(Ls),e&&s(z),e&&s(Ss),g(Oe,e),e&&s(Ms),g(ye,e),e&&s(Us),e&&s(m),e&&s(Ns),e&&s(N),e&&s(Fs),g(Ae,e),e&&s(Is),e&&s(O),e&&s(Gs),g(Le,e),e&&s(Rs),g(Se,e),e&&s(Bs),e&&s(W),e&&s(Vs),e&&s(_e),e&&s(Ws),g(Ue,e),e&&s(Hs),e&&s(oe),e&&s(Ys),g(Ne,e),e&&s(Js),e&&s(H),e&&s(Xs),g(Fe,e),e&&s(Ks),e&&s(Ye),e&&s(Qs),e&&s(ne),e&&s(Zs),e&&s(Y),e&&s(eo),g(Ee,e)}}}const ri={local:"finetuner-un-modle-avec-lapi-trainer",sections:[{local:"entranement",title:"Entra\xEEnement"},{local:"evaluation",title:"Evaluation"}],title:"*Finetuner* un mod\xE8le avec l'API Trainer"};function li(Ce,p,S){let f="pt";return Zl(()=>{const M=new URLSearchParams(window.location.search);S(0,f=M.get("fw")||"pt")}),[f]}class vi extends Jl{constructor(p){super();Xl(this,p,li,ai,Kl,{})}}export{vi as default,ri as metadata};
