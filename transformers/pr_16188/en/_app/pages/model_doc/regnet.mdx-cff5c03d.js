import{S as ka,i as Ca,s as Fa,e as a,k as c,w as v,t as n,M as Pa,c as s,d as o,m as p,a as r,x as b,h as i,b as l,F as t,g as h,y,q as $,o as N,B as R,v as Aa}from"../../chunks/vendor-6b77c823.js";import{T as ja}from"../../chunks/Tip-39098574.js";import{D as et}from"../../chunks/Docstring-abef54e3.js";import{C as Ho}from"../../chunks/CodeBlock-3a8b25a8.js";import{I as tt}from"../../chunks/IconCopyLink-7a11ce68.js";function Ma(be){let g,k,f,_,T;return{c(){g=a("p"),k=n("Although the recipe for forward pass needs to be defined within this function, one should call the "),f=a("code"),_=n("Module"),T=n(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(m){g=s(m,"P",{});var u=r(g);k=i(u,"Although the recipe for forward pass needs to be defined within this function, one should call the "),f=s(u,"CODE",{});var C=r(f);_=i(C,"Module"),C.forEach(o),T=i(u,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),u.forEach(o)},m(m,u){h(m,g,u),t(g,k),t(g,f),t(f,_),t(g,T)},d(m){m&&o(g)}}}function Ia(be){let g,k,f,_,T;return{c(){g=a("p"),k=n("Although the recipe for forward pass needs to be defined within this function, one should call the "),f=a("code"),_=n("Module"),T=n(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(m){g=s(m,"P",{});var u=r(g);k=i(u,"Although the recipe for forward pass needs to be defined within this function, one should call the "),f=s(u,"CODE",{});var C=r(f);_=i(C,"Module"),C.forEach(o),T=i(u,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),u.forEach(o)},m(m,u){h(m,g,u),t(g,k),t(g,f),t(f,_),t(g,T)},d(m){m&&o(g)}}}function qa(be){let g,k,f,_,T,m,u,C,Et,ot,q,W,De,Y,xt,Se,Tt,at,V,jt,Z,kt,Ct,st,ye,Ft,rt,$e,Pt,nt,Ne,Oe,At,it,Re,Mt,lt,Ee,ee,It,xe,qt,zt,dt,P,Dt,te,St,Ot,oe,Lt,Ut,ct,z,G,Le,ae,Ht,Ue,Wt,pt,w,se,Vt,D,Gt,Te,Kt,Bt,re,Jt,Qt,Xt,S,Yt,je,Zt,eo,ke,to,oo,ao,He,so,ro,ne,ht,O,K,We,ie,no,Ve,io,gt,F,le,lo,de,co,ce,po,ho,go,E,pe,fo,L,mo,Ce,uo,_o,Ge,wo,vo,bo,B,yo,Ke,$o,No,he,ft,U,J,Be,ge,Ro,Je,Eo,mt,j,fe,xo,Qe,To,jo,me,ko,ue,Co,Fo,Po,x,_e,Ao,H,Mo,Fe,Io,qo,Xe,zo,Do,So,Q,Oo,Ye,Lo,Uo,we,ut;return m=new tt({}),Y=new tt({}),ae=new tt({}),se=new et({props:{name:"class transformers.RegNetConfig",anchor:"transformers.RegNetConfig",parameters:[{name:"num_channels",val:" = 3"},{name:"embedding_size",val:" = 32"},{name:"hidden_sizes",val:" = [128, 192, 512, 1088]"},{name:"depths",val:" = [2, 6, 12, 2]"},{name:"groups_width",val:" = 64"},{name:"layer_type",val:" = 'y'"},{name:"hidden_act",val:" = 'relu'"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16188/src/transformers/models/regnet/configuration_regnet.py#L28",parametersDescription:[{anchor:"transformers.RegNetConfig.num_channels",description:`<strong>num_channels</strong> (<code>int</code>, <em>optional</em>, defaults to 3) &#x2014;
The number of input channels.`,name:"num_channels"},{anchor:"transformers.RegNetConfig.embedding_size",description:`<strong>embedding_size</strong> (<code>int</code>, <em>optional</em>, defaults to 64) &#x2014;
Dimensionality (hidden size) for the embedding layer.`,name:"embedding_size"},{anchor:"transformers.RegNetConfig.hidden_sizes",description:`<strong>hidden_sizes</strong> (<code>List[int]</code>, <em>optional</em>, defaults to <code>[256, 512, 1024, 2048]</code>) &#x2014;
Dimensionality (hidden size) at each stage.`,name:"hidden_sizes"},{anchor:"transformers.RegNetConfig.depths",description:`<strong>depths</strong> (<code>List[int]</code>, <em>optional</em>, defaults to <code>[3, 4, 6, 3]</code>) &#x2014;
Depth (number of layers) for each stage.`,name:"depths"},{anchor:"transformers.RegNetConfig.layer_type",description:`<strong>layer_type</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;y&quot;</code>) &#x2014;
The layer to use, it can be either <code>&quot;x&quot; or </code>&#x201C;y&#x201D;<code>. An </code>x<code>layer is a ResNet&apos;s BottleNeck layer with</code>reduction<code>fixed to</code>1<code>. While a </code>y<code>layer is a</code>x\` but with squeeze and excitation. Please refer to the
paper for a detailed explanation of how these layers were constructed.`,name:"layer_type"},{anchor:"transformers.RegNetConfig.hidden_act",description:`<strong>hidden_act</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;relu&quot;</code>) &#x2014;
The non-linear activation function in each block. If string, <code>&quot;gelu&quot;</code>, <code>&quot;relu&quot;</code>, <code>&quot;selu&quot;</code> and <code>&quot;gelu_new&quot;</code>
are supported.`,name:"hidden_act"},{anchor:"transformers.RegNetConfig.downsample_in_first_stage",description:`<strong>downsample_in_first_stage</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>True</code>, the first stage will downsample the inputs using a <code>stride</code> of 2.`,name:"downsample_in_first_stage"}]}}),ne=new Ho({props:{code:`from transformers import RegNetConfig, RegNetModel

# Initializing a RegNet regnet-y-40 style configuration
configuration = RegNetConfig()
# Initializing a model from the regnet-y-40 style configuration
model = RegNetModel(configuration)
# Accessing the model configuration
configuration = model.config`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> RegNetConfig, RegNetModel

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a RegNet regnet-y-40 style configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = RegNetConfig()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a model from the regnet-y-40 style configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = RegNetModel(configuration)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Accessing the model configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = model.config`}}),ie=new tt({}),le=new et({props:{name:"class transformers.RegNetModel",anchor:"transformers.RegNetModel",parameters:[{name:"config",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16188/src/transformers/models/regnet/modeling_regnet.py#L357",parametersDescription:[{anchor:"transformers.RegNetModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16188/en/model_doc/regnet#transformers.RegNetConfig">RegNetConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16188/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),pe=new et({props:{name:"forward",anchor:"transformers.RegNetModel.forward",parameters:[{name:"pixel_values",val:": Tensor"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16188/src/transformers/models/regnet/modeling_regnet.py#L367",parametersDescription:[{anchor:"transformers.RegNetModel.forward.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Pixel values can be obtained using <a href="/docs/transformers/pr_16188/en/model_doc/auto#transformers.AutoFeatureExtractor">AutoFeatureExtractor</a>. See
<code>AutoFeatureExtractor.__call__()</code>for details.`,name:"pixel_values"},{anchor:"transformers.RegNetModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.RegNetModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16188/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],returnDescription:`
<p>A <code>transformers.models.regnet.modeling_regnet.RegNetModelOutput</code>or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16188/en/model_doc/regnet#transformers.RegNetConfig"
>RegNetConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>pooler_output</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.hidden_sizes[-1])</code>) \u2014 The pooled last hidden state.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, num_channels, height, width)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
</ul>
`,returnType:`
<p><code>transformers.models.regnet.modeling_regnet.RegNetModelOutput</code>or <code>tuple(torch.FloatTensor)</code></p>
`}}),B=new ja({props:{$$slots:{default:[Ma]},$$scope:{ctx:be}}}),he=new Ho({props:{code:`from transformers import AutoFeatureExtractor, RegNetModel
import torch
from datasets import load_dataset

dataset = load_dataset("huggingface/cats-image")
image = dataset["test"]["image"][0]

feature_extractor = AutoFeatureExtractor.from_pretrained("zuppif/regnety-040")
model = RegNetModel.from_pretrained("zuppif/regnety-040")

inputs = feature_extractor(image, return_tensors="pt")

with torch.no_grad():
    outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state
list(last_hidden_states.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoFeatureExtractor, RegNetModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;huggingface/cats-image&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>image = dataset[<span class="hljs-string">&quot;test&quot;</span>][<span class="hljs-string">&quot;image&quot;</span>][<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = AutoFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;zuppif/regnety-040&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = RegNetModel.from_pretrained(<span class="hljs-string">&quot;zuppif/regnety-040&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = feature_extractor(image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(last_hidden_states.shape)
[<span class="hljs-number">1</span>, <span class="hljs-number">1088</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>]`}}),ge=new tt({}),fe=new et({props:{name:"class transformers.RegNetForImageClassification",anchor:"transformers.RegNetForImageClassification",parameters:[{name:"config",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16188/src/transformers/models/regnet/modeling_regnet.py#L412",parametersDescription:[{anchor:"transformers.RegNetForImageClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16188/en/model_doc/regnet#transformers.RegNetConfig">RegNetConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16188/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),_e=new et({props:{name:"forward",anchor:"transformers.RegNetForImageClassification.forward",parameters:[{name:"pixel_values",val:": Tensor = None"},{name:"labels",val:": Tensor = None"},{name:"output_hidden_states",val:": bool = None"},{name:"return_dict",val:": bool = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16188/src/transformers/models/regnet/modeling_regnet.py#L425",parametersDescription:[{anchor:"transformers.RegNetForImageClassification.forward.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Pixel values can be obtained using <a href="/docs/transformers/pr_16188/en/model_doc/auto#transformers.AutoFeatureExtractor">AutoFeatureExtractor</a>. See
<code>AutoFeatureExtractor.__call__()</code>for details.`,name:"pixel_values"},{anchor:"transformers.RegNetForImageClassification.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.RegNetForImageClassification.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16188/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.RegNetForImageClassification.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the image classification/regression loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>. If <code>config.num_labels &gt; 1</code> a classification loss is computed (Cross-Entropy).`,name:"labels"}],returnDescription:`
<p>A <code>transformers.modeling_outputs.ImageClassifierOutput</code>or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16188/en/model_doc/regnet#transformers.RegNetConfig"
>RegNetConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification (or regression if config.num_labels==1) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.num_labels)</code>) \u2014 Classification (or regression if config.num_labels==1) scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the model at
the output of each stage.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, patch_size, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><code>transformers.modeling_outputs.ImageClassifierOutput</code>or <code>tuple(torch.FloatTensor)</code></p>
`}}),Q=new ja({props:{$$slots:{default:[Ia]},$$scope:{ctx:be}}}),we=new Ho({props:{code:`from transformers import AutoFeatureExtractor, RegNetForImageClassification
import torch
from datasets import load_dataset

dataset = load_dataset("huggingface/cats-image")
image = dataset["test"]["image"][0]

feature_extractor = AutoFeatureExtractor.from_pretrained("zuppif/regnety-040")
model = RegNetForImageClassification.from_pretrained("zuppif/regnety-040")

inputs = feature_extractor(image, return_tensors="pt")

with torch.no_grad():
    logits = model(**inputs).logits

# model predicts one of the 1000 ImageNet classes
predicted_label = logits.argmax(-1).item()
print(model.config.id2label[predicted_label])`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoFeatureExtractor, RegNetForImageClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;huggingface/cats-image&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>image = dataset[<span class="hljs-string">&quot;test&quot;</span>][<span class="hljs-string">&quot;image&quot;</span>][<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = AutoFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;zuppif/regnety-040&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = RegNetForImageClassification.from_pretrained(<span class="hljs-string">&quot;zuppif/regnety-040&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = feature_extractor(image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># model predicts one of the 1000 ImageNet classes</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_label = logits.argmax(-<span class="hljs-number">1</span>).item()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(model.config.id2label[predicted_label])
<span class="hljs-string">&#x27;tabby, tabby cat&#x27;</span>`}}),{c(){g=a("meta"),k=c(),f=a("h1"),_=a("a"),T=a("span"),v(m.$$.fragment),u=c(),C=a("span"),Et=n("RegNet"),ot=c(),q=a("h2"),W=a("a"),De=a("span"),v(Y.$$.fragment),xt=c(),Se=a("span"),Tt=n("Overview"),at=c(),V=a("p"),jt=n("The RegNet model was proposed in "),Z=a("a"),kt=n("Designing Network Design Spaces"),Ct=n(" by Ilija Radosavovic, Raj Prateek Kosaraju, Ross Girshick, Kaiming He, Piotr Doll\xE1r."),st=c(),ye=a("p"),Ft=n("The authors design search spaces to perform Neural Architecture Search (NAS). They first start from a high dimensional search space and iteratively reduce the search space by empirically applying constraints based on the best-performing models sampled by the current search space."),rt=c(),$e=a("p"),Pt=n("The abstract from the paper is the following:"),nt=c(),Ne=a("p"),Oe=a("em"),At=n("In this work, we present a new network design paradigm. Our goal is to help advance the understanding of network design and discover design principles that generalize across settings. Instead of focusing on designing individual network instances, we design network design spaces that parametrize populations of networks. The overall process is analogous to classic manual design of networks, but elevated to the design space level. Using our methodology we explore the structure aspect of network design and arrive at a low-dimensional design space consisting of simple, regular networks that we call RegNet. The core insight of the RegNet parametrization is surprisingly simple: widths and depths of good networks can be explained by a quantized linear function. We analyze the RegNet design space and arrive at interesting findings that do not match the current practice of network design. The RegNet design space provides simple and fast networks that work well across a wide range of flop regimes. Under comparable training settings and flops, the RegNet models outperform the popular EfficientNet models while being up to 5x faster on GPUs."),it=c(),Re=a("p"),Mt=n("Tips:"),lt=c(),Ee=a("ul"),ee=a("li"),It=n("One can use "),xe=a("a"),qt=n("AutoFeatureExtractor"),zt=n(" to prepare images for the model."),dt=c(),P=a("p"),Dt=n("This model was contributed by "),te=a("a"),St=n("Francesco"),Ot=n(`.
The original code can be found `),oe=a("a"),Lt=n("here"),Ut=n("."),ct=c(),z=a("h2"),G=a("a"),Le=a("span"),v(ae.$$.fragment),Ht=c(),Ue=a("span"),Wt=n("RegNetConfig"),pt=c(),w=a("div"),v(se.$$.fragment),Vt=c(),D=a("p"),Gt=n("This is the configuration class to store the configuration of a "),Te=a("a"),Kt=n("RegNetModel"),Bt=n(`. It is used to instantiate an
RegNet model according to the specified arguments, defining the model architecture. Instantiating a configuration
with the defaults will yield a similar configuration to that of the
`),re=a("a"),Jt=n("regnety-40"),Qt=n(" architecture."),Xt=c(),S=a("p"),Yt=n("Configuration objects inherit from "),je=a("a"),Zt=n("PretrainedConfig"),eo=n(` and can be used to control the model outputs. Read the
documentation from `),ke=a("a"),to=n("PretrainedConfig"),oo=n(" for more information."),ao=c(),He=a("p"),so=n("Example:"),ro=c(),v(ne.$$.fragment),ht=c(),O=a("h2"),K=a("a"),We=a("span"),v(ie.$$.fragment),no=c(),Ve=a("span"),io=n("RegNetModel"),gt=c(),F=a("div"),v(le.$$.fragment),lo=c(),de=a("p"),co=n(`The bare RegNet model outputting raw features without any specific head on top.
This model is a PyTorch `),ce=a("a"),po=n("torch.nn.Module"),ho=n(` subclass. Use it
as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),go=c(),E=a("div"),v(pe.$$.fragment),fo=c(),L=a("p"),mo=n("The "),Ce=a("a"),uo=n("RegNetModel"),_o=n(" forward method, overrides the "),Ge=a("code"),wo=n("__call__"),vo=n(" special method."),bo=c(),v(B.$$.fragment),yo=c(),Ke=a("p"),$o=n("Example:"),No=c(),v(he.$$.fragment),ft=c(),U=a("h2"),J=a("a"),Be=a("span"),v(ge.$$.fragment),Ro=c(),Je=a("span"),Eo=n("RegNetForImageClassification"),mt=c(),j=a("div"),v(fe.$$.fragment),xo=c(),Qe=a("p"),To=n(`RegNet Model with an image classification head on top (a linear layer on top of the pooled features), e.g. for
ImageNet.`),jo=c(),me=a("p"),ko=n("This model is a PyTorch "),ue=a("a"),Co=n("torch.nn.Module"),Fo=n(` subclass. Use it
as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),Po=c(),x=a("div"),v(_e.$$.fragment),Ao=c(),H=a("p"),Mo=n("The "),Fe=a("a"),Io=n("RegNetForImageClassification"),qo=n(" forward method, overrides the "),Xe=a("code"),zo=n("__call__"),Do=n(" special method."),So=c(),v(Q.$$.fragment),Oo=c(),Ye=a("p"),Lo=n("Example:"),Uo=c(),v(we.$$.fragment),this.h()},l(e){const d=Pa('[data-svelte="svelte-1phssyn"]',document.head);g=s(d,"META",{name:!0,content:!0}),d.forEach(o),k=p(e),f=s(e,"H1",{class:!0});var ve=r(f);_=s(ve,"A",{id:!0,class:!0,href:!0});var Ze=r(_);T=s(Ze,"SPAN",{});var Wo=r(T);b(m.$$.fragment,Wo),Wo.forEach(o),Ze.forEach(o),u=p(ve),C=s(ve,"SPAN",{});var Vo=r(C);Et=i(Vo,"RegNet"),Vo.forEach(o),ve.forEach(o),ot=p(e),q=s(e,"H2",{class:!0});var _t=r(q);W=s(_t,"A",{id:!0,class:!0,href:!0});var Go=r(W);De=s(Go,"SPAN",{});var Ko=r(De);b(Y.$$.fragment,Ko),Ko.forEach(o),Go.forEach(o),xt=p(_t),Se=s(_t,"SPAN",{});var Bo=r(Se);Tt=i(Bo,"Overview"),Bo.forEach(o),_t.forEach(o),at=p(e),V=s(e,"P",{});var wt=r(V);jt=i(wt,"The RegNet model was proposed in "),Z=s(wt,"A",{href:!0,rel:!0});var Jo=r(Z);kt=i(Jo,"Designing Network Design Spaces"),Jo.forEach(o),Ct=i(wt," by Ilija Radosavovic, Raj Prateek Kosaraju, Ross Girshick, Kaiming He, Piotr Doll\xE1r."),wt.forEach(o),st=p(e),ye=s(e,"P",{});var Qo=r(ye);Ft=i(Qo,"The authors design search spaces to perform Neural Architecture Search (NAS). They first start from a high dimensional search space and iteratively reduce the search space by empirically applying constraints based on the best-performing models sampled by the current search space."),Qo.forEach(o),rt=p(e),$e=s(e,"P",{});var Xo=r($e);Pt=i(Xo,"The abstract from the paper is the following:"),Xo.forEach(o),nt=p(e),Ne=s(e,"P",{});var Yo=r(Ne);Oe=s(Yo,"EM",{});var Zo=r(Oe);At=i(Zo,"In this work, we present a new network design paradigm. Our goal is to help advance the understanding of network design and discover design principles that generalize across settings. Instead of focusing on designing individual network instances, we design network design spaces that parametrize populations of networks. The overall process is analogous to classic manual design of networks, but elevated to the design space level. Using our methodology we explore the structure aspect of network design and arrive at a low-dimensional design space consisting of simple, regular networks that we call RegNet. The core insight of the RegNet parametrization is surprisingly simple: widths and depths of good networks can be explained by a quantized linear function. We analyze the RegNet design space and arrive at interesting findings that do not match the current practice of network design. The RegNet design space provides simple and fast networks that work well across a wide range of flop regimes. Under comparable training settings and flops, the RegNet models outperform the popular EfficientNet models while being up to 5x faster on GPUs."),Zo.forEach(o),Yo.forEach(o),it=p(e),Re=s(e,"P",{});var ea=r(Re);Mt=i(ea,"Tips:"),ea.forEach(o),lt=p(e),Ee=s(e,"UL",{});var ta=r(Ee);ee=s(ta,"LI",{});var vt=r(ee);It=i(vt,"One can use "),xe=s(vt,"A",{href:!0});var oa=r(xe);qt=i(oa,"AutoFeatureExtractor"),oa.forEach(o),zt=i(vt," to prepare images for the model."),vt.forEach(o),ta.forEach(o),dt=p(e),P=s(e,"P",{});var Pe=r(P);Dt=i(Pe,"This model was contributed by "),te=s(Pe,"A",{href:!0,rel:!0});var aa=r(te);St=i(aa,"Francesco"),aa.forEach(o),Ot=i(Pe,`.
The original code can be found `),oe=s(Pe,"A",{href:!0,rel:!0});var sa=r(oe);Lt=i(sa,"here"),sa.forEach(o),Ut=i(Pe,"."),Pe.forEach(o),ct=p(e),z=s(e,"H2",{class:!0});var bt=r(z);G=s(bt,"A",{id:!0,class:!0,href:!0});var ra=r(G);Le=s(ra,"SPAN",{});var na=r(Le);b(ae.$$.fragment,na),na.forEach(o),ra.forEach(o),Ht=p(bt),Ue=s(bt,"SPAN",{});var ia=r(Ue);Wt=i(ia,"RegNetConfig"),ia.forEach(o),bt.forEach(o),pt=p(e),w=s(e,"DIV",{class:!0});var A=r(w);b(se.$$.fragment,A),Vt=p(A),D=s(A,"P",{});var Ae=r(D);Gt=i(Ae,"This is the configuration class to store the configuration of a "),Te=s(Ae,"A",{href:!0});var la=r(Te);Kt=i(la,"RegNetModel"),la.forEach(o),Bt=i(Ae,`. It is used to instantiate an
RegNet model according to the specified arguments, defining the model architecture. Instantiating a configuration
with the defaults will yield a similar configuration to that of the
`),re=s(Ae,"A",{href:!0,rel:!0});var da=r(re);Jt=i(da,"regnety-40"),da.forEach(o),Qt=i(Ae," architecture."),Ae.forEach(o),Xt=p(A),S=s(A,"P",{});var Me=r(S);Yt=i(Me,"Configuration objects inherit from "),je=s(Me,"A",{href:!0});var ca=r(je);Zt=i(ca,"PretrainedConfig"),ca.forEach(o),eo=i(Me,` and can be used to control the model outputs. Read the
documentation from `),ke=s(Me,"A",{href:!0});var pa=r(ke);to=i(pa,"PretrainedConfig"),pa.forEach(o),oo=i(Me," for more information."),Me.forEach(o),ao=p(A),He=s(A,"P",{});var ha=r(He);so=i(ha,"Example:"),ha.forEach(o),ro=p(A),b(ne.$$.fragment,A),A.forEach(o),ht=p(e),O=s(e,"H2",{class:!0});var yt=r(O);K=s(yt,"A",{id:!0,class:!0,href:!0});var ga=r(K);We=s(ga,"SPAN",{});var fa=r(We);b(ie.$$.fragment,fa),fa.forEach(o),ga.forEach(o),no=p(yt),Ve=s(yt,"SPAN",{});var ma=r(Ve);io=i(ma,"RegNetModel"),ma.forEach(o),yt.forEach(o),gt=p(e),F=s(e,"DIV",{class:!0});var Ie=r(F);b(le.$$.fragment,Ie),lo=p(Ie),de=s(Ie,"P",{});var $t=r(de);co=i($t,`The bare RegNet model outputting raw features without any specific head on top.
This model is a PyTorch `),ce=s($t,"A",{href:!0,rel:!0});var ua=r(ce);po=i(ua,"torch.nn.Module"),ua.forEach(o),ho=i($t,` subclass. Use it
as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),$t.forEach(o),go=p(Ie),E=s(Ie,"DIV",{class:!0});var M=r(E);b(pe.$$.fragment,M),fo=p(M),L=s(M,"P",{});var qe=r(L);mo=i(qe,"The "),Ce=s(qe,"A",{href:!0});var _a=r(Ce);uo=i(_a,"RegNetModel"),_a.forEach(o),_o=i(qe," forward method, overrides the "),Ge=s(qe,"CODE",{});var wa=r(Ge);wo=i(wa,"__call__"),wa.forEach(o),vo=i(qe," special method."),qe.forEach(o),bo=p(M),b(B.$$.fragment,M),yo=p(M),Ke=s(M,"P",{});var va=r(Ke);$o=i(va,"Example:"),va.forEach(o),No=p(M),b(he.$$.fragment,M),M.forEach(o),Ie.forEach(o),ft=p(e),U=s(e,"H2",{class:!0});var Nt=r(U);J=s(Nt,"A",{id:!0,class:!0,href:!0});var ba=r(J);Be=s(ba,"SPAN",{});var ya=r(Be);b(ge.$$.fragment,ya),ya.forEach(o),ba.forEach(o),Ro=p(Nt),Je=s(Nt,"SPAN",{});var $a=r(Je);Eo=i($a,"RegNetForImageClassification"),$a.forEach(o),Nt.forEach(o),mt=p(e),j=s(e,"DIV",{class:!0});var X=r(j);b(fe.$$.fragment,X),xo=p(X),Qe=s(X,"P",{});var Na=r(Qe);To=i(Na,`RegNet Model with an image classification head on top (a linear layer on top of the pooled features), e.g. for
ImageNet.`),Na.forEach(o),jo=p(X),me=s(X,"P",{});var Rt=r(me);ko=i(Rt,"This model is a PyTorch "),ue=s(Rt,"A",{href:!0,rel:!0});var Ra=r(ue);Co=i(Ra,"torch.nn.Module"),Ra.forEach(o),Fo=i(Rt,` subclass. Use it
as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),Rt.forEach(o),Po=p(X),x=s(X,"DIV",{class:!0});var I=r(x);b(_e.$$.fragment,I),Ao=p(I),H=s(I,"P",{});var ze=r(H);Mo=i(ze,"The "),Fe=s(ze,"A",{href:!0});var Ea=r(Fe);Io=i(Ea,"RegNetForImageClassification"),Ea.forEach(o),qo=i(ze," forward method, overrides the "),Xe=s(ze,"CODE",{});var xa=r(Xe);zo=i(xa,"__call__"),xa.forEach(o),Do=i(ze," special method."),ze.forEach(o),So=p(I),b(Q.$$.fragment,I),Oo=p(I),Ye=s(I,"P",{});var Ta=r(Ye);Lo=i(Ta,"Example:"),Ta.forEach(o),Uo=p(I),b(we.$$.fragment,I),I.forEach(o),X.forEach(o),this.h()},h(){l(g,"name","hf:doc:metadata"),l(g,"content",JSON.stringify(za)),l(_,"id","regnet"),l(_,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(_,"href","#regnet"),l(f,"class","relative group"),l(W,"id","overview"),l(W,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(W,"href","#overview"),l(q,"class","relative group"),l(Z,"href","https://arxiv.org/abs/2003.13678"),l(Z,"rel","nofollow"),l(xe,"href","/docs/transformers/pr_16188/en/model_doc/auto#transformers.AutoFeatureExtractor"),l(te,"href","https://huggingface.co/Francesco"),l(te,"rel","nofollow"),l(oe,"href","https://github.com/facebookresearch/pycls"),l(oe,"rel","nofollow"),l(G,"id","transformers.RegNetConfig"),l(G,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(G,"href","#transformers.RegNetConfig"),l(z,"class","relative group"),l(Te,"href","/docs/transformers/pr_16188/en/model_doc/regnet#transformers.RegNetModel"),l(re,"href","https://huggingface.co/microsoft/regnety-40"),l(re,"rel","nofollow"),l(je,"href","/docs/transformers/pr_16188/en/main_classes/configuration#transformers.PretrainedConfig"),l(ke,"href","/docs/transformers/pr_16188/en/main_classes/configuration#transformers.PretrainedConfig"),l(w,"class","docstring"),l(K,"id","transformers.RegNetModel"),l(K,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(K,"href","#transformers.RegNetModel"),l(O,"class","relative group"),l(ce,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),l(ce,"rel","nofollow"),l(Ce,"href","/docs/transformers/pr_16188/en/model_doc/regnet#transformers.RegNetModel"),l(E,"class","docstring"),l(F,"class","docstring"),l(J,"id","transformers.RegNetForImageClassification"),l(J,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(J,"href","#transformers.RegNetForImageClassification"),l(U,"class","relative group"),l(ue,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),l(ue,"rel","nofollow"),l(Fe,"href","/docs/transformers/pr_16188/en/model_doc/regnet#transformers.RegNetForImageClassification"),l(x,"class","docstring"),l(j,"class","docstring")},m(e,d){t(document.head,g),h(e,k,d),h(e,f,d),t(f,_),t(_,T),y(m,T,null),t(f,u),t(f,C),t(C,Et),h(e,ot,d),h(e,q,d),t(q,W),t(W,De),y(Y,De,null),t(q,xt),t(q,Se),t(Se,Tt),h(e,at,d),h(e,V,d),t(V,jt),t(V,Z),t(Z,kt),t(V,Ct),h(e,st,d),h(e,ye,d),t(ye,Ft),h(e,rt,d),h(e,$e,d),t($e,Pt),h(e,nt,d),h(e,Ne,d),t(Ne,Oe),t(Oe,At),h(e,it,d),h(e,Re,d),t(Re,Mt),h(e,lt,d),h(e,Ee,d),t(Ee,ee),t(ee,It),t(ee,xe),t(xe,qt),t(ee,zt),h(e,dt,d),h(e,P,d),t(P,Dt),t(P,te),t(te,St),t(P,Ot),t(P,oe),t(oe,Lt),t(P,Ut),h(e,ct,d),h(e,z,d),t(z,G),t(G,Le),y(ae,Le,null),t(z,Ht),t(z,Ue),t(Ue,Wt),h(e,pt,d),h(e,w,d),y(se,w,null),t(w,Vt),t(w,D),t(D,Gt),t(D,Te),t(Te,Kt),t(D,Bt),t(D,re),t(re,Jt),t(D,Qt),t(w,Xt),t(w,S),t(S,Yt),t(S,je),t(je,Zt),t(S,eo),t(S,ke),t(ke,to),t(S,oo),t(w,ao),t(w,He),t(He,so),t(w,ro),y(ne,w,null),h(e,ht,d),h(e,O,d),t(O,K),t(K,We),y(ie,We,null),t(O,no),t(O,Ve),t(Ve,io),h(e,gt,d),h(e,F,d),y(le,F,null),t(F,lo),t(F,de),t(de,co),t(de,ce),t(ce,po),t(de,ho),t(F,go),t(F,E),y(pe,E,null),t(E,fo),t(E,L),t(L,mo),t(L,Ce),t(Ce,uo),t(L,_o),t(L,Ge),t(Ge,wo),t(L,vo),t(E,bo),y(B,E,null),t(E,yo),t(E,Ke),t(Ke,$o),t(E,No),y(he,E,null),h(e,ft,d),h(e,U,d),t(U,J),t(J,Be),y(ge,Be,null),t(U,Ro),t(U,Je),t(Je,Eo),h(e,mt,d),h(e,j,d),y(fe,j,null),t(j,xo),t(j,Qe),t(Qe,To),t(j,jo),t(j,me),t(me,ko),t(me,ue),t(ue,Co),t(me,Fo),t(j,Po),t(j,x),y(_e,x,null),t(x,Ao),t(x,H),t(H,Mo),t(H,Fe),t(Fe,Io),t(H,qo),t(H,Xe),t(Xe,zo),t(H,Do),t(x,So),y(Q,x,null),t(x,Oo),t(x,Ye),t(Ye,Lo),t(x,Uo),y(we,x,null),ut=!0},p(e,[d]){const ve={};d&2&&(ve.$$scope={dirty:d,ctx:e}),B.$set(ve);const Ze={};d&2&&(Ze.$$scope={dirty:d,ctx:e}),Q.$set(Ze)},i(e){ut||($(m.$$.fragment,e),$(Y.$$.fragment,e),$(ae.$$.fragment,e),$(se.$$.fragment,e),$(ne.$$.fragment,e),$(ie.$$.fragment,e),$(le.$$.fragment,e),$(pe.$$.fragment,e),$(B.$$.fragment,e),$(he.$$.fragment,e),$(ge.$$.fragment,e),$(fe.$$.fragment,e),$(_e.$$.fragment,e),$(Q.$$.fragment,e),$(we.$$.fragment,e),ut=!0)},o(e){N(m.$$.fragment,e),N(Y.$$.fragment,e),N(ae.$$.fragment,e),N(se.$$.fragment,e),N(ne.$$.fragment,e),N(ie.$$.fragment,e),N(le.$$.fragment,e),N(pe.$$.fragment,e),N(B.$$.fragment,e),N(he.$$.fragment,e),N(ge.$$.fragment,e),N(fe.$$.fragment,e),N(_e.$$.fragment,e),N(Q.$$.fragment,e),N(we.$$.fragment,e),ut=!1},d(e){o(g),e&&o(k),e&&o(f),R(m),e&&o(ot),e&&o(q),R(Y),e&&o(at),e&&o(V),e&&o(st),e&&o(ye),e&&o(rt),e&&o($e),e&&o(nt),e&&o(Ne),e&&o(it),e&&o(Re),e&&o(lt),e&&o(Ee),e&&o(dt),e&&o(P),e&&o(ct),e&&o(z),R(ae),e&&o(pt),e&&o(w),R(se),R(ne),e&&o(ht),e&&o(O),R(ie),e&&o(gt),e&&o(F),R(le),R(pe),R(B),R(he),e&&o(ft),e&&o(U),R(ge),e&&o(mt),e&&o(j),R(fe),R(_e),R(Q),R(we)}}}const za={local:"regnet",sections:[{local:"overview",title:"Overview"},{local:"transformers.RegNetConfig",title:"RegNetConfig"},{local:"transformers.RegNetModel",title:"RegNetModel"},{local:"transformers.RegNetForImageClassification",title:"RegNetForImageClassification"}],title:"RegNet"};function Da(be){return Aa(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Wa extends ka{constructor(g){super();Ca(this,g,Da,qa,Fa,{})}}export{Wa as default,za as metadata};
