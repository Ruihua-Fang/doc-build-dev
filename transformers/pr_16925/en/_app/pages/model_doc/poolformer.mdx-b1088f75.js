import{S as Nl,i as Ol,s as ql,e as t,k as i,w as P,t as n,M as Sl,c as a,d as r,m as d,a as s,x as b,h as l,b as c,N as Hl,F as e,g as h,y as $,q as w,o as y,B as T,v as Rl,L as ln}from"../../chunks/vendor-6b77c823.js";import{T as sn}from"../../chunks/Tip-39098574.js";import{D as de}from"../../chunks/Docstring-1088f2fb.js";import{C as dn}from"../../chunks/CodeBlock-3a8b25a8.js";import{I as lo}from"../../chunks/IconCopyLink-7a11ce68.js";import{E as nn}from"../../chunks/ExampleCodeBlock-5212b321.js";function Bl(E){let p,v,g,u,F;return u=new dn({props:{code:`from transformers import PoolFormerModel, PoolFormerConfig

# Initializing a PoolFormer sail/poolformer_s12 style configuration
configuration = PoolFormerConfig()

# Initializing a model from the sail/poolformer_s12 style configuration
model = PoolFormerModel(configuration)

# Accessing the model configuration
configuration = model.config`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> PoolFormerModel, PoolFormerConfig

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a PoolFormer sail/poolformer_s12 style configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = PoolFormerConfig()

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a model from the sail/poolformer_s12 style configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = PoolFormerModel(configuration)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Accessing the model configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = model.config`}}),{c(){p=t("p"),v=n("Example:"),g=i(),P(u.$$.fragment)},l(m){p=a(m,"P",{});var _=s(p);v=l(_,"Example:"),_.forEach(r),g=d(m),b(u.$$.fragment,m)},m(m,_){h(m,p,_),e(p,v),h(m,g,_),$(u,m,_),F=!0},p:ln,i(m){F||(w(u.$$.fragment,m),F=!0)},o(m){y(u.$$.fragment,m),F=!1},d(m){m&&r(p),m&&r(g),T(u,m)}}}function Ul(E){let p,v;return{c(){p=t("p"),v=n(`NumPy arrays and PyTorch tensors are converted to PIL images when resizing, so the most efficient is to pass
PIL images.`)},l(g){p=a(g,"P",{});var u=s(p);v=l(u,`NumPy arrays and PyTorch tensors are converted to PIL images when resizing, so the most efficient is to pass
PIL images.`),u.forEach(r)},m(g,u){h(g,p,u),e(p,v)},d(g){g&&r(p)}}}function Vl(E){let p,v,g,u,F;return{c(){p=t("p"),v=n("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=t("code"),u=n("Module"),F=n(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(m){p=a(m,"P",{});var _=s(p);v=l(_,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(_,"CODE",{});var q=s(g);u=l(q,"Module"),q.forEach(r),F=l(_,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),_.forEach(r)},m(m,_){h(m,p,_),e(p,v),e(p,g),e(g,u),e(p,F)},d(m){m&&r(p)}}}function Gl(E){let p,v,g,u,F;return u=new dn({props:{code:`from transformers import PoolFormerFeatureExtractor, PoolFormerModel
import torch
from datasets import load_dataset

dataset = load_dataset("huggingface/cats-image")
image = dataset["test"]["image"][0]

feature_extractor = PoolFormerFeatureExtractor.from_pretrained("sail/poolformer_s12")
model = PoolFormerModel.from_pretrained("sail/poolformer_s12")

inputs = feature_extractor(image, return_tensors="pt")

with torch.no_grad():
    outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state
list(last_hidden_states.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> PoolFormerFeatureExtractor, PoolFormerModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;huggingface/cats-image&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>image = dataset[<span class="hljs-string">&quot;test&quot;</span>][<span class="hljs-string">&quot;image&quot;</span>][<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = PoolFormerFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;sail/poolformer_s12&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = PoolFormerModel.from_pretrained(<span class="hljs-string">&quot;sail/poolformer_s12&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = feature_extractor(image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(last_hidden_states.shape)
[<span class="hljs-number">1</span>, <span class="hljs-number">512</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>]`}}),{c(){p=t("p"),v=n("Example:"),g=i(),P(u.$$.fragment)},l(m){p=a(m,"P",{});var _=s(p);v=l(_,"Example:"),_.forEach(r),g=d(m),b(u.$$.fragment,m)},m(m,_){h(m,p,_),e(p,v),h(m,g,_),$(u,m,_),F=!0},p:ln,i(m){F||(w(u.$$.fragment,m),F=!0)},o(m){y(u.$$.fragment,m),F=!1},d(m){m&&r(p),m&&r(g),T(u,m)}}}function Wl(E){let p,v,g,u,F;return{c(){p=t("p"),v=n("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=t("code"),u=n("Module"),F=n(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(m){p=a(m,"P",{});var _=s(p);v=l(_,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(_,"CODE",{});var q=s(g);u=l(q,"Module"),q.forEach(r),F=l(_,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),_.forEach(r)},m(m,_){h(m,p,_),e(p,v),e(p,g),e(g,u),e(p,F)},d(m){m&&r(p)}}}function Yl(E){let p,v,g,u,F;return u=new dn({props:{code:`from transformers import PoolFormerFeatureExtractor, PoolFormerForImageClassification
import torch
from datasets import load_dataset

dataset = load_dataset("huggingface/cats-image")
image = dataset["test"]["image"][0]

feature_extractor = PoolFormerFeatureExtractor.from_pretrained("sail/poolformer_s12")
model = PoolFormerForImageClassification.from_pretrained("sail/poolformer_s12")

inputs = feature_extractor(image, return_tensors="pt")

with torch.no_grad():
    logits = model(**inputs).logits

# model predicts one of the 1000 ImageNet classes
predicted_label = logits.argmax(-1).item()
print(model.config.id2label[predicted_label])`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> PoolFormerFeatureExtractor, PoolFormerForImageClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;huggingface/cats-image&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>image = dataset[<span class="hljs-string">&quot;test&quot;</span>][<span class="hljs-string">&quot;image&quot;</span>][<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = PoolFormerFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;sail/poolformer_s12&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = PoolFormerForImageClassification.from_pretrained(<span class="hljs-string">&quot;sail/poolformer_s12&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = feature_extractor(image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># model predicts one of the 1000 ImageNet classes</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_label = logits.argmax(-<span class="hljs-number">1</span>).item()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(model.config.id2label[predicted_label])
tabby, tabby cat`}}),{c(){p=t("p"),v=n("Example:"),g=i(),P(u.$$.fragment)},l(m){p=a(m,"P",{});var _=s(p);v=l(_,"Example:"),_.forEach(r),g=d(m),b(u.$$.fragment,m)},m(m,_){h(m,p,_),e(p,v),h(m,g,_),$(u,m,_),F=!0},p:ln,i(m){F||(w(u.$$.fragment,m),F=!0)},o(m){y(u.$$.fragment,m),F=!1},d(m){m&&r(p),m&&r(g),T(u,m)}}}function Jl(E){let p,v,g,u,F,m,_,q,_t,Ar,X,ce,Vo,Me,vt,Go,Ft,Dr,me,Pt,Ie,bt,$t,Lr,io,wt,Nr,co,Wo,yt,Or,fe,Tt,je,Et,xt,qr,ze,cn,Sr,mo,Ct,Hr,H,Ae,kt,De,Mt,It,jt,Le,zt,fo,At,Dt,Lt,Yo,Nt,Rr,pe,Jo,x,po,Ko,Ot,qt,Xo,Zo,St,Ht,Qo,er,Rt,Bt,ho,or,Ut,Vt,uo,rr,Gt,Wt,C,k,go,Yt,Jt,tr,Kt,Xt,ar,Zt,Qt,_o,ea,oa,vo,ra,ta,M,Fo,aa,sa,sr,na,la,nr,ia,da,Po,ca,ma,bo,fa,pa,I,$o,ha,ua,lr,ga,_a,ir,va,Fa,wo,Pa,ba,yo,$a,wa,j,To,ya,Ta,dr,Ea,xa,cr,Ca,ka,Eo,Ma,Ia,xo,ja,za,z,Co,Aa,Da,mr,La,Na,fr,Oa,qa,ko,Sa,Ha,Mo,Ra,Br,R,Ba,Ne,Ua,Va,Oe,Ga,Wa,Ur,Z,he,pr,qe,Ya,hr,Ja,Vr,Q,Se,Ka,ur,Xa,Gr,ee,He,Za,gr,Qa,Wr,oe,ue,_r,Re,es,vr,os,Yr,A,Be,rs,re,ts,Io,as,ss,Ue,ns,ls,is,te,ds,jo,cs,ms,zo,fs,ps,hs,ge,Jr,ae,_e,Fr,Ve,us,Pr,gs,Kr,D,Ge,_s,br,vs,Fs,We,Ps,Ao,bs,$s,ws,B,Ye,ys,$r,Ts,Es,ve,Xr,se,Fe,wr,Je,xs,yr,Cs,Zr,S,Ke,ks,Xe,Ms,Ze,Is,js,zs,N,Qe,As,ne,Ds,Do,Ls,Ns,Tr,Os,qs,Ss,Pe,Hs,be,Qr,le,$e,Er,eo,Rs,xr,Bs,et,L,oo,Us,Cr,Vs,Gs,ro,Ws,to,Ys,Js,Ks,O,ao,Xs,ie,Zs,Lo,Qs,en,kr,on,rn,tn,we,an,ye,ot;return m=new lo({}),Me=new lo({}),qe=new lo({}),Se=new de({props:{name:"class transformers.models.poolformer.modeling_poolformer.PoolFormerModelOutput",anchor:"transformers.models.poolformer.modeling_poolformer.PoolFormerModelOutput",parameters:[{name:"last_hidden_state",val:": FloatTensor = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"}],parametersDescription:[{anchor:"transformers.models.poolformer.modeling_poolformer.PoolFormerModelOutput.last_hidden_state",description:`<strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) &#x2014;
Sequence of hidden-states at the output of the last layer of the model.`,name:"last_hidden_state"},{anchor:"transformers.models.poolformer.modeling_poolformer.PoolFormerModelOutput.hidden_states",description:`<strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>. Hidden-states of the model at the output of each layer
plus the initial embedding outputs.`,name:"hidden_states"}],source:"https://github.com/huggingface/transformers/blob/pr_16925/src/transformers/models/poolformer/modeling_poolformer.py#L67"}}),He=new de({props:{name:"class transformers.models.poolformer.modeling_poolformer.PoolFormerClassifierOutput",anchor:"transformers.models.poolformer.modeling_poolformer.PoolFormerClassifierOutput",parameters:[{name:"loss",val:": typing.Optional[torch.FloatTensor] = None"},{name:"logits",val:": FloatTensor = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"}],parametersDescription:[{anchor:"transformers.models.poolformer.modeling_poolformer.PoolFormerClassifierOutput.loss",description:`<strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) &#x2014;
Classification (or regression if config.num_labels==1) loss.`,name:"loss"},{anchor:"transformers.models.poolformer.modeling_poolformer.PoolFormerClassifierOutput.logits",description:`<strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.num_labels)</code>) &#x2014;
Classification (or regression if config.num_labels==1) scores (before SoftMax).`,name:"logits"},{anchor:"transformers.models.poolformer.modeling_poolformer.PoolFormerClassifierOutput.hidden_states",description:`<strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, num_channels, height, width)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.`,name:"hidden_states"}],source:"https://github.com/huggingface/transformers/blob/pr_16925/src/transformers/models/poolformer/modeling_poolformer.py#L86"}}),Re=new lo({}),Be=new de({props:{name:"class transformers.PoolFormerConfig",anchor:"transformers.PoolFormerConfig",parameters:[{name:"num_channels",val:" = 3"},{name:"patch_size",val:" = 16"},{name:"stride",val:" = 16"},{name:"pool_size",val:" = 3"},{name:"mlp_ratio",val:" = 4.0"},{name:"depths",val:" = [2, 2, 6, 2]"},{name:"hidden_sizes",val:" = [64, 128, 320, 512]"},{name:"patch_sizes",val:" = [7, 3, 3, 3]"},{name:"strides",val:" = [4, 2, 2, 2]"},{name:"padding",val:" = [2, 1, 1, 1]"},{name:"num_encoder_blocks",val:" = 4"},{name:"drop_path_rate",val:" = 0.0"},{name:"hidden_act",val:" = 'gelu'"},{name:"use_layer_scale",val:" = True"},{name:"layer_scale_init_value",val:" = 1e-05"},{name:"initializer_range",val:" = 0.02"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.PoolFormerConfig.num_channels",description:`<strong>num_channels</strong> (<code>int</code>, <em>optional</em>, defaults to 3) &#x2014;
The number of channels in the input image.`,name:"num_channels"},{anchor:"transformers.PoolFormerConfig.patch_size",description:`<strong>patch_size</strong> (<code>int</code>, <em>optional</em>, defaults to 16) &#x2014;
The size of the input patch.`,name:"patch_size"},{anchor:"transformers.PoolFormerConfig.stride",description:`<strong>stride</strong> (<code>int</code>, <em>optional</em>, defaults to 16) &#x2014;
The stride of the input patch.`,name:"stride"},{anchor:"transformers.PoolFormerConfig.pool_size",description:`<strong>pool_size</strong> (<code>int</code>, <em>optional</em>, defaults to 3) &#x2014;
The size of the pooling window.`,name:"pool_size"},{anchor:"transformers.PoolFormerConfig.mlp_ratio",description:`<strong>mlp_ratio</strong> (<code>float</code>, <em>optional</em>, defaults to 4.0) &#x2014;
The ratio of the number of channels in the output of the MLP to the number of channels in the input.`,name:"mlp_ratio"},{anchor:"transformers.PoolFormerConfig.depths",description:`<strong>depths</strong> (<code>list</code>, <em>optional</em>, defaults to <code>[2, 2, 6, 2]</code>) &#x2014;
The depth of each encoder block.`,name:"depths"},{anchor:"transformers.PoolFormerConfig.hidden_sizes",description:`<strong>hidden_sizes</strong> (<code>list</code>, <em>optional</em>, defaults to <code>[64, 128, 320, 512]</code>) &#x2014;
The hidden sizes of each encoder block.`,name:"hidden_sizes"},{anchor:"transformers.PoolFormerConfig.patch_sizes",description:`<strong>patch_sizes</strong> (<code>list</code>, <em>optional</em>, defaults to <code>[7, 3, 3, 3]</code>) &#x2014;
The size of the input patch for each encoder block.`,name:"patch_sizes"},{anchor:"transformers.PoolFormerConfig.strides",description:`<strong>strides</strong> (<code>list</code>, <em>optional</em>, defaults to <code>[4, 2, 2, 2]</code>) &#x2014;
The stride of the input patch for each encoder block.`,name:"strides"},{anchor:"transformers.PoolFormerConfig.padding",description:`<strong>padding</strong> (<code>list</code>, <em>optional</em>, defaults to <code>[2, 1, 1, 1]</code>) &#x2014;
The padding of the input patch for each encoder block.`,name:"padding"},{anchor:"transformers.PoolFormerConfig.num_encoder_blocks",description:`<strong>num_encoder_blocks</strong> (<code>int</code>, <em>optional</em>, defaults to 4) &#x2014;
The number of encoder blocks.`,name:"num_encoder_blocks"},{anchor:"transformers.PoolFormerConfig.drop_path_rate",description:`<strong>drop_path_rate</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
The dropout rate for the dropout layers.`,name:"drop_path_rate"},{anchor:"transformers.PoolFormerConfig.hidden_act",description:`<strong>hidden_act</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;gelu&quot;</code>) &#x2014;
The activation function for the hidden layers.`,name:"hidden_act"},{anchor:"transformers.PoolFormerConfig.use_layer_scale",description:`<strong>use_layer_scale</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to use layer scale.`,name:"use_layer_scale"},{anchor:"transformers.PoolFormerConfig.layer_scale_init_value",description:`<strong>layer_scale_init_value</strong> (<code>float</code>, <em>optional</em>, defaults to 1e-5) &#x2014;
The initial value for the layer scale.`,name:"layer_scale_init_value"},{anchor:"transformers.PoolFormerConfig.initializer_range",description:`<strong>initializer_range</strong> (<code>float</code>, <em>optional</em>, defaults to 0.02) &#x2014;
The initializer range for the weights.`,name:"initializer_range"}],source:"https://github.com/huggingface/transformers/blob/pr_16925/src/transformers/models/poolformer/configuration_poolformer.py#L29"}}),ge=new nn({props:{anchor:"transformers.PoolFormerConfig.example",$$slots:{default:[Bl]},$$scope:{ctx:E}}}),Ve=new lo({}),Ge=new de({props:{name:"class transformers.PoolFormerFeatureExtractor",anchor:"transformers.PoolFormerFeatureExtractor",parameters:[{name:"do_resize_and_center_crop",val:" = True"},{name:"size",val:" = 224"},{name:"resample",val:" = 3"},{name:"crop_pct",val:" = 0.9"},{name:"do_normalize",val:" = True"},{name:"image_mean",val:" = None"},{name:"image_std",val:" = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.PoolFormerFeatureExtractor.do_resize_and_center_crop",description:`<strong>do_resize_and_center_crop</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to resize the shortest edge of the image and center crop the input to a certain <code>size</code>.`,name:"do_resize_and_center_crop"},{anchor:"transformers.PoolFormerFeatureExtractor.size",description:`<strong>size</strong> (<code>int</code> or <code>Tuple(int)</code>, <em>optional</em>, defaults to 224) &#x2014;
Center crop the input to the given size. If a tuple is provided, it should be (width, height). If only an
integer is provided, then the input will be center cropped to (size, size). Only has an effect if
<code>do_resize_and_center_crop</code> is set to <code>True</code>.`,name:"size"},{anchor:"transformers.PoolFormerFeatureExtractor.resample",description:`<strong>resample</strong> (<code>int</code>, <em>optional</em>, defaults to <code>PIL.Image.BICUBIC</code>) &#x2014;
An optional resampling filter. This can be one of <code>PIL.Image.NEAREST</code>, <code>PIL.Image.BOX</code>,
<code>PIL.Image.BILINEAR</code>, <code>PIL.Image.HAMMING</code>, <code>PIL.Image.BICUBIC</code> or <code>PIL.Image.LANCZOS</code>. Only has an effect
if <code>do_resize_and_center_crop</code> is set to <code>True</code>.`,name:"resample"},{anchor:"transformers.PoolFormerFeatureExtractor.crop_pct",description:`<strong>crop_pct</strong> (<code>float</code>, <em>optional</em>, defaults to <code>0.9</code>) &#x2014;
The percentage of the image to crop from the center. Only has an effect if <code>do_resize_and_center_crop</code> is
set to <code>True</code>.`,name:"crop_pct"},{anchor:"transformers.PoolFormerFeatureExtractor.do_normalize",description:`<strong>do_normalize</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to normalize the input with <code>image_mean</code> and <code>image_std</code>.`,name:"do_normalize"},{anchor:"transformers.PoolFormerFeatureExtractor.image_mean",description:`<strong>image_mean</strong> (<code>List[int]</code>, defaults to <code>[0.485, 0.456, 0.406]</code>) &#x2014;
The sequence of means for each channel, to be used when normalizing images.`,name:"image_mean"},{anchor:"transformers.PoolFormerFeatureExtractor.image_std",description:`<strong>image_std</strong> (<code>List[int]</code>, defaults to <code>[0.229, 0.224, 0.225]</code>) &#x2014;
The sequence of standard deviations for each channel, to be used when normalizing images.`,name:"image_std"}],source:"https://github.com/huggingface/transformers/blob/pr_16925/src/transformers/models/poolformer/feature_extraction_poolformer.py#L37"}}),Ye=new de({props:{name:"__call__",anchor:"transformers.PoolFormerFeatureExtractor.__call__",parameters:[{name:"images",val:": typing.Union[PIL.Image.Image, numpy.ndarray, ForwardRef('torch.Tensor'), typing.List[PIL.Image.Image], typing.List[numpy.ndarray], typing.List[ForwardRef('torch.Tensor')]]"},{name:"return_tensors",val:": typing.Union[str, transformers.utils.generic.TensorType, NoneType] = None"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.PoolFormerFeatureExtractor.__call__.images",description:`<strong>images</strong> (<code>PIL.Image.Image</code>, <code>np.ndarray</code>, <code>torch.Tensor</code>, <code>List[PIL.Image.Image]</code>, <code>List[np.ndarray]</code>, <code>List[torch.Tensor]</code>) &#x2014;
The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch
tensor. In case of a NumPy array/PyTorch tensor, each image should be of shape (C, H, W), where C is a
number of channels, H and W are image height and width.`,name:"images"},{anchor:"transformers.PoolFormerFeatureExtractor.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>str</code> or <a href="/docs/transformers/pr_16925/en/internal/file_utils#transformers.TensorType">TensorType</a>, <em>optional</em>, defaults to <code>&apos;np&apos;</code>) &#x2014;
If set, will return tensors of a particular framework. Acceptable values are:</p>
<ul>
<li><code>&apos;tf&apos;</code>: Return TensorFlow <code>tf.constant</code> objects.</li>
<li><code>&apos;pt&apos;</code>: Return PyTorch <code>torch.Tensor</code> objects.</li>
<li><code>&apos;np&apos;</code>: Return NumPy <code>np.ndarray</code> objects.</li>
<li><code>&apos;jax&apos;</code>: Return JAX <code>jnp.ndarray</code> objects.</li>
</ul>`,name:"return_tensors"}],source:"https://github.com/huggingface/transformers/blob/pr_16925/src/transformers/models/poolformer/feature_extraction_poolformer.py#L88",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16925/en/main_classes/feature_extractor#transformers.BatchFeature"
>BatchFeature</a> with the following fields:</p>
<ul>
<li><strong>pixel_values</strong> \u2014 Pixel values to be fed to a model, of shape (batch_size, num_channels, height,
width).</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16925/en/main_classes/feature_extractor#transformers.BatchFeature"
>BatchFeature</a></p>
`}}),ve=new sn({props:{warning:!0,$$slots:{default:[Ul]},$$scope:{ctx:E}}}),Je=new lo({}),Ke=new de({props:{name:"class transformers.PoolFormerModel",anchor:"transformers.PoolFormerModel",parameters:[{name:"config",val:""}],parametersDescription:[{anchor:"transformers.PoolFormerModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16925/en/model_doc/poolformer#transformers.PoolFormerConfig">PoolFormerConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16925/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_16925/src/transformers/models/poolformer/modeling_poolformer.py#L360"}}),Qe=new de({props:{name:"forward",anchor:"transformers.PoolFormerModel.forward",parameters:[{name:"pixel_values",val:": typing.Optional[torch.FloatTensor] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.PoolFormerModel.forward.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Pixel values can be obtained using <a href="/docs/transformers/pr_16925/en/model_doc/poolformer#transformers.PoolFormerFeatureExtractor">PoolFormerFeatureExtractor</a>. See
<a href="/docs/transformers/pr_16925/en/model_doc/poolformer#transformers.PoolFormerFeatureExtractor.__call__">PoolFormerFeatureExtractor.<strong>call</strong>()</a> for details.`,name:"pixel_values"}],source:"https://github.com/huggingface/transformers/blob/pr_16925/src/transformers/models/poolformer/modeling_poolformer.py#L373",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16925/en/model_doc/poolformer#transformers.models.poolformer.modeling_poolformer.PoolFormerModelOutput"
>transformers.models.poolformer.modeling_poolformer.PoolFormerModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16925/en/model_doc/poolformer#transformers.PoolFormerConfig"
>PoolFormerConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>. Hidden-states of the model at the output of each layer
plus the initial embedding outputs.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16925/en/model_doc/poolformer#transformers.models.poolformer.modeling_poolformer.PoolFormerModelOutput"
>transformers.models.poolformer.modeling_poolformer.PoolFormerModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Pe=new sn({props:{$$slots:{default:[Vl]},$$scope:{ctx:E}}}),be=new nn({props:{anchor:"transformers.PoolFormerModel.forward.example",$$slots:{default:[Gl]},$$scope:{ctx:E}}}),eo=new lo({}),oo=new de({props:{name:"class transformers.PoolFormerForImageClassification",anchor:"transformers.PoolFormerForImageClassification",parameters:[{name:"config",val:""}],parametersDescription:[{anchor:"transformers.PoolFormerForImageClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16925/en/model_doc/poolformer#transformers.PoolFormerConfig">PoolFormerConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16925/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_16925/src/transformers/models/poolformer/modeling_poolformer.py#L428"}}),ao=new de({props:{name:"forward",anchor:"transformers.PoolFormerForImageClassification.forward",parameters:[{name:"pixel_values",val:": typing.Optional[torch.FloatTensor] = None"},{name:"labels",val:": typing.Optional[torch.LongTensor] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.PoolFormerForImageClassification.forward.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Pixel values can be obtained using <a href="/docs/transformers/pr_16925/en/model_doc/poolformer#transformers.PoolFormerFeatureExtractor">PoolFormerFeatureExtractor</a>. See
<a href="/docs/transformers/pr_16925/en/model_doc/poolformer#transformers.PoolFormerFeatureExtractor.__call__">PoolFormerFeatureExtractor.<strong>call</strong>()</a> for details.`,name:"pixel_values"},{anchor:"transformers.PoolFormerForImageClassification.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the image classification/regression loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>. If <code>config.num_labels == 1</code> a regression loss is computed (Mean-Square loss), If
<code>config.num_labels &gt; 1</code> a classification loss is computed (Cross-Entropy).`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/pr_16925/src/transformers/models/poolformer/modeling_poolformer.py#L444",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16925/en/model_doc/poolformer#transformers.models.poolformer.modeling_poolformer.PoolFormerClassifierOutput"
>transformers.models.poolformer.modeling_poolformer.PoolFormerClassifierOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16925/en/model_doc/poolformer#transformers.PoolFormerConfig"
>PoolFormerConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification (or regression if config.num_labels==1) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.num_labels)</code>) \u2014 Classification (or regression if config.num_labels==1) scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, num_channels, height, width)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16925/en/model_doc/poolformer#transformers.models.poolformer.modeling_poolformer.PoolFormerClassifierOutput"
>transformers.models.poolformer.modeling_poolformer.PoolFormerClassifierOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),we=new sn({props:{$$slots:{default:[Wl]},$$scope:{ctx:E}}}),ye=new nn({props:{anchor:"transformers.PoolFormerForImageClassification.forward.example",$$slots:{default:[Yl]},$$scope:{ctx:E}}}),{c(){p=t("meta"),v=i(),g=t("h1"),u=t("a"),F=t("span"),P(m.$$.fragment),_=i(),q=t("span"),_t=n("PoolFormer"),Ar=i(),X=t("h2"),ce=t("a"),Vo=t("span"),P(Me.$$.fragment),vt=i(),Go=t("span"),Ft=n("Overview"),Dr=i(),me=t("p"),Pt=n("The PoolFormer model was proposed in "),Ie=t("a"),bt=n("MetaFormer is Actually What You Need for Vision"),$t=n("  by Sea AI Labs. Instead of designing complicated token mixer to achieve SOTA performance, the target of this work is to demonstrate the competence of transformer models largely stem from the general architecture MetaFormer."),Lr=i(),io=t("p"),wt=n("The abstract from the paper is the following:"),Nr=i(),co=t("p"),Wo=t("em"),yt=n("Transformers have shown great potential in computer vision tasks. A common belief is their attention-based token mixer module contributes most to their competence. However, recent works show the attention-based module in transformers can be replaced by spatial MLPs and the resulted models still perform quite well. Based on this observation, we hypothesize that the general architecture of the transformers, instead of the specific token mixer module, is more essential to the model\u2019s performance. To verify this, we deliberately replace the attention module in transformers with an embarrassingly simple spatial pooling operator to conduct only the most basic token mixing. Surprisingly, we observe that the derived model, termed as PoolFormer, achieves competitive performance on multiple computer vision tasks. For example, on ImageNet-1K, PoolFormer achieves 82.1% top-1 accuracy, surpassing well-tuned vision transformer/MLP-like baselines DeiT-B/ResMLP-B24 by 0.3%/1.1% accuracy with 35%/52% fewer parameters and 48%/60% fewer MACs. The effectiveness of PoolFormer verifies our hypothesis and urges us to initiate the concept of \u201CMetaFormer\u201D, a general architecture abstracted from transformers without specifying the token mixer. Based on the extensive experiments, we argue that MetaFormer is the key player in achieving superior results for recent transformer and MLP-like models on vision tasks. This work calls for more future research dedicated to improving MetaFormer instead of focusing on the token mixer modules. Additionally, our proposed PoolFormer could serve as a starting baseline for future MetaFormer architecture design."),Or=i(),fe=t("p"),Tt=n("The figure below illustrates the architecture of PoolFormer. Taken from the "),je=t("a"),Et=n("original paper"),xt=n("."),qr=i(),ze=t("img"),Sr=i(),mo=t("p"),Ct=n("Tips:"),Hr=i(),H=t("ul"),Ae=t("li"),kt=n("PoolFormer has a hierarchical architecture, where instead of Attention, a simple Average Pooling layer is present. All checkpoints of the model can be found on the "),De=t("a"),Mt=n("hub"),It=n("."),jt=i(),Le=t("li"),zt=n("One can use "),fo=t("a"),At=n("PoolFormerFeatureExtractor"),Dt=n(" to prepare images for the model."),Lt=i(),Yo=t("li"),Nt=n("As most models, PoolFormer comes in different sizes, the details of which can be found in the table below."),Rr=i(),pe=t("table"),Jo=t("thead"),x=t("tr"),po=t("th"),Ko=t("strong"),Ot=n("Model variant"),qt=i(),Xo=t("th"),Zo=t("strong"),St=n("Depths"),Ht=i(),Qo=t("th"),er=t("strong"),Rt=n("Hidden sizes"),Bt=i(),ho=t("th"),or=t("strong"),Ut=n("Params (M)"),Vt=i(),uo=t("th"),rr=t("strong"),Gt=n("ImageNet-1k Top 1"),Wt=i(),C=t("tbody"),k=t("tr"),go=t("td"),Yt=n("s12"),Jt=i(),tr=t("td"),Kt=n("[2, 2, 6, 2]"),Xt=i(),ar=t("td"),Zt=n("[64, 128, 320, 512]"),Qt=i(),_o=t("td"),ea=n("12"),oa=i(),vo=t("td"),ra=n("77.2"),ta=i(),M=t("tr"),Fo=t("td"),aa=n("s24"),sa=i(),sr=t("td"),na=n("[4, 4, 12, 4]"),la=i(),nr=t("td"),ia=n("[64, 128, 320, 512]"),da=i(),Po=t("td"),ca=n("21"),ma=i(),bo=t("td"),fa=n("80.3"),pa=i(),I=t("tr"),$o=t("td"),ha=n("s36"),ua=i(),lr=t("td"),ga=n("[6, 6, 18, 6]"),_a=i(),ir=t("td"),va=n("[64, 128, 320, 512]"),Fa=i(),wo=t("td"),Pa=n("31"),ba=i(),yo=t("td"),$a=n("81.4"),wa=i(),j=t("tr"),To=t("td"),ya=n("m36"),Ta=i(),dr=t("td"),Ea=n("[6, 6, 18, 6]"),xa=i(),cr=t("td"),Ca=n("[96, 192, 384, 768]"),ka=i(),Eo=t("td"),Ma=n("56"),Ia=i(),xo=t("td"),ja=n("82.1"),za=i(),z=t("tr"),Co=t("td"),Aa=n("m48"),Da=i(),mr=t("td"),La=n("[8, 8, 24, 8]"),Na=i(),fr=t("td"),Oa=n("[96, 192, 384, 768]"),qa=i(),ko=t("td"),Sa=n("73"),Ha=i(),Mo=t("td"),Ra=n("82.5"),Br=i(),R=t("p"),Ba=n("This model was contributed by "),Ne=t("a"),Ua=n("heytanay"),Va=n(". The original code can be found "),Oe=t("a"),Ga=n("here"),Wa=n("."),Ur=i(),Z=t("h2"),he=t("a"),pr=t("span"),P(qe.$$.fragment),Ya=i(),hr=t("span"),Ja=n("PoolFormer specific outputs"),Vr=i(),Q=t("div"),P(Se.$$.fragment),Ka=i(),ur=t("p"),Xa=n("Class for PoolFormerModel\u2019s outputs, with potential hidden states."),Gr=i(),ee=t("div"),P(He.$$.fragment),Za=i(),gr=t("p"),Qa=n("Class for PoolformerForImageClassification\u2019s outputs."),Wr=i(),oe=t("h2"),ue=t("a"),_r=t("span"),P(Re.$$.fragment),es=i(),vr=t("span"),os=n("PoolFormerConfig"),Yr=i(),A=t("div"),P(Be.$$.fragment),rs=i(),re=t("p"),ts=n("This is the configuration class to store the configuration of "),Io=t("a"),as=n("PoolFormerModel"),ss=n(`. It is used to instantiate a
PoolFormer model according to the specified arguments, defining the model architecture. Instantiating a
configuration with the defaults will yield a similar configuration to that of the PoolFormer
`),Ue=t("a"),ns=n("sail/poolformer_s12"),ls=n(" architecture."),is=i(),te=t("p"),ds=n("Configuration objects inherit from "),jo=t("a"),cs=n("PretrainedConfig"),ms=n(` and can be used to control the model outputs. Read the
documentation from `),zo=t("a"),fs=n("PretrainedConfig"),ps=n(" for more information."),hs=i(),P(ge.$$.fragment),Jr=i(),ae=t("h2"),_e=t("a"),Fr=t("span"),P(Ve.$$.fragment),us=i(),Pr=t("span"),gs=n("PoolFormerFeatureExtractor"),Kr=i(),D=t("div"),P(Ge.$$.fragment),_s=i(),br=t("p"),vs=n("Constructs a PoolFormer feature extractor."),Fs=i(),We=t("p"),Ps=n("This feature extractor inherits from "),Ao=t("a"),bs=n("FeatureExtractionMixin"),$s=n(` which contains most of the main methods. Users
should refer to this superclass for more information regarding those methods.`),ws=i(),B=t("div"),P(Ye.$$.fragment),ys=i(),$r=t("p"),Ts=n("Main method to prepare for the model one or several image(s)."),Es=i(),P(ve.$$.fragment),Xr=i(),se=t("h2"),Fe=t("a"),wr=t("span"),P(Je.$$.fragment),xs=i(),yr=t("span"),Cs=n("PoolFormerModel"),Zr=i(),S=t("div"),P(Ke.$$.fragment),ks=i(),Xe=t("p"),Ms=n(`The bare PoolFormer Model transformer outputting raw hidden-states without any specific head on top.
This model is a PyTorch `),Ze=t("a"),Is=n("torch.nn.Module"),js=n(` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),zs=i(),N=t("div"),P(Qe.$$.fragment),As=i(),ne=t("p"),Ds=n("The "),Do=t("a"),Ls=n("PoolFormerModel"),Ns=n(" forward method, overrides the "),Tr=t("code"),Os=n("__call__"),qs=n(" special method."),Ss=i(),P(Pe.$$.fragment),Hs=i(),P(be.$$.fragment),Qr=i(),le=t("h2"),$e=t("a"),Er=t("span"),P(eo.$$.fragment),Rs=i(),xr=t("span"),Bs=n("PoolFormerForImageClassification"),et=i(),L=t("div"),P(oo.$$.fragment),Us=i(),Cr=t("p"),Vs=n("PoolFormer Model transformer with an image classification head on top"),Gs=i(),ro=t("p"),Ws=n("This model is a PyTorch "),to=t("a"),Ys=n("torch.nn.Module"),Js=n(` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),Ks=i(),O=t("div"),P(ao.$$.fragment),Xs=i(),ie=t("p"),Zs=n("The "),Lo=t("a"),Qs=n("PoolFormerForImageClassification"),en=n(" forward method, overrides the "),kr=t("code"),on=n("__call__"),rn=n(" special method."),tn=i(),P(we.$$.fragment),an=i(),P(ye.$$.fragment),this.h()},l(o){const f=Sl('[data-svelte="svelte-1phssyn"]',document.head);p=a(f,"META",{name:!0,content:!0}),f.forEach(r),v=d(o),g=a(o,"H1",{class:!0});var so=s(g);u=a(so,"A",{id:!0,class:!0,href:!0});var Mr=s(u);F=a(Mr,"SPAN",{});var Ir=s(F);b(m.$$.fragment,Ir),Ir.forEach(r),Mr.forEach(r),_=d(so),q=a(so,"SPAN",{});var jr=s(q);_t=l(jr,"PoolFormer"),jr.forEach(r),so.forEach(r),Ar=d(o),X=a(o,"H2",{class:!0});var no=s(X);ce=a(no,"A",{id:!0,class:!0,href:!0});var zr=s(ce);Vo=a(zr,"SPAN",{});var mn=s(Vo);b(Me.$$.fragment,mn),mn.forEach(r),zr.forEach(r),vt=d(no),Go=a(no,"SPAN",{});var fn=s(Go);Ft=l(fn,"Overview"),fn.forEach(r),no.forEach(r),Dr=d(o),me=a(o,"P",{});var rt=s(me);Pt=l(rt,"The PoolFormer model was proposed in "),Ie=a(rt,"A",{href:!0,rel:!0});var pn=s(Ie);bt=l(pn,"MetaFormer is Actually What You Need for Vision"),pn.forEach(r),$t=l(rt,"  by Sea AI Labs. Instead of designing complicated token mixer to achieve SOTA performance, the target of this work is to demonstrate the competence of transformer models largely stem from the general architecture MetaFormer."),rt.forEach(r),Lr=d(o),io=a(o,"P",{});var hn=s(io);wt=l(hn,"The abstract from the paper is the following:"),hn.forEach(r),Nr=d(o),co=a(o,"P",{});var un=s(co);Wo=a(un,"EM",{});var gn=s(Wo);yt=l(gn,"Transformers have shown great potential in computer vision tasks. A common belief is their attention-based token mixer module contributes most to their competence. However, recent works show the attention-based module in transformers can be replaced by spatial MLPs and the resulted models still perform quite well. Based on this observation, we hypothesize that the general architecture of the transformers, instead of the specific token mixer module, is more essential to the model\u2019s performance. To verify this, we deliberately replace the attention module in transformers with an embarrassingly simple spatial pooling operator to conduct only the most basic token mixing. Surprisingly, we observe that the derived model, termed as PoolFormer, achieves competitive performance on multiple computer vision tasks. For example, on ImageNet-1K, PoolFormer achieves 82.1% top-1 accuracy, surpassing well-tuned vision transformer/MLP-like baselines DeiT-B/ResMLP-B24 by 0.3%/1.1% accuracy with 35%/52% fewer parameters and 48%/60% fewer MACs. The effectiveness of PoolFormer verifies our hypothesis and urges us to initiate the concept of \u201CMetaFormer\u201D, a general architecture abstracted from transformers without specifying the token mixer. Based on the extensive experiments, we argue that MetaFormer is the key player in achieving superior results for recent transformer and MLP-like models on vision tasks. This work calls for more future research dedicated to improving MetaFormer instead of focusing on the token mixer modules. Additionally, our proposed PoolFormer could serve as a starting baseline for future MetaFormer architecture design."),gn.forEach(r),un.forEach(r),Or=d(o),fe=a(o,"P",{});var tt=s(fe);Tt=l(tt,"The figure below illustrates the architecture of PoolFormer. Taken from the "),je=a(tt,"A",{href:!0,rel:!0});var _n=s(je);Et=l(_n,"original paper"),_n.forEach(r),xt=l(tt,"."),tt.forEach(r),qr=d(o),ze=a(o,"IMG",{width:!0,src:!0}),Sr=d(o),mo=a(o,"P",{});var vn=s(mo);Ct=l(vn,"Tips:"),vn.forEach(r),Hr=d(o),H=a(o,"UL",{});var No=s(H);Ae=a(No,"LI",{});var at=s(Ae);kt=l(at,"PoolFormer has a hierarchical architecture, where instead of Attention, a simple Average Pooling layer is present. All checkpoints of the model can be found on the "),De=a(at,"A",{href:!0,rel:!0});var Fn=s(De);Mt=l(Fn,"hub"),Fn.forEach(r),It=l(at,"."),at.forEach(r),jt=d(No),Le=a(No,"LI",{});var st=s(Le);zt=l(st,"One can use "),fo=a(st,"A",{href:!0});var Pn=s(fo);At=l(Pn,"PoolFormerFeatureExtractor"),Pn.forEach(r),Dt=l(st," to prepare images for the model."),st.forEach(r),Lt=d(No),Yo=a(No,"LI",{});var bn=s(Yo);Nt=l(bn,"As most models, PoolFormer comes in different sizes, the details of which can be found in the table below."),bn.forEach(r),No.forEach(r),Rr=d(o),pe=a(o,"TABLE",{});var nt=s(pe);Jo=a(nt,"THEAD",{});var $n=s(Jo);x=a($n,"TR",{});var U=s(x);po=a(U,"TH",{align:!0});var wn=s(po);Ko=a(wn,"STRONG",{});var yn=s(Ko);Ot=l(yn,"Model variant"),yn.forEach(r),wn.forEach(r),qt=d(U),Xo=a(U,"TH",{});var Tn=s(Xo);Zo=a(Tn,"STRONG",{});var En=s(Zo);St=l(En,"Depths"),En.forEach(r),Tn.forEach(r),Ht=d(U),Qo=a(U,"TH",{});var xn=s(Qo);er=a(xn,"STRONG",{});var Cn=s(er);Rt=l(Cn,"Hidden sizes"),Cn.forEach(r),xn.forEach(r),Bt=d(U),ho=a(U,"TH",{align:!0});var kn=s(ho);or=a(kn,"STRONG",{});var Mn=s(or);Ut=l(Mn,"Params (M)"),Mn.forEach(r),kn.forEach(r),Vt=d(U),uo=a(U,"TH",{align:!0});var In=s(uo);rr=a(In,"STRONG",{});var jn=s(rr);Gt=l(jn,"ImageNet-1k Top 1"),jn.forEach(r),In.forEach(r),U.forEach(r),$n.forEach(r),Wt=d(nt),C=a(nt,"TBODY",{});var V=s(C);k=a(V,"TR",{});var G=s(k);go=a(G,"TD",{align:!0});var zn=s(go);Yt=l(zn,"s12"),zn.forEach(r),Jt=d(G),tr=a(G,"TD",{});var An=s(tr);Kt=l(An,"[2, 2, 6, 2]"),An.forEach(r),Xt=d(G),ar=a(G,"TD",{});var Dn=s(ar);Zt=l(Dn,"[64, 128, 320, 512]"),Dn.forEach(r),Qt=d(G),_o=a(G,"TD",{align:!0});var Ln=s(_o);ea=l(Ln,"12"),Ln.forEach(r),oa=d(G),vo=a(G,"TD",{align:!0});var Nn=s(vo);ra=l(Nn,"77.2"),Nn.forEach(r),G.forEach(r),ta=d(V),M=a(V,"TR",{});var W=s(M);Fo=a(W,"TD",{align:!0});var On=s(Fo);aa=l(On,"s24"),On.forEach(r),sa=d(W),sr=a(W,"TD",{});var qn=s(sr);na=l(qn,"[4, 4, 12, 4]"),qn.forEach(r),la=d(W),nr=a(W,"TD",{});var Sn=s(nr);ia=l(Sn,"[64, 128, 320, 512]"),Sn.forEach(r),da=d(W),Po=a(W,"TD",{align:!0});var Hn=s(Po);ca=l(Hn,"21"),Hn.forEach(r),ma=d(W),bo=a(W,"TD",{align:!0});var Rn=s(bo);fa=l(Rn,"80.3"),Rn.forEach(r),W.forEach(r),pa=d(V),I=a(V,"TR",{});var Y=s(I);$o=a(Y,"TD",{align:!0});var Bn=s($o);ha=l(Bn,"s36"),Bn.forEach(r),ua=d(Y),lr=a(Y,"TD",{});var Un=s(lr);ga=l(Un,"[6, 6, 18, 6]"),Un.forEach(r),_a=d(Y),ir=a(Y,"TD",{});var Vn=s(ir);va=l(Vn,"[64, 128, 320, 512]"),Vn.forEach(r),Fa=d(Y),wo=a(Y,"TD",{align:!0});var Gn=s(wo);Pa=l(Gn,"31"),Gn.forEach(r),ba=d(Y),yo=a(Y,"TD",{align:!0});var Wn=s(yo);$a=l(Wn,"81.4"),Wn.forEach(r),Y.forEach(r),wa=d(V),j=a(V,"TR",{});var J=s(j);To=a(J,"TD",{align:!0});var Yn=s(To);ya=l(Yn,"m36"),Yn.forEach(r),Ta=d(J),dr=a(J,"TD",{});var Jn=s(dr);Ea=l(Jn,"[6, 6, 18, 6]"),Jn.forEach(r),xa=d(J),cr=a(J,"TD",{});var Kn=s(cr);Ca=l(Kn,"[96, 192, 384, 768]"),Kn.forEach(r),ka=d(J),Eo=a(J,"TD",{align:!0});var Xn=s(Eo);Ma=l(Xn,"56"),Xn.forEach(r),Ia=d(J),xo=a(J,"TD",{align:!0});var Zn=s(xo);ja=l(Zn,"82.1"),Zn.forEach(r),J.forEach(r),za=d(V),z=a(V,"TR",{});var K=s(z);Co=a(K,"TD",{align:!0});var Qn=s(Co);Aa=l(Qn,"m48"),Qn.forEach(r),Da=d(K),mr=a(K,"TD",{});var el=s(mr);La=l(el,"[8, 8, 24, 8]"),el.forEach(r),Na=d(K),fr=a(K,"TD",{});var ol=s(fr);Oa=l(ol,"[96, 192, 384, 768]"),ol.forEach(r),qa=d(K),ko=a(K,"TD",{align:!0});var rl=s(ko);Sa=l(rl,"73"),rl.forEach(r),Ha=d(K),Mo=a(K,"TD",{align:!0});var tl=s(Mo);Ra=l(tl,"82.5"),tl.forEach(r),K.forEach(r),V.forEach(r),nt.forEach(r),Br=d(o),R=a(o,"P",{});var Oo=s(R);Ba=l(Oo,"This model was contributed by "),Ne=a(Oo,"A",{href:!0,rel:!0});var al=s(Ne);Ua=l(al,"heytanay"),al.forEach(r),Va=l(Oo,". The original code can be found "),Oe=a(Oo,"A",{href:!0,rel:!0});var sl=s(Oe);Ga=l(sl,"here"),sl.forEach(r),Wa=l(Oo,"."),Oo.forEach(r),Ur=d(o),Z=a(o,"H2",{class:!0});var lt=s(Z);he=a(lt,"A",{id:!0,class:!0,href:!0});var nl=s(he);pr=a(nl,"SPAN",{});var ll=s(pr);b(qe.$$.fragment,ll),ll.forEach(r),nl.forEach(r),Ya=d(lt),hr=a(lt,"SPAN",{});var il=s(hr);Ja=l(il,"PoolFormer specific outputs"),il.forEach(r),lt.forEach(r),Vr=d(o),Q=a(o,"DIV",{class:!0});var it=s(Q);b(Se.$$.fragment,it),Ka=d(it),ur=a(it,"P",{});var dl=s(ur);Xa=l(dl,"Class for PoolFormerModel\u2019s outputs, with potential hidden states."),dl.forEach(r),it.forEach(r),Gr=d(o),ee=a(o,"DIV",{class:!0});var dt=s(ee);b(He.$$.fragment,dt),Za=d(dt),gr=a(dt,"P",{});var cl=s(gr);Qa=l(cl,"Class for PoolformerForImageClassification\u2019s outputs."),cl.forEach(r),dt.forEach(r),Wr=d(o),oe=a(o,"H2",{class:!0});var ct=s(oe);ue=a(ct,"A",{id:!0,class:!0,href:!0});var ml=s(ue);_r=a(ml,"SPAN",{});var fl=s(_r);b(Re.$$.fragment,fl),fl.forEach(r),ml.forEach(r),es=d(ct),vr=a(ct,"SPAN",{});var pl=s(vr);os=l(pl,"PoolFormerConfig"),pl.forEach(r),ct.forEach(r),Yr=d(o),A=a(o,"DIV",{class:!0});var Te=s(A);b(Be.$$.fragment,Te),rs=d(Te),re=a(Te,"P",{});var qo=s(re);ts=l(qo,"This is the configuration class to store the configuration of "),Io=a(qo,"A",{href:!0});var hl=s(Io);as=l(hl,"PoolFormerModel"),hl.forEach(r),ss=l(qo,`. It is used to instantiate a
PoolFormer model according to the specified arguments, defining the model architecture. Instantiating a
configuration with the defaults will yield a similar configuration to that of the PoolFormer
`),Ue=a(qo,"A",{href:!0,rel:!0});var ul=s(Ue);ns=l(ul,"sail/poolformer_s12"),ul.forEach(r),ls=l(qo," architecture."),qo.forEach(r),is=d(Te),te=a(Te,"P",{});var So=s(te);ds=l(So,"Configuration objects inherit from "),jo=a(So,"A",{href:!0});var gl=s(jo);cs=l(gl,"PretrainedConfig"),gl.forEach(r),ms=l(So,` and can be used to control the model outputs. Read the
documentation from `),zo=a(So,"A",{href:!0});var _l=s(zo);fs=l(_l,"PretrainedConfig"),_l.forEach(r),ps=l(So," for more information."),So.forEach(r),hs=d(Te),b(ge.$$.fragment,Te),Te.forEach(r),Jr=d(o),ae=a(o,"H2",{class:!0});var mt=s(ae);_e=a(mt,"A",{id:!0,class:!0,href:!0});var vl=s(_e);Fr=a(vl,"SPAN",{});var Fl=s(Fr);b(Ve.$$.fragment,Fl),Fl.forEach(r),vl.forEach(r),us=d(mt),Pr=a(mt,"SPAN",{});var Pl=s(Pr);gs=l(Pl,"PoolFormerFeatureExtractor"),Pl.forEach(r),mt.forEach(r),Kr=d(o),D=a(o,"DIV",{class:!0});var Ee=s(D);b(Ge.$$.fragment,Ee),_s=d(Ee),br=a(Ee,"P",{});var bl=s(br);vs=l(bl,"Constructs a PoolFormer feature extractor."),bl.forEach(r),Fs=d(Ee),We=a(Ee,"P",{});var ft=s(We);Ps=l(ft,"This feature extractor inherits from "),Ao=a(ft,"A",{href:!0});var $l=s(Ao);bs=l($l,"FeatureExtractionMixin"),$l.forEach(r),$s=l(ft,` which contains most of the main methods. Users
should refer to this superclass for more information regarding those methods.`),ft.forEach(r),ws=d(Ee),B=a(Ee,"DIV",{class:!0});var Ho=s(B);b(Ye.$$.fragment,Ho),ys=d(Ho),$r=a(Ho,"P",{});var wl=s($r);Ts=l(wl,"Main method to prepare for the model one or several image(s)."),wl.forEach(r),Es=d(Ho),b(ve.$$.fragment,Ho),Ho.forEach(r),Ee.forEach(r),Xr=d(o),se=a(o,"H2",{class:!0});var pt=s(se);Fe=a(pt,"A",{id:!0,class:!0,href:!0});var yl=s(Fe);wr=a(yl,"SPAN",{});var Tl=s(wr);b(Je.$$.fragment,Tl),Tl.forEach(r),yl.forEach(r),xs=d(pt),yr=a(pt,"SPAN",{});var El=s(yr);Cs=l(El,"PoolFormerModel"),El.forEach(r),pt.forEach(r),Zr=d(o),S=a(o,"DIV",{class:!0});var Ro=s(S);b(Ke.$$.fragment,Ro),ks=d(Ro),Xe=a(Ro,"P",{});var ht=s(Xe);Ms=l(ht,`The bare PoolFormer Model transformer outputting raw hidden-states without any specific head on top.
This model is a PyTorch `),Ze=a(ht,"A",{href:!0,rel:!0});var xl=s(Ze);Is=l(xl,"torch.nn.Module"),xl.forEach(r),js=l(ht,` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),ht.forEach(r),zs=d(Ro),N=a(Ro,"DIV",{class:!0});var xe=s(N);b(Qe.$$.fragment,xe),As=d(xe),ne=a(xe,"P",{});var Bo=s(ne);Ds=l(Bo,"The "),Do=a(Bo,"A",{href:!0});var Cl=s(Do);Ls=l(Cl,"PoolFormerModel"),Cl.forEach(r),Ns=l(Bo," forward method, overrides the "),Tr=a(Bo,"CODE",{});var kl=s(Tr);Os=l(kl,"__call__"),kl.forEach(r),qs=l(Bo," special method."),Bo.forEach(r),Ss=d(xe),b(Pe.$$.fragment,xe),Hs=d(xe),b(be.$$.fragment,xe),xe.forEach(r),Ro.forEach(r),Qr=d(o),le=a(o,"H2",{class:!0});var ut=s(le);$e=a(ut,"A",{id:!0,class:!0,href:!0});var Ml=s($e);Er=a(Ml,"SPAN",{});var Il=s(Er);b(eo.$$.fragment,Il),Il.forEach(r),Ml.forEach(r),Rs=d(ut),xr=a(ut,"SPAN",{});var jl=s(xr);Bs=l(jl,"PoolFormerForImageClassification"),jl.forEach(r),ut.forEach(r),et=d(o),L=a(o,"DIV",{class:!0});var Ce=s(L);b(oo.$$.fragment,Ce),Us=d(Ce),Cr=a(Ce,"P",{});var zl=s(Cr);Vs=l(zl,"PoolFormer Model transformer with an image classification head on top"),zl.forEach(r),Gs=d(Ce),ro=a(Ce,"P",{});var gt=s(ro);Ws=l(gt,"This model is a PyTorch "),to=a(gt,"A",{href:!0,rel:!0});var Al=s(to);Ys=l(Al,"torch.nn.Module"),Al.forEach(r),Js=l(gt,` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),gt.forEach(r),Ks=d(Ce),O=a(Ce,"DIV",{class:!0});var ke=s(O);b(ao.$$.fragment,ke),Xs=d(ke),ie=a(ke,"P",{});var Uo=s(ie);Zs=l(Uo,"The "),Lo=a(Uo,"A",{href:!0});var Dl=s(Lo);Qs=l(Dl,"PoolFormerForImageClassification"),Dl.forEach(r),en=l(Uo," forward method, overrides the "),kr=a(Uo,"CODE",{});var Ll=s(kr);on=l(Ll,"__call__"),Ll.forEach(r),rn=l(Uo," special method."),Uo.forEach(r),tn=d(ke),b(we.$$.fragment,ke),an=d(ke),b(ye.$$.fragment,ke),ke.forEach(r),Ce.forEach(r),this.h()},h(){c(p,"name","hf:doc:metadata"),c(p,"content",JSON.stringify(Kl)),c(u,"id","poolformer"),c(u,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(u,"href","#poolformer"),c(g,"class","relative group"),c(ce,"id","overview"),c(ce,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ce,"href","#overview"),c(X,"class","relative group"),c(Ie,"href","https://arxiv.org/abs/2111.11418"),c(Ie,"rel","nofollow"),c(je,"href","https://arxiv.org/abs/2111.11418"),c(je,"rel","nofollow"),c(ze,"width","600"),Hl(ze.src,cn="https://user-images.githubusercontent.com/15921929/142746124-1ab7635d-2536-4a0e-ad43-b4fe2c5a525d.png")||c(ze,"src",cn),c(De,"href","https://huggingface.co/models?other=poolformer"),c(De,"rel","nofollow"),c(fo,"href","/docs/transformers/pr_16925/en/model_doc/poolformer#transformers.PoolFormerFeatureExtractor"),c(po,"align","center"),c(ho,"align","center"),c(uo,"align","center"),c(go,"align","center"),c(_o,"align","center"),c(vo,"align","center"),c(Fo,"align","center"),c(Po,"align","center"),c(bo,"align","center"),c($o,"align","center"),c(wo,"align","center"),c(yo,"align","center"),c(To,"align","center"),c(Eo,"align","center"),c(xo,"align","center"),c(Co,"align","center"),c(ko,"align","center"),c(Mo,"align","center"),c(Ne,"href","https://huggingface.co/heytanay"),c(Ne,"rel","nofollow"),c(Oe,"href","https://github.com/sail-sg/poolformer"),c(Oe,"rel","nofollow"),c(he,"id","transformers.models.poolformer.modeling_poolformer.PoolFormerModelOutput"),c(he,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(he,"href","#transformers.models.poolformer.modeling_poolformer.PoolFormerModelOutput"),c(Z,"class","relative group"),c(Q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(ee,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(ue,"id","transformers.PoolFormerConfig"),c(ue,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ue,"href","#transformers.PoolFormerConfig"),c(oe,"class","relative group"),c(Io,"href","/docs/transformers/pr_16925/en/model_doc/poolformer#transformers.PoolFormerModel"),c(Ue,"href","https://huggingface.co/sail/poolformer_s12"),c(Ue,"rel","nofollow"),c(jo,"href","/docs/transformers/pr_16925/en/main_classes/configuration#transformers.PretrainedConfig"),c(zo,"href","/docs/transformers/pr_16925/en/main_classes/configuration#transformers.PretrainedConfig"),c(A,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(_e,"id","transformers.PoolFormerFeatureExtractor"),c(_e,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(_e,"href","#transformers.PoolFormerFeatureExtractor"),c(ae,"class","relative group"),c(Ao,"href","/docs/transformers/pr_16925/en/main_classes/feature_extractor#transformers.FeatureExtractionMixin"),c(B,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(D,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Fe,"id","transformers.PoolFormerModel"),c(Fe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Fe,"href","#transformers.PoolFormerModel"),c(se,"class","relative group"),c(Ze,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Ze,"rel","nofollow"),c(Do,"href","/docs/transformers/pr_16925/en/model_doc/poolformer#transformers.PoolFormerModel"),c(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(S,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c($e,"id","transformers.PoolFormerForImageClassification"),c($e,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c($e,"href","#transformers.PoolFormerForImageClassification"),c(le,"class","relative group"),c(to,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(to,"rel","nofollow"),c(Lo,"href","/docs/transformers/pr_16925/en/model_doc/poolformer#transformers.PoolFormerForImageClassification"),c(O,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(L,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(o,f){e(document.head,p),h(o,v,f),h(o,g,f),e(g,u),e(u,F),$(m,F,null),e(g,_),e(g,q),e(q,_t),h(o,Ar,f),h(o,X,f),e(X,ce),e(ce,Vo),$(Me,Vo,null),e(X,vt),e(X,Go),e(Go,Ft),h(o,Dr,f),h(o,me,f),e(me,Pt),e(me,Ie),e(Ie,bt),e(me,$t),h(o,Lr,f),h(o,io,f),e(io,wt),h(o,Nr,f),h(o,co,f),e(co,Wo),e(Wo,yt),h(o,Or,f),h(o,fe,f),e(fe,Tt),e(fe,je),e(je,Et),e(fe,xt),h(o,qr,f),h(o,ze,f),h(o,Sr,f),h(o,mo,f),e(mo,Ct),h(o,Hr,f),h(o,H,f),e(H,Ae),e(Ae,kt),e(Ae,De),e(De,Mt),e(Ae,It),e(H,jt),e(H,Le),e(Le,zt),e(Le,fo),e(fo,At),e(Le,Dt),e(H,Lt),e(H,Yo),e(Yo,Nt),h(o,Rr,f),h(o,pe,f),e(pe,Jo),e(Jo,x),e(x,po),e(po,Ko),e(Ko,Ot),e(x,qt),e(x,Xo),e(Xo,Zo),e(Zo,St),e(x,Ht),e(x,Qo),e(Qo,er),e(er,Rt),e(x,Bt),e(x,ho),e(ho,or),e(or,Ut),e(x,Vt),e(x,uo),e(uo,rr),e(rr,Gt),e(pe,Wt),e(pe,C),e(C,k),e(k,go),e(go,Yt),e(k,Jt),e(k,tr),e(tr,Kt),e(k,Xt),e(k,ar),e(ar,Zt),e(k,Qt),e(k,_o),e(_o,ea),e(k,oa),e(k,vo),e(vo,ra),e(C,ta),e(C,M),e(M,Fo),e(Fo,aa),e(M,sa),e(M,sr),e(sr,na),e(M,la),e(M,nr),e(nr,ia),e(M,da),e(M,Po),e(Po,ca),e(M,ma),e(M,bo),e(bo,fa),e(C,pa),e(C,I),e(I,$o),e($o,ha),e(I,ua),e(I,lr),e(lr,ga),e(I,_a),e(I,ir),e(ir,va),e(I,Fa),e(I,wo),e(wo,Pa),e(I,ba),e(I,yo),e(yo,$a),e(C,wa),e(C,j),e(j,To),e(To,ya),e(j,Ta),e(j,dr),e(dr,Ea),e(j,xa),e(j,cr),e(cr,Ca),e(j,ka),e(j,Eo),e(Eo,Ma),e(j,Ia),e(j,xo),e(xo,ja),e(C,za),e(C,z),e(z,Co),e(Co,Aa),e(z,Da),e(z,mr),e(mr,La),e(z,Na),e(z,fr),e(fr,Oa),e(z,qa),e(z,ko),e(ko,Sa),e(z,Ha),e(z,Mo),e(Mo,Ra),h(o,Br,f),h(o,R,f),e(R,Ba),e(R,Ne),e(Ne,Ua),e(R,Va),e(R,Oe),e(Oe,Ga),e(R,Wa),h(o,Ur,f),h(o,Z,f),e(Z,he),e(he,pr),$(qe,pr,null),e(Z,Ya),e(Z,hr),e(hr,Ja),h(o,Vr,f),h(o,Q,f),$(Se,Q,null),e(Q,Ka),e(Q,ur),e(ur,Xa),h(o,Gr,f),h(o,ee,f),$(He,ee,null),e(ee,Za),e(ee,gr),e(gr,Qa),h(o,Wr,f),h(o,oe,f),e(oe,ue),e(ue,_r),$(Re,_r,null),e(oe,es),e(oe,vr),e(vr,os),h(o,Yr,f),h(o,A,f),$(Be,A,null),e(A,rs),e(A,re),e(re,ts),e(re,Io),e(Io,as),e(re,ss),e(re,Ue),e(Ue,ns),e(re,ls),e(A,is),e(A,te),e(te,ds),e(te,jo),e(jo,cs),e(te,ms),e(te,zo),e(zo,fs),e(te,ps),e(A,hs),$(ge,A,null),h(o,Jr,f),h(o,ae,f),e(ae,_e),e(_e,Fr),$(Ve,Fr,null),e(ae,us),e(ae,Pr),e(Pr,gs),h(o,Kr,f),h(o,D,f),$(Ge,D,null),e(D,_s),e(D,br),e(br,vs),e(D,Fs),e(D,We),e(We,Ps),e(We,Ao),e(Ao,bs),e(We,$s),e(D,ws),e(D,B),$(Ye,B,null),e(B,ys),e(B,$r),e($r,Ts),e(B,Es),$(ve,B,null),h(o,Xr,f),h(o,se,f),e(se,Fe),e(Fe,wr),$(Je,wr,null),e(se,xs),e(se,yr),e(yr,Cs),h(o,Zr,f),h(o,S,f),$(Ke,S,null),e(S,ks),e(S,Xe),e(Xe,Ms),e(Xe,Ze),e(Ze,Is),e(Xe,js),e(S,zs),e(S,N),$(Qe,N,null),e(N,As),e(N,ne),e(ne,Ds),e(ne,Do),e(Do,Ls),e(ne,Ns),e(ne,Tr),e(Tr,Os),e(ne,qs),e(N,Ss),$(Pe,N,null),e(N,Hs),$(be,N,null),h(o,Qr,f),h(o,le,f),e(le,$e),e($e,Er),$(eo,Er,null),e(le,Rs),e(le,xr),e(xr,Bs),h(o,et,f),h(o,L,f),$(oo,L,null),e(L,Us),e(L,Cr),e(Cr,Vs),e(L,Gs),e(L,ro),e(ro,Ws),e(ro,to),e(to,Ys),e(ro,Js),e(L,Ks),e(L,O),$(ao,O,null),e(O,Xs),e(O,ie),e(ie,Zs),e(ie,Lo),e(Lo,Qs),e(ie,en),e(ie,kr),e(kr,on),e(ie,rn),e(O,tn),$(we,O,null),e(O,an),$(ye,O,null),ot=!0},p(o,[f]){const so={};f&2&&(so.$$scope={dirty:f,ctx:o}),ge.$set(so);const Mr={};f&2&&(Mr.$$scope={dirty:f,ctx:o}),ve.$set(Mr);const Ir={};f&2&&(Ir.$$scope={dirty:f,ctx:o}),Pe.$set(Ir);const jr={};f&2&&(jr.$$scope={dirty:f,ctx:o}),be.$set(jr);const no={};f&2&&(no.$$scope={dirty:f,ctx:o}),we.$set(no);const zr={};f&2&&(zr.$$scope={dirty:f,ctx:o}),ye.$set(zr)},i(o){ot||(w(m.$$.fragment,o),w(Me.$$.fragment,o),w(qe.$$.fragment,o),w(Se.$$.fragment,o),w(He.$$.fragment,o),w(Re.$$.fragment,o),w(Be.$$.fragment,o),w(ge.$$.fragment,o),w(Ve.$$.fragment,o),w(Ge.$$.fragment,o),w(Ye.$$.fragment,o),w(ve.$$.fragment,o),w(Je.$$.fragment,o),w(Ke.$$.fragment,o),w(Qe.$$.fragment,o),w(Pe.$$.fragment,o),w(be.$$.fragment,o),w(eo.$$.fragment,o),w(oo.$$.fragment,o),w(ao.$$.fragment,o),w(we.$$.fragment,o),w(ye.$$.fragment,o),ot=!0)},o(o){y(m.$$.fragment,o),y(Me.$$.fragment,o),y(qe.$$.fragment,o),y(Se.$$.fragment,o),y(He.$$.fragment,o),y(Re.$$.fragment,o),y(Be.$$.fragment,o),y(ge.$$.fragment,o),y(Ve.$$.fragment,o),y(Ge.$$.fragment,o),y(Ye.$$.fragment,o),y(ve.$$.fragment,o),y(Je.$$.fragment,o),y(Ke.$$.fragment,o),y(Qe.$$.fragment,o),y(Pe.$$.fragment,o),y(be.$$.fragment,o),y(eo.$$.fragment,o),y(oo.$$.fragment,o),y(ao.$$.fragment,o),y(we.$$.fragment,o),y(ye.$$.fragment,o),ot=!1},d(o){r(p),o&&r(v),o&&r(g),T(m),o&&r(Ar),o&&r(X),T(Me),o&&r(Dr),o&&r(me),o&&r(Lr),o&&r(io),o&&r(Nr),o&&r(co),o&&r(Or),o&&r(fe),o&&r(qr),o&&r(ze),o&&r(Sr),o&&r(mo),o&&r(Hr),o&&r(H),o&&r(Rr),o&&r(pe),o&&r(Br),o&&r(R),o&&r(Ur),o&&r(Z),T(qe),o&&r(Vr),o&&r(Q),T(Se),o&&r(Gr),o&&r(ee),T(He),o&&r(Wr),o&&r(oe),T(Re),o&&r(Yr),o&&r(A),T(Be),T(ge),o&&r(Jr),o&&r(ae),T(Ve),o&&r(Kr),o&&r(D),T(Ge),T(Ye),T(ve),o&&r(Xr),o&&r(se),T(Je),o&&r(Zr),o&&r(S),T(Ke),T(Qe),T(Pe),T(be),o&&r(Qr),o&&r(le),T(eo),o&&r(et),o&&r(L),T(oo),T(ao),T(we),T(ye)}}}const Kl={local:"poolformer",sections:[{local:"overview",title:"Overview"},{local:"transformers.models.poolformer.modeling_poolformer.PoolFormerModelOutput",title:"PoolFormer specific outputs"},{local:"transformers.PoolFormerConfig",title:"PoolFormerConfig"},{local:"transformers.PoolFormerFeatureExtractor",title:"PoolFormerFeatureExtractor"},{local:"transformers.PoolFormerModel",title:"PoolFormerModel"},{local:"transformers.PoolFormerForImageClassification",title:"PoolFormerForImageClassification"}],title:"PoolFormer"};function Xl(E){return Rl(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class ai extends Nl{constructor(p){super();Ol(this,p,Xl,Jl,ql,{})}}export{ai as default,Kl as metadata};
