import{S as wi,i as $i,s as yi,e as r,k as i,w as E,t as o,M as Ei,c as s,d as t,m as p,a as n,x as D,h as l,b,F as e,g,y as j,q as k,o as P,B as x,v as Di,L as Aa}from"../../chunks/vendor-6b77c823.js";import{D as A}from"../../chunks/Docstring-1088f2fb.js";import{C as Ua}from"../../chunks/CodeBlock-3a8b25a8.js";import{I as it}from"../../chunks/IconCopyLink-7a11ce68.js";import{E as Ca}from"../../chunks/ExampleCodeBlock-5212b321.js";function ji(U){let m,T,w,u,$;return u=new Ua({props:{code:"debug_overflow = DebugUnderflowOverflow(model)",highlighted:"debug_overflow = DebugUnderflowOverflow(model)"}}),{c(){m=r("p"),T=o("To activate the underflow/overflow detection, initialize the object with the model :"),w=i(),E(u.$$.fragment)},l(c){m=s(c,"P",{});var v=n(m);T=l(v,"To activate the underflow/overflow detection, initialize the object with the model :"),v.forEach(t),w=p(c),D(u.$$.fragment,c)},m(c,v){g(c,m,v),e(m,T),g(c,w,v),j(u,c,v),$=!0},p:Aa,i(c){$||(k(u.$$.fragment,c),$=!0)},o(c){P(u.$$.fragment,c),$=!1},d(c){c&&t(m),c&&t(w),x(u,c)}}}function ki(U){let m,T,w,u,$;return u=new Ua({props:{code:`Detected inf/nan during batch_number=0
Last 21 forward frames:
abs min  abs max  metadata
[...]
                  encoder.block.2.layer.1.DenseReluDense.wi_0 Linear
2.17e-07 4.50e+00 weight
1.79e-06 4.65e+00 input[0]
2.68e-06 3.70e+01 output
                  encoder.block.2.layer.1.DenseReluDense.wi_1 Linear
8.08e-07 2.66e+01 weight
1.79e-06 4.65e+00 input[0]
1.27e-04 2.37e+02 output
                  encoder.block.2.layer.1.DenseReluDense.wo Linear
1.01e-06 6.44e+00 weight
0.00e+00 9.74e+03 input[0]
3.18e-04 6.27e+04 output
                  encoder.block.2.layer.1.DenseReluDense T5DenseGatedGeluDense
1.79e-06 4.65e+00 input[0]
3.18e-04 6.27e+04 output
                  encoder.block.2.layer.1.dropout Dropout
3.18e-04 6.27e+04 input[0]
0.00e+00      inf output`,highlighted:`<span class="hljs-attribute">Detected</span> inf/nan during batch_number=<span class="hljs-number">0</span>
<span class="hljs-attribute">Last</span> <span class="hljs-number">21</span> forward frames:
<span class="hljs-attribute">abs</span> min  abs max  metadata<span class="hljs-meta">
[...]</span>
                  <span class="hljs-attribute">encoder</span>.block.<span class="hljs-number">2</span>.layer.<span class="hljs-number">1</span>.DenseReluDense.wi_0 Linear
<span class="hljs-attribute">2</span>.<span class="hljs-number">17</span>e-<span class="hljs-number">07</span> <span class="hljs-number">4</span>.<span class="hljs-number">50</span>e+<span class="hljs-number">00</span> weight
<span class="hljs-attribute">1</span>.<span class="hljs-number">79</span>e-<span class="hljs-number">06</span> <span class="hljs-number">4</span>.<span class="hljs-number">65</span>e+<span class="hljs-number">00</span> input[<span class="hljs-number">0</span>]
<span class="hljs-attribute">2</span>.<span class="hljs-number">68</span>e-<span class="hljs-number">06</span> <span class="hljs-number">3</span>.<span class="hljs-number">70</span>e+<span class="hljs-number">01</span> output
                  <span class="hljs-attribute">encoder</span>.block.<span class="hljs-number">2</span>.layer.<span class="hljs-number">1</span>.DenseReluDense.wi_1 Linear
<span class="hljs-attribute">8</span>.<span class="hljs-number">08</span>e-<span class="hljs-number">07</span> <span class="hljs-number">2</span>.<span class="hljs-number">66</span>e+<span class="hljs-number">01</span> weight
<span class="hljs-attribute">1</span>.<span class="hljs-number">79</span>e-<span class="hljs-number">06</span> <span class="hljs-number">4</span>.<span class="hljs-number">65</span>e+<span class="hljs-number">00</span> input[<span class="hljs-number">0</span>]
<span class="hljs-attribute">1</span>.<span class="hljs-number">27</span>e-<span class="hljs-number">04</span> <span class="hljs-number">2</span>.<span class="hljs-number">37</span>e+<span class="hljs-number">02</span> output
                  <span class="hljs-attribute">encoder</span>.block.<span class="hljs-number">2</span>.layer.<span class="hljs-number">1</span>.DenseReluDense.wo Linear
<span class="hljs-attribute">1</span>.<span class="hljs-number">01</span>e-<span class="hljs-number">06</span> <span class="hljs-number">6</span>.<span class="hljs-number">44</span>e+<span class="hljs-number">00</span> weight
<span class="hljs-attribute">0</span>.<span class="hljs-number">00</span>e+<span class="hljs-number">00</span> <span class="hljs-number">9</span>.<span class="hljs-number">74</span>e+<span class="hljs-number">03</span> input[<span class="hljs-number">0</span>]
<span class="hljs-attribute">3</span>.<span class="hljs-number">18</span>e-<span class="hljs-number">04</span> <span class="hljs-number">6</span>.<span class="hljs-number">27</span>e+<span class="hljs-number">04</span> output
                  <span class="hljs-attribute">encoder</span>.block.<span class="hljs-number">2</span>.layer.<span class="hljs-number">1</span>.DenseReluDense T5DenseGatedGeluDense
<span class="hljs-attribute">1</span>.<span class="hljs-number">79</span>e-<span class="hljs-number">06</span> <span class="hljs-number">4</span>.<span class="hljs-number">65</span>e+<span class="hljs-number">00</span> input[<span class="hljs-number">0</span>]
<span class="hljs-attribute">3</span>.<span class="hljs-number">18</span>e-<span class="hljs-number">04</span> <span class="hljs-number">6</span>.<span class="hljs-number">27</span>e+<span class="hljs-number">04</span> output
                  <span class="hljs-attribute">encoder</span>.block.<span class="hljs-number">2</span>.layer.<span class="hljs-number">1</span>.dropout Dropout
<span class="hljs-attribute">3</span>.<span class="hljs-number">18</span>e-<span class="hljs-number">04</span> <span class="hljs-number">6</span>.<span class="hljs-number">27</span>e+<span class="hljs-number">04</span> input[<span class="hljs-number">0</span>]
<span class="hljs-attribute">0</span>.<span class="hljs-number">00</span>e+<span class="hljs-number">00</span>      inf output`}}),{c(){m=r("p"),T=o("mixed precision :"),w=i(),E(u.$$.fragment)},l(c){m=s(c,"P",{});var v=n(m);T=l(v,"mixed precision :"),v.forEach(t),w=p(c),D(u.$$.fragment,c)},m(c,v){g(c,m,v),e(m,T),g(c,w,v),j(u,c,v),$=!0},p:Aa,i(c){$||(k(u.$$.fragment,c),$=!0)},o(c){P(u.$$.fragment,c),$=!1},d(c){c&&t(m),c&&t(w),x(u,c)}}}function Pi(U){let m,T,w,u,$;return u=new Ua({props:{code:"debug_overflow = DebugUnderflowOverflow(model, max_frames_to_save=100)",highlighted:'debug_overflow = DebugUnderflowOverflow(model, max_frames_to_save=<span class="hljs-number">100</span>)'}}),{c(){m=r("p"),T=o("By default the last 21 frames are printed. You can change the default to adjust for your needs. For example :"),w=i(),E(u.$$.fragment)},l(c){m=s(c,"P",{});var v=n(m);T=l(v,"By default the last 21 frames are printed. You can change the default to adjust for your needs. For example :"),v.forEach(t),w=p(c),D(u.$$.fragment,c)},m(c,v){g(c,m,v),e(m,T),g(c,w,v),j(u,c,v),$=!0},p:Aa,i(c){$||(k(u.$$.fragment,c),$=!0)},o(c){P(u.$$.fragment,c),$=!1},d(c){c&&t(m),c&&t(w),x(u,c)}}}function xi(U){let m,T,w,u,$;return u=new Ua({props:{code:"debug_overflow = DebugUnderflowOverflow(model, trace_batch_nums=[1, 3])",highlighted:'debug_overflow = DebugUnderflowOverflow(model, trace_batch_nums=[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>])'}}),{c(){m=r("p"),T=o("given batch, and only do that for batches 1 and 3. Then you instantiate this class as :"),w=i(),E(u.$$.fragment)},l(c){m=s(c,"P",{});var v=n(m);T=l(v,"given batch, and only do that for batches 1 and 3. Then you instantiate this class as :"),v.forEach(t),w=p(c),D(u.$$.fragment,c)},m(c,v){g(c,m,v),e(m,T),g(c,w,v),j(u,c,v),$=!0},p:Aa,i(c){$||(k(u.$$.fragment,c),$=!0)},o(c){P(u.$$.fragment,c),$=!1},d(c){c&&t(m),c&&t(w),x(u,c)}}}function Ti(U){let m,T,w,u,$;return u=new Ua({props:{code:"debug_overflow = DebugUnderflowOverflow(model, trace_batch_nums=[1, 3], abort_after_batch_num=3)",highlighted:'debug_overflow = DebugUnderflowOverflow(model, trace_batch_nums=[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>], abort_after_batch_num=<span class="hljs-number">3</span>)'}}),{c(){m=r("p"),T=o("You can also specify the batch number after which to stop the training, with :"),w=i(),E(u.$$.fragment)},l(c){m=s(c,"P",{});var v=n(m);T=l(v,"You can also specify the batch number after which to stop the training, with :"),v.forEach(t),w=p(c),D(u.$$.fragment,c)},m(c,v){g(c,m,v),e(m,T),g(c,w,v),j(u,c,v),$=!0},p:Aa,i(c){$||(k(u.$$.fragment,c),$=!0)},o(c){P(u.$$.fragment,c),$=!1},d(c){c&&t(m),c&&t(w),x(u,c)}}}function Oi(U){let m,T,w,u,$,c,v,pt,yr,La,Z,Er,Ke,Dr,jr,Ia,Ye,kr,za,N,ee,ct,me,Pr,dt,xr,Sa,H,ge,Tr,ht,Or,Na,G,be,Cr,ut,Ar,Ha,V,ve,Ur,C,Lr,ft,Ir,zr,mt,Sr,Nr,gt,Hr,Gr,bt,Vr,Mr,Ga,M,_e,Rr,vt,Fr,Va,R,te,_t,we,qr,wt,Br,Ma,F,$e,Kr,$t,Yr,Ra,q,ae,yt,ye,Wr,Et,Jr,Fa,_,Ee,Qr,Dt,Xr,Zr,jt,es,ts,kt,Pt,as,rs,xt,ss,ns,B,We,os,Tt,ls,is,Je,ps,Ot,cs,ds,Qe,hs,Ct,us,fs,At,ms,gs,K,Xe,bs,Ut,vs,_s,Ze,ws,Lt,$s,ys,et,Es,It,Ds,js,zt,ks,Ps,St,Nt,xs,Ts,Ht,Os,Cs,Gt,Vt,As,Us,Mt,Ls,Is,re,De,zs,je,Ss,Rt,Ns,Hs,Gs,se,ke,Vs,Ft,Ms,qa,Y,ne,qt,Pe,Rs,Bt,Fs,Ba,O,xe,qs,Te,Bs,Kt,Ks,Ys,Ws,Oe,Js,Yt,Qs,Xs,Zs,z,Ce,en,Wt,tn,an,Ae,rn,Jt,sn,nn,on,oe,Ue,ln,Le,pn,Qt,cn,dn,hn,le,Ie,un,ze,fn,Xt,mn,gn,Ka,W,ie,Zt,Se,bn,ea,vn,Ya,d,Ne,_n,J,wn,ta,$n,yn,aa,En,Dn,jn,ra,kn,Pn,He,sa,xn,Tn,na,On,Cn,oa,An,Un,pe,Ln,I,In,la,zn,Sn,ia,Nn,Hn,pa,Gn,Vn,Mn,Ge,Ve,Rn,ca,Fn,qn,Bn,da,Kn,Yn,Me,Wn,ha,Jn,Qn,Xn,ce,Zn,Q,eo,ua,to,ao,fa,ro,so,no,ma,oo,lo,Re,io,ga,po,co,ho,de,uo,ba,fo,mo,va,go,bo,_a,vo,_o,Fe,wo,wa,$o,yo,Eo,he,Do,$a,jo,ko,ya,Po,xo,Ea,To,Oo,ue,Co,Da,Ao,Uo,tt,ja,Lo,Io,zo,X,So,ka,No,Ho,Pa,Go,Vo,Wa;return c=new it({}),me=new it({}),ge=new A({props:{name:"class transformers.EvalPrediction",anchor:"transformers.EvalPrediction",parameters:[{name:"predictions",val:": typing.Union[numpy.ndarray, typing.Tuple[numpy.ndarray]]"},{name:"label_ids",val:": typing.Union[numpy.ndarray, typing.Tuple[numpy.ndarray]]"},{name:"inputs",val:": typing.Union[numpy.ndarray, typing.Tuple[numpy.ndarray], NoneType] = None"}],parametersDescription:[{anchor:"transformers.EvalPrediction.predictions",description:"<strong>predictions</strong> (<code>np.ndarray</code>) &#x2014; Predictions of the model.",name:"predictions"},{anchor:"transformers.EvalPrediction.label_ids",description:"<strong>label_ids</strong> (<code>np.ndarray</code>) &#x2014; Targets to be matched.",name:"label_ids"},{anchor:"transformers.EvalPrediction.inputs",description:"<strong>inputs</strong> (<code>np.ndarray</code>, <em>optional</em>) &#x2014;",name:"inputs"}],source:"https://github.com/huggingface/transformers/blob/vr_16995/src/transformers/trainer_utils.py#L66"}}),be=new A({props:{name:"class transformers.IntervalStrategy",anchor:"transformers.IntervalStrategy",parameters:[{name:"value",val:""},{name:"names",val:" = None"},{name:"module",val:" = None"},{name:"qualname",val:" = None"},{name:"type",val:" = None"},{name:"start",val:" = 1"}],source:"https://github.com/huggingface/transformers/blob/vr_16995/src/transformers/trainer_utils.py#L140"}}),ve=new A({props:{name:"transformers.set_seed",anchor:"transformers.set_seed",parameters:[{name:"seed",val:": int"}],parametersDescription:[{anchor:"transformers.set_seed.seed",description:"<strong>seed</strong> (<code>int</code>) &#x2014; The seed to set.",name:"seed"}],source:"https://github.com/huggingface/transformers/blob/vr_16995/src/transformers/trainer_utils.py#L49"}}),_e=new A({props:{name:"transformers.torch_distributed_zero_first",anchor:"transformers.torch_distributed_zero_first",parameters:[{name:"local_rank",val:": int"}],parametersDescription:[{anchor:"transformers.torch_distributed_zero_first.local_rank",description:"<strong>local_rank</strong> (<code>int</code>) &#x2014; The rank of the local process.",name:"local_rank"}],source:"https://github.com/huggingface/transformers/blob/vr_16995/src/transformers/trainer_pt_utils.py#L204"}}),we=new it({}),$e=new A({props:{name:"class transformers.trainer_callback.CallbackHandler",anchor:"transformers.trainer_callback.CallbackHandler",parameters:[{name:"callbacks",val:""},{name:"model",val:""},{name:"tokenizer",val:""},{name:"optimizer",val:""},{name:"lr_scheduler",val:""}],source:"https://github.com/huggingface/transformers/blob/vr_16995/src/transformers/trainer_callback.py#L284"}}),ye=new it({}),Ee=new A({props:{name:"class transformers.trainer_pt_utils.DistributedTensorGatherer",anchor:"transformers.trainer_pt_utils.DistributedTensorGatherer",parameters:[{name:"world_size",val:""},{name:"num_samples",val:""},{name:"make_multiple_of",val:" = None"},{name:"padding_index",val:" = -100"}],parametersDescription:[{anchor:"transformers.trainer_pt_utils.DistributedTensorGatherer.world_size",description:`<strong>world_size</strong> (<code>int</code>) &#x2014;
The number of processes used in the distributed training.`,name:"world_size"},{anchor:"transformers.trainer_pt_utils.DistributedTensorGatherer.num_samples",description:`<strong>num_samples</strong> (<code>int</code>) &#x2014;
The number of samples in our dataset.`,name:"num_samples"},{anchor:"transformers.trainer_pt_utils.DistributedTensorGatherer.make_multiple_of",description:`<strong>make_multiple_of</strong> (<code>int</code>, <em>optional</em>) &#x2014;
If passed, the class assumes the datasets passed to each process are made to be a multiple of this argument
(by adding samples).`,name:"make_multiple_of"},{anchor:"transformers.trainer_pt_utils.DistributedTensorGatherer.padding_index",description:`<strong>padding_index</strong> (<code>int</code>, <em>optional</em>, defaults to -100) &#x2014;
The padding index to use if the arrays don&#x2019;t all have the same sequence length.`,name:"padding_index"}],source:"https://github.com/huggingface/transformers/blob/vr_16995/src/transformers/trainer_pt_utils.py#L330"}}),De=new A({props:{name:"add_arrays",anchor:"transformers.trainer_pt_utils.DistributedTensorGatherer.add_arrays",parameters:[{name:"arrays",val:""}],source:"https://github.com/huggingface/transformers/blob/vr_16995/src/transformers/trainer_pt_utils.py#L391"}}),ke=new A({props:{name:"finalize",anchor:"transformers.trainer_pt_utils.DistributedTensorGatherer.finalize",parameters:[],source:"https://github.com/huggingface/transformers/blob/vr_16995/src/transformers/trainer_pt_utils.py#L427"}}),Pe=new it({}),xe=new A({props:{name:"class transformers.HfArgumentParser",anchor:"transformers.HfArgumentParser",parameters:[{name:"dataclass_types",val:": typing.Union[DataClassType, typing.Iterable[DataClassType]]"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/vr_16995/src/transformers/hf_argparser.py#L44"}}),Ce=new A({props:{name:"parse_args_into_dataclasses",anchor:"transformers.HfArgumentParser.parse_args_into_dataclasses",parameters:[{name:"args",val:" = None"},{name:"return_remaining_strings",val:" = False"},{name:"look_for_args_file",val:" = True"},{name:"args_filename",val:" = None"}],source:"https://github.com/huggingface/transformers/blob/vr_16995/src/transformers/hf_argparser.py#L168",returnDescription:`
<ul>
<li>the dataclass instances in the same order as they were passed to the initializer.abspath</li>
<li>if applicable, an additional namespace for more (non-dataclass backed) arguments added to the parser
after initialization.</li>
<li>The potential list of remaining argument strings. (same as argparse.ArgumentParser.parse_known_args)</li>
</ul>
`,returnType:`
<p>Tuple consisting of</p>
`}}),Ue=new A({props:{name:"parse_dict",anchor:"transformers.HfArgumentParser.parse_dict",parameters:[{name:"args",val:": dict"}],source:"https://github.com/huggingface/transformers/blob/vr_16995/src/transformers/hf_argparser.py#L241"}}),Ie=new A({props:{name:"parse_json_file",anchor:"transformers.HfArgumentParser.parse_json_file",parameters:[{name:"json_file",val:": str"}],source:"https://github.com/huggingface/transformers/blob/vr_16995/src/transformers/hf_argparser.py#L227"}}),Se=new it({}),Ne=new A({props:{name:"class transformers.debug_utils.DebugUnderflowOverflow",anchor:"transformers.debug_utils.DebugUnderflowOverflow",parameters:[{name:"model",val:""},{name:"max_frames_to_save",val:" = 21"},{name:"trace_batch_nums",val:" = []"},{name:"abort_after_batch_num",val:" = None"}],parametersDescription:[{anchor:"transformers.debug_utils.DebugUnderflowOverflow.model",description:`<strong>model</strong> (<code>nn.Module</code>) &#x2014;
The model to debug.`,name:"model"},{anchor:"transformers.debug_utils.DebugUnderflowOverflow.max_frames_to_save",description:`<strong>max_frames_to_save</strong> (<code>int</code>, <em>optional</em>, defaults to 21) &#x2014;
How many frames back to record`,name:"max_frames_to_save"},{anchor:"transformers.debug_utils.DebugUnderflowOverflow.trace_batch_nums(List[int],",description:`<strong>trace_batch_nums(<code>List[int]</code>,</strong> <em>optional</em>, defaults to <code>[]</code>) &#x2014;
Which batch numbers to trace (turns detection off)`,name:"trace_batch_nums(List[int],"},{anchor:"transformers.debug_utils.DebugUnderflowOverflow.abort_after_batch_num",description:"<strong>abort_after_batch_num</strong>  (`int&#x201C;, <em>optional</em>) &#x2014;\nWhether to abort after a certain batch number has finished",name:"abort_after_batch_num"}],source:"https://github.com/huggingface/transformers/blob/vr_16995/src/transformers/debug_utils.py#L27"}}),pe=new Ca({props:{anchor:"transformers.debug_utils.DebugUnderflowOverflow.example",$$slots:{default:[ji]},$$scope:{ctx:U}}}),ce=new Ca({props:{anchor:"transformers.debug_utils.DebugUnderflowOverflow.example-2",$$slots:{default:[ki]},$$scope:{ctx:U}}}),de=new Ca({props:{anchor:"transformers.debug_utils.DebugUnderflowOverflow.example-3",$$slots:{default:[Pi]},$$scope:{ctx:U}}}),he=new Ca({props:{anchor:"transformers.debug_utils.DebugUnderflowOverflow.example-4",$$slots:{default:[xi]},$$scope:{ctx:U}}}),ue=new Ca({props:{anchor:"transformers.debug_utils.DebugUnderflowOverflow.example-5",$$slots:{default:[Ti]},$$scope:{ctx:U}}}),{c(){m=r("meta"),T=i(),w=r("h1"),u=r("a"),$=r("span"),E(c.$$.fragment),v=i(),pt=r("span"),yr=o("Utilities for Trainer"),La=i(),Z=r("p"),Er=o("This page lists all the utility functions used by "),Ke=r("a"),Dr=o("Trainer"),jr=o("."),Ia=i(),Ye=r("p"),kr=o("Most of those are only useful if you are studying the code of the Trainer in the library."),za=i(),N=r("h2"),ee=r("a"),ct=r("span"),E(me.$$.fragment),Pr=i(),dt=r("span"),xr=o("Utilities"),Sa=i(),H=r("div"),E(ge.$$.fragment),Tr=i(),ht=r("p"),Or=o("Evaluation output (always contains labels), to be used to compute metrics."),Na=i(),G=r("div"),E(be.$$.fragment),Cr=i(),ut=r("p"),Ar=o("An enumeration."),Ha=i(),V=r("div"),E(ve.$$.fragment),Ur=i(),C=r("p"),Lr=o("Helper function for reproducible behavior to set the seed in "),ft=r("code"),Ir=o("random"),zr=o(", "),mt=r("code"),Sr=o("numpy"),Nr=o(", "),gt=r("code"),Hr=o("torch"),Gr=o(" and/or "),bt=r("code"),Vr=o("tf"),Mr=o(" (if installed)."),Ga=i(),M=r("div"),E(_e.$$.fragment),Rr=i(),vt=r("p"),Fr=o("Decorator to make all processes in distributed training wait for each local_master to do something."),Va=i(),R=r("h2"),te=r("a"),_t=r("span"),E(we.$$.fragment),qr=i(),wt=r("span"),Br=o("Callbacks internals"),Ma=i(),F=r("div"),E($e.$$.fragment),Kr=i(),$t=r("p"),Yr=o("Internal class that just calls the list of callbacks in order."),Ra=i(),q=r("h2"),ae=r("a"),yt=r("span"),E(ye.$$.fragment),Wr=i(),Et=r("span"),Jr=o("Distributed Evaluation"),Fa=i(),_=r("div"),E(Ee.$$.fragment),Qr=i(),Dt=r("p"),Xr=o("A class responsible for properly gathering tensors (or nested list/tuple of tensors) on the CPU by chunks."),Zr=i(),jt=r("p"),es=o(`If our dataset has 16 samples with a batch size of 2 on 3 processes and we gather then transfer on CPU at every
step, our sampler will generate the following indices:`),ts=i(),kt=r("p"),Pt=r("code"),as=o("[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1]"),rs=i(),xt=r("p"),ss=o(`to get something of size a multiple of 3 (so that each process gets the same dataset length). Then process 0, 1 and
2 will be responsible of making predictions for the following samples:`),ns=i(),B=r("ul"),We=r("li"),os=o("P0: "),Tt=r("code"),ls=o("[0, 1, 2, 3, 4, 5]"),is=i(),Je=r("li"),ps=o("P1: "),Ot=r("code"),cs=o("[6, 7, 8, 9, 10, 11]"),ds=i(),Qe=r("li"),hs=o("P2: "),Ct=r("code"),us=o("[12, 13, 14, 15, 0, 1]"),fs=i(),At=r("p"),ms=o("The first batch treated on each process will be"),gs=i(),K=r("ul"),Xe=r("li"),bs=o("P0: "),Ut=r("code"),vs=o("[0, 1]"),_s=i(),Ze=r("li"),ws=o("P1: "),Lt=r("code"),$s=o("[6, 7]"),ys=i(),et=r("li"),Es=o("P2: "),It=r("code"),Ds=o("[12, 13]"),js=i(),zt=r("p"),ks=o(`So if we gather at the end of the first batch, we will get a tensor (nested list/tuple of tensor) corresponding to
the following indices:`),Ps=i(),St=r("p"),Nt=r("code"),xs=o("[0, 1, 6, 7, 12, 13]"),Ts=i(),Ht=r("p"),Os=o(`If we directly concatenate our results without taking any precautions, the user will then get the predictions for
the indices in this order at the end of the prediction loop:`),Cs=i(),Gt=r("p"),Vt=r("code"),As=o("[0, 1, 6, 7, 12, 13, 2, 3, 8, 9, 14, 15, 4, 5, 10, 11, 0, 1]"),Us=i(),Mt=r("p"),Ls=o("For some reason, that\u2019s not going to roll their boat. This class is there to solve that problem."),Is=i(),re=r("div"),E(De.$$.fragment),zs=i(),je=r("p"),Ss=o("Add "),Rt=r("code"),Ns=o("arrays"),Hs=o(` to the internal storage, Will initialize the storage to the full size at the first arrays passed
so that if we\u2019re bound to get an OOM, it happens at the beginning.`),Gs=i(),se=r("div"),E(ke.$$.fragment),Vs=i(),Ft=r("p"),Ms=o(`Return the properly gathered arrays and truncate to the number of samples (since the sampler added some extras
to get each process a dataset of the same length).`),qa=i(),Y=r("h2"),ne=r("a"),qt=r("span"),E(Pe.$$.fragment),Rs=i(),Bt=r("span"),Fs=o("Distributed Evaluation"),Ba=i(),O=r("div"),E(xe.$$.fragment),qs=i(),Te=r("p"),Bs=o("This subclass of "),Kt=r("code"),Ks=o("argparse.ArgumentParser"),Ys=o(" uses type hints on dataclasses to generate arguments."),Ws=i(),Oe=r("p"),Js=o(`The class is designed to play well with the native argparse. In particular, you can add more (non-dataclass backed)
arguments to the parser after initialization and you\u2019ll get the output back after parsing as an additional
namespace. Optional: To create sub argument groups use the `),Yt=r("code"),Qs=o("_argument_group_name"),Xs=o(" attribute in the dataclass."),Zs=i(),z=r("div"),E(Ce.$$.fragment),en=i(),Wt=r("p"),tn=o("Parse command-line args into instances of the specified dataclass types."),an=i(),Ae=r("p"),rn=o("This relies on argparse\u2019s "),Jt=r("code"),sn=o("ArgumentParser.parse_known_args"),nn=o(`. See the doc at:
docs.python.org/3.7/library/argparse.html#argparse.ArgumentParser.parse_args`),on=i(),oe=r("div"),E(Ue.$$.fragment),ln=i(),Le=r("p"),pn=o("Alternative helper method that does not use "),Qt=r("code"),cn=o("argparse"),dn=o(` at all, instead uses a dict and populating the dataclass
types.`),hn=i(),le=r("div"),E(Ie.$$.fragment),un=i(),ze=r("p"),fn=o("Alternative helper method that does not use "),Xt=r("code"),mn=o("argparse"),gn=o(` at all, instead loading a json file and populating the
dataclass types.`),Ka=i(),W=r("h2"),ie=r("a"),Zt=r("span"),E(Se.$$.fragment),bn=i(),ea=r("span"),vn=o("Debug Utilities"),Ya=i(),d=r("div"),E(Ne.$$.fragment),_n=i(),J=r("p"),wn=o(`This debug class helps detect and understand where the model starts getting very large or very small, and more
importantly `),ta=r("code"),$n=o("nan"),yn=o(" or "),aa=r("code"),En=o("inf"),Dn=o(" weight and activation elements."),jn=i(),ra=r("p"),kn=o("There are 2 working modes:"),Pn=i(),He=r("ol"),sa=r("li"),xn=o("Underflow/overflow detection (default)"),Tn=i(),na=r("li"),On=o("Specific batch absolute min/max tracing without detection"),Cn=i(),oa=r("p"),An=o("Mode 1: Underflow/overflow detection"),Un=i(),E(pe.$$.fragment),Ln=i(),I=r("p"),In=o("then run the training as normal and if "),la=r("code"),zn=o("nan"),Sn=o(" or "),ia=r("code"),Nn=o("inf"),Hn=o(` gets detected in at least one of the weight, input or output
elements this module will throw an exception and will print `),pa=r("code"),Gn=o("max_frames_to_save"),Vn=o(` frames that lead to this event,
each frame reporting`),Mn=i(),Ge=r("ol"),Ve=r("li"),Rn=o("the fully qualified module name plus the class name whose "),ca=r("code"),Fn=o("forward"),qn=o(" was run"),Bn=i(),da=r("li"),Kn=o("the absolute min and max value of all elements for each module weights, and the inputs and output"),Yn=i(),Me=r("p"),Wn=o("For example, here is the header and the last few frames in detection report for "),ha=r("code"),Jn=o("google/mt5-small"),Qn=o(" run in fp16"),Xn=i(),E(ce.$$.fragment),Zn=i(),Q=r("p"),eo=o("You can see here, that "),ua=r("code"),to=o("T5DenseGatedGeluDense.forward"),ao=o(` resulted in output activations, whose absolute max value was
around 62.7K, which is very close to fp16\u2019s top limit of 64K. In the next frame we have `),fa=r("code"),ro=o("Dropout"),so=o(` which
renormalizes the weights, after it zeroed some of the elements, which pushes the absolute max value to more than
64K, and we get an overlow.`),no=i(),ma=r("p"),oo=o(`As you can see it\u2019s the previous frames that we need to look into when the numbers start going into very large for
fp16 numbers.`),lo=i(),Re=r("p"),io=o("The tracking is done in a forward hook, which gets invoked immediately after "),ga=r("code"),po=o("forward"),co=o(" has completed."),ho=i(),E(de.$$.fragment),uo=i(),ba=r("p"),fo=o(`To validate that you have set up this debugging feature correctly, and you intend to use it in a training that
may take hours to complete, first run it with normal tracing enabled for one of a few batches as explained in
the next section.`),mo=i(),va=r("p"),go=o("Mode 2. Specific batch absolute min/max tracing without detection"),bo=i(),_a=r("p"),vo=o("The second work mode is per-batch tracing with the underflow/overflow detection feature turned off."),_o=i(),Fe=r("p"),wo=o("Let\u2019s say you want to watch the absolute min and max values for all the ingredients of each "),wa=r("code"),$o=o("forward"),yo=o(" call of a"),Eo=i(),E(he.$$.fragment),Do=i(),$a=r("p"),jo=o("And now full batches 1 and 3 will be traced using the same format as explained above. Batches are 0-indexed."),ko=i(),ya=r("p"),Po=o(`This is helpful if you know that the program starts misbehaving after a certain batch number, so you can
fast-forward right to that area.`),xo=i(),Ea=r("p"),To=o("Early stopping:"),Oo=i(),E(ue.$$.fragment),Co=i(),Da=r("p"),Ao=o("This feature is mainly useful in the tracing mode, but you can use it for any mode."),Uo=i(),tt=r("p"),ja=r("strong"),Lo=o("Performance"),Io=o(":"),zo=i(),X=r("p"),So=o("As this module measures absolute "),ka=r("code"),No=o("min"),Ho=o("/`"),Pa=r("code"),Go=o("max"),Vo=o(` of each weight of the model on every forward it\u2019ll slow the training
down. Therefore remember to turn it off once the debugging needs have been met.`),this.h()},l(a){const f=Ei('[data-svelte="svelte-1phssyn"]',document.head);m=s(f,"META",{name:!0,content:!0}),f.forEach(t),T=p(a),w=s(a,"H1",{class:!0});var qe=n(w);u=s(qe,"A",{id:!0,class:!0,href:!0});var xa=n(u);$=s(xa,"SPAN",{});var Ta=n($);D(c.$$.fragment,Ta),Ta.forEach(t),xa.forEach(t),v=p(qe),pt=s(qe,"SPAN",{});var Oa=n(pt);yr=l(Oa,"Utilities for Trainer"),Oa.forEach(t),qe.forEach(t),La=p(a),Z=s(a,"P",{});var Be=n(Z);Er=l(Be,"This page lists all the utility functions used by "),Ke=s(Be,"A",{href:!0});var Wo=n(Ke);Dr=l(Wo,"Trainer"),Wo.forEach(t),jr=l(Be,"."),Be.forEach(t),Ia=p(a),Ye=s(a,"P",{});var Jo=n(Ye);kr=l(Jo,"Most of those are only useful if you are studying the code of the Trainer in the library."),Jo.forEach(t),za=p(a),N=s(a,"H2",{class:!0});var Ja=n(N);ee=s(Ja,"A",{id:!0,class:!0,href:!0});var Qo=n(ee);ct=s(Qo,"SPAN",{});var Xo=n(ct);D(me.$$.fragment,Xo),Xo.forEach(t),Qo.forEach(t),Pr=p(Ja),dt=s(Ja,"SPAN",{});var Zo=n(dt);xr=l(Zo,"Utilities"),Zo.forEach(t),Ja.forEach(t),Sa=p(a),H=s(a,"DIV",{class:!0});var Qa=n(H);D(ge.$$.fragment,Qa),Tr=p(Qa),ht=s(Qa,"P",{});var el=n(ht);Or=l(el,"Evaluation output (always contains labels), to be used to compute metrics."),el.forEach(t),Qa.forEach(t),Na=p(a),G=s(a,"DIV",{class:!0});var Xa=n(G);D(be.$$.fragment,Xa),Cr=p(Xa),ut=s(Xa,"P",{});var tl=n(ut);Ar=l(tl,"An enumeration."),tl.forEach(t),Xa.forEach(t),Ha=p(a),V=s(a,"DIV",{class:!0});var Za=n(V);D(ve.$$.fragment,Za),Ur=p(Za),C=s(Za,"P",{});var S=n(C);Lr=l(S,"Helper function for reproducible behavior to set the seed in "),ft=s(S,"CODE",{});var al=n(ft);Ir=l(al,"random"),al.forEach(t),zr=l(S,", "),mt=s(S,"CODE",{});var rl=n(mt);Sr=l(rl,"numpy"),rl.forEach(t),Nr=l(S,", "),gt=s(S,"CODE",{});var sl=n(gt);Hr=l(sl,"torch"),sl.forEach(t),Gr=l(S," and/or "),bt=s(S,"CODE",{});var nl=n(bt);Vr=l(nl,"tf"),nl.forEach(t),Mr=l(S," (if installed)."),S.forEach(t),Za.forEach(t),Ga=p(a),M=s(a,"DIV",{class:!0});var er=n(M);D(_e.$$.fragment,er),Rr=p(er),vt=s(er,"P",{});var ol=n(vt);Fr=l(ol,"Decorator to make all processes in distributed training wait for each local_master to do something."),ol.forEach(t),er.forEach(t),Va=p(a),R=s(a,"H2",{class:!0});var tr=n(R);te=s(tr,"A",{id:!0,class:!0,href:!0});var ll=n(te);_t=s(ll,"SPAN",{});var il=n(_t);D(we.$$.fragment,il),il.forEach(t),ll.forEach(t),qr=p(tr),wt=s(tr,"SPAN",{});var pl=n(wt);Br=l(pl,"Callbacks internals"),pl.forEach(t),tr.forEach(t),Ma=p(a),F=s(a,"DIV",{class:!0});var ar=n(F);D($e.$$.fragment,ar),Kr=p(ar),$t=s(ar,"P",{});var cl=n($t);Yr=l(cl,"Internal class that just calls the list of callbacks in order."),cl.forEach(t),ar.forEach(t),Ra=p(a),q=s(a,"H2",{class:!0});var rr=n(q);ae=s(rr,"A",{id:!0,class:!0,href:!0});var dl=n(ae);yt=s(dl,"SPAN",{});var hl=n(yt);D(ye.$$.fragment,hl),hl.forEach(t),dl.forEach(t),Wr=p(rr),Et=s(rr,"SPAN",{});var ul=n(Et);Jr=l(ul,"Distributed Evaluation"),ul.forEach(t),rr.forEach(t),Fa=p(a),_=s(a,"DIV",{class:!0});var y=n(_);D(Ee.$$.fragment,y),Qr=p(y),Dt=s(y,"P",{});var fl=n(Dt);Xr=l(fl,"A class responsible for properly gathering tensors (or nested list/tuple of tensors) on the CPU by chunks."),fl.forEach(t),Zr=p(y),jt=s(y,"P",{});var ml=n(jt);es=l(ml,`If our dataset has 16 samples with a batch size of 2 on 3 processes and we gather then transfer on CPU at every
step, our sampler will generate the following indices:`),ml.forEach(t),ts=p(y),kt=s(y,"P",{});var gl=n(kt);Pt=s(gl,"CODE",{});var bl=n(Pt);as=l(bl,"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1]"),bl.forEach(t),gl.forEach(t),rs=p(y),xt=s(y,"P",{});var vl=n(xt);ss=l(vl,`to get something of size a multiple of 3 (so that each process gets the same dataset length). Then process 0, 1 and
2 will be responsible of making predictions for the following samples:`),vl.forEach(t),ns=p(y),B=s(y,"UL",{});var at=n(B);We=s(at,"LI",{});var Mo=n(We);os=l(Mo,"P0: "),Tt=s(Mo,"CODE",{});var _l=n(Tt);ls=l(_l,"[0, 1, 2, 3, 4, 5]"),_l.forEach(t),Mo.forEach(t),is=p(at),Je=s(at,"LI",{});var Ro=n(Je);ps=l(Ro,"P1: "),Ot=s(Ro,"CODE",{});var wl=n(Ot);cs=l(wl,"[6, 7, 8, 9, 10, 11]"),wl.forEach(t),Ro.forEach(t),ds=p(at),Qe=s(at,"LI",{});var Fo=n(Qe);hs=l(Fo,"P2: "),Ct=s(Fo,"CODE",{});var $l=n(Ct);us=l($l,"[12, 13, 14, 15, 0, 1]"),$l.forEach(t),Fo.forEach(t),at.forEach(t),fs=p(y),At=s(y,"P",{});var yl=n(At);ms=l(yl,"The first batch treated on each process will be"),yl.forEach(t),gs=p(y),K=s(y,"UL",{});var rt=n(K);Xe=s(rt,"LI",{});var qo=n(Xe);bs=l(qo,"P0: "),Ut=s(qo,"CODE",{});var El=n(Ut);vs=l(El,"[0, 1]"),El.forEach(t),qo.forEach(t),_s=p(rt),Ze=s(rt,"LI",{});var Bo=n(Ze);ws=l(Bo,"P1: "),Lt=s(Bo,"CODE",{});var Dl=n(Lt);$s=l(Dl,"[6, 7]"),Dl.forEach(t),Bo.forEach(t),ys=p(rt),et=s(rt,"LI",{});var Ko=n(et);Es=l(Ko,"P2: "),It=s(Ko,"CODE",{});var jl=n(It);Ds=l(jl,"[12, 13]"),jl.forEach(t),Ko.forEach(t),rt.forEach(t),js=p(y),zt=s(y,"P",{});var kl=n(zt);ks=l(kl,`So if we gather at the end of the first batch, we will get a tensor (nested list/tuple of tensor) corresponding to
the following indices:`),kl.forEach(t),Ps=p(y),St=s(y,"P",{});var Pl=n(St);Nt=s(Pl,"CODE",{});var xl=n(Nt);xs=l(xl,"[0, 1, 6, 7, 12, 13]"),xl.forEach(t),Pl.forEach(t),Ts=p(y),Ht=s(y,"P",{});var Tl=n(Ht);Os=l(Tl,`If we directly concatenate our results without taking any precautions, the user will then get the predictions for
the indices in this order at the end of the prediction loop:`),Tl.forEach(t),Cs=p(y),Gt=s(y,"P",{});var Ol=n(Gt);Vt=s(Ol,"CODE",{});var Cl=n(Vt);As=l(Cl,"[0, 1, 6, 7, 12, 13, 2, 3, 8, 9, 14, 15, 4, 5, 10, 11, 0, 1]"),Cl.forEach(t),Ol.forEach(t),Us=p(y),Mt=s(y,"P",{});var Al=n(Mt);Ls=l(Al,"For some reason, that\u2019s not going to roll their boat. This class is there to solve that problem."),Al.forEach(t),Is=p(y),re=s(y,"DIV",{class:!0});var sr=n(re);D(De.$$.fragment,sr),zs=p(sr),je=s(sr,"P",{});var nr=n(je);Ss=l(nr,"Add "),Rt=s(nr,"CODE",{});var Ul=n(Rt);Ns=l(Ul,"arrays"),Ul.forEach(t),Hs=l(nr,` to the internal storage, Will initialize the storage to the full size at the first arrays passed
so that if we\u2019re bound to get an OOM, it happens at the beginning.`),nr.forEach(t),sr.forEach(t),Gs=p(y),se=s(y,"DIV",{class:!0});var or=n(se);D(ke.$$.fragment,or),Vs=p(or),Ft=s(or,"P",{});var Ll=n(Ft);Ms=l(Ll,`Return the properly gathered arrays and truncate to the number of samples (since the sampler added some extras
to get each process a dataset of the same length).`),Ll.forEach(t),or.forEach(t),y.forEach(t),qa=p(a),Y=s(a,"H2",{class:!0});var lr=n(Y);ne=s(lr,"A",{id:!0,class:!0,href:!0});var Il=n(ne);qt=s(Il,"SPAN",{});var zl=n(qt);D(Pe.$$.fragment,zl),zl.forEach(t),Il.forEach(t),Rs=p(lr),Bt=s(lr,"SPAN",{});var Sl=n(Bt);Fs=l(Sl,"Distributed Evaluation"),Sl.forEach(t),lr.forEach(t),Ba=p(a),O=s(a,"DIV",{class:!0});var L=n(O);D(xe.$$.fragment,L),qs=p(L),Te=s(L,"P",{});var ir=n(Te);Bs=l(ir,"This subclass of "),Kt=s(ir,"CODE",{});var Nl=n(Kt);Ks=l(Nl,"argparse.ArgumentParser"),Nl.forEach(t),Ys=l(ir," uses type hints on dataclasses to generate arguments."),ir.forEach(t),Ws=p(L),Oe=s(L,"P",{});var pr=n(Oe);Js=l(pr,`The class is designed to play well with the native argparse. In particular, you can add more (non-dataclass backed)
arguments to the parser after initialization and you\u2019ll get the output back after parsing as an additional
namespace. Optional: To create sub argument groups use the `),Yt=s(pr,"CODE",{});var Hl=n(Yt);Qs=l(Hl,"_argument_group_name"),Hl.forEach(t),Xs=l(pr," attribute in the dataclass."),pr.forEach(t),Zs=p(L),z=s(L,"DIV",{class:!0});var st=n(z);D(Ce.$$.fragment,st),en=p(st),Wt=s(st,"P",{});var Gl=n(Wt);tn=l(Gl,"Parse command-line args into instances of the specified dataclass types."),Gl.forEach(t),an=p(st),Ae=s(st,"P",{});var cr=n(Ae);rn=l(cr,"This relies on argparse\u2019s "),Jt=s(cr,"CODE",{});var Vl=n(Jt);sn=l(Vl,"ArgumentParser.parse_known_args"),Vl.forEach(t),nn=l(cr,`. See the doc at:
docs.python.org/3.7/library/argparse.html#argparse.ArgumentParser.parse_args`),cr.forEach(t),st.forEach(t),on=p(L),oe=s(L,"DIV",{class:!0});var dr=n(oe);D(Ue.$$.fragment,dr),ln=p(dr),Le=s(dr,"P",{});var hr=n(Le);pn=l(hr,"Alternative helper method that does not use "),Qt=s(hr,"CODE",{});var Ml=n(Qt);cn=l(Ml,"argparse"),Ml.forEach(t),dn=l(hr,` at all, instead uses a dict and populating the dataclass
types.`),hr.forEach(t),dr.forEach(t),hn=p(L),le=s(L,"DIV",{class:!0});var ur=n(le);D(Ie.$$.fragment,ur),un=p(ur),ze=s(ur,"P",{});var fr=n(ze);fn=l(fr,"Alternative helper method that does not use "),Xt=s(fr,"CODE",{});var Rl=n(Xt);mn=l(Rl,"argparse"),Rl.forEach(t),gn=l(fr,` at all, instead loading a json file and populating the
dataclass types.`),fr.forEach(t),ur.forEach(t),L.forEach(t),Ka=p(a),W=s(a,"H2",{class:!0});var mr=n(W);ie=s(mr,"A",{id:!0,class:!0,href:!0});var Fl=n(ie);Zt=s(Fl,"SPAN",{});var ql=n(Zt);D(Se.$$.fragment,ql),ql.forEach(t),Fl.forEach(t),bn=p(mr),ea=s(mr,"SPAN",{});var Bl=n(ea);vn=l(Bl,"Debug Utilities"),Bl.forEach(t),mr.forEach(t),Ya=p(a),d=s(a,"DIV",{class:!0});var h=n(d);D(Ne.$$.fragment,h),_n=p(h),J=s(h,"P",{});var nt=n(J);wn=l(nt,`This debug class helps detect and understand where the model starts getting very large or very small, and more
importantly `),ta=s(nt,"CODE",{});var Kl=n(ta);$n=l(Kl,"nan"),Kl.forEach(t),yn=l(nt," or "),aa=s(nt,"CODE",{});var Yl=n(aa);En=l(Yl,"inf"),Yl.forEach(t),Dn=l(nt," weight and activation elements."),nt.forEach(t),jn=p(h),ra=s(h,"P",{});var Wl=n(ra);kn=l(Wl,"There are 2 working modes:"),Wl.forEach(t),Pn=p(h),He=s(h,"OL",{});var gr=n(He);sa=s(gr,"LI",{});var Jl=n(sa);xn=l(Jl,"Underflow/overflow detection (default)"),Jl.forEach(t),Tn=p(gr),na=s(gr,"LI",{});var Ql=n(na);On=l(Ql,"Specific batch absolute min/max tracing without detection"),Ql.forEach(t),gr.forEach(t),Cn=p(h),oa=s(h,"P",{});var Xl=n(oa);An=l(Xl,"Mode 1: Underflow/overflow detection"),Xl.forEach(t),Un=p(h),D(pe.$$.fragment,h),Ln=p(h),I=s(h,"P",{});var fe=n(I);In=l(fe,"then run the training as normal and if "),la=s(fe,"CODE",{});var Zl=n(la);zn=l(Zl,"nan"),Zl.forEach(t),Sn=l(fe," or "),ia=s(fe,"CODE",{});var ei=n(ia);Nn=l(ei,"inf"),ei.forEach(t),Hn=l(fe,` gets detected in at least one of the weight, input or output
elements this module will throw an exception and will print `),pa=s(fe,"CODE",{});var ti=n(pa);Gn=l(ti,"max_frames_to_save"),ti.forEach(t),Vn=l(fe,` frames that lead to this event,
each frame reporting`),fe.forEach(t),Mn=p(h),Ge=s(h,"OL",{});var br=n(Ge);Ve=s(br,"LI",{});var vr=n(Ve);Rn=l(vr,"the fully qualified module name plus the class name whose "),ca=s(vr,"CODE",{});var ai=n(ca);Fn=l(ai,"forward"),ai.forEach(t),qn=l(vr," was run"),vr.forEach(t),Bn=p(br),da=s(br,"LI",{});var ri=n(da);Kn=l(ri,"the absolute min and max value of all elements for each module weights, and the inputs and output"),ri.forEach(t),br.forEach(t),Yn=p(h),Me=s(h,"P",{});var _r=n(Me);Wn=l(_r,"For example, here is the header and the last few frames in detection report for "),ha=s(_r,"CODE",{});var si=n(ha);Jn=l(si,"google/mt5-small"),si.forEach(t),Qn=l(_r," run in fp16"),_r.forEach(t),Xn=p(h),D(ce.$$.fragment,h),Zn=p(h),Q=s(h,"P",{});var ot=n(Q);eo=l(ot,"You can see here, that "),ua=s(ot,"CODE",{});var ni=n(ua);to=l(ni,"T5DenseGatedGeluDense.forward"),ni.forEach(t),ao=l(ot,` resulted in output activations, whose absolute max value was
around 62.7K, which is very close to fp16\u2019s top limit of 64K. In the next frame we have `),fa=s(ot,"CODE",{});var oi=n(fa);ro=l(oi,"Dropout"),oi.forEach(t),so=l(ot,` which
renormalizes the weights, after it zeroed some of the elements, which pushes the absolute max value to more than
64K, and we get an overlow.`),ot.forEach(t),no=p(h),ma=s(h,"P",{});var li=n(ma);oo=l(li,`As you can see it\u2019s the previous frames that we need to look into when the numbers start going into very large for
fp16 numbers.`),li.forEach(t),lo=p(h),Re=s(h,"P",{});var wr=n(Re);io=l(wr,"The tracking is done in a forward hook, which gets invoked immediately after "),ga=s(wr,"CODE",{});var ii=n(ga);po=l(ii,"forward"),ii.forEach(t),co=l(wr," has completed."),wr.forEach(t),ho=p(h),D(de.$$.fragment,h),uo=p(h),ba=s(h,"P",{});var pi=n(ba);fo=l(pi,`To validate that you have set up this debugging feature correctly, and you intend to use it in a training that
may take hours to complete, first run it with normal tracing enabled for one of a few batches as explained in
the next section.`),pi.forEach(t),mo=p(h),va=s(h,"P",{});var ci=n(va);go=l(ci,"Mode 2. Specific batch absolute min/max tracing without detection"),ci.forEach(t),bo=p(h),_a=s(h,"P",{});var di=n(_a);vo=l(di,"The second work mode is per-batch tracing with the underflow/overflow detection feature turned off."),di.forEach(t),_o=p(h),Fe=s(h,"P",{});var $r=n(Fe);wo=l($r,"Let\u2019s say you want to watch the absolute min and max values for all the ingredients of each "),wa=s($r,"CODE",{});var hi=n(wa);$o=l(hi,"forward"),hi.forEach(t),yo=l($r," call of a"),$r.forEach(t),Eo=p(h),D(he.$$.fragment,h),Do=p(h),$a=s(h,"P",{});var ui=n($a);jo=l(ui,"And now full batches 1 and 3 will be traced using the same format as explained above. Batches are 0-indexed."),ui.forEach(t),ko=p(h),ya=s(h,"P",{});var fi=n(ya);Po=l(fi,`This is helpful if you know that the program starts misbehaving after a certain batch number, so you can
fast-forward right to that area.`),fi.forEach(t),xo=p(h),Ea=s(h,"P",{});var mi=n(Ea);To=l(mi,"Early stopping:"),mi.forEach(t),Oo=p(h),D(ue.$$.fragment,h),Co=p(h),Da=s(h,"P",{});var gi=n(Da);Ao=l(gi,"This feature is mainly useful in the tracing mode, but you can use it for any mode."),gi.forEach(t),Uo=p(h),tt=s(h,"P",{});var Yo=n(tt);ja=s(Yo,"STRONG",{});var bi=n(ja);Lo=l(bi,"Performance"),bi.forEach(t),Io=l(Yo,":"),Yo.forEach(t),zo=p(h),X=s(h,"P",{});var lt=n(X);So=l(lt,"As this module measures absolute "),ka=s(lt,"CODE",{});var vi=n(ka);No=l(vi,"min"),vi.forEach(t),Ho=l(lt,"/`"),Pa=s(lt,"CODE",{});var _i=n(Pa);Go=l(_i,"max"),_i.forEach(t),Vo=l(lt,` of each weight of the model on every forward it\u2019ll slow the training
down. Therefore remember to turn it off once the debugging needs have been met.`),lt.forEach(t),h.forEach(t),this.h()},h(){b(m,"name","hf:doc:metadata"),b(m,"content",JSON.stringify(Ci)),b(u,"id","utilities-for-trainer"),b(u,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),b(u,"href","#utilities-for-trainer"),b(w,"class","relative group"),b(Ke,"href","/docs/transformers/pr_16995/en/main_classes/trainer#transformers.Trainer"),b(ee,"id","transformers.EvalPrediction"),b(ee,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),b(ee,"href","#transformers.EvalPrediction"),b(N,"class","relative group"),b(H,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),b(G,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),b(V,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),b(M,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),b(te,"id","transformers.trainer_callback.CallbackHandler"),b(te,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),b(te,"href","#transformers.trainer_callback.CallbackHandler"),b(R,"class","relative group"),b(F,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),b(ae,"id","transformers.trainer_pt_utils.DistributedTensorGatherer"),b(ae,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),b(ae,"href","#transformers.trainer_pt_utils.DistributedTensorGatherer"),b(q,"class","relative group"),b(re,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),b(se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),b(_,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),b(ne,"id","transformers.HfArgumentParser"),b(ne,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),b(ne,"href","#transformers.HfArgumentParser"),b(Y,"class","relative group"),b(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),b(oe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),b(le,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),b(O,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),b(ie,"id","transformers.debug_utils.DebugUnderflowOverflow"),b(ie,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),b(ie,"href","#transformers.debug_utils.DebugUnderflowOverflow"),b(W,"class","relative group"),b(d,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(a,f){e(document.head,m),g(a,T,f),g(a,w,f),e(w,u),e(u,$),j(c,$,null),e(w,v),e(w,pt),e(pt,yr),g(a,La,f),g(a,Z,f),e(Z,Er),e(Z,Ke),e(Ke,Dr),e(Z,jr),g(a,Ia,f),g(a,Ye,f),e(Ye,kr),g(a,za,f),g(a,N,f),e(N,ee),e(ee,ct),j(me,ct,null),e(N,Pr),e(N,dt),e(dt,xr),g(a,Sa,f),g(a,H,f),j(ge,H,null),e(H,Tr),e(H,ht),e(ht,Or),g(a,Na,f),g(a,G,f),j(be,G,null),e(G,Cr),e(G,ut),e(ut,Ar),g(a,Ha,f),g(a,V,f),j(ve,V,null),e(V,Ur),e(V,C),e(C,Lr),e(C,ft),e(ft,Ir),e(C,zr),e(C,mt),e(mt,Sr),e(C,Nr),e(C,gt),e(gt,Hr),e(C,Gr),e(C,bt),e(bt,Vr),e(C,Mr),g(a,Ga,f),g(a,M,f),j(_e,M,null),e(M,Rr),e(M,vt),e(vt,Fr),g(a,Va,f),g(a,R,f),e(R,te),e(te,_t),j(we,_t,null),e(R,qr),e(R,wt),e(wt,Br),g(a,Ma,f),g(a,F,f),j($e,F,null),e(F,Kr),e(F,$t),e($t,Yr),g(a,Ra,f),g(a,q,f),e(q,ae),e(ae,yt),j(ye,yt,null),e(q,Wr),e(q,Et),e(Et,Jr),g(a,Fa,f),g(a,_,f),j(Ee,_,null),e(_,Qr),e(_,Dt),e(Dt,Xr),e(_,Zr),e(_,jt),e(jt,es),e(_,ts),e(_,kt),e(kt,Pt),e(Pt,as),e(_,rs),e(_,xt),e(xt,ss),e(_,ns),e(_,B),e(B,We),e(We,os),e(We,Tt),e(Tt,ls),e(B,is),e(B,Je),e(Je,ps),e(Je,Ot),e(Ot,cs),e(B,ds),e(B,Qe),e(Qe,hs),e(Qe,Ct),e(Ct,us),e(_,fs),e(_,At),e(At,ms),e(_,gs),e(_,K),e(K,Xe),e(Xe,bs),e(Xe,Ut),e(Ut,vs),e(K,_s),e(K,Ze),e(Ze,ws),e(Ze,Lt),e(Lt,$s),e(K,ys),e(K,et),e(et,Es),e(et,It),e(It,Ds),e(_,js),e(_,zt),e(zt,ks),e(_,Ps),e(_,St),e(St,Nt),e(Nt,xs),e(_,Ts),e(_,Ht),e(Ht,Os),e(_,Cs),e(_,Gt),e(Gt,Vt),e(Vt,As),e(_,Us),e(_,Mt),e(Mt,Ls),e(_,Is),e(_,re),j(De,re,null),e(re,zs),e(re,je),e(je,Ss),e(je,Rt),e(Rt,Ns),e(je,Hs),e(_,Gs),e(_,se),j(ke,se,null),e(se,Vs),e(se,Ft),e(Ft,Ms),g(a,qa,f),g(a,Y,f),e(Y,ne),e(ne,qt),j(Pe,qt,null),e(Y,Rs),e(Y,Bt),e(Bt,Fs),g(a,Ba,f),g(a,O,f),j(xe,O,null),e(O,qs),e(O,Te),e(Te,Bs),e(Te,Kt),e(Kt,Ks),e(Te,Ys),e(O,Ws),e(O,Oe),e(Oe,Js),e(Oe,Yt),e(Yt,Qs),e(Oe,Xs),e(O,Zs),e(O,z),j(Ce,z,null),e(z,en),e(z,Wt),e(Wt,tn),e(z,an),e(z,Ae),e(Ae,rn),e(Ae,Jt),e(Jt,sn),e(Ae,nn),e(O,on),e(O,oe),j(Ue,oe,null),e(oe,ln),e(oe,Le),e(Le,pn),e(Le,Qt),e(Qt,cn),e(Le,dn),e(O,hn),e(O,le),j(Ie,le,null),e(le,un),e(le,ze),e(ze,fn),e(ze,Xt),e(Xt,mn),e(ze,gn),g(a,Ka,f),g(a,W,f),e(W,ie),e(ie,Zt),j(Se,Zt,null),e(W,bn),e(W,ea),e(ea,vn),g(a,Ya,f),g(a,d,f),j(Ne,d,null),e(d,_n),e(d,J),e(J,wn),e(J,ta),e(ta,$n),e(J,yn),e(J,aa),e(aa,En),e(J,Dn),e(d,jn),e(d,ra),e(ra,kn),e(d,Pn),e(d,He),e(He,sa),e(sa,xn),e(He,Tn),e(He,na),e(na,On),e(d,Cn),e(d,oa),e(oa,An),e(d,Un),j(pe,d,null),e(d,Ln),e(d,I),e(I,In),e(I,la),e(la,zn),e(I,Sn),e(I,ia),e(ia,Nn),e(I,Hn),e(I,pa),e(pa,Gn),e(I,Vn),e(d,Mn),e(d,Ge),e(Ge,Ve),e(Ve,Rn),e(Ve,ca),e(ca,Fn),e(Ve,qn),e(Ge,Bn),e(Ge,da),e(da,Kn),e(d,Yn),e(d,Me),e(Me,Wn),e(Me,ha),e(ha,Jn),e(Me,Qn),e(d,Xn),j(ce,d,null),e(d,Zn),e(d,Q),e(Q,eo),e(Q,ua),e(ua,to),e(Q,ao),e(Q,fa),e(fa,ro),e(Q,so),e(d,no),e(d,ma),e(ma,oo),e(d,lo),e(d,Re),e(Re,io),e(Re,ga),e(ga,po),e(Re,co),e(d,ho),j(de,d,null),e(d,uo),e(d,ba),e(ba,fo),e(d,mo),e(d,va),e(va,go),e(d,bo),e(d,_a),e(_a,vo),e(d,_o),e(d,Fe),e(Fe,wo),e(Fe,wa),e(wa,$o),e(Fe,yo),e(d,Eo),j(he,d,null),e(d,Do),e(d,$a),e($a,jo),e(d,ko),e(d,ya),e(ya,Po),e(d,xo),e(d,Ea),e(Ea,To),e(d,Oo),j(ue,d,null),e(d,Co),e(d,Da),e(Da,Ao),e(d,Uo),e(d,tt),e(tt,ja),e(ja,Lo),e(tt,Io),e(d,zo),e(d,X),e(X,So),e(X,ka),e(ka,No),e(X,Ho),e(X,Pa),e(Pa,Go),e(X,Vo),Wa=!0},p(a,[f]){const qe={};f&2&&(qe.$$scope={dirty:f,ctx:a}),pe.$set(qe);const xa={};f&2&&(xa.$$scope={dirty:f,ctx:a}),ce.$set(xa);const Ta={};f&2&&(Ta.$$scope={dirty:f,ctx:a}),de.$set(Ta);const Oa={};f&2&&(Oa.$$scope={dirty:f,ctx:a}),he.$set(Oa);const Be={};f&2&&(Be.$$scope={dirty:f,ctx:a}),ue.$set(Be)},i(a){Wa||(k(c.$$.fragment,a),k(me.$$.fragment,a),k(ge.$$.fragment,a),k(be.$$.fragment,a),k(ve.$$.fragment,a),k(_e.$$.fragment,a),k(we.$$.fragment,a),k($e.$$.fragment,a),k(ye.$$.fragment,a),k(Ee.$$.fragment,a),k(De.$$.fragment,a),k(ke.$$.fragment,a),k(Pe.$$.fragment,a),k(xe.$$.fragment,a),k(Ce.$$.fragment,a),k(Ue.$$.fragment,a),k(Ie.$$.fragment,a),k(Se.$$.fragment,a),k(Ne.$$.fragment,a),k(pe.$$.fragment,a),k(ce.$$.fragment,a),k(de.$$.fragment,a),k(he.$$.fragment,a),k(ue.$$.fragment,a),Wa=!0)},o(a){P(c.$$.fragment,a),P(me.$$.fragment,a),P(ge.$$.fragment,a),P(be.$$.fragment,a),P(ve.$$.fragment,a),P(_e.$$.fragment,a),P(we.$$.fragment,a),P($e.$$.fragment,a),P(ye.$$.fragment,a),P(Ee.$$.fragment,a),P(De.$$.fragment,a),P(ke.$$.fragment,a),P(Pe.$$.fragment,a),P(xe.$$.fragment,a),P(Ce.$$.fragment,a),P(Ue.$$.fragment,a),P(Ie.$$.fragment,a),P(Se.$$.fragment,a),P(Ne.$$.fragment,a),P(pe.$$.fragment,a),P(ce.$$.fragment,a),P(de.$$.fragment,a),P(he.$$.fragment,a),P(ue.$$.fragment,a),Wa=!1},d(a){t(m),a&&t(T),a&&t(w),x(c),a&&t(La),a&&t(Z),a&&t(Ia),a&&t(Ye),a&&t(za),a&&t(N),x(me),a&&t(Sa),a&&t(H),x(ge),a&&t(Na),a&&t(G),x(be),a&&t(Ha),a&&t(V),x(ve),a&&t(Ga),a&&t(M),x(_e),a&&t(Va),a&&t(R),x(we),a&&t(Ma),a&&t(F),x($e),a&&t(Ra),a&&t(q),x(ye),a&&t(Fa),a&&t(_),x(Ee),x(De),x(ke),a&&t(qa),a&&t(Y),x(Pe),a&&t(Ba),a&&t(O),x(xe),x(Ce),x(Ue),x(Ie),a&&t(Ka),a&&t(W),x(Se),a&&t(Ya),a&&t(d),x(Ne),x(pe),x(ce),x(de),x(he),x(ue)}}}const Ci={local:"utilities-for-trainer",sections:[{local:"transformers.EvalPrediction",title:"Utilities"},{local:"transformers.trainer_callback.CallbackHandler",title:"Callbacks internals"},{local:"transformers.trainer_pt_utils.DistributedTensorGatherer",title:"Distributed Evaluation"},{local:"transformers.HfArgumentParser",title:"Distributed Evaluation"},{local:"transformers.debug_utils.DebugUnderflowOverflow",title:"Debug Utilities"}],title:"Utilities for Trainer"};function Ai(U){return Di(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Ni extends wi{constructor(m){super();$i(this,m,Ai,Oi,yi,{})}}export{Ni as default,Ci as metadata};
