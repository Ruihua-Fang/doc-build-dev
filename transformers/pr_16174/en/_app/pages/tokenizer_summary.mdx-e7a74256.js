import{S as _m,i as zm,s as qm,e as o,k as c,w as f,t as a,Y as ko,M as jm,c as l,d as s,m as u,a as r,x as g,h as n,Z as Eo,b as h,F as t,g as p,y as b,L as $m,q as v,o as y,B as w}from"../chunks/vendor-6b77c823.js";import{Y as _o}from"../chunks/Youtube-5c6e11e6.js";import{I as De}from"../chunks/IconCopyLink-7a11ce68.js";import{C as re}from"../chunks/CodeBlock-3a8b25a8.js";import{D as xm}from"../chunks/DocNotebookDropdown-b2654249.js";function Pm(zo){let V,ht,U,K,ts,Se,qo,ss,jo,Ha,Ce,Ra,ct,$o,Fa,Be,Ga,D,xo,ut,Po,To,mt,Ao,Do,dt,So,Co,ft,Bo,Oo,Xa,J,Mo,gt,No,Wo,bt,Io,Lo,Ka,ie,ve,as,Oe,Uo,ns,Ho,Va,Me,Ro,os,Fo,Ja,Ne,Ya,vt,Go,Za,We,Qa,S,Xo,ls,Ko,Vo,rs,Jo,Yo,is,Zo,Qo,ps,el,tl,en,Ie,tn,C,sl,hs,al,nl,cs,ol,ll,us,rl,il,ms,pl,hl,sn,W,Le,cl,ul,Ue,ml,dl,ds,fl,gl,fs,bl,vl,an,He,nn,Y,yl,gs,wl,kl,yt,El,_l,on,wt,zl,ln,kt,ql,rn,Re,pn,B,jl,bs,$l,xl,vs,Pl,Tl,ys,Al,Dl,ws,Sl,Cl,hn,pe,ye,ks,Fe,Bl,Es,Ol,cn,Ge,un,k,Ml,_s,Nl,Wl,zs,Il,Ll,qs,Ul,Hl,js,Rl,Fl,$s,Gl,Xl,xs,Kl,Vl,Ps,Jl,Yl,Ts,Zl,Ql,mn,Z,er,Et,tr,sr,As,ar,nr,dn,Xe,fn,P,or,Ds,lr,rr,Ss,ir,pr,Cs,hr,cr,Bs,ur,mr,Os,dr,fr,gn,we,gr,_t,br,vr,bn,Ke,vn,T,yr,Ms,wr,kr,zt,Er,_r,Ns,zr,qr,Ws,jr,$r,Is,xr,Pr,yn,qt,Tr,wn,jt,kn,he,ke,Ls,Ve,Ar,Us,Dr,En,q,Sr,Je,Cr,Br,$t,Or,Mr,xt,Nr,Wr,Pt,Ir,Lr,Tt,Ur,Hr,At,Rr,Fr,_n,Dt,Gr,zn,St,Xr,qn,Ye,jn,Ee,Kr,Hs,Vr,Jr,$n,Ze,xn,m,Yr,Rs,Zr,Qr,Fs,ei,ti,Gs,si,ai,Xs,ni,oi,Ks,li,ri,Vs,ii,pi,Js,hi,ci,Ys,ui,mi,Zs,di,fi,Qs,gi,bi,ea,vi,yi,Pn,Qe,Tn,E,wi,ta,ki,Ei,sa,_i,zi,aa,qi,ji,na,$i,xi,oa,Pi,Ti,la,Ai,Di,ra,Si,Ci,ia,Bi,Oi,An,_e,Mi,pa,Ni,Wi,Dn,et,Sn,z,Ii,ha,Li,Ui,ca,Hi,Ri,ua,Fi,Gi,ma,Xi,Ki,da,Vi,Ji,fa,Yi,Zi,ga,Qi,ep,Cn,Q,tp,ba,sp,ap,Ct,np,op,Bn,ce,ze,va,tt,lp,ya,rp,On,H,ip,wa,pp,hp,st,cp,up,Bt,mp,dp,Mn,Ot,Nn,ue,qe,ka,at,fp,Ea,gp,Wn,O,bp,Mt,vp,yp,Nt,wp,kp,Wt,Ep,_p,nt,zp,qp,In,_,jp,_a,$p,xp,za,Pp,Tp,qa,Ap,Dp,ja,Sp,Cp,$a,Bp,Op,xa,Mp,Np,Pa,Wp,Ip,Ta,Lp,Up,Ln,It,Un,me,je,Aa,ot,Hp,Da,Rp,Hn,ee,Fp,lt,Gp,Xp,Lt,Kp,Vp,Rn,$e,Jp,Sa,Yp,Zp,Fn,Ut,Qp,Gn,rt,Xn,I,Ca,eh,th,Ba,sh,ah,Oa,nh,oh,Ma,lh,rh,Kn,L,ih,Vn,ym='<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><mo>\u2026</mo><mo separator="true">,</mo><msub><mi>x</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">x_{1}, \\dots, x_{N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">\u200B</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner">\u2026</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">\u200B</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>',Jn,Yn,wm='<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">\u200B</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>',Zn,Qn,km='<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(x_{i})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">\u200B</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>',eo,to,Em=`<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="script">L</mi><mo>=</mo><mo>\u2212</mo><munderover><mo>\u2211</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><mi>log</mi><mo>\u2061</mo><mrow><mo fence="true">(</mo><munder><mo>\u2211</mo><mrow><mi>x</mi><mo>\u2208</mo><mi>S</mi><mo stretchy="false">(</mo><msub><mi>x</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></munder><mi>p</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow></mrow><annotation encoding="application/x-tex">\\mathcal{L} = -\\sum_{i=1}^{N} \\log \\left ( \\sum_{x \\in S(x_{i})} p(x) \\right )</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathcal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:3.6em;vertical-align:-1.55em;"></span><span class="mord">\u2212</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">\u2211</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">\u200B</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>\u239D</span></span></span><span style="top:-3.397em;"><span class="pstrut" style="height:3.155em;"></span><span style="height:0.016em;width:0.875em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.875em' height='0.016em' style='width:0.875em' viewBox='0 0 875 16' preserveAspectRatio='xMinYMin'><path d='M291 0 H417 V16 H291z M291 0 H417 V16 H291z'/></svg></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>\u239B</span></span></span></span><span class="vlist-s">\u200B</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.05em;"><span style="top:-1.809em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="mrel mtight">\u2208</span><span class="mord mathnormal mtight" style="margin-right:0.05764em;">S</span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3281em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span><span class="vlist-s">\u200B</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight">)</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">\u2211</span></span></span></span><span class="vlist-s">\u200B</span></span><span class="vlist-r"><span class="vlist" style="height:1.516em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">p</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-2.25em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>\u23A0</span></span></span><span style="top:-3.397em;"><span class="pstrut" style="height:3.155em;"></span><span style="height:0.016em;width:0.875em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.875em' height='0.016em' style='width:0.875em' viewBox='0 0 875 16' preserveAspectRatio='xMinYMin'><path d='M457 0 H583 V16 H457z M457 0 H583 V16 H457z'/></svg></span></span><span style="top:-4.05em;"><span class="pstrut" style="height:3.155em;"></span><span class="delimsizinginner delim-size4"><span>\u239E</span></span></span></span><span class="vlist-s">\u200B</span></span><span class="vlist-r"><span class="vlist" style="height:1.55em;"><span></span></span></span></span></span></span></span></span></span></span></span>`,so,Ht,ao,de,xe,Na,it,ph,Wa,hh,no,R,ch,Ia,uh,mh,Rt,dh,fh,pt,gh,bh,oo,F,vh,Ft,yh,wh,La,kh,Eh,Ua,_h,zh,lo,M,qh,Gt,jh,$h,Xt,xh,Ph,Kt,Th,Ah,Vt,Dh,Sh,ro;return Se=new De({}),Ce=new xm({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Mixed",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/transformers_doc/tokenizer_summary.ipynb"},{label:"PyTorch",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/transformers_doc/pytorch/tokenizer_summary.ipynb"},{label:"TensorFlow",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/transformers_doc/tensorflow/tokenizer_summary.ipynb"},{label:"Mixed",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/transformers_doc/tokenizer_summary.ipynb"},{label:"PyTorch",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/transformers_doc/pytorch/tokenizer_summary.ipynb"},{label:"TensorFlow",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/transformers_doc/tensorflow/tokenizer_summary.ipynb"}]}}),Be=new _o({props:{id:"VFp38yj8h3A"}}),Oe=new De({}),Ne=new _o({props:{id:"nhJxYji1aho"}}),We=new re({props:{code:`["Don't", "you", "love", "\u{1F917}", "Transformers?", "We", "sure", "do."]`,highlighted:'<span class="hljs-selector-attr">[<span class="hljs-string">&quot;Don&#x27;t&quot;</span>, <span class="hljs-string">&quot;you&quot;</span>, <span class="hljs-string">&quot;love&quot;</span>, <span class="hljs-string">&quot;\u{1F917}&quot;</span>, <span class="hljs-string">&quot;Transformers?&quot;</span>, <span class="hljs-string">&quot;We&quot;</span>, <span class="hljs-string">&quot;sure&quot;</span>, <span class="hljs-string">&quot;do.&quot;</span>]</span>'}}),Ie=new re({props:{code:`["Don", "'", "t", "you", "love", "\u{1F917}", "Transformers", "?", "We", "sure", "do", "."]`,highlighted:'<span class="hljs-selector-attr">[<span class="hljs-string">&quot;Don&quot;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-string">&quot;you&quot;</span>, <span class="hljs-string">&quot;love&quot;</span>, <span class="hljs-string">&quot;\u{1F917}&quot;</span>, <span class="hljs-string">&quot;Transformers&quot;</span>, <span class="hljs-string">&quot;?&quot;</span>, <span class="hljs-string">&quot;We&quot;</span>, <span class="hljs-string">&quot;sure&quot;</span>, <span class="hljs-string">&quot;do&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>]</span>'}}),He=new re({props:{code:`["Do", "n't", "you", "love", "\u{1F917}", "Transformers", "?", "We", "sure", "do", "."]`,highlighted:'<span class="hljs-selector-attr">[<span class="hljs-string">&quot;Do&quot;</span>, <span class="hljs-string">&quot;n&#x27;t&quot;</span>, <span class="hljs-string">&quot;you&quot;</span>, <span class="hljs-string">&quot;love&quot;</span>, <span class="hljs-string">&quot;\u{1F917}&quot;</span>, <span class="hljs-string">&quot;Transformers&quot;</span>, <span class="hljs-string">&quot;?&quot;</span>, <span class="hljs-string">&quot;We&quot;</span>, <span class="hljs-string">&quot;sure&quot;</span>, <span class="hljs-string">&quot;do&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>]</span>'}}),Re=new _o({props:{id:"ssLq_EK2jLE"}}),Fe=new De({}),Ge=new _o({props:{id:"zHvTiHr506c"}}),Xe=new re({props:{code:`from transformers import BertTokenizer

tokenizer = BertTokenizer.from_pretrained("bert-base-uncased")
tokenizer.tokenize("I have a new GPU!")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizer

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = BertTokenizer.from_pretrained(<span class="hljs-string">&quot;bert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.tokenize(<span class="hljs-string">&quot;I have a new GPU!&quot;</span>)
[<span class="hljs-string">&quot;i&quot;</span>, <span class="hljs-string">&quot;have&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;new&quot;</span>, <span class="hljs-string">&quot;gp&quot;</span>, <span class="hljs-string">&quot;##u&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>]`}}),Ke=new re({props:{code:`from transformers import XLNetTokenizer

tokenizer = XLNetTokenizer.from_pretrained("xlnet-base-cased")
tokenizer.tokenize("Don't you love \u{1F917} Transformers? We sure do.")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> XLNetTokenizer

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = XLNetTokenizer.from_pretrained(<span class="hljs-string">&quot;xlnet-base-cased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.tokenize(<span class="hljs-string">&quot;Don&#x27;t you love \u{1F917} Transformers? We sure do.&quot;</span>)
[<span class="hljs-string">&quot;\u2581Don&quot;</span>, <span class="hljs-string">&quot;&#x27;&quot;</span>, <span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-string">&quot;\u2581you&quot;</span>, <span class="hljs-string">&quot;\u2581love&quot;</span>, <span class="hljs-string">&quot;\u2581&quot;</span>, <span class="hljs-string">&quot;\u{1F917}&quot;</span>, <span class="hljs-string">&quot;\u2581&quot;</span>, <span class="hljs-string">&quot;Transform&quot;</span>, <span class="hljs-string">&quot;ers&quot;</span>, <span class="hljs-string">&quot;?&quot;</span>, <span class="hljs-string">&quot;\u2581We&quot;</span>, <span class="hljs-string">&quot;\u2581sure&quot;</span>, <span class="hljs-string">&quot;\u2581do&quot;</span>, <span class="hljs-string">&quot;.&quot;</span>]`}}),Ve=new De({}),Ye=new re({props:{code:'("hug", 10), ("pug", 5), ("pun", 12), ("bun", 4), ("hugs", 5)',highlighted:'(<span class="hljs-string">&quot;hug&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">10</span>)<span class="hljs-punctuation">,</span> (<span class="hljs-string">&quot;pug&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span>)<span class="hljs-punctuation">,</span> (<span class="hljs-string">&quot;pun&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">12</span>)<span class="hljs-punctuation">,</span> (<span class="hljs-string">&quot;bun&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">4</span>)<span class="hljs-punctuation">,</span> (<span class="hljs-string">&quot;hugs&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span>)'}}),Ze=new re({props:{code:'("h" "u" "g", 10), ("p" "u" "g", 5), ("p" "u" "n", 12), ("b" "u" "n", 4), ("h" "u" "g" "s", 5)',highlighted:'(<span class="hljs-string">&quot;h&quot;</span> <span class="hljs-string">&quot;u&quot;</span> <span class="hljs-string">&quot;g&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">10</span>)<span class="hljs-punctuation">,</span> (<span class="hljs-string">&quot;p&quot;</span> <span class="hljs-string">&quot;u&quot;</span> <span class="hljs-string">&quot;g&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span>)<span class="hljs-punctuation">,</span> (<span class="hljs-string">&quot;p&quot;</span> <span class="hljs-string">&quot;u&quot;</span> <span class="hljs-string">&quot;n&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">12</span>)<span class="hljs-punctuation">,</span> (<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-string">&quot;u&quot;</span> <span class="hljs-string">&quot;n&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">4</span>)<span class="hljs-punctuation">,</span> (<span class="hljs-string">&quot;h&quot;</span> <span class="hljs-string">&quot;u&quot;</span> <span class="hljs-string">&quot;g&quot;</span> <span class="hljs-string">&quot;s&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span>)'}}),Qe=new re({props:{code:'("h" "ug", 10), ("p" "ug", 5), ("p" "u" "n", 12), ("b" "u" "n", 4), ("h" "ug" "s", 5)',highlighted:'(<span class="hljs-string">&quot;h&quot;</span> <span class="hljs-string">&quot;ug&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">10</span>)<span class="hljs-punctuation">,</span> (<span class="hljs-string">&quot;p&quot;</span> <span class="hljs-string">&quot;ug&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span>)<span class="hljs-punctuation">,</span> (<span class="hljs-string">&quot;p&quot;</span> <span class="hljs-string">&quot;u&quot;</span> <span class="hljs-string">&quot;n&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">12</span>)<span class="hljs-punctuation">,</span> (<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-string">&quot;u&quot;</span> <span class="hljs-string">&quot;n&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">4</span>)<span class="hljs-punctuation">,</span> (<span class="hljs-string">&quot;h&quot;</span> <span class="hljs-string">&quot;ug&quot;</span> <span class="hljs-string">&quot;s&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span>)'}}),et=new re({props:{code:'("hug", 10), ("p" "ug", 5), ("p" "un", 12), ("b" "un", 4), ("hug" "s", 5)',highlighted:'(<span class="hljs-string">&quot;hug&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">10</span>)<span class="hljs-punctuation">,</span> (<span class="hljs-string">&quot;p&quot;</span> <span class="hljs-string">&quot;ug&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span>)<span class="hljs-punctuation">,</span> (<span class="hljs-string">&quot;p&quot;</span> <span class="hljs-string">&quot;un&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">12</span>)<span class="hljs-punctuation">,</span> (<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-string">&quot;un&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">4</span>)<span class="hljs-punctuation">,</span> (<span class="hljs-string">&quot;hug&quot;</span> <span class="hljs-string">&quot;s&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-number">5</span>)'}}),tt=new De({}),at=new De({}),ot=new De({}),rt=new re({props:{code:'["b", "g", "h", "n", "p", "s", "u", "ug", "un", "hug"],',highlighted:'<span class="hljs-selector-attr">[<span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;g&quot;</span>, <span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot;u&quot;</span>, <span class="hljs-string">&quot;ug&quot;</span>, <span class="hljs-string">&quot;un&quot;</span>, <span class="hljs-string">&quot;hug&quot;</span>]</span>,'}}),it=new De({}),{c(){V=o("meta"),ht=c(),U=o("h1"),K=o("a"),ts=o("span"),f(Se.$$.fragment),qo=c(),ss=o("span"),jo=a("Summary of the tokenizers"),Ha=c(),f(Ce.$$.fragment),Ra=c(),ct=o("p"),$o=a("On this page, we will have a closer look at tokenization."),Fa=c(),f(Be.$$.fragment),Ga=c(),D=o("p"),xo=a("As we saw in "),ut=o("a"),Po=a("the preprocessing tutorial"),To=a(`, tokenizing a text is splitting it into words or
subwords, which then are converted to ids through a look-up table. Converting words or subwords to ids is
straightforward, so in this summary, we will focus on splitting a text into words or subwords (i.e. tokenizing a text).
More specifically, we will look at the three main types of tokenizers used in \u{1F917} Transformers: `),mt=o("a"),Ao=a(`Byte-Pair Encoding
(BPE)`),Do=a(", "),dt=o("a"),So=a("WordPiece"),Co=a(", and "),ft=o("a"),Bo=a("SentencePiece"),Oo=a(`, and show examples
of which tokenizer type is used by which model.`),Xa=c(),J=o("p"),Mo=a(`Note that on each model page, you can look at the documentation of the associated tokenizer to know which tokenizer
type was used by the pretrained model. For instance, if we look at `),gt=o("a"),No=a("BertTokenizer"),Wo=a(`, we can see
that the model uses `),bt=o("a"),Io=a("WordPiece"),Lo=a("."),Ka=c(),ie=o("h2"),ve=o("a"),as=o("span"),f(Oe.$$.fragment),Uo=c(),ns=o("span"),Ho=a("Introduction"),Va=c(),Me=o("p"),Ro=a(`Splitting a text into smaller chunks is a task that is harder than it looks, and there are multiple ways of doing so.
For instance, let\u2019s look at the sentence `),os=o("code"),Fo=a(`"Don't you love \u{1F917} Transformers? We sure do."`),Ja=c(),f(Ne.$$.fragment),Ya=c(),vt=o("p"),Go=a("A simple way of tokenizing this text is to split it by spaces, which would give:"),Za=c(),f(We.$$.fragment),Qa=c(),S=o("p"),Xo=a("This is a sensible first step, but if we look at the tokens "),ls=o("code"),Ko=a('"Transformers?"'),Vo=a(" and "),rs=o("code"),Jo=a('"do."'),Yo=a(`, we notice that the
punctuation is attached to the words `),is=o("code"),Zo=a('"Transformer"'),Qo=a(" and "),ps=o("code"),el=a('"do"'),tl=a(`, which is suboptimal. We should take the
punctuation into account so that a model does not have to learn a different representation of a word and every possible
punctuation symbol that could follow it, which would explode the number of representations the model has to learn.
Taking punctuation into account, tokenizing our exemplary text would give:`),en=c(),f(Ie.$$.fragment),tn=c(),C=o("p"),sl=a("Better. However, it is disadvantageous, how the tokenization dealt with the word "),hs=o("code"),al=a(`"Don't"`),nl=a(". "),cs=o("code"),ol=a(`"Don't"`),ll=a(` stands for
`),us=o("code"),rl=a('"do not"'),il=a(", so it would be better tokenized as "),ms=o("code"),pl=a(`["Do", "n't"]`),hl=a(`. This is where things start getting complicated, and
part of the reason each model has its own tokenizer type. Depending on the rules we apply for tokenizing a text, a
different tokenized output is generated for the same text. A pretrained model only performs properly if you feed it an
input that was tokenized with the same rules that were used to tokenize its training data.`),sn=c(),W=o("p"),Le=o("a"),cl=a("spaCy"),ul=a(" and "),Ue=o("a"),ml=a("Moses"),dl=a(` are two popular
rule-based tokenizers. Applying them on our example, `),ds=o("em"),fl=a("spaCy"),gl=a(" and "),fs=o("em"),bl=a("Moses"),vl=a(" would output something like:"),an=c(),f(He.$$.fragment),nn=c(),Y=o("p"),yl=a(`As can be seen space and punctuation tokenization, as well as rule-based tokenization, is used here. Space and
punctuation tokenization and rule-based tokenization are both examples of word tokenization, which is loosely defined
as splitting sentences into words. While it\u2019s the most intuitive way to split texts into smaller chunks, this
tokenization method can lead to problems for massive text corpora. In this case, space and punctuation tokenization
usually generates a very big vocabulary (the set of all unique words and tokens used). `),gs=o("em"),wl=a("E.g."),kl=a(", "),yt=o("a"),El=a("Transformer XL"),_l=a(" uses space and punctuation tokenization, resulting in a vocabulary size of 267,735!"),on=c(),wt=o("p"),zl=a(`Such a big vocabulary size forces the model to have an enormous embedding matrix as the input and output layer, which
causes both an increased memory and time complexity. In general, transformers models rarely have a vocabulary size
greater than 50,000, especially if they are pretrained only on a single language.`),ln=c(),kt=o("p"),ql=a("So if simple space and punctuation tokenization is unsatisfactory, why not simply tokenize on characters?"),rn=c(),f(Re.$$.fragment),pn=c(),B=o("p"),jl=a(`While character tokenization is very simple and would greatly reduce memory and time complexity it makes it much harder
for the model to learn meaningful input representations. `),bs=o("em"),$l=a("E.g."),xl=a(` learning a meaningful context-independent
representation for the letter `),vs=o("code"),Pl=a('"t"'),Tl=a(` is much harder than learning a context-independent representation for the word
`),ys=o("code"),Al=a('"today"'),Dl=a(`. Therefore, character tokenization is often accompanied by a loss of performance. So to get the best of
both worlds, transformers models use a hybrid between word-level and character-level tokenization called `),ws=o("strong"),Sl=a("subword"),Cl=a(`
tokenization.`),hn=c(),pe=o("h3"),ye=o("a"),ks=o("span"),f(Fe.$$.fragment),Bl=c(),Es=o("span"),Ol=a("Subword tokenization"),cn=c(),f(Ge.$$.fragment),un=c(),k=o("p"),Ml=a(`Subword tokenization algorithms rely on the principle that frequently used words should not be split into smaller
subwords, but rare words should be decomposed into meaningful subwords. For instance `),_s=o("code"),Nl=a('"annoyingly"'),Wl=a(` might be
considered a rare word and could be decomposed into `),zs=o("code"),Il=a('"annoying"'),Ll=a(" and "),qs=o("code"),Ul=a('"ly"'),Hl=a(". Both "),js=o("code"),Rl=a('"annoying"'),Fl=a(" and "),$s=o("code"),Gl=a('"ly"'),Xl=a(` as
stand-alone subwords would appear more frequently while at the same time the meaning of `),xs=o("code"),Kl=a('"annoyingly"'),Vl=a(` is kept by the
composite meaning of `),Ps=o("code"),Jl=a('"annoying"'),Yl=a(" and "),Ts=o("code"),Zl=a('"ly"'),Ql=a(`. This is especially useful in agglutinative languages such as Turkish,
where you can form (almost) arbitrarily long complex words by stringing together subwords.`),mn=c(),Z=o("p"),er=a(`Subword tokenization allows the model to have a reasonable vocabulary size while being able to learn meaningful
context-independent representations. In addition, subword tokenization enables the model to process words it has never
seen before, by decomposing them into known subwords. For instance, the `),Et=o("a"),tr=a("BertTokenizer"),sr=a(` tokenizes
`),As=o("code"),ar=a('"I have a new GPU!"'),nr=a(" as follows:"),dn=c(),f(Xe.$$.fragment),fn=c(),P=o("p"),or=a("Because we are considering the uncased model, the sentence was lowercased first. We can see that the words "),Ds=o("code"),lr=a('["i", "have", "a", "new"]'),rr=a(" are present in the tokenizer\u2019s vocabulary, but the word "),Ss=o("code"),ir=a('"gpu"'),pr=a(` is not. Consequently, the
tokenizer splits `),Cs=o("code"),hr=a('"gpu"'),cr=a(" into known subwords: "),Bs=o("code"),ur=a('["gp" and "##u"]'),mr=a(". "),Os=o("code"),dr=a('"##"'),fr=a(` means that the rest of the token should
be attached to the previous one, without space (for decoding or reversal of the tokenization).`),gn=c(),we=o("p"),gr=a("As another example, "),_t=o("a"),br=a("XLNetTokenizer"),vr=a(" tokenizes our previously exemplary text as follows:"),bn=c(),f(Ke.$$.fragment),vn=c(),T=o("p"),yr=a("We\u2019ll get back to the meaning of those "),Ms=o("code"),wr=a('"\u2581"'),kr=a(" when we look at "),zt=o("a"),Er=a("SentencePiece"),_r=a(`. As one can see,
the rare word `),Ns=o("code"),zr=a('"Transformers"'),qr=a(" has been split into the more frequent subwords "),Ws=o("code"),jr=a('"Transform"'),$r=a(" and "),Is=o("code"),xr=a('"ers"'),Pr=a("."),yn=c(),qt=o("p"),Tr=a(`Let\u2019s now look at how the different subword tokenization algorithms work. Note that all of those tokenization
algorithms rely on some form of training which is usually done on the corpus the corresponding model will be trained
on.`),wn=c(),jt=o("a"),kn=c(),he=o("h2"),ke=o("a"),Ls=o("span"),f(Ve.$$.fragment),Ar=c(),Us=o("span"),Dr=a("Byte-Pair Encoding (BPE)"),En=c(),q=o("p"),Sr=a("Byte-Pair Encoding (BPE) was introduced in "),Je=o("a"),Cr=a(`Neural Machine Translation of Rare Words with Subword Units (Sennrich et
al., 2015)`),Br=a(`. BPE relies on a pre-tokenizer that splits the training data into
words. Pretokenization can be as simple as space tokenization, e.g. `),$t=o("a"),Or=a("GPT-2"),Mr=a(", "),xt=o("a"),Nr=a("Roberta"),Wr=a(". More advanced pre-tokenization include rule-based tokenization, e.g. "),Pt=o("a"),Ir=a("XLM"),Lr=a(`,
`),Tt=o("a"),Ur=a("FlauBERT"),Hr=a(" which uses Moses for most languages, or "),At=o("a"),Rr=a("GPT"),Fr=a(` which uses
Spacy and ftfy, to count the frequency of each word in the training corpus.`),_n=c(),Dt=o("p"),Gr=a(`After pre-tokenization, a set of unique words has been created and the frequency of each word it occurred in the
training data has been determined. Next, BPE creates a base vocabulary consisting of all symbols that occur in the set
of unique words and learns merge rules to form a new symbol from two symbols of the base vocabulary. It does so until
the vocabulary has attained the desired vocabulary size. Note that the desired vocabulary size is a hyperparameter to
define before training the tokenizer.`),zn=c(),St=o("p"),Xr=a(`As an example, let\u2019s assume that after pre-tokenization, the following set of words including their frequency has been
determined:`),qn=c(),f(Ye.$$.fragment),jn=c(),Ee=o("p"),Kr=a("Consequently, the base vocabulary is "),Hs=o("code"),Vr=a('["b", "g", "h", "n", "p", "s", "u"]'),Jr=a(`. Splitting all words into symbols of the
base vocabulary, we obtain:`),$n=c(),f(Ze.$$.fragment),xn=c(),m=o("p"),Yr=a(`BPE then counts the frequency of each possible symbol pair and picks the symbol pair that occurs most frequently. In
the example above `),Rs=o("code"),Zr=a('"h"'),Qr=a(" followed by "),Fs=o("code"),ei=a('"u"'),ti=a(" is present "),Gs=o("em"),si=a("10 + 5 = 15"),ai=a(` times (10 times in the 10 occurrences of
`),Xs=o("code"),ni=a('"hug"'),oi=a(", 5 times in the 5 occurrences of "),Ks=o("code"),li=a('"hugs"'),ri=a("). However, the most frequent symbol pair is "),Vs=o("code"),ii=a('"u"'),pi=a(` followed by
`),Js=o("code"),hi=a('"g"'),ci=a(", occurring "),Ys=o("em"),ui=a("10 + 5 + 5 = 20"),mi=a(` times in total. Thus, the first merge rule the tokenizer learns is to group all
`),Zs=o("code"),di=a('"u"'),fi=a(" symbols followed by a "),Qs=o("code"),gi=a('"g"'),bi=a(" symbol together. Next, "),ea=o("code"),vi=a('"ug"'),yi=a(` is added to the vocabulary. The set of words then
becomes`),Pn=c(),f(Qe.$$.fragment),Tn=c(),E=o("p"),wi=a("BPE then identifies the next most common symbol pair. It\u2019s "),ta=o("code"),ki=a('"u"'),Ei=a(" followed by "),sa=o("code"),_i=a('"n"'),zi=a(", which occurs 16 times. "),aa=o("code"),qi=a('"u"'),ji=a(`,
`),na=o("code"),$i=a('"n"'),xi=a(" is merged to "),oa=o("code"),Pi=a('"un"'),Ti=a(" and added to the vocabulary. The next most frequent symbol pair is "),la=o("code"),Ai=a('"h"'),Di=a(` followed by
`),ra=o("code"),Si=a('"ug"'),Ci=a(", occurring 15 times. Again the pair is merged and "),ia=o("code"),Bi=a('"hug"'),Oi=a(" can be added to the vocabulary."),An=c(),_e=o("p"),Mi=a("At this stage, the vocabulary is "),pa=o("code"),Ni=a('["b", "g", "h", "n", "p", "s", "u", "ug", "un", "hug"]'),Wi=a(` and our set of unique words
is represented as`),Dn=c(),f(et.$$.fragment),Sn=c(),z=o("p"),Ii=a(`Assuming, that the Byte-Pair Encoding training would stop at this point, the learned merge rules would then be applied
to new words (as long as those new words do not include symbols that were not in the base vocabulary). For instance,
the word `),ha=o("code"),Li=a('"bug"'),Ui=a(" would be tokenized to "),ca=o("code"),Hi=a('["b", "ug"]'),Ri=a(" but "),ua=o("code"),Fi=a('"mug"'),Gi=a(" would be tokenized as "),ma=o("code"),Xi=a('["<unk>", "ug"]'),Ki=a(` since
the symbol `),da=o("code"),Vi=a('"m"'),Ji=a(" is not in the base vocabulary. In general, single letters such as "),fa=o("code"),Yi=a('"m"'),Zi=a(` are not replaced by the
`),ga=o("code"),Qi=a('"<unk>"'),ep=a(` symbol because the training data usually includes at least one occurrence of each letter, but it is likely
to happen for very special characters like emojis.`),Cn=c(),Q=o("p"),tp=a("As mentioned earlier, the vocabulary size, "),ba=o("em"),sp=a("i.e."),ap=a(` the base vocabulary size + the number of merges, is a hyperparameter
to choose. For instance `),Ct=o("a"),np=a("GPT"),op=a(` has a vocabulary size of 40,478 since they have 478 base characters
and chose to stop training after 40,000 merges.`),Bn=c(),ce=o("h3"),ze=o("a"),va=o("span"),f(tt.$$.fragment),lp=c(),ya=o("span"),rp=a("Byte-level BPE"),On=c(),H=o("p"),ip=a("A base vocabulary that includes all possible base characters can be quite large if "),wa=o("em"),pp=a("e.g."),hp=a(` all unicode characters are
considered as base characters. To have a better base vocabulary, `),st=o("a"),cp=a("GPT-2"),up=a(` uses bytes
as the base vocabulary, which is a clever trick to force the base vocabulary to be of size 256 while ensuring that
every base character is included in the vocabulary. With some additional rules to deal with punctuation, the GPT2\u2019s
tokenizer can tokenize every text without the need for the <unk> symbol. `),Bt=o("a"),mp=a("GPT-2"),dp=a(` has a vocabulary
size of 50,257, which corresponds to the 256 bytes base tokens, a special end-of-text token and the symbols learned
with 50,000 merges.`),Mn=c(),Ot=o("a"),Nn=c(),ue=o("h4"),qe=o("a"),ka=o("span"),f(at.$$.fragment),fp=c(),Ea=o("span"),gp=a("WordPiece"),Wn=c(),O=o("p"),bp=a("WordPiece is the subword tokenization algorithm used for "),Mt=o("a"),vp=a("BERT"),yp=a(", "),Nt=o("a"),wp=a("DistilBERT"),kp=a(", and "),Wt=o("a"),Ep=a("Electra"),_p=a(". The algorithm was outlined in "),nt=o("a"),zp=a(`Japanese and Korean
Voice Search (Schuster et al., 2012)`),qp=a(` and is very similar to
BPE. WordPiece first initializes the vocabulary to include every character present in the training data and
progressively learns a given number of merge rules. In contrast to BPE, WordPiece does not choose the most frequent
symbol pair, but the one that maximizes the likelihood of the training data once added to the vocabulary.`),In=c(),_=o("p"),jp=a(`So what does this mean exactly? Referring to the previous example, maximizing the likelihood of the training data is
equivalent to finding the symbol pair, whose probability divided by the probabilities of its first symbol followed by
its second symbol is the greatest among all symbol pairs. `),_a=o("em"),$p=a("E.g."),xp=c(),za=o("code"),Pp=a('"u"'),Tp=a(", followed by "),qa=o("code"),Ap=a('"g"'),Dp=a(` would have only been
merged if the probability of `),ja=o("code"),Sp=a('"ug"'),Cp=a(" divided by "),$a=o("code"),Bp=a('"u"'),Op=a(", "),xa=o("code"),Mp=a('"g"'),Np=a(` would have been greater than for any other symbol
pair. Intuitively, WordPiece is slightly different to BPE in that it evaluates what it `),Pa=o("em"),Wp=a("loses"),Ip=a(` by merging two symbols
to ensure it\u2019s `),Ta=o("em"),Lp=a("worth it"),Up=a("."),Ln=c(),It=o("a"),Un=c(),me=o("h4"),je=o("a"),Aa=o("span"),f(ot.$$.fragment),Hp=c(),Da=o("span"),Rp=a("Unigram"),Hn=c(),ee=o("p"),Fp=a("Unigram is a subword tokenization algorithm introduced in "),lt=o("a"),Gp=a(`Subword Regularization: Improving Neural Network Translation
Models with Multiple Subword Candidates (Kudo, 2018)`),Xp=a(`. In contrast to BPE or
WordPiece, Unigram initializes its base vocabulary to a large number of symbols and progressively trims down each
symbol to obtain a smaller vocabulary. The base vocabulary could for instance correspond to all pre-tokenized words and
the most common substrings. Unigram is not used directly for any of the models in the transformers, but it\u2019s used in
conjunction with `),Lt=o("a"),Kp=a("SentencePiece"),Vp=a("."),Rn=c(),$e=o("p"),Jp=a(`At each training step, the Unigram algorithm defines a loss (often defined as the log-likelihood) over the training
data given the current vocabulary and a unigram language model. Then, for each symbol in the vocabulary, the algorithm
computes how much the overall loss would increase if the symbol was to be removed from the vocabulary. Unigram then
removes p (with p usually being 10% or 20%) percent of the symbols whose loss increase is the lowest, `),Sa=o("em"),Yp=a("i.e."),Zp=a(` those
symbols that least affect the overall loss over the training data. This process is repeated until the vocabulary has
reached the desired size. The Unigram algorithm always keeps the base characters so that any word can be tokenized.`),Fn=c(),Ut=o("p"),Qp=a(`Because Unigram is not based on merge rules (in contrast to BPE and WordPiece), the algorithm has several ways of
tokenizing new text after training. As an example, if a trained Unigram tokenizer exhibits the vocabulary:`),Gn=c(),f(rt.$$.fragment),Xn=c(),I=o("p"),Ca=o("code"),eh=a('"hugs"'),th=a(" could be tokenized both as "),Ba=o("code"),sh=a('["hug", "s"]'),ah=a(", "),Oa=o("code"),nh=a('["h", "ug", "s"]'),oh=a(" or "),Ma=o("code"),lh=a('["h", "u", "g", "s"]'),rh=a(`. So which one
to choose? Unigram saves the probability of each token in the training corpus on top of saving the vocabulary so that
the probability of each possible tokenization can be computed after training. The algorithm simply picks the most
likely tokenization in practice, but also offers the possibility to sample a possible tokenization according to their
probabilities.`),Kn=c(),L=o("p"),ih=a(`Those probabilities are defined by the loss the tokenizer is trained on. Assuming that the training data consists of
the words `),Vn=new ko,Jn=a(" and that the set of all possible tokenizations for a word "),Yn=new ko,Zn=a(` is
defined as `),Qn=new ko,eo=a(`, then the overall loss is defined as
`),to=new ko,so=c(),Ht=o("a"),ao=c(),de=o("h4"),xe=o("a"),Na=o("span"),f(it.$$.fragment),ph=c(),Wa=o("span"),hh=a("SentencePiece"),no=c(),R=o("p"),ch=a(`All tokenization algorithms described so far have the same problem: It is assumed that the input text uses spaces to
separate words. However, not all languages use spaces to separate words. One possible solution is to use language
specific pre-tokenizers, `),Ia=o("em"),uh=a("e.g."),mh=c(),Rt=o("a"),dh=a("XLM"),fh=a(` uses a specific Chinese, Japanese, and Thai pre-tokenizer).
To solve this problem more generally, `),pt=o("a"),gh=a(`SentencePiece: A simple and language independent subword tokenizer and
detokenizer for Neural Text Processing (Kudo et al., 2018)`),bh=a(` treats the input
as a raw input stream, thus including the space in the set of characters to use. It then uses the BPE or unigram
algorithm to construct the appropriate vocabulary.`),oo=c(),F=o("p"),vh=a("The "),Ft=o("a"),yh=a("XLNetTokenizer"),wh=a(` uses SentencePiece for example, which is also why in the example earlier the
`),La=o("code"),kh=a('"\u2581"'),Eh=a(` character was included in the vocabulary. Decoding with SentencePiece is very easy since all tokens can just be
concatenated and `),Ua=o("code"),_h=a('"\u2581"'),zh=a(" is replaced by a space."),lo=c(),M=o("p"),qh=a(`All transformers models in the library that use SentencePiece use it in combination with unigram. Examples of models
using SentencePiece are `),Gt=o("a"),jh=a("ALBERT"),$h=a(", "),Xt=o("a"),xh=a("XLNet"),Ph=a(", "),Kt=o("a"),Th=a("Marian"),Ah=a(", and "),Vt=o("a"),Dh=a("T5"),Sh=a("."),this.h()},l(e){const i=jm('[data-svelte="svelte-1phssyn"]',document.head);V=l(i,"META",{name:!0,content:!0}),i.forEach(s),ht=u(e),U=l(e,"H1",{class:!0});var io=r(U);K=l(io,"A",{id:!0,class:!0,href:!0});var Bh=r(K);ts=l(Bh,"SPAN",{});var Oh=r(ts);g(Se.$$.fragment,Oh),Oh.forEach(s),Bh.forEach(s),qo=u(io),ss=l(io,"SPAN",{});var Mh=r(ss);jo=n(Mh,"Summary of the tokenizers"),Mh.forEach(s),io.forEach(s),Ha=u(e),g(Ce.$$.fragment,e),Ra=u(e),ct=l(e,"P",{});var Nh=r(ct);$o=n(Nh,"On this page, we will have a closer look at tokenization."),Nh.forEach(s),Fa=u(e),g(Be.$$.fragment,e),Ga=u(e),D=l(e,"P",{});var te=r(D);xo=n(te,"As we saw in "),ut=l(te,"A",{href:!0});var Wh=r(ut);Po=n(Wh,"the preprocessing tutorial"),Wh.forEach(s),To=n(te,`, tokenizing a text is splitting it into words or
subwords, which then are converted to ids through a look-up table. Converting words or subwords to ids is
straightforward, so in this summary, we will focus on splitting a text into words or subwords (i.e. tokenizing a text).
More specifically, we will look at the three main types of tokenizers used in \u{1F917} Transformers: `),mt=l(te,"A",{href:!0});var Ih=r(mt);Ao=n(Ih,`Byte-Pair Encoding
(BPE)`),Ih.forEach(s),Do=n(te,", "),dt=l(te,"A",{href:!0});var Lh=r(dt);So=n(Lh,"WordPiece"),Lh.forEach(s),Co=n(te,", and "),ft=l(te,"A",{href:!0});var Uh=r(ft);Bo=n(Uh,"SentencePiece"),Uh.forEach(s),Oo=n(te,`, and show examples
of which tokenizer type is used by which model.`),te.forEach(s),Xa=u(e),J=l(e,"P",{});var Jt=r(J);Mo=n(Jt,`Note that on each model page, you can look at the documentation of the associated tokenizer to know which tokenizer
type was used by the pretrained model. For instance, if we look at `),gt=l(Jt,"A",{href:!0});var Hh=r(gt);No=n(Hh,"BertTokenizer"),Hh.forEach(s),Wo=n(Jt,`, we can see
that the model uses `),bt=l(Jt,"A",{href:!0});var Rh=r(bt);Io=n(Rh,"WordPiece"),Rh.forEach(s),Lo=n(Jt,"."),Jt.forEach(s),Ka=u(e),ie=l(e,"H2",{class:!0});var po=r(ie);ve=l(po,"A",{id:!0,class:!0,href:!0});var Fh=r(ve);as=l(Fh,"SPAN",{});var Gh=r(as);g(Oe.$$.fragment,Gh),Gh.forEach(s),Fh.forEach(s),Uo=u(po),ns=l(po,"SPAN",{});var Xh=r(ns);Ho=n(Xh,"Introduction"),Xh.forEach(s),po.forEach(s),Va=u(e),Me=l(e,"P",{});var Ch=r(Me);Ro=n(Ch,`Splitting a text into smaller chunks is a task that is harder than it looks, and there are multiple ways of doing so.
For instance, let\u2019s look at the sentence `),os=l(Ch,"CODE",{});var Kh=r(os);Fo=n(Kh,`"Don't you love \u{1F917} Transformers? We sure do."`),Kh.forEach(s),Ch.forEach(s),Ja=u(e),g(Ne.$$.fragment,e),Ya=u(e),vt=l(e,"P",{});var Vh=r(vt);Go=n(Vh,"A simple way of tokenizing this text is to split it by spaces, which would give:"),Vh.forEach(s),Za=u(e),g(We.$$.fragment,e),Qa=u(e),S=l(e,"P",{});var se=r(S);Xo=n(se,"This is a sensible first step, but if we look at the tokens "),ls=l(se,"CODE",{});var Jh=r(ls);Ko=n(Jh,'"Transformers?"'),Jh.forEach(s),Vo=n(se," and "),rs=l(se,"CODE",{});var Yh=r(rs);Jo=n(Yh,'"do."'),Yh.forEach(s),Yo=n(se,`, we notice that the
punctuation is attached to the words `),is=l(se,"CODE",{});var Zh=r(is);Zo=n(Zh,'"Transformer"'),Zh.forEach(s),Qo=n(se," and "),ps=l(se,"CODE",{});var Qh=r(ps);el=n(Qh,'"do"'),Qh.forEach(s),tl=n(se,`, which is suboptimal. We should take the
punctuation into account so that a model does not have to learn a different representation of a word and every possible
punctuation symbol that could follow it, which would explode the number of representations the model has to learn.
Taking punctuation into account, tokenizing our exemplary text would give:`),se.forEach(s),en=u(e),g(Ie.$$.fragment,e),tn=u(e),C=l(e,"P",{});var ae=r(C);sl=n(ae,"Better. However, it is disadvantageous, how the tokenization dealt with the word "),hs=l(ae,"CODE",{});var ec=r(hs);al=n(ec,`"Don't"`),ec.forEach(s),nl=n(ae,". "),cs=l(ae,"CODE",{});var tc=r(cs);ol=n(tc,`"Don't"`),tc.forEach(s),ll=n(ae,` stands for
`),us=l(ae,"CODE",{});var sc=r(us);rl=n(sc,'"do not"'),sc.forEach(s),il=n(ae,", so it would be better tokenized as "),ms=l(ae,"CODE",{});var ac=r(ms);pl=n(ac,`["Do", "n't"]`),ac.forEach(s),hl=n(ae,`. This is where things start getting complicated, and
part of the reason each model has its own tokenizer type. Depending on the rules we apply for tokenizing a text, a
different tokenized output is generated for the same text. A pretrained model only performs properly if you feed it an
input that was tokenized with the same rules that were used to tokenize its training data.`),ae.forEach(s),sn=u(e),W=l(e,"P",{});var fe=r(W);Le=l(fe,"A",{href:!0,rel:!0});var nc=r(Le);cl=n(nc,"spaCy"),nc.forEach(s),ul=n(fe," and "),Ue=l(fe,"A",{href:!0,rel:!0});var oc=r(Ue);ml=n(oc,"Moses"),oc.forEach(s),dl=n(fe,` are two popular
rule-based tokenizers. Applying them on our example, `),ds=l(fe,"EM",{});var lc=r(ds);fl=n(lc,"spaCy"),lc.forEach(s),gl=n(fe," and "),fs=l(fe,"EM",{});var rc=r(fs);bl=n(rc,"Moses"),rc.forEach(s),vl=n(fe," would output something like:"),fe.forEach(s),an=u(e),g(He.$$.fragment,e),nn=u(e),Y=l(e,"P",{});var Yt=r(Y);yl=n(Yt,`As can be seen space and punctuation tokenization, as well as rule-based tokenization, is used here. Space and
punctuation tokenization and rule-based tokenization are both examples of word tokenization, which is loosely defined
as splitting sentences into words. While it\u2019s the most intuitive way to split texts into smaller chunks, this
tokenization method can lead to problems for massive text corpora. In this case, space and punctuation tokenization
usually generates a very big vocabulary (the set of all unique words and tokens used). `),gs=l(Yt,"EM",{});var ic=r(gs);wl=n(ic,"E.g."),ic.forEach(s),kl=n(Yt,", "),yt=l(Yt,"A",{href:!0});var pc=r(yt);El=n(pc,"Transformer XL"),pc.forEach(s),_l=n(Yt," uses space and punctuation tokenization, resulting in a vocabulary size of 267,735!"),Yt.forEach(s),on=u(e),wt=l(e,"P",{});var hc=r(wt);zl=n(hc,`Such a big vocabulary size forces the model to have an enormous embedding matrix as the input and output layer, which
causes both an increased memory and time complexity. In general, transformers models rarely have a vocabulary size
greater than 50,000, especially if they are pretrained only on a single language.`),hc.forEach(s),ln=u(e),kt=l(e,"P",{});var cc=r(kt);ql=n(cc,"So if simple space and punctuation tokenization is unsatisfactory, why not simply tokenize on characters?"),cc.forEach(s),rn=u(e),g(Re.$$.fragment,e),pn=u(e),B=l(e,"P",{});var ne=r(B);jl=n(ne,`While character tokenization is very simple and would greatly reduce memory and time complexity it makes it much harder
for the model to learn meaningful input representations. `),bs=l(ne,"EM",{});var uc=r(bs);$l=n(uc,"E.g."),uc.forEach(s),xl=n(ne,` learning a meaningful context-independent
representation for the letter `),vs=l(ne,"CODE",{});var mc=r(vs);Pl=n(mc,'"t"'),mc.forEach(s),Tl=n(ne,` is much harder than learning a context-independent representation for the word
`),ys=l(ne,"CODE",{});var dc=r(ys);Al=n(dc,'"today"'),dc.forEach(s),Dl=n(ne,`. Therefore, character tokenization is often accompanied by a loss of performance. So to get the best of
both worlds, transformers models use a hybrid between word-level and character-level tokenization called `),ws=l(ne,"STRONG",{});var fc=r(ws);Sl=n(fc,"subword"),fc.forEach(s),Cl=n(ne,`
tokenization.`),ne.forEach(s),hn=u(e),pe=l(e,"H3",{class:!0});var ho=r(pe);ye=l(ho,"A",{id:!0,class:!0,href:!0});var gc=r(ye);ks=l(gc,"SPAN",{});var bc=r(ks);g(Fe.$$.fragment,bc),bc.forEach(s),gc.forEach(s),Bl=u(ho),Es=l(ho,"SPAN",{});var vc=r(Es);Ol=n(vc,"Subword tokenization"),vc.forEach(s),ho.forEach(s),cn=u(e),g(Ge.$$.fragment,e),un=u(e),k=l(e,"P",{});var j=r(k);Ml=n(j,`Subword tokenization algorithms rely on the principle that frequently used words should not be split into smaller
subwords, but rare words should be decomposed into meaningful subwords. For instance `),_s=l(j,"CODE",{});var yc=r(_s);Nl=n(yc,'"annoyingly"'),yc.forEach(s),Wl=n(j,` might be
considered a rare word and could be decomposed into `),zs=l(j,"CODE",{});var wc=r(zs);Il=n(wc,'"annoying"'),wc.forEach(s),Ll=n(j," and "),qs=l(j,"CODE",{});var kc=r(qs);Ul=n(kc,'"ly"'),kc.forEach(s),Hl=n(j,". Both "),js=l(j,"CODE",{});var Ec=r(js);Rl=n(Ec,'"annoying"'),Ec.forEach(s),Fl=n(j," and "),$s=l(j,"CODE",{});var _c=r($s);Gl=n(_c,'"ly"'),_c.forEach(s),Xl=n(j,` as
stand-alone subwords would appear more frequently while at the same time the meaning of `),xs=l(j,"CODE",{});var zc=r(xs);Kl=n(zc,'"annoyingly"'),zc.forEach(s),Vl=n(j,` is kept by the
composite meaning of `),Ps=l(j,"CODE",{});var qc=r(Ps);Jl=n(qc,'"annoying"'),qc.forEach(s),Yl=n(j," and "),Ts=l(j,"CODE",{});var jc=r(Ts);Zl=n(jc,'"ly"'),jc.forEach(s),Ql=n(j,`. This is especially useful in agglutinative languages such as Turkish,
where you can form (almost) arbitrarily long complex words by stringing together subwords.`),j.forEach(s),mn=u(e),Z=l(e,"P",{});var Zt=r(Z);er=n(Zt,`Subword tokenization allows the model to have a reasonable vocabulary size while being able to learn meaningful
context-independent representations. In addition, subword tokenization enables the model to process words it has never
seen before, by decomposing them into known subwords. For instance, the `),Et=l(Zt,"A",{href:!0});var $c=r(Et);tr=n($c,"BertTokenizer"),$c.forEach(s),sr=n(Zt,` tokenizes
`),As=l(Zt,"CODE",{});var xc=r(As);ar=n(xc,'"I have a new GPU!"'),xc.forEach(s),nr=n(Zt," as follows:"),Zt.forEach(s),dn=u(e),g(Xe.$$.fragment,e),fn=u(e),P=l(e,"P",{});var G=r(P);or=n(G,"Because we are considering the uncased model, the sentence was lowercased first. We can see that the words "),Ds=l(G,"CODE",{});var Pc=r(Ds);lr=n(Pc,'["i", "have", "a", "new"]'),Pc.forEach(s),rr=n(G," are present in the tokenizer\u2019s vocabulary, but the word "),Ss=l(G,"CODE",{});var Tc=r(Ss);ir=n(Tc,'"gpu"'),Tc.forEach(s),pr=n(G,` is not. Consequently, the
tokenizer splits `),Cs=l(G,"CODE",{});var Ac=r(Cs);hr=n(Ac,'"gpu"'),Ac.forEach(s),cr=n(G," into known subwords: "),Bs=l(G,"CODE",{});var Dc=r(Bs);ur=n(Dc,'["gp" and "##u"]'),Dc.forEach(s),mr=n(G,". "),Os=l(G,"CODE",{});var Sc=r(Os);dr=n(Sc,'"##"'),Sc.forEach(s),fr=n(G,` means that the rest of the token should
be attached to the previous one, without space (for decoding or reversal of the tokenization).`),G.forEach(s),gn=u(e),we=l(e,"P",{});var co=r(we);gr=n(co,"As another example, "),_t=l(co,"A",{href:!0});var Cc=r(_t);br=n(Cc,"XLNetTokenizer"),Cc.forEach(s),vr=n(co," tokenizes our previously exemplary text as follows:"),co.forEach(s),bn=u(e),g(Ke.$$.fragment,e),vn=u(e),T=l(e,"P",{});var X=r(T);yr=n(X,"We\u2019ll get back to the meaning of those "),Ms=l(X,"CODE",{});var Bc=r(Ms);wr=n(Bc,'"\u2581"'),Bc.forEach(s),kr=n(X," when we look at "),zt=l(X,"A",{href:!0});var Oc=r(zt);Er=n(Oc,"SentencePiece"),Oc.forEach(s),_r=n(X,`. As one can see,
the rare word `),Ns=l(X,"CODE",{});var Mc=r(Ns);zr=n(Mc,'"Transformers"'),Mc.forEach(s),qr=n(X," has been split into the more frequent subwords "),Ws=l(X,"CODE",{});var Nc=r(Ws);jr=n(Nc,'"Transform"'),Nc.forEach(s),$r=n(X," and "),Is=l(X,"CODE",{});var Wc=r(Is);xr=n(Wc,'"ers"'),Wc.forEach(s),Pr=n(X,"."),X.forEach(s),yn=u(e),qt=l(e,"P",{});var Ic=r(qt);Tr=n(Ic,`Let\u2019s now look at how the different subword tokenization algorithms work. Note that all of those tokenization
algorithms rely on some form of training which is usually done on the corpus the corresponding model will be trained
on.`),Ic.forEach(s),wn=u(e),jt=l(e,"A",{id:!0}),r(jt).forEach(s),kn=u(e),he=l(e,"H2",{class:!0});var uo=r(he);ke=l(uo,"A",{id:!0,class:!0,href:!0});var Lc=r(ke);Ls=l(Lc,"SPAN",{});var Uc=r(Ls);g(Ve.$$.fragment,Uc),Uc.forEach(s),Lc.forEach(s),Ar=u(uo),Us=l(uo,"SPAN",{});var Hc=r(Us);Dr=n(Hc,"Byte-Pair Encoding (BPE)"),Hc.forEach(s),uo.forEach(s),En=u(e),q=l(e,"P",{});var N=r(q);Sr=n(N,"Byte-Pair Encoding (BPE) was introduced in "),Je=l(N,"A",{href:!0,rel:!0});var Rc=r(Je);Cr=n(Rc,`Neural Machine Translation of Rare Words with Subword Units (Sennrich et
al., 2015)`),Rc.forEach(s),Br=n(N,`. BPE relies on a pre-tokenizer that splits the training data into
words. Pretokenization can be as simple as space tokenization, e.g. `),$t=l(N,"A",{href:!0});var Fc=r($t);Or=n(Fc,"GPT-2"),Fc.forEach(s),Mr=n(N,", "),xt=l(N,"A",{href:!0});var Gc=r(xt);Nr=n(Gc,"Roberta"),Gc.forEach(s),Wr=n(N,". More advanced pre-tokenization include rule-based tokenization, e.g. "),Pt=l(N,"A",{href:!0});var Xc=r(Pt);Ir=n(Xc,"XLM"),Xc.forEach(s),Lr=n(N,`,
`),Tt=l(N,"A",{href:!0});var Kc=r(Tt);Ur=n(Kc,"FlauBERT"),Kc.forEach(s),Hr=n(N," which uses Moses for most languages, or "),At=l(N,"A",{href:!0});var Vc=r(At);Rr=n(Vc,"GPT"),Vc.forEach(s),Fr=n(N,` which uses
Spacy and ftfy, to count the frequency of each word in the training corpus.`),N.forEach(s),_n=u(e),Dt=l(e,"P",{});var Jc=r(Dt);Gr=n(Jc,`After pre-tokenization, a set of unique words has been created and the frequency of each word it occurred in the
training data has been determined. Next, BPE creates a base vocabulary consisting of all symbols that occur in the set
of unique words and learns merge rules to form a new symbol from two symbols of the base vocabulary. It does so until
the vocabulary has attained the desired vocabulary size. Note that the desired vocabulary size is a hyperparameter to
define before training the tokenizer.`),Jc.forEach(s),zn=u(e),St=l(e,"P",{});var Yc=r(St);Xr=n(Yc,`As an example, let\u2019s assume that after pre-tokenization, the following set of words including their frequency has been
determined:`),Yc.forEach(s),qn=u(e),g(Ye.$$.fragment,e),jn=u(e),Ee=l(e,"P",{});var mo=r(Ee);Kr=n(mo,"Consequently, the base vocabulary is "),Hs=l(mo,"CODE",{});var Zc=r(Hs);Vr=n(Zc,'["b", "g", "h", "n", "p", "s", "u"]'),Zc.forEach(s),Jr=n(mo,`. Splitting all words into symbols of the
base vocabulary, we obtain:`),mo.forEach(s),$n=u(e),g(Ze.$$.fragment,e),xn=u(e),m=l(e,"P",{});var d=r(m);Yr=n(d,`BPE then counts the frequency of each possible symbol pair and picks the symbol pair that occurs most frequently. In
the example above `),Rs=l(d,"CODE",{});var Qc=r(Rs);Zr=n(Qc,'"h"'),Qc.forEach(s),Qr=n(d," followed by "),Fs=l(d,"CODE",{});var eu=r(Fs);ei=n(eu,'"u"'),eu.forEach(s),ti=n(d," is present "),Gs=l(d,"EM",{});var tu=r(Gs);si=n(tu,"10 + 5 = 15"),tu.forEach(s),ai=n(d,` times (10 times in the 10 occurrences of
`),Xs=l(d,"CODE",{});var su=r(Xs);ni=n(su,'"hug"'),su.forEach(s),oi=n(d,", 5 times in the 5 occurrences of "),Ks=l(d,"CODE",{});var au=r(Ks);li=n(au,'"hugs"'),au.forEach(s),ri=n(d,"). However, the most frequent symbol pair is "),Vs=l(d,"CODE",{});var nu=r(Vs);ii=n(nu,'"u"'),nu.forEach(s),pi=n(d,` followed by
`),Js=l(d,"CODE",{});var ou=r(Js);hi=n(ou,'"g"'),ou.forEach(s),ci=n(d,", occurring "),Ys=l(d,"EM",{});var lu=r(Ys);ui=n(lu,"10 + 5 + 5 = 20"),lu.forEach(s),mi=n(d,` times in total. Thus, the first merge rule the tokenizer learns is to group all
`),Zs=l(d,"CODE",{});var ru=r(Zs);di=n(ru,'"u"'),ru.forEach(s),fi=n(d," symbols followed by a "),Qs=l(d,"CODE",{});var iu=r(Qs);gi=n(iu,'"g"'),iu.forEach(s),bi=n(d," symbol together. Next, "),ea=l(d,"CODE",{});var pu=r(ea);vi=n(pu,'"ug"'),pu.forEach(s),yi=n(d,` is added to the vocabulary. The set of words then
becomes`),d.forEach(s),Pn=u(e),g(Qe.$$.fragment,e),Tn=u(e),E=l(e,"P",{});var $=r(E);wi=n($,"BPE then identifies the next most common symbol pair. It\u2019s "),ta=l($,"CODE",{});var hu=r(ta);ki=n(hu,'"u"'),hu.forEach(s),Ei=n($," followed by "),sa=l($,"CODE",{});var cu=r(sa);_i=n(cu,'"n"'),cu.forEach(s),zi=n($,", which occurs 16 times. "),aa=l($,"CODE",{});var uu=r(aa);qi=n(uu,'"u"'),uu.forEach(s),ji=n($,`,
`),na=l($,"CODE",{});var mu=r(na);$i=n(mu,'"n"'),mu.forEach(s),xi=n($," is merged to "),oa=l($,"CODE",{});var du=r(oa);Pi=n(du,'"un"'),du.forEach(s),Ti=n($," and added to the vocabulary. The next most frequent symbol pair is "),la=l($,"CODE",{});var fu=r(la);Ai=n(fu,'"h"'),fu.forEach(s),Di=n($,` followed by
`),ra=l($,"CODE",{});var gu=r(ra);Si=n(gu,'"ug"'),gu.forEach(s),Ci=n($,", occurring 15 times. Again the pair is merged and "),ia=l($,"CODE",{});var bu=r(ia);Bi=n(bu,'"hug"'),bu.forEach(s),Oi=n($," can be added to the vocabulary."),$.forEach(s),An=u(e),_e=l(e,"P",{});var fo=r(_e);Mi=n(fo,"At this stage, the vocabulary is "),pa=l(fo,"CODE",{});var vu=r(pa);Ni=n(vu,'["b", "g", "h", "n", "p", "s", "u", "ug", "un", "hug"]'),vu.forEach(s),Wi=n(fo,` and our set of unique words
is represented as`),fo.forEach(s),Dn=u(e),g(et.$$.fragment,e),Sn=u(e),z=l(e,"P",{});var A=r(z);Ii=n(A,`Assuming, that the Byte-Pair Encoding training would stop at this point, the learned merge rules would then be applied
to new words (as long as those new words do not include symbols that were not in the base vocabulary). For instance,
the word `),ha=l(A,"CODE",{});var yu=r(ha);Li=n(yu,'"bug"'),yu.forEach(s),Ui=n(A," would be tokenized to "),ca=l(A,"CODE",{});var wu=r(ca);Hi=n(wu,'["b", "ug"]'),wu.forEach(s),Ri=n(A," but "),ua=l(A,"CODE",{});var ku=r(ua);Fi=n(ku,'"mug"'),ku.forEach(s),Gi=n(A," would be tokenized as "),ma=l(A,"CODE",{});var Eu=r(ma);Xi=n(Eu,'["<unk>", "ug"]'),Eu.forEach(s),Ki=n(A,` since
the symbol `),da=l(A,"CODE",{});var _u=r(da);Vi=n(_u,'"m"'),_u.forEach(s),Ji=n(A," is not in the base vocabulary. In general, single letters such as "),fa=l(A,"CODE",{});var zu=r(fa);Yi=n(zu,'"m"'),zu.forEach(s),Zi=n(A,` are not replaced by the
`),ga=l(A,"CODE",{});var qu=r(ga);Qi=n(qu,'"<unk>"'),qu.forEach(s),ep=n(A,` symbol because the training data usually includes at least one occurrence of each letter, but it is likely
to happen for very special characters like emojis.`),A.forEach(s),Cn=u(e),Q=l(e,"P",{});var Qt=r(Q);tp=n(Qt,"As mentioned earlier, the vocabulary size, "),ba=l(Qt,"EM",{});var ju=r(ba);sp=n(ju,"i.e."),ju.forEach(s),ap=n(Qt,` the base vocabulary size + the number of merges, is a hyperparameter
to choose. For instance `),Ct=l(Qt,"A",{href:!0});var $u=r(Ct);np=n($u,"GPT"),$u.forEach(s),op=n(Qt,` has a vocabulary size of 40,478 since they have 478 base characters
and chose to stop training after 40,000 merges.`),Qt.forEach(s),Bn=u(e),ce=l(e,"H3",{class:!0});var go=r(ce);ze=l(go,"A",{id:!0,class:!0,href:!0});var xu=r(ze);va=l(xu,"SPAN",{});var Pu=r(va);g(tt.$$.fragment,Pu),Pu.forEach(s),xu.forEach(s),lp=u(go),ya=l(go,"SPAN",{});var Tu=r(ya);rp=n(Tu,"Byte-level BPE"),Tu.forEach(s),go.forEach(s),On=u(e),H=l(e,"P",{});var Pe=r(H);ip=n(Pe,"A base vocabulary that includes all possible base characters can be quite large if "),wa=l(Pe,"EM",{});var Au=r(wa);pp=n(Au,"e.g."),Au.forEach(s),hp=n(Pe,` all unicode characters are
considered as base characters. To have a better base vocabulary, `),st=l(Pe,"A",{href:!0,rel:!0});var Du=r(st);cp=n(Du,"GPT-2"),Du.forEach(s),up=n(Pe,` uses bytes
as the base vocabulary, which is a clever trick to force the base vocabulary to be of size 256 while ensuring that
every base character is included in the vocabulary. With some additional rules to deal with punctuation, the GPT2\u2019s
tokenizer can tokenize every text without the need for the <unk> symbol. `),Bt=l(Pe,"A",{href:!0});var Su=r(Bt);mp=n(Su,"GPT-2"),Su.forEach(s),dp=n(Pe,` has a vocabulary
size of 50,257, which corresponds to the 256 bytes base tokens, a special end-of-text token and the symbols learned
with 50,000 merges.`),Pe.forEach(s),Mn=u(e),Ot=l(e,"A",{id:!0}),r(Ot).forEach(s),Nn=u(e),ue=l(e,"H4",{class:!0});var bo=r(ue);qe=l(bo,"A",{id:!0,class:!0,href:!0});var Cu=r(qe);ka=l(Cu,"SPAN",{});var Bu=r(ka);g(at.$$.fragment,Bu),Bu.forEach(s),Cu.forEach(s),fp=u(bo),Ea=l(bo,"SPAN",{});var Ou=r(Ea);gp=n(Ou,"WordPiece"),Ou.forEach(s),bo.forEach(s),Wn=u(e),O=l(e,"P",{});var oe=r(O);bp=n(oe,"WordPiece is the subword tokenization algorithm used for "),Mt=l(oe,"A",{href:!0});var Mu=r(Mt);vp=n(Mu,"BERT"),Mu.forEach(s),yp=n(oe,", "),Nt=l(oe,"A",{href:!0});var Nu=r(Nt);wp=n(Nu,"DistilBERT"),Nu.forEach(s),kp=n(oe,", and "),Wt=l(oe,"A",{href:!0});var Wu=r(Wt);Ep=n(Wu,"Electra"),Wu.forEach(s),_p=n(oe,". The algorithm was outlined in "),nt=l(oe,"A",{href:!0,rel:!0});var Iu=r(nt);zp=n(Iu,`Japanese and Korean
Voice Search (Schuster et al., 2012)`),Iu.forEach(s),qp=n(oe,` and is very similar to
BPE. WordPiece first initializes the vocabulary to include every character present in the training data and
progressively learns a given number of merge rules. In contrast to BPE, WordPiece does not choose the most frequent
symbol pair, but the one that maximizes the likelihood of the training data once added to the vocabulary.`),oe.forEach(s),In=u(e),_=l(e,"P",{});var x=r(_);jp=n(x,`So what does this mean exactly? Referring to the previous example, maximizing the likelihood of the training data is
equivalent to finding the symbol pair, whose probability divided by the probabilities of its first symbol followed by
its second symbol is the greatest among all symbol pairs. `),_a=l(x,"EM",{});var Lu=r(_a);$p=n(Lu,"E.g."),Lu.forEach(s),xp=u(x),za=l(x,"CODE",{});var Uu=r(za);Pp=n(Uu,'"u"'),Uu.forEach(s),Tp=n(x,", followed by "),qa=l(x,"CODE",{});var Hu=r(qa);Ap=n(Hu,'"g"'),Hu.forEach(s),Dp=n(x,` would have only been
merged if the probability of `),ja=l(x,"CODE",{});var Ru=r(ja);Sp=n(Ru,'"ug"'),Ru.forEach(s),Cp=n(x," divided by "),$a=l(x,"CODE",{});var Fu=r($a);Bp=n(Fu,'"u"'),Fu.forEach(s),Op=n(x,", "),xa=l(x,"CODE",{});var Gu=r(xa);Mp=n(Gu,'"g"'),Gu.forEach(s),Np=n(x,` would have been greater than for any other symbol
pair. Intuitively, WordPiece is slightly different to BPE in that it evaluates what it `),Pa=l(x,"EM",{});var Xu=r(Pa);Wp=n(Xu,"loses"),Xu.forEach(s),Ip=n(x,` by merging two symbols
to ensure it\u2019s `),Ta=l(x,"EM",{});var Ku=r(Ta);Lp=n(Ku,"worth it"),Ku.forEach(s),Up=n(x,"."),x.forEach(s),Ln=u(e),It=l(e,"A",{id:!0}),r(It).forEach(s),Un=u(e),me=l(e,"H4",{class:!0});var vo=r(me);je=l(vo,"A",{id:!0,class:!0,href:!0});var Vu=r(je);Aa=l(Vu,"SPAN",{});var Ju=r(Aa);g(ot.$$.fragment,Ju),Ju.forEach(s),Vu.forEach(s),Hp=u(vo),Da=l(vo,"SPAN",{});var Yu=r(Da);Rp=n(Yu,"Unigram"),Yu.forEach(s),vo.forEach(s),Hn=u(e),ee=l(e,"P",{});var es=r(ee);Fp=n(es,"Unigram is a subword tokenization algorithm introduced in "),lt=l(es,"A",{href:!0,rel:!0});var Zu=r(lt);Gp=n(Zu,`Subword Regularization: Improving Neural Network Translation
Models with Multiple Subword Candidates (Kudo, 2018)`),Zu.forEach(s),Xp=n(es,`. In contrast to BPE or
WordPiece, Unigram initializes its base vocabulary to a large number of symbols and progressively trims down each
symbol to obtain a smaller vocabulary. The base vocabulary could for instance correspond to all pre-tokenized words and
the most common substrings. Unigram is not used directly for any of the models in the transformers, but it\u2019s used in
conjunction with `),Lt=l(es,"A",{href:!0});var Qu=r(Lt);Kp=n(Qu,"SentencePiece"),Qu.forEach(s),Vp=n(es,"."),es.forEach(s),Rn=u(e),$e=l(e,"P",{});var yo=r($e);Jp=n(yo,`At each training step, the Unigram algorithm defines a loss (often defined as the log-likelihood) over the training
data given the current vocabulary and a unigram language model. Then, for each symbol in the vocabulary, the algorithm
computes how much the overall loss would increase if the symbol was to be removed from the vocabulary. Unigram then
removes p (with p usually being 10% or 20%) percent of the symbols whose loss increase is the lowest, `),Sa=l(yo,"EM",{});var em=r(Sa);Yp=n(em,"i.e."),em.forEach(s),Zp=n(yo,` those
symbols that least affect the overall loss over the training data. This process is repeated until the vocabulary has
reached the desired size. The Unigram algorithm always keeps the base characters so that any word can be tokenized.`),yo.forEach(s),Fn=u(e),Ut=l(e,"P",{});var tm=r(Ut);Qp=n(tm,`Because Unigram is not based on merge rules (in contrast to BPE and WordPiece), the algorithm has several ways of
tokenizing new text after training. As an example, if a trained Unigram tokenizer exhibits the vocabulary:`),tm.forEach(s),Gn=u(e),g(rt.$$.fragment,e),Xn=u(e),I=l(e,"P",{});var ge=r(I);Ca=l(ge,"CODE",{});var sm=r(Ca);eh=n(sm,'"hugs"'),sm.forEach(s),th=n(ge," could be tokenized both as "),Ba=l(ge,"CODE",{});var am=r(Ba);sh=n(am,'["hug", "s"]'),am.forEach(s),ah=n(ge,", "),Oa=l(ge,"CODE",{});var nm=r(Oa);nh=n(nm,'["h", "ug", "s"]'),nm.forEach(s),oh=n(ge," or "),Ma=l(ge,"CODE",{});var om=r(Ma);lh=n(om,'["h", "u", "g", "s"]'),om.forEach(s),rh=n(ge,`. So which one
to choose? Unigram saves the probability of each token in the training corpus on top of saving the vocabulary so that
the probability of each possible tokenization can be computed after training. The algorithm simply picks the most
likely tokenization in practice, but also offers the possibility to sample a possible tokenization according to their
probabilities.`),ge.forEach(s),Kn=u(e),L=l(e,"P",{});var be=r(L);ih=n(be,`Those probabilities are defined by the loss the tokenizer is trained on. Assuming that the training data consists of
the words `),Vn=Eo(be),Jn=n(be," and that the set of all possible tokenizations for a word "),Yn=Eo(be),Zn=n(be,` is
defined as `),Qn=Eo(be),eo=n(be,`, then the overall loss is defined as
`),to=Eo(be),be.forEach(s),so=u(e),Ht=l(e,"A",{id:!0}),r(Ht).forEach(s),ao=u(e),de=l(e,"H4",{class:!0});var wo=r(de);xe=l(wo,"A",{id:!0,class:!0,href:!0});var lm=r(xe);Na=l(lm,"SPAN",{});var rm=r(Na);g(it.$$.fragment,rm),rm.forEach(s),lm.forEach(s),ph=u(wo),Wa=l(wo,"SPAN",{});var im=r(Wa);hh=n(im,"SentencePiece"),im.forEach(s),wo.forEach(s),no=u(e),R=l(e,"P",{});var Te=r(R);ch=n(Te,`All tokenization algorithms described so far have the same problem: It is assumed that the input text uses spaces to
separate words. However, not all languages use spaces to separate words. One possible solution is to use language
specific pre-tokenizers, `),Ia=l(Te,"EM",{});var pm=r(Ia);uh=n(pm,"e.g."),pm.forEach(s),mh=u(Te),Rt=l(Te,"A",{href:!0});var hm=r(Rt);dh=n(hm,"XLM"),hm.forEach(s),fh=n(Te,` uses a specific Chinese, Japanese, and Thai pre-tokenizer).
To solve this problem more generally, `),pt=l(Te,"A",{href:!0,rel:!0});var cm=r(pt);gh=n(cm,`SentencePiece: A simple and language independent subword tokenizer and
detokenizer for Neural Text Processing (Kudo et al., 2018)`),cm.forEach(s),bh=n(Te,` treats the input
as a raw input stream, thus including the space in the set of characters to use. It then uses the BPE or unigram
algorithm to construct the appropriate vocabulary.`),Te.forEach(s),oo=u(e),F=l(e,"P",{});var Ae=r(F);vh=n(Ae,"The "),Ft=l(Ae,"A",{href:!0});var um=r(Ft);yh=n(um,"XLNetTokenizer"),um.forEach(s),wh=n(Ae,` uses SentencePiece for example, which is also why in the example earlier the
`),La=l(Ae,"CODE",{});var mm=r(La);kh=n(mm,'"\u2581"'),mm.forEach(s),Eh=n(Ae,` character was included in the vocabulary. Decoding with SentencePiece is very easy since all tokens can just be
concatenated and `),Ua=l(Ae,"CODE",{});var dm=r(Ua);_h=n(dm,'"\u2581"'),dm.forEach(s),zh=n(Ae," is replaced by a space."),Ae.forEach(s),lo=u(e),M=l(e,"P",{});var le=r(M);qh=n(le,`All transformers models in the library that use SentencePiece use it in combination with unigram. Examples of models
using SentencePiece are `),Gt=l(le,"A",{href:!0});var fm=r(Gt);jh=n(fm,"ALBERT"),fm.forEach(s),$h=n(le,", "),Xt=l(le,"A",{href:!0});var gm=r(Xt);xh=n(gm,"XLNet"),gm.forEach(s),Ph=n(le,", "),Kt=l(le,"A",{href:!0});var bm=r(Kt);Th=n(bm,"Marian"),bm.forEach(s),Ah=n(le,", and "),Vt=l(le,"A",{href:!0});var vm=r(Vt);Dh=n(vm,"T5"),vm.forEach(s),Sh=n(le,"."),le.forEach(s),this.h()},h(){h(V,"name","hf:doc:metadata"),h(V,"content",JSON.stringify(Tm)),h(K,"id","summary-of-the-tokenizers"),h(K,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(K,"href","#summary-of-the-tokenizers"),h(U,"class","relative group"),h(ut,"href","preprocessing"),h(mt,"href","#byte-pair-encoding"),h(dt,"href","#wordpiece"),h(ft,"href","#sentencepiece"),h(gt,"href","/docs/transformers/pr_16174/en/model_doc/bert#transformers.BertTokenizer"),h(bt,"href","#wordpiece"),h(ve,"id","introduction"),h(ve,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(ve,"href","#introduction"),h(ie,"class","relative group"),h(Le,"href","https://spacy.io/"),h(Le,"rel","nofollow"),h(Ue,"href","http://www.statmt.org/moses/?n=Development.GetStarted"),h(Ue,"rel","nofollow"),h(yt,"href","model_doc/transformerxl"),h(ye,"id","subword-tokenization"),h(ye,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(ye,"href","#subword-tokenization"),h(pe,"class","relative group"),h(Et,"href","/docs/transformers/pr_16174/en/model_doc/bert#transformers.BertTokenizer"),h(_t,"href","/docs/transformers/pr_16174/en/model_doc/xlnet#transformers.XLNetTokenizer"),h(zt,"href","#sentencepiece"),h(jt,"id","byte-pair-encoding"),h(ke,"id","bytepair-encoding-bpe"),h(ke,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(ke,"href","#bytepair-encoding-bpe"),h(he,"class","relative group"),h(Je,"href","https://arxiv.org/abs/1508.07909"),h(Je,"rel","nofollow"),h($t,"href","model_doc/gpt2"),h(xt,"href","model_doc/roberta"),h(Pt,"href","model_doc/xlm"),h(Tt,"href","model_doc/flaubert"),h(At,"href","model_doc/gpt"),h(Ct,"href","model_doc/gpt"),h(ze,"id","bytelevel-bpe"),h(ze,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(ze,"href","#bytelevel-bpe"),h(ce,"class","relative group"),h(st,"href","https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf"),h(st,"rel","nofollow"),h(Bt,"href","model_doc/gpt"),h(Ot,"id","wordpiece"),h(qe,"id","wordpiece"),h(qe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(qe,"href","#wordpiece"),h(ue,"class","relative group"),h(Mt,"href","model_doc/bert"),h(Nt,"href","model_doc/distilbert"),h(Wt,"href","model_doc/electra"),h(nt,"href","https://static.googleusercontent.com/media/research.google.com/ja//pubs/archive/37842.pdf"),h(nt,"rel","nofollow"),h(It,"id","unigram"),h(je,"id","unigram"),h(je,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(je,"href","#unigram"),h(me,"class","relative group"),h(lt,"href","https://arxiv.org/pdf/1804.10959.pdf"),h(lt,"rel","nofollow"),h(Lt,"href","#sentencepiece"),Vn.a=Jn,Yn.a=Zn,Qn.a=eo,to.a=null,h(Ht,"id","sentencepiece"),h(xe,"id","sentencepiece"),h(xe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(xe,"href","#sentencepiece"),h(de,"class","relative group"),h(Rt,"href","model_doc/xlm"),h(pt,"href","https://arxiv.org/pdf/1808.06226.pdf"),h(pt,"rel","nofollow"),h(Ft,"href","/docs/transformers/pr_16174/en/model_doc/xlnet#transformers.XLNetTokenizer"),h(Gt,"href","model_doc/albert"),h(Xt,"href","model_doc/xlnet"),h(Kt,"href","model_doc/marian"),h(Vt,"href","model_doc/t5")},m(e,i){t(document.head,V),p(e,ht,i),p(e,U,i),t(U,K),t(K,ts),b(Se,ts,null),t(U,qo),t(U,ss),t(ss,jo),p(e,Ha,i),b(Ce,e,i),p(e,Ra,i),p(e,ct,i),t(ct,$o),p(e,Fa,i),b(Be,e,i),p(e,Ga,i),p(e,D,i),t(D,xo),t(D,ut),t(ut,Po),t(D,To),t(D,mt),t(mt,Ao),t(D,Do),t(D,dt),t(dt,So),t(D,Co),t(D,ft),t(ft,Bo),t(D,Oo),p(e,Xa,i),p(e,J,i),t(J,Mo),t(J,gt),t(gt,No),t(J,Wo),t(J,bt),t(bt,Io),t(J,Lo),p(e,Ka,i),p(e,ie,i),t(ie,ve),t(ve,as),b(Oe,as,null),t(ie,Uo),t(ie,ns),t(ns,Ho),p(e,Va,i),p(e,Me,i),t(Me,Ro),t(Me,os),t(os,Fo),p(e,Ja,i),b(Ne,e,i),p(e,Ya,i),p(e,vt,i),t(vt,Go),p(e,Za,i),b(We,e,i),p(e,Qa,i),p(e,S,i),t(S,Xo),t(S,ls),t(ls,Ko),t(S,Vo),t(S,rs),t(rs,Jo),t(S,Yo),t(S,is),t(is,Zo),t(S,Qo),t(S,ps),t(ps,el),t(S,tl),p(e,en,i),b(Ie,e,i),p(e,tn,i),p(e,C,i),t(C,sl),t(C,hs),t(hs,al),t(C,nl),t(C,cs),t(cs,ol),t(C,ll),t(C,us),t(us,rl),t(C,il),t(C,ms),t(ms,pl),t(C,hl),p(e,sn,i),p(e,W,i),t(W,Le),t(Le,cl),t(W,ul),t(W,Ue),t(Ue,ml),t(W,dl),t(W,ds),t(ds,fl),t(W,gl),t(W,fs),t(fs,bl),t(W,vl),p(e,an,i),b(He,e,i),p(e,nn,i),p(e,Y,i),t(Y,yl),t(Y,gs),t(gs,wl),t(Y,kl),t(Y,yt),t(yt,El),t(Y,_l),p(e,on,i),p(e,wt,i),t(wt,zl),p(e,ln,i),p(e,kt,i),t(kt,ql),p(e,rn,i),b(Re,e,i),p(e,pn,i),p(e,B,i),t(B,jl),t(B,bs),t(bs,$l),t(B,xl),t(B,vs),t(vs,Pl),t(B,Tl),t(B,ys),t(ys,Al),t(B,Dl),t(B,ws),t(ws,Sl),t(B,Cl),p(e,hn,i),p(e,pe,i),t(pe,ye),t(ye,ks),b(Fe,ks,null),t(pe,Bl),t(pe,Es),t(Es,Ol),p(e,cn,i),b(Ge,e,i),p(e,un,i),p(e,k,i),t(k,Ml),t(k,_s),t(_s,Nl),t(k,Wl),t(k,zs),t(zs,Il),t(k,Ll),t(k,qs),t(qs,Ul),t(k,Hl),t(k,js),t(js,Rl),t(k,Fl),t(k,$s),t($s,Gl),t(k,Xl),t(k,xs),t(xs,Kl),t(k,Vl),t(k,Ps),t(Ps,Jl),t(k,Yl),t(k,Ts),t(Ts,Zl),t(k,Ql),p(e,mn,i),p(e,Z,i),t(Z,er),t(Z,Et),t(Et,tr),t(Z,sr),t(Z,As),t(As,ar),t(Z,nr),p(e,dn,i),b(Xe,e,i),p(e,fn,i),p(e,P,i),t(P,or),t(P,Ds),t(Ds,lr),t(P,rr),t(P,Ss),t(Ss,ir),t(P,pr),t(P,Cs),t(Cs,hr),t(P,cr),t(P,Bs),t(Bs,ur),t(P,mr),t(P,Os),t(Os,dr),t(P,fr),p(e,gn,i),p(e,we,i),t(we,gr),t(we,_t),t(_t,br),t(we,vr),p(e,bn,i),b(Ke,e,i),p(e,vn,i),p(e,T,i),t(T,yr),t(T,Ms),t(Ms,wr),t(T,kr),t(T,zt),t(zt,Er),t(T,_r),t(T,Ns),t(Ns,zr),t(T,qr),t(T,Ws),t(Ws,jr),t(T,$r),t(T,Is),t(Is,xr),t(T,Pr),p(e,yn,i),p(e,qt,i),t(qt,Tr),p(e,wn,i),p(e,jt,i),p(e,kn,i),p(e,he,i),t(he,ke),t(ke,Ls),b(Ve,Ls,null),t(he,Ar),t(he,Us),t(Us,Dr),p(e,En,i),p(e,q,i),t(q,Sr),t(q,Je),t(Je,Cr),t(q,Br),t(q,$t),t($t,Or),t(q,Mr),t(q,xt),t(xt,Nr),t(q,Wr),t(q,Pt),t(Pt,Ir),t(q,Lr),t(q,Tt),t(Tt,Ur),t(q,Hr),t(q,At),t(At,Rr),t(q,Fr),p(e,_n,i),p(e,Dt,i),t(Dt,Gr),p(e,zn,i),p(e,St,i),t(St,Xr),p(e,qn,i),b(Ye,e,i),p(e,jn,i),p(e,Ee,i),t(Ee,Kr),t(Ee,Hs),t(Hs,Vr),t(Ee,Jr),p(e,$n,i),b(Ze,e,i),p(e,xn,i),p(e,m,i),t(m,Yr),t(m,Rs),t(Rs,Zr),t(m,Qr),t(m,Fs),t(Fs,ei),t(m,ti),t(m,Gs),t(Gs,si),t(m,ai),t(m,Xs),t(Xs,ni),t(m,oi),t(m,Ks),t(Ks,li),t(m,ri),t(m,Vs),t(Vs,ii),t(m,pi),t(m,Js),t(Js,hi),t(m,ci),t(m,Ys),t(Ys,ui),t(m,mi),t(m,Zs),t(Zs,di),t(m,fi),t(m,Qs),t(Qs,gi),t(m,bi),t(m,ea),t(ea,vi),t(m,yi),p(e,Pn,i),b(Qe,e,i),p(e,Tn,i),p(e,E,i),t(E,wi),t(E,ta),t(ta,ki),t(E,Ei),t(E,sa),t(sa,_i),t(E,zi),t(E,aa),t(aa,qi),t(E,ji),t(E,na),t(na,$i),t(E,xi),t(E,oa),t(oa,Pi),t(E,Ti),t(E,la),t(la,Ai),t(E,Di),t(E,ra),t(ra,Si),t(E,Ci),t(E,ia),t(ia,Bi),t(E,Oi),p(e,An,i),p(e,_e,i),t(_e,Mi),t(_e,pa),t(pa,Ni),t(_e,Wi),p(e,Dn,i),b(et,e,i),p(e,Sn,i),p(e,z,i),t(z,Ii),t(z,ha),t(ha,Li),t(z,Ui),t(z,ca),t(ca,Hi),t(z,Ri),t(z,ua),t(ua,Fi),t(z,Gi),t(z,ma),t(ma,Xi),t(z,Ki),t(z,da),t(da,Vi),t(z,Ji),t(z,fa),t(fa,Yi),t(z,Zi),t(z,ga),t(ga,Qi),t(z,ep),p(e,Cn,i),p(e,Q,i),t(Q,tp),t(Q,ba),t(ba,sp),t(Q,ap),t(Q,Ct),t(Ct,np),t(Q,op),p(e,Bn,i),p(e,ce,i),t(ce,ze),t(ze,va),b(tt,va,null),t(ce,lp),t(ce,ya),t(ya,rp),p(e,On,i),p(e,H,i),t(H,ip),t(H,wa),t(wa,pp),t(H,hp),t(H,st),t(st,cp),t(H,up),t(H,Bt),t(Bt,mp),t(H,dp),p(e,Mn,i),p(e,Ot,i),p(e,Nn,i),p(e,ue,i),t(ue,qe),t(qe,ka),b(at,ka,null),t(ue,fp),t(ue,Ea),t(Ea,gp),p(e,Wn,i),p(e,O,i),t(O,bp),t(O,Mt),t(Mt,vp),t(O,yp),t(O,Nt),t(Nt,wp),t(O,kp),t(O,Wt),t(Wt,Ep),t(O,_p),t(O,nt),t(nt,zp),t(O,qp),p(e,In,i),p(e,_,i),t(_,jp),t(_,_a),t(_a,$p),t(_,xp),t(_,za),t(za,Pp),t(_,Tp),t(_,qa),t(qa,Ap),t(_,Dp),t(_,ja),t(ja,Sp),t(_,Cp),t(_,$a),t($a,Bp),t(_,Op),t(_,xa),t(xa,Mp),t(_,Np),t(_,Pa),t(Pa,Wp),t(_,Ip),t(_,Ta),t(Ta,Lp),t(_,Up),p(e,Ln,i),p(e,It,i),p(e,Un,i),p(e,me,i),t(me,je),t(je,Aa),b(ot,Aa,null),t(me,Hp),t(me,Da),t(Da,Rp),p(e,Hn,i),p(e,ee,i),t(ee,Fp),t(ee,lt),t(lt,Gp),t(ee,Xp),t(ee,Lt),t(Lt,Kp),t(ee,Vp),p(e,Rn,i),p(e,$e,i),t($e,Jp),t($e,Sa),t(Sa,Yp),t($e,Zp),p(e,Fn,i),p(e,Ut,i),t(Ut,Qp),p(e,Gn,i),b(rt,e,i),p(e,Xn,i),p(e,I,i),t(I,Ca),t(Ca,eh),t(I,th),t(I,Ba),t(Ba,sh),t(I,ah),t(I,Oa),t(Oa,nh),t(I,oh),t(I,Ma),t(Ma,lh),t(I,rh),p(e,Kn,i),p(e,L,i),t(L,ih),Vn.m(ym,L),t(L,Jn),Yn.m(wm,L),t(L,Zn),Qn.m(km,L),t(L,eo),to.m(Em,L),p(e,so,i),p(e,Ht,i),p(e,ao,i),p(e,de,i),t(de,xe),t(xe,Na),b(it,Na,null),t(de,ph),t(de,Wa),t(Wa,hh),p(e,no,i),p(e,R,i),t(R,ch),t(R,Ia),t(Ia,uh),t(R,mh),t(R,Rt),t(Rt,dh),t(R,fh),t(R,pt),t(pt,gh),t(R,bh),p(e,oo,i),p(e,F,i),t(F,vh),t(F,Ft),t(Ft,yh),t(F,wh),t(F,La),t(La,kh),t(F,Eh),t(F,Ua),t(Ua,_h),t(F,zh),p(e,lo,i),p(e,M,i),t(M,qh),t(M,Gt),t(Gt,jh),t(M,$h),t(M,Xt),t(Xt,xh),t(M,Ph),t(M,Kt),t(Kt,Th),t(M,Ah),t(M,Vt),t(Vt,Dh),t(M,Sh),ro=!0},p:$m,i(e){ro||(v(Se.$$.fragment,e),v(Ce.$$.fragment,e),v(Be.$$.fragment,e),v(Oe.$$.fragment,e),v(Ne.$$.fragment,e),v(We.$$.fragment,e),v(Ie.$$.fragment,e),v(He.$$.fragment,e),v(Re.$$.fragment,e),v(Fe.$$.fragment,e),v(Ge.$$.fragment,e),v(Xe.$$.fragment,e),v(Ke.$$.fragment,e),v(Ve.$$.fragment,e),v(Ye.$$.fragment,e),v(Ze.$$.fragment,e),v(Qe.$$.fragment,e),v(et.$$.fragment,e),v(tt.$$.fragment,e),v(at.$$.fragment,e),v(ot.$$.fragment,e),v(rt.$$.fragment,e),v(it.$$.fragment,e),ro=!0)},o(e){y(Se.$$.fragment,e),y(Ce.$$.fragment,e),y(Be.$$.fragment,e),y(Oe.$$.fragment,e),y(Ne.$$.fragment,e),y(We.$$.fragment,e),y(Ie.$$.fragment,e),y(He.$$.fragment,e),y(Re.$$.fragment,e),y(Fe.$$.fragment,e),y(Ge.$$.fragment,e),y(Xe.$$.fragment,e),y(Ke.$$.fragment,e),y(Ve.$$.fragment,e),y(Ye.$$.fragment,e),y(Ze.$$.fragment,e),y(Qe.$$.fragment,e),y(et.$$.fragment,e),y(tt.$$.fragment,e),y(at.$$.fragment,e),y(ot.$$.fragment,e),y(rt.$$.fragment,e),y(it.$$.fragment,e),ro=!1},d(e){s(V),e&&s(ht),e&&s(U),w(Se),e&&s(Ha),w(Ce,e),e&&s(Ra),e&&s(ct),e&&s(Fa),w(Be,e),e&&s(Ga),e&&s(D),e&&s(Xa),e&&s(J),e&&s(Ka),e&&s(ie),w(Oe),e&&s(Va),e&&s(Me),e&&s(Ja),w(Ne,e),e&&s(Ya),e&&s(vt),e&&s(Za),w(We,e),e&&s(Qa),e&&s(S),e&&s(en),w(Ie,e),e&&s(tn),e&&s(C),e&&s(sn),e&&s(W),e&&s(an),w(He,e),e&&s(nn),e&&s(Y),e&&s(on),e&&s(wt),e&&s(ln),e&&s(kt),e&&s(rn),w(Re,e),e&&s(pn),e&&s(B),e&&s(hn),e&&s(pe),w(Fe),e&&s(cn),w(Ge,e),e&&s(un),e&&s(k),e&&s(mn),e&&s(Z),e&&s(dn),w(Xe,e),e&&s(fn),e&&s(P),e&&s(gn),e&&s(we),e&&s(bn),w(Ke,e),e&&s(vn),e&&s(T),e&&s(yn),e&&s(qt),e&&s(wn),e&&s(jt),e&&s(kn),e&&s(he),w(Ve),e&&s(En),e&&s(q),e&&s(_n),e&&s(Dt),e&&s(zn),e&&s(St),e&&s(qn),w(Ye,e),e&&s(jn),e&&s(Ee),e&&s($n),w(Ze,e),e&&s(xn),e&&s(m),e&&s(Pn),w(Qe,e),e&&s(Tn),e&&s(E),e&&s(An),e&&s(_e),e&&s(Dn),w(et,e),e&&s(Sn),e&&s(z),e&&s(Cn),e&&s(Q),e&&s(Bn),e&&s(ce),w(tt),e&&s(On),e&&s(H),e&&s(Mn),e&&s(Ot),e&&s(Nn),e&&s(ue),w(at),e&&s(Wn),e&&s(O),e&&s(In),e&&s(_),e&&s(Ln),e&&s(It),e&&s(Un),e&&s(me),w(ot),e&&s(Hn),e&&s(ee),e&&s(Rn),e&&s($e),e&&s(Fn),e&&s(Ut),e&&s(Gn),w(rt,e),e&&s(Xn),e&&s(I),e&&s(Kn),e&&s(L),e&&s(so),e&&s(Ht),e&&s(ao),e&&s(de),w(it),e&&s(no),e&&s(R),e&&s(oo),e&&s(F),e&&s(lo),e&&s(M)}}}const Tm={local:"summary-of-the-tokenizers",sections:[{local:"introduction",sections:[{local:"subword-tokenization",title:"Subword tokenization"}],title:"Introduction"},{local:"bytepair-encoding-bpe",sections:[{local:"bytelevel-bpe",sections:[{local:"wordpiece",title:"WordPiece"},{local:"unigram",title:"Unigram"},{local:"sentencepiece",title:"SentencePiece"}],title:"Byte-level BPE"}],title:"Byte-Pair Encoding (BPE)"}],title:"Summary of the tokenizers"};function Am(zo,V,ht){let{fw:U}=V;return zo.$$set=K=>{"fw"in K&&ht(0,U=K.fw)},[U]}class Mm extends _m{constructor(V){super();zm(this,V,Am,Pm,qm,{fw:0})}}export{Mm as default,Tm as metadata};
