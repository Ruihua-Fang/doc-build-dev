import{S as rF,i as aF,s as iF,e as s,k as l,w as b,t as a,M as lF,c as n,d as t,m as d,a as r,x as k,h as i,b as c,F as e,g as u,y as w,q as $,o as D,B as y}from"../../chunks/vendor-4833417e.js";import{T as me}from"../../chunks/Tip-fffd6df1.js";import{D as U}from"../../chunks/Docstring-4f315ed9.js";import{C as Fe}from"../../chunks/CodeBlock-6a3d1b46.js";import{I as ve}from"../../chunks/IconCopyLink-4b81c553.js";import"../../chunks/CopyButton-dacfbfaf.js";function dF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function cF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function pF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function hF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function uF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function fF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function mF(C){let p,F,g,v,T,_,f,B,de,V,E,G,S,X,ce,N,pe,re,I,q,Y,J,x,z,he,W,oe,ue,R,ae,ee,A,ie,L,se,fe,P,te,H,le;return{c(){p=s("p"),F=a("TF 2.0 models accepts two formats as inputs:"),g=l(),v=s("ul"),T=s("li"),_=a("having all inputs as keyword arguments (like PyTorch models), or"),f=l(),B=s("li"),de=a("having all inputs as a list, tuple or dict in the first positional arguments."),V=l(),E=s("p"),G=a("This second option is useful when using "),S=s("code"),X=a("tf.keras.Model.fit"),ce=a(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=s("code"),pe=a("model(inputs)"),re=a("."),I=l(),q=s("p"),Y=a(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),J=l(),x=s("ul"),z=s("li"),he=a("a single Tensor with "),W=s("code"),oe=a("input_ids"),ue=a(" only and nothing else: "),R=s("code"),ae=a("model(inputs_ids)"),ee=l(),A=s("li"),ie=a(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),L=s("code"),se=a("model([input_ids, attention_mask])"),fe=l(),P=s("li"),te=a(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),H=s("code"),le=a('model({"input_ids": input_ids})')},l(h){p=n(h,"P",{});var M=r(p);F=i(M,"TF 2.0 models accepts two formats as inputs:"),M.forEach(t),g=d(h),v=n(h,"UL",{});var K=r(v);T=n(K,"LI",{});var ge=r(T);_=i(ge,"having all inputs as keyword arguments (like PyTorch models), or"),ge.forEach(t),f=d(K),B=n(K,"LI",{});var Te=r(B);de=i(Te,"having all inputs as a list, tuple or dict in the first positional arguments."),Te.forEach(t),K.forEach(t),V=d(h),E=n(h,"P",{});var O=r(E);G=i(O,"This second option is useful when using "),S=n(O,"CODE",{});var _e=r(S);X=i(_e,"tf.keras.Model.fit"),_e.forEach(t),ce=i(O,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=n(O,"CODE",{});var be=r(N);pe=i(be,"model(inputs)"),be.forEach(t),re=i(O,"."),O.forEach(t),I=d(h),q=n(h,"P",{});var ke=r(q);Y=i(ke,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),ke.forEach(t),J=d(h),x=n(h,"UL",{});var j=r(x);z=n(j,"LI",{});var Q=r(z);he=i(Q,"a single Tensor with "),W=n(Q,"CODE",{});var we=r(W);oe=i(we,"input_ids"),we.forEach(t),ue=i(Q," only and nothing else: "),R=n(Q,"CODE",{});var $e=r(R);ae=i($e,"model(inputs_ids)"),$e.forEach(t),Q.forEach(t),ee=d(j),A=n(j,"LI",{});var Z=r(A);ie=i(Z,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),L=n(Z,"CODE",{});var De=r(L);se=i(De,"model([input_ids, attention_mask])"),De.forEach(t),Z.forEach(t),fe=d(j),P=n(j,"LI",{});var ne=r(P);te=i(ne,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),H=n(ne,"CODE",{});var ye=r(H);le=i(ye,'model({"input_ids": input_ids})'),ye.forEach(t),ne.forEach(t),j.forEach(t)},m(h,M){u(h,p,M),e(p,F),u(h,g,M),u(h,v,M),e(v,T),e(T,_),e(v,f),e(v,B),e(B,de),u(h,V,M),u(h,E,M),e(E,G),e(E,S),e(S,X),e(E,ce),e(E,N),e(N,pe),e(E,re),u(h,I,M),u(h,q,M),e(q,Y),u(h,J,M),u(h,x,M),e(x,z),e(z,he),e(z,W),e(W,oe),e(z,ue),e(z,R),e(R,ae),e(x,ee),e(x,A),e(A,ie),e(A,L),e(L,se),e(x,fe),e(x,P),e(P,te),e(P,H),e(H,le)},d(h){h&&t(p),h&&t(g),h&&t(v),h&&t(V),h&&t(E),h&&t(I),h&&t(q),h&&t(J),h&&t(x)}}}function gF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function _F(C){let p,F,g,v,T,_,f,B,de,V,E,G,S,X,ce,N,pe,re,I,q,Y,J,x,z,he,W,oe,ue,R,ae,ee,A,ie,L,se,fe,P,te,H,le;return{c(){p=s("p"),F=a("TF 2.0 models accepts two formats as inputs:"),g=l(),v=s("ul"),T=s("li"),_=a("having all inputs as keyword arguments (like PyTorch models), or"),f=l(),B=s("li"),de=a("having all inputs as a list, tuple or dict in the first positional arguments."),V=l(),E=s("p"),G=a("This second option is useful when using "),S=s("code"),X=a("tf.keras.Model.fit"),ce=a(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=s("code"),pe=a("model(inputs)"),re=a("."),I=l(),q=s("p"),Y=a(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),J=l(),x=s("ul"),z=s("li"),he=a("a single Tensor with "),W=s("code"),oe=a("input_ids"),ue=a(" only and nothing else: "),R=s("code"),ae=a("model(inputs_ids)"),ee=l(),A=s("li"),ie=a(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),L=s("code"),se=a("model([input_ids, attention_mask])"),fe=l(),P=s("li"),te=a(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),H=s("code"),le=a('model({"input_ids": input_ids})')},l(h){p=n(h,"P",{});var M=r(p);F=i(M,"TF 2.0 models accepts two formats as inputs:"),M.forEach(t),g=d(h),v=n(h,"UL",{});var K=r(v);T=n(K,"LI",{});var ge=r(T);_=i(ge,"having all inputs as keyword arguments (like PyTorch models), or"),ge.forEach(t),f=d(K),B=n(K,"LI",{});var Te=r(B);de=i(Te,"having all inputs as a list, tuple or dict in the first positional arguments."),Te.forEach(t),K.forEach(t),V=d(h),E=n(h,"P",{});var O=r(E);G=i(O,"This second option is useful when using "),S=n(O,"CODE",{});var _e=r(S);X=i(_e,"tf.keras.Model.fit"),_e.forEach(t),ce=i(O,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=n(O,"CODE",{});var be=r(N);pe=i(be,"model(inputs)"),be.forEach(t),re=i(O,"."),O.forEach(t),I=d(h),q=n(h,"P",{});var ke=r(q);Y=i(ke,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),ke.forEach(t),J=d(h),x=n(h,"UL",{});var j=r(x);z=n(j,"LI",{});var Q=r(z);he=i(Q,"a single Tensor with "),W=n(Q,"CODE",{});var we=r(W);oe=i(we,"input_ids"),we.forEach(t),ue=i(Q," only and nothing else: "),R=n(Q,"CODE",{});var $e=r(R);ae=i($e,"model(inputs_ids)"),$e.forEach(t),Q.forEach(t),ee=d(j),A=n(j,"LI",{});var Z=r(A);ie=i(Z,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),L=n(Z,"CODE",{});var De=r(L);se=i(De,"model([input_ids, attention_mask])"),De.forEach(t),Z.forEach(t),fe=d(j),P=n(j,"LI",{});var ne=r(P);te=i(ne,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),H=n(ne,"CODE",{});var ye=r(H);le=i(ye,'model({"input_ids": input_ids})'),ye.forEach(t),ne.forEach(t),j.forEach(t)},m(h,M){u(h,p,M),e(p,F),u(h,g,M),u(h,v,M),e(v,T),e(T,_),e(v,f),e(v,B),e(B,de),u(h,V,M),u(h,E,M),e(E,G),e(E,S),e(S,X),e(E,ce),e(E,N),e(N,pe),e(E,re),u(h,I,M),u(h,q,M),e(q,Y),u(h,J,M),u(h,x,M),e(x,z),e(z,he),e(z,W),e(W,oe),e(z,ue),e(z,R),e(R,ae),e(x,ee),e(x,A),e(A,ie),e(A,L),e(L,se),e(x,fe),e(x,P),e(P,te),e(P,H),e(H,le)},d(h){h&&t(p),h&&t(g),h&&t(v),h&&t(V),h&&t(E),h&&t(I),h&&t(q),h&&t(J),h&&t(x)}}}function vF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function TF(C){let p,F,g,v,T,_,f,B,de,V,E,G,S,X,ce,N,pe,re,I,q,Y,J,x,z,he,W,oe,ue,R,ae,ee,A,ie,L,se,fe,P,te,H,le;return{c(){p=s("p"),F=a("TF 2.0 models accepts two formats as inputs:"),g=l(),v=s("ul"),T=s("li"),_=a("having all inputs as keyword arguments (like PyTorch models), or"),f=l(),B=s("li"),de=a("having all inputs as a list, tuple or dict in the first positional arguments."),V=l(),E=s("p"),G=a("This second option is useful when using "),S=s("code"),X=a("tf.keras.Model.fit"),ce=a(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=s("code"),pe=a("model(inputs)"),re=a("."),I=l(),q=s("p"),Y=a(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),J=l(),x=s("ul"),z=s("li"),he=a("a single Tensor with "),W=s("code"),oe=a("input_ids"),ue=a(" only and nothing else: "),R=s("code"),ae=a("model(inputs_ids)"),ee=l(),A=s("li"),ie=a(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),L=s("code"),se=a("model([input_ids, attention_mask])"),fe=l(),P=s("li"),te=a(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),H=s("code"),le=a('model({"input_ids": input_ids})')},l(h){p=n(h,"P",{});var M=r(p);F=i(M,"TF 2.0 models accepts two formats as inputs:"),M.forEach(t),g=d(h),v=n(h,"UL",{});var K=r(v);T=n(K,"LI",{});var ge=r(T);_=i(ge,"having all inputs as keyword arguments (like PyTorch models), or"),ge.forEach(t),f=d(K),B=n(K,"LI",{});var Te=r(B);de=i(Te,"having all inputs as a list, tuple or dict in the first positional arguments."),Te.forEach(t),K.forEach(t),V=d(h),E=n(h,"P",{});var O=r(E);G=i(O,"This second option is useful when using "),S=n(O,"CODE",{});var _e=r(S);X=i(_e,"tf.keras.Model.fit"),_e.forEach(t),ce=i(O,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=n(O,"CODE",{});var be=r(N);pe=i(be,"model(inputs)"),be.forEach(t),re=i(O,"."),O.forEach(t),I=d(h),q=n(h,"P",{});var ke=r(q);Y=i(ke,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),ke.forEach(t),J=d(h),x=n(h,"UL",{});var j=r(x);z=n(j,"LI",{});var Q=r(z);he=i(Q,"a single Tensor with "),W=n(Q,"CODE",{});var we=r(W);oe=i(we,"input_ids"),we.forEach(t),ue=i(Q," only and nothing else: "),R=n(Q,"CODE",{});var $e=r(R);ae=i($e,"model(inputs_ids)"),$e.forEach(t),Q.forEach(t),ee=d(j),A=n(j,"LI",{});var Z=r(A);ie=i(Z,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),L=n(Z,"CODE",{});var De=r(L);se=i(De,"model([input_ids, attention_mask])"),De.forEach(t),Z.forEach(t),fe=d(j),P=n(j,"LI",{});var ne=r(P);te=i(ne,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),H=n(ne,"CODE",{});var ye=r(H);le=i(ye,'model({"input_ids": input_ids})'),ye.forEach(t),ne.forEach(t),j.forEach(t)},m(h,M){u(h,p,M),e(p,F),u(h,g,M),u(h,v,M),e(v,T),e(T,_),e(v,f),e(v,B),e(B,de),u(h,V,M),u(h,E,M),e(E,G),e(E,S),e(S,X),e(E,ce),e(E,N),e(N,pe),e(E,re),u(h,I,M),u(h,q,M),e(q,Y),u(h,J,M),u(h,x,M),e(x,z),e(z,he),e(z,W),e(W,oe),e(z,ue),e(z,R),e(R,ae),e(x,ee),e(x,A),e(A,ie),e(A,L),e(L,se),e(x,fe),e(x,P),e(P,te),e(P,H),e(H,le)},d(h){h&&t(p),h&&t(g),h&&t(v),h&&t(V),h&&t(E),h&&t(I),h&&t(q),h&&t(J),h&&t(x)}}}function bF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function kF(C){let p,F,g,v,T,_,f,B,de,V,E,G,S,X,ce,N,pe,re,I,q,Y,J,x,z,he,W,oe,ue,R,ae,ee,A,ie,L,se,fe,P,te,H,le;return{c(){p=s("p"),F=a("TF 2.0 models accepts two formats as inputs:"),g=l(),v=s("ul"),T=s("li"),_=a("having all inputs as keyword arguments (like PyTorch models), or"),f=l(),B=s("li"),de=a("having all inputs as a list, tuple or dict in the first positional arguments."),V=l(),E=s("p"),G=a("This second option is useful when using "),S=s("code"),X=a("tf.keras.Model.fit"),ce=a(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=s("code"),pe=a("model(inputs)"),re=a("."),I=l(),q=s("p"),Y=a(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),J=l(),x=s("ul"),z=s("li"),he=a("a single Tensor with "),W=s("code"),oe=a("input_ids"),ue=a(" only and nothing else: "),R=s("code"),ae=a("model(inputs_ids)"),ee=l(),A=s("li"),ie=a(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),L=s("code"),se=a("model([input_ids, attention_mask])"),fe=l(),P=s("li"),te=a(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),H=s("code"),le=a('model({"input_ids": input_ids})')},l(h){p=n(h,"P",{});var M=r(p);F=i(M,"TF 2.0 models accepts two formats as inputs:"),M.forEach(t),g=d(h),v=n(h,"UL",{});var K=r(v);T=n(K,"LI",{});var ge=r(T);_=i(ge,"having all inputs as keyword arguments (like PyTorch models), or"),ge.forEach(t),f=d(K),B=n(K,"LI",{});var Te=r(B);de=i(Te,"having all inputs as a list, tuple or dict in the first positional arguments."),Te.forEach(t),K.forEach(t),V=d(h),E=n(h,"P",{});var O=r(E);G=i(O,"This second option is useful when using "),S=n(O,"CODE",{});var _e=r(S);X=i(_e,"tf.keras.Model.fit"),_e.forEach(t),ce=i(O,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=n(O,"CODE",{});var be=r(N);pe=i(be,"model(inputs)"),be.forEach(t),re=i(O,"."),O.forEach(t),I=d(h),q=n(h,"P",{});var ke=r(q);Y=i(ke,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),ke.forEach(t),J=d(h),x=n(h,"UL",{});var j=r(x);z=n(j,"LI",{});var Q=r(z);he=i(Q,"a single Tensor with "),W=n(Q,"CODE",{});var we=r(W);oe=i(we,"input_ids"),we.forEach(t),ue=i(Q," only and nothing else: "),R=n(Q,"CODE",{});var $e=r(R);ae=i($e,"model(inputs_ids)"),$e.forEach(t),Q.forEach(t),ee=d(j),A=n(j,"LI",{});var Z=r(A);ie=i(Z,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),L=n(Z,"CODE",{});var De=r(L);se=i(De,"model([input_ids, attention_mask])"),De.forEach(t),Z.forEach(t),fe=d(j),P=n(j,"LI",{});var ne=r(P);te=i(ne,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),H=n(ne,"CODE",{});var ye=r(H);le=i(ye,'model({"input_ids": input_ids})'),ye.forEach(t),ne.forEach(t),j.forEach(t)},m(h,M){u(h,p,M),e(p,F),u(h,g,M),u(h,v,M),e(v,T),e(T,_),e(v,f),e(v,B),e(B,de),u(h,V,M),u(h,E,M),e(E,G),e(E,S),e(S,X),e(E,ce),e(E,N),e(N,pe),e(E,re),u(h,I,M),u(h,q,M),e(q,Y),u(h,J,M),u(h,x,M),e(x,z),e(z,he),e(z,W),e(W,oe),e(z,ue),e(z,R),e(R,ae),e(x,ee),e(x,A),e(A,ie),e(A,L),e(L,se),e(x,fe),e(x,P),e(P,te),e(P,H),e(H,le)},d(h){h&&t(p),h&&t(g),h&&t(v),h&&t(V),h&&t(E),h&&t(I),h&&t(q),h&&t(J),h&&t(x)}}}function wF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function $F(C){let p,F,g,v,T,_,f,B,de,V,E,G,S,X,ce,N,pe,re,I,q,Y,J,x,z,he,W,oe,ue,R,ae,ee,A,ie,L,se,fe,P,te,H,le;return{c(){p=s("p"),F=a("TF 2.0 models accepts two formats as inputs:"),g=l(),v=s("ul"),T=s("li"),_=a("having all inputs as keyword arguments (like PyTorch models), or"),f=l(),B=s("li"),de=a("having all inputs as a list, tuple or dict in the first positional arguments."),V=l(),E=s("p"),G=a("This second option is useful when using "),S=s("code"),X=a("tf.keras.Model.fit"),ce=a(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=s("code"),pe=a("model(inputs)"),re=a("."),I=l(),q=s("p"),Y=a(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),J=l(),x=s("ul"),z=s("li"),he=a("a single Tensor with "),W=s("code"),oe=a("input_ids"),ue=a(" only and nothing else: "),R=s("code"),ae=a("model(inputs_ids)"),ee=l(),A=s("li"),ie=a(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),L=s("code"),se=a("model([input_ids, attention_mask])"),fe=l(),P=s("li"),te=a(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),H=s("code"),le=a('model({"input_ids": input_ids})')},l(h){p=n(h,"P",{});var M=r(p);F=i(M,"TF 2.0 models accepts two formats as inputs:"),M.forEach(t),g=d(h),v=n(h,"UL",{});var K=r(v);T=n(K,"LI",{});var ge=r(T);_=i(ge,"having all inputs as keyword arguments (like PyTorch models), or"),ge.forEach(t),f=d(K),B=n(K,"LI",{});var Te=r(B);de=i(Te,"having all inputs as a list, tuple or dict in the first positional arguments."),Te.forEach(t),K.forEach(t),V=d(h),E=n(h,"P",{});var O=r(E);G=i(O,"This second option is useful when using "),S=n(O,"CODE",{});var _e=r(S);X=i(_e,"tf.keras.Model.fit"),_e.forEach(t),ce=i(O,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=n(O,"CODE",{});var be=r(N);pe=i(be,"model(inputs)"),be.forEach(t),re=i(O,"."),O.forEach(t),I=d(h),q=n(h,"P",{});var ke=r(q);Y=i(ke,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),ke.forEach(t),J=d(h),x=n(h,"UL",{});var j=r(x);z=n(j,"LI",{});var Q=r(z);he=i(Q,"a single Tensor with "),W=n(Q,"CODE",{});var we=r(W);oe=i(we,"input_ids"),we.forEach(t),ue=i(Q," only and nothing else: "),R=n(Q,"CODE",{});var $e=r(R);ae=i($e,"model(inputs_ids)"),$e.forEach(t),Q.forEach(t),ee=d(j),A=n(j,"LI",{});var Z=r(A);ie=i(Z,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),L=n(Z,"CODE",{});var De=r(L);se=i(De,"model([input_ids, attention_mask])"),De.forEach(t),Z.forEach(t),fe=d(j),P=n(j,"LI",{});var ne=r(P);te=i(ne,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),H=n(ne,"CODE",{});var ye=r(H);le=i(ye,'model({"input_ids": input_ids})'),ye.forEach(t),ne.forEach(t),j.forEach(t)},m(h,M){u(h,p,M),e(p,F),u(h,g,M),u(h,v,M),e(v,T),e(T,_),e(v,f),e(v,B),e(B,de),u(h,V,M),u(h,E,M),e(E,G),e(E,S),e(S,X),e(E,ce),e(E,N),e(N,pe),e(E,re),u(h,I,M),u(h,q,M),e(q,Y),u(h,J,M),u(h,x,M),e(x,z),e(z,he),e(z,W),e(W,oe),e(z,ue),e(z,R),e(R,ae),e(x,ee),e(x,A),e(A,ie),e(A,L),e(L,se),e(x,fe),e(x,P),e(P,te),e(P,H),e(H,le)},d(h){h&&t(p),h&&t(g),h&&t(v),h&&t(V),h&&t(E),h&&t(I),h&&t(q),h&&t(J),h&&t(x)}}}function DF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function yF(C){let p,F,g,v,T,_,f,B,de,V,E,G,S,X,ce,N,pe,re,I,q,Y,J,x,z,he,W,oe,ue,R,ae,ee,A,ie,L,se,fe,P,te,H,le;return{c(){p=s("p"),F=a("TF 2.0 models accepts two formats as inputs:"),g=l(),v=s("ul"),T=s("li"),_=a("having all inputs as keyword arguments (like PyTorch models), or"),f=l(),B=s("li"),de=a("having all inputs as a list, tuple or dict in the first positional arguments."),V=l(),E=s("p"),G=a("This second option is useful when using "),S=s("code"),X=a("tf.keras.Model.fit"),ce=a(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=s("code"),pe=a("model(inputs)"),re=a("."),I=l(),q=s("p"),Y=a(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),J=l(),x=s("ul"),z=s("li"),he=a("a single Tensor with "),W=s("code"),oe=a("input_ids"),ue=a(" only and nothing else: "),R=s("code"),ae=a("model(inputs_ids)"),ee=l(),A=s("li"),ie=a(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),L=s("code"),se=a("model([input_ids, attention_mask])"),fe=l(),P=s("li"),te=a(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),H=s("code"),le=a('model({"input_ids": input_ids})')},l(h){p=n(h,"P",{});var M=r(p);F=i(M,"TF 2.0 models accepts two formats as inputs:"),M.forEach(t),g=d(h),v=n(h,"UL",{});var K=r(v);T=n(K,"LI",{});var ge=r(T);_=i(ge,"having all inputs as keyword arguments (like PyTorch models), or"),ge.forEach(t),f=d(K),B=n(K,"LI",{});var Te=r(B);de=i(Te,"having all inputs as a list, tuple or dict in the first positional arguments."),Te.forEach(t),K.forEach(t),V=d(h),E=n(h,"P",{});var O=r(E);G=i(O,"This second option is useful when using "),S=n(O,"CODE",{});var _e=r(S);X=i(_e,"tf.keras.Model.fit"),_e.forEach(t),ce=i(O,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=n(O,"CODE",{});var be=r(N);pe=i(be,"model(inputs)"),be.forEach(t),re=i(O,"."),O.forEach(t),I=d(h),q=n(h,"P",{});var ke=r(q);Y=i(ke,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),ke.forEach(t),J=d(h),x=n(h,"UL",{});var j=r(x);z=n(j,"LI",{});var Q=r(z);he=i(Q,"a single Tensor with "),W=n(Q,"CODE",{});var we=r(W);oe=i(we,"input_ids"),we.forEach(t),ue=i(Q," only and nothing else: "),R=n(Q,"CODE",{});var $e=r(R);ae=i($e,"model(inputs_ids)"),$e.forEach(t),Q.forEach(t),ee=d(j),A=n(j,"LI",{});var Z=r(A);ie=i(Z,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),L=n(Z,"CODE",{});var De=r(L);se=i(De,"model([input_ids, attention_mask])"),De.forEach(t),Z.forEach(t),fe=d(j),P=n(j,"LI",{});var ne=r(P);te=i(ne,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),H=n(ne,"CODE",{});var ye=r(H);le=i(ye,'model({"input_ids": input_ids})'),ye.forEach(t),ne.forEach(t),j.forEach(t)},m(h,M){u(h,p,M),e(p,F),u(h,g,M),u(h,v,M),e(v,T),e(T,_),e(v,f),e(v,B),e(B,de),u(h,V,M),u(h,E,M),e(E,G),e(E,S),e(S,X),e(E,ce),e(E,N),e(N,pe),e(E,re),u(h,I,M),u(h,q,M),e(q,Y),u(h,J,M),u(h,x,M),e(x,z),e(z,he),e(z,W),e(W,oe),e(z,ue),e(z,R),e(R,ae),e(x,ee),e(x,A),e(A,ie),e(A,L),e(L,se),e(x,fe),e(x,P),e(P,te),e(P,H),e(H,le)},d(h){h&&t(p),h&&t(g),h&&t(v),h&&t(V),h&&t(E),h&&t(I),h&&t(q),h&&t(J),h&&t(x)}}}function FF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function BF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function MF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function EF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function xF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function zF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function CF(C){let p,F,g,v,T;return{c(){p=s("p"),F=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=s("code"),v=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(_){p=n(_,"P",{});var f=r(p);F=i(f,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=n(f,"CODE",{});var B=r(g);v=i(B,"Module"),B.forEach(t),T=i(f,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),f.forEach(t)},m(_,f){u(_,p,f),e(p,F),e(p,g),e(g,v),e(p,T)},d(_){_&&t(p)}}}function jF(C){let p,F,g,v,T,_,f,B,de,V,E,G,S,X,ce,N,pe,re,I,q,Y,J,x,z,he,W,oe,ue,R,ae,ee,A,ie,L,se,fe,P,te,H,le,h,M,K,ge,Te,O,_e,be,ke,j,Q,we,$e,Z,De,ne,ye,hu,up,Tt,uu,Ys,fu,mu,Zs,gu,_u,en,vu,Tu,fp,ao,Go,_l,tn,bu,vl,ku,mp,Se,on,wu,Ft,$u,di,Du,yu,ci,Fu,Bu,sn,Mu,Eu,xu,io,zu,pi,Cu,ju,hi,Pu,qu,Au,Tl,Ou,Iu,nn,gp,lo,Xo,bl,rn,Lu,kl,Su,_p,_t,an,Nu,wl,Wu,Ru,Yo,ui,Hu,Qu,fi,Uu,Vu,Ju,ln,Ku,mi,Gu,Xu,vp,co,Zo,$l,dn,Yu,Dl,Zu,Tp,vt,cn,ef,pn,tf,yl,of,sf,nf,es,gi,rf,af,_i,lf,df,cf,hn,pf,vi,hf,uf,bp,po,ts,Fl,un,ff,Bl,mf,kp,Ne,fn,gf,Ml,_f,vf,mn,Tf,Ti,bf,kf,wf,gn,$f,_n,Df,yf,Ff,Ve,vn,Bf,ho,Mf,bi,Ef,xf,El,zf,Cf,jf,os,Pf,xl,qf,Af,Tn,wp,uo,ss,zl,bn,Of,Cl,If,$p,We,kn,Lf,wn,Sf,jl,Nf,Wf,Rf,$n,Hf,ki,Qf,Uf,Vf,Dn,Jf,yn,Kf,Gf,Xf,Je,Fn,Yf,fo,Zf,wi,em,tm,Pl,om,sm,nm,ns,rm,ql,am,im,Bn,Dp,mo,rs,Al,Mn,lm,Ol,dm,yp,Re,En,cm,Il,pm,hm,xn,um,$i,fm,mm,gm,zn,_m,Cn,vm,Tm,bm,je,jn,km,go,wm,Di,$m,Dm,Ll,ym,Fm,Bm,as,Mm,Sl,Em,xm,Pn,zm,Nl,Cm,jm,qn,Fp,_o,is,Wl,An,Pm,Rl,qm,Bp,He,On,Am,Hl,Om,Im,In,Lm,yi,Sm,Nm,Wm,Ln,Rm,Sn,Hm,Qm,Um,Ke,Nn,Vm,vo,Jm,Fi,Km,Gm,Ql,Xm,Ym,Zm,ls,eg,Ul,tg,og,Wn,Mp,To,ds,Vl,Rn,sg,Jl,ng,Ep,Qe,Hn,rg,Kl,ag,ig,Qn,lg,Bi,dg,cg,pg,Un,hg,Vn,ug,fg,mg,Ge,Jn,gg,bo,_g,Mi,vg,Tg,Gl,bg,kg,wg,cs,$g,Xl,Dg,yg,Kn,xp,ko,ps,Yl,Gn,Fg,Zl,Bg,zp,Ue,Xn,Mg,wo,Eg,ed,xg,zg,td,Cg,jg,Pg,Yn,qg,Ei,Ag,Og,Ig,Zn,Lg,er,Sg,Ng,Wg,Xe,tr,Rg,$o,Hg,xi,Qg,Ug,od,Vg,Jg,Kg,hs,Gg,sd,Xg,Yg,or,Cp,Do,us,nd,sr,Zg,rd,e_,jp,Pe,nr,t_,ad,o_,s_,rr,n_,zi,r_,a_,i_,ar,l_,ir,d_,c_,p_,fs,h_,Ye,lr,u_,yo,f_,Ci,m_,g_,id,__,v_,T_,ms,b_,ld,k_,w_,dr,Pp,Fo,gs,dd,cr,$_,cd,D_,qp,qe,pr,y_,hr,F_,pd,B_,M_,E_,ur,x_,ji,z_,C_,j_,fr,P_,mr,q_,A_,O_,_s,I_,Ze,gr,L_,Bo,S_,Pi,N_,W_,hd,R_,H_,Q_,vs,U_,ud,V_,J_,_r,Ap,Mo,Ts,fd,vr,K_,md,G_,Op,Ae,Tr,X_,gd,Y_,Z_,br,ev,qi,tv,ov,sv,kr,nv,wr,rv,av,iv,bs,lv,et,$r,dv,Eo,cv,Ai,pv,hv,_d,uv,fv,mv,ks,gv,vd,_v,vv,Dr,Ip,xo,ws,Td,yr,Tv,bd,bv,Lp,Oe,Fr,kv,kd,wv,$v,Br,Dv,Oi,yv,Fv,Bv,Mr,Mv,Er,Ev,xv,zv,$s,Cv,tt,xr,jv,zo,Pv,Ii,qv,Av,wd,Ov,Iv,Lv,Ds,Sv,$d,Nv,Wv,zr,Sp,Co,ys,Dd,Cr,Rv,yd,Hv,Np,Ie,jr,Qv,Fd,Uv,Vv,Pr,Jv,Li,Kv,Gv,Xv,qr,Yv,Ar,Zv,eT,tT,Fs,oT,ot,Or,sT,jo,nT,Si,rT,aT,Bd,iT,lT,dT,Bs,cT,Md,pT,hT,Ir,Wp,Po,Ms,Ed,Lr,uT,xd,fT,Rp,Le,Sr,mT,qo,gT,zd,_T,vT,Cd,TT,bT,kT,Nr,wT,Ni,$T,DT,yT,Wr,FT,Rr,BT,MT,ET,Es,xT,st,Hr,zT,Ao,CT,Wi,jT,PT,jd,qT,AT,OT,xs,IT,Pd,LT,ST,Qr,Hp,Oo,zs,qd,Ur,NT,Ad,WT,Qp,Be,Vr,RT,Od,HT,QT,Jr,UT,Ri,VT,JT,KT,Kr,GT,Gr,XT,YT,ZT,Id,eb,tb,Bt,Ld,Xr,ob,sb,Sd,Yr,nb,rb,Nd,Zr,ab,ib,Wd,ea,lb,db,nt,ta,cb,Io,pb,Rd,hb,ub,Hd,fb,mb,gb,Cs,_b,Qd,vb,Tb,oa,Up,Lo,js,Ud,sa,bb,Vd,kb,Vp,Me,na,wb,ra,$b,Jd,Db,yb,Fb,aa,Bb,Hi,Mb,Eb,xb,ia,zb,la,Cb,jb,Pb,Kd,qb,Ab,Mt,Gd,da,Ob,Ib,Xd,ca,Lb,Sb,Yd,pa,Nb,Wb,Zd,ha,Rb,Hb,rt,ua,Qb,So,Ub,ec,Vb,Jb,tc,Kb,Gb,Xb,Ps,Yb,oc,Zb,e1,fa,Jp,No,qs,sc,ma,t1,nc,o1,Kp,Ee,ga,s1,rc,n1,r1,_a,a1,Qi,i1,l1,d1,va,c1,Ta,p1,h1,u1,ac,f1,m1,Et,ic,ba,g1,_1,lc,ka,v1,T1,dc,wa,b1,k1,cc,$a,w1,$1,at,Da,D1,Wo,y1,pc,F1,B1,hc,M1,E1,x1,As,z1,uc,C1,j1,ya,Gp,Ro,Os,fc,Fa,P1,mc,q1,Xp,xe,Ba,A1,gc,O1,I1,Ma,L1,Ui,S1,N1,W1,Ea,R1,xa,H1,Q1,U1,_c,V1,J1,xt,vc,za,K1,G1,Tc,Ca,X1,Y1,bc,ja,Z1,ek,kc,Pa,tk,ok,it,qa,sk,Ho,nk,wc,rk,ak,$c,ik,lk,dk,Is,ck,Dc,pk,hk,Aa,Yp,Qo,Ls,yc,Oa,uk,Fc,fk,Zp,ze,Ia,mk,Bc,gk,_k,La,vk,Vi,Tk,bk,kk,Sa,wk,Na,$k,Dk,yk,Mc,Fk,Bk,zt,Ec,Wa,Mk,Ek,xc,Ra,xk,zk,zc,Ha,Ck,jk,Cc,Qa,Pk,qk,lt,Ua,Ak,Uo,Ok,jc,Ik,Lk,Pc,Sk,Nk,Wk,Ss,Rk,qc,Hk,Qk,Va,eh,Vo,Ns,Ac,Ja,Uk,Oc,Vk,th,Ce,Ka,Jk,Jo,Kk,Ic,Gk,Xk,Lc,Yk,Zk,e0,Ga,t0,Ji,o0,s0,n0,Xa,r0,Ya,a0,i0,l0,Sc,d0,c0,Ct,Nc,Za,p0,h0,Wc,ei,u0,f0,Rc,ti,m0,g0,Hc,oi,_0,v0,dt,si,T0,Ko,b0,Qc,k0,w0,Uc,$0,D0,y0,Ws,F0,Vc,B0,M0,ni,oh;return _=new ve({}),X=new ve({}),tn=new ve({}),on=new U({props:{name:"class transformers.DistilBertConfig",anchor:"transformers.DistilBertConfig",parameters:[{name:"vocab_size",val:" = 30522"},{name:"max_position_embeddings",val:" = 512"},{name:"sinusoidal_pos_embds",val:" = False"},{name:"n_layers",val:" = 6"},{name:"n_heads",val:" = 12"},{name:"dim",val:" = 768"},{name:"hidden_dim",val:" = 3072"},{name:"dropout",val:" = 0.1"},{name:"attention_dropout",val:" = 0.1"},{name:"activation",val:" = 'gelu'"},{name:"initializer_range",val:" = 0.02"},{name:"qa_dropout",val:" = 0.1"},{name:"seq_classif_dropout",val:" = 0.2"},{name:"pad_token_id",val:" = 0"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/configuration_distilbert.py#L37",parametersDescription:[{anchor:"transformers.DistilBertConfig.vocab_size",description:`<strong>vocab_size</strong> (<code>int</code>, <em>optional</em>, defaults to 30522) &#x2014;
Vocabulary size of the DistilBERT model. Defines the number of different tokens that can be represented by
the <code>inputs_ids</code> passed when calling <a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertModel">DistilBertModel</a> or <a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.TFDistilBertModel">TFDistilBertModel</a>.`,name:"vocab_size"},{anchor:"transformers.DistilBertConfig.max_position_embeddings",description:`<strong>max_position_embeddings</strong> (<code>int</code>, <em>optional</em>, defaults to 512) &#x2014;
The maximum sequence length that this model might ever be used with. Typically set this to something large
just in case (e.g., 512 or 1024 or 2048).`,name:"max_position_embeddings"},{anchor:"transformers.DistilBertConfig.sinusoidal_pos_embds",description:`<strong>sinusoidal_pos_embds</strong> (<code>boolean</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to use sinusoidal positional embeddings.`,name:"sinusoidal_pos_embds"},{anchor:"transformers.DistilBertConfig.n_layers",description:`<strong>n_layers</strong> (<code>int</code>, <em>optional</em>, defaults to 6) &#x2014;
Number of hidden layers in the Transformer encoder.`,name:"n_layers"},{anchor:"transformers.DistilBertConfig.n_heads",description:`<strong>n_heads</strong> (<code>int</code>, <em>optional</em>, defaults to 12) &#x2014;
Number of attention heads for each attention layer in the Transformer encoder.`,name:"n_heads"},{anchor:"transformers.DistilBertConfig.dim",description:`<strong>dim</strong> (<code>int</code>, <em>optional</em>, defaults to 768) &#x2014;
Dimensionality of the encoder layers and the pooler layer.`,name:"dim"},{anchor:"transformers.DistilBertConfig.hidden_dim",description:`<strong>hidden_dim</strong> (<code>int</code>, <em>optional</em>, defaults to 3072) &#x2014;
The size of the &#x201C;intermediate&#x201D; (often named feed-forward) layer in the Transformer encoder.`,name:"hidden_dim"},{anchor:"transformers.DistilBertConfig.dropout",description:`<strong>dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.`,name:"dropout"},{anchor:"transformers.DistilBertConfig.attention_dropout",description:`<strong>attention_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The dropout ratio for the attention probabilities.`,name:"attention_dropout"},{anchor:"transformers.DistilBertConfig.activation",description:`<strong>activation</strong> (<code>str</code> or <code>Callable</code>, <em>optional</em>, defaults to <code>&quot;gelu&quot;</code>) &#x2014;
The non-linear activation function (function or string) in the encoder and pooler. If string, <code>&quot;gelu&quot;</code>,
<code>&quot;relu&quot;</code>, <code>&quot;silu&quot;</code> and <code>&quot;gelu_new&quot;</code> are supported.`,name:"activation"},{anchor:"transformers.DistilBertConfig.initializer_range",description:`<strong>initializer_range</strong> (<code>float</code>, <em>optional</em>, defaults to 0.02) &#x2014;
The standard deviation of the truncated_normal_initializer for initializing all weight matrices.`,name:"initializer_range"},{anchor:"transformers.DistilBertConfig.qa_dropout",description:`<strong>qa_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The dropout probabilities used in the question answering model <a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertForQuestionAnswering">DistilBertForQuestionAnswering</a>.`,name:"qa_dropout"},{anchor:"transformers.DistilBertConfig.seq_classif_dropout",description:`<strong>seq_classif_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.2) &#x2014;
The dropout probabilities used in the sequence classification and the multiple choice model
<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertForSequenceClassification">DistilBertForSequenceClassification</a>.`,name:"seq_classif_dropout"}]}}),nn=new Fe({props:{code:`from transformers import DistilBertModel, DistilBertConfig

# Initializing a DistilBERT configuration
configuration = DistilBertConfig()

# Initializing a model from the configuration
model = DistilBertModel(configuration)

# Accessing the model configuration
configuration = model.config`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertModel, DistilBertConfig

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a DistilBERT configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = DistilBertConfig()

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a model from the configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = DistilBertModel(configuration)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Accessing the model configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = model.config`}}),rn=new ve({}),an=new U({props:{name:"class transformers.DistilBertTokenizer",anchor:"transformers.DistilBertTokenizer",parameters:[{name:"vocab_file",val:""},{name:"do_lower_case",val:" = True"},{name:"do_basic_tokenize",val:" = True"},{name:"never_split",val:" = None"},{name:"unk_token",val:" = '[UNK]'"},{name:"sep_token",val:" = '[SEP]'"},{name:"pad_token",val:" = '[PAD]'"},{name:"cls_token",val:" = '[CLS]'"},{name:"mask_token",val:" = '[MASK]'"},{name:"tokenize_chinese_chars",val:" = True"},{name:"strip_accents",val:" = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/tokenization_distilbert.py#L56"}}),dn=new ve({}),cn=new U({props:{name:"class transformers.DistilBertTokenizerFast",anchor:"transformers.DistilBertTokenizerFast",parameters:[{name:"vocab_file",val:" = None"},{name:"tokenizer_file",val:" = None"},{name:"do_lower_case",val:" = True"},{name:"unk_token",val:" = '[UNK]'"},{name:"sep_token",val:" = '[SEP]'"},{name:"pad_token",val:" = '[PAD]'"},{name:"cls_token",val:" = '[CLS]'"},{name:"mask_token",val:" = '[MASK]'"},{name:"tokenize_chinese_chars",val:" = True"},{name:"strip_accents",val:" = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/tokenization_distilbert_fast.py#L65"}}),un=new ve({}),fn=new U({props:{name:"class transformers.DistilBertModel",anchor:"transformers.DistilBertModel",parameters:[{name:"config",val:": PretrainedConfig"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_distilbert.py#L457",parametersDescription:[{anchor:"transformers.DistilBertModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),vn=new U({props:{name:"forward",anchor:"transformers.DistilBertModel.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"head_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_distilbert.py#L529",parametersDescription:[{anchor:"transformers.DistilBertModel.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, num_choices)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertTokenizer">DistilBertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.DistilBertModel.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.DistilBertModel.forward.head_mask",description:`<strong>head_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(num_heads,)</code> or <code>(num_layers, num_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the self-attention modules. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"head_mask"},{anchor:"transformers.DistilBertModel.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.DistilBertModel.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.DistilBertModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.DistilBertModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig"
>DistilBertConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),os=new me({props:{$$slots:{default:[dF]},$$scope:{ctx:C}}}),Tn=new Fe({props:{code:`from transformers import DistilBertTokenizer, DistilBertModel
import torch

tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = DistilBertModel.from_pretrained("distilbert-base-uncased")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, DistilBertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = DistilBertModel.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),bn=new ve({}),kn=new U({props:{name:"class transformers.DistilBertForMaskedLM",anchor:"transformers.DistilBertForMaskedLM",parameters:[{name:"config",val:": PretrainedConfig"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_distilbert.py#L585",parametersDescription:[{anchor:"transformers.DistilBertForMaskedLM.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Fn=new U({props:{name:"forward",anchor:"transformers.DistilBertForMaskedLM.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"head_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.LongTensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_distilbert.py#L627",parametersDescription:[{anchor:"transformers.DistilBertForMaskedLM.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, num_choices)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertTokenizer">DistilBertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.DistilBertForMaskedLM.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.DistilBertForMaskedLM.forward.head_mask",description:`<strong>head_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(num_heads,)</code> or <code>(num_layers, num_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the self-attention modules. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"head_mask"},{anchor:"transformers.DistilBertForMaskedLM.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.DistilBertForMaskedLM.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.DistilBertForMaskedLM.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.DistilBertForMaskedLM.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.DistilBertForMaskedLM.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the masked language modeling loss. Indices should be in <code>[-100, 0, ..., config.vocab_size]</code> (see <code>input_ids</code> docstring) Tokens with indices set to <code>-100</code> are ignored (masked), the
loss is only computed for the tokens with labels in <code>[0, ..., config.vocab_size]</code>.`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_outputs.MaskedLMOutput"
>transformers.modeling_outputs.MaskedLMOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig"
>DistilBertConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Masked language modeling (MLM) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, config.vocab_size)</code>) \u2014 Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_outputs.MaskedLMOutput"
>transformers.modeling_outputs.MaskedLMOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),ns=new me({props:{$$slots:{default:[cF]},$$scope:{ctx:C}}}),Bn=new Fe({props:{code:`from transformers import DistilBertTokenizer, DistilBertForMaskedLM
import torch

tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = DistilBertForMaskedLM.from_pretrained("distilbert-base-uncased")

inputs = tokenizer("The capital of France is [MASK].", return_tensors="pt")
labels = tokenizer("The capital of France is Paris.", return_tensors="pt")["input_ids"]

outputs = model(**inputs, labels=labels)
loss = outputs.loss
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, DistilBertForMaskedLM
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = DistilBertForMaskedLM.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;The capital of France is [MASK].&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = tokenizer(<span class="hljs-string">&quot;The capital of France is Paris.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)[<span class="hljs-string">&quot;input_ids&quot;</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, labels=labels)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = outputs.loss
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),Mn=new ve({}),En=new U({props:{name:"class transformers.DistilBertForSequenceClassification",anchor:"transformers.DistilBertForSequenceClassification",parameters:[{name:"config",val:": PretrainedConfig"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_distilbert.py#L691",parametersDescription:[{anchor:"transformers.DistilBertForSequenceClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),jn=new U({props:{name:"forward",anchor:"transformers.DistilBertForSequenceClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"head_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.LongTensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_distilbert.py#L725",parametersDescription:[{anchor:"transformers.DistilBertForSequenceClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertTokenizer">DistilBertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.DistilBertForSequenceClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.DistilBertForSequenceClassification.forward.head_mask",description:`<strong>head_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(num_heads,)</code> or <code>(num_layers, num_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the self-attention modules. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"head_mask"},{anchor:"transformers.DistilBertForSequenceClassification.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.DistilBertForSequenceClassification.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.DistilBertForSequenceClassification.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.DistilBertForSequenceClassification.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.DistilBertForSequenceClassification.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the sequence classification/regression loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>. If <code>config.num_labels == 1</code> a regression loss is computed (Mean-Square loss), If
<code>config.num_labels &gt; 1</code> a classification loss is computed (Cross-Entropy).`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_outputs.SequenceClassifierOutput"
>transformers.modeling_outputs.SequenceClassifierOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig"
>DistilBertConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification (or regression if config.num_labels==1) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.num_labels)</code>) \u2014 Classification (or regression if config.num_labels==1) scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_outputs.SequenceClassifierOutput"
>transformers.modeling_outputs.SequenceClassifierOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),as=new me({props:{$$slots:{default:[pF]},$$scope:{ctx:C}}}),Pn=new Fe({props:{code:`import torch
from transformers import DistilBertTokenizer, DistilBertForSequenceClassification

torch.manual_seed(0)
tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = DistilBertForSequenceClassification.from_pretrained("distilbert-base-uncased", num_labels=2)

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
labels = torch.tensor([1]).unsqueeze(0)  # Batch size 1
outputs = model(**inputs, labels=labels)
loss = outputs.loss
logits = outputs.logits
list(logits.shape)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, DistilBertForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>torch.manual_seed(<span class="hljs-number">0</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = DistilBertForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>, num_labels=<span class="hljs-number">2</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.tensor([<span class="hljs-number">1</span>]).unsqueeze(<span class="hljs-number">0</span>)  <span class="hljs-comment"># Batch size 1</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, labels=labels)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = outputs.loss
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)
`}}),qn=new Fe({props:{code:`import torch
from transformers import DistilBertTokenizer, DistilBertForSequenceClassification

torch.manual_seed(0)
tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = DistilBertForSequenceClassification.from_pretrained("distilbert-base-uncased", problem_type="multi_label_classification", num_labels=2)

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
labels = torch.tensor([[1, 1]], dtype=torch.float)  # need dtype=float for BCEWithLogitsLoss
outputs = model(**inputs, labels=labels)
loss = outputs.loss
list(logits.shape)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, DistilBertForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>torch.manual_seed(<span class="hljs-number">0</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = DistilBertForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>, problem_type=<span class="hljs-string">&quot;multi_label_classification&quot;</span>, num_labels=<span class="hljs-number">2</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.tensor([[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]], dtype=torch.<span class="hljs-built_in">float</span>)  <span class="hljs-comment"># need dtype=float for BCEWithLogitsLoss</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, labels=labels)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = outputs.loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)
`}}),An=new ve({}),On=new U({props:{name:"class transformers.DistilBertForMultipleChoice",anchor:"transformers.DistilBertForMultipleChoice",parameters:[{name:"config",val:": PretrainedConfig"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_distilbert.py#L1021",parametersDescription:[{anchor:"transformers.DistilBertForMultipleChoice.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Nn=new U({props:{name:"forward",anchor:"transformers.DistilBertForMultipleChoice.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"head_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.LongTensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_distilbert.py#L1053",parametersDescription:[{anchor:"transformers.DistilBertForMultipleChoice.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertTokenizer">DistilBertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.DistilBertForMultipleChoice.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.DistilBertForMultipleChoice.forward.head_mask",description:`<strong>head_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(num_heads,)</code> or <code>(num_layers, num_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the self-attention modules. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"head_mask"},{anchor:"transformers.DistilBertForMultipleChoice.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.DistilBertForMultipleChoice.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.DistilBertForMultipleChoice.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.DistilBertForMultipleChoice.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.DistilBertForMultipleChoice.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the multiple choice classification loss. Indices should be in <code>[0, ..., num_choices-1]</code> where <code>num_choices</code> is the size of the second dimension of the input tensors. (See
<code>input_ids</code> above)`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_outputs.MultipleChoiceModelOutput"
>transformers.modeling_outputs.MultipleChoiceModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig"
>DistilBertConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <em>(1,)</em>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices)</code>) \u2014 <em>num_choices</em> is the second dimension of the input tensors. (see <em>input_ids</em> above).</p>
<p>Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_outputs.MultipleChoiceModelOutput"
>transformers.modeling_outputs.MultipleChoiceModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),ls=new me({props:{$$slots:{default:[hF]},$$scope:{ctx:C}}}),Wn=new Fe({props:{code:`from transformers import DistilBertTokenizer, DistilBertForMultipleChoice
import torch

tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-cased")
model = DistilBertForMultipleChoice.from_pretrained("distilbert-base-cased")

prompt = "In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced."
choice0 = "It is eaten with a fork and a knife."
choice1 = "It is eaten while held in the hand."
labels = torch.tensor(0).unsqueeze(0)  # choice0 is correct (according to Wikipedia ;)), batch size 1

encoding = tokenizer([[prompt, choice0], [prompt, choice1]], return_tensors="pt", padding=True)
outputs = model(**{k: v.unsqueeze(0) for k, v in encoding.items()}, labels=labels)  # batch size is 1

# the linear classifier still needs to be trained
loss = outputs.loss
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, DistilBertForMultipleChoice
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-cased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = DistilBertForMultipleChoice.from_pretrained(<span class="hljs-string">&quot;distilbert-base-cased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>prompt = <span class="hljs-string">&quot;In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice0 = <span class="hljs-string">&quot;It is eaten with a fork and a knife.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice1 = <span class="hljs-string">&quot;It is eaten while held in the hand.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.tensor(<span class="hljs-number">0</span>).unsqueeze(<span class="hljs-number">0</span>)  <span class="hljs-comment"># choice0 is correct (according to Wikipedia ;)), batch size 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>encoding = tokenizer([[prompt, choice0], [prompt, choice1]], return_tensors=<span class="hljs-string">&quot;pt&quot;</span>, padding=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**{k: v.unsqueeze(<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> encoding.items()}, labels=labels)  <span class="hljs-comment"># batch size is 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># the linear classifier still needs to be trained</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = outputs.loss
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),Rn=new ve({}),Hn=new U({props:{name:"class transformers.DistilBertForTokenClassification",anchor:"transformers.DistilBertForTokenClassification",parameters:[{name:"config",val:": PretrainedConfig"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_distilbert.py#L926",parametersDescription:[{anchor:"transformers.DistilBertForTokenClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Jn=new U({props:{name:"forward",anchor:"transformers.DistilBertForTokenClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"head_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.LongTensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_distilbert.py#L958",parametersDescription:[{anchor:"transformers.DistilBertForTokenClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>({0})</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertTokenizer">DistilBertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.DistilBertForTokenClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>({0})</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.DistilBertForTokenClassification.forward.head_mask",description:`<strong>head_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(num_heads,)</code> or <code>(num_layers, num_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the self-attention modules. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"head_mask"},{anchor:"transformers.DistilBertForTokenClassification.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>({0}, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.DistilBertForTokenClassification.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.DistilBertForTokenClassification.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.DistilBertForTokenClassification.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.DistilBertForTokenClassification.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the token classification loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>.`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_outputs.TokenClassifierOutput"
>transformers.modeling_outputs.TokenClassifierOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig"
>DistilBertConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided)  \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, config.num_labels)</code>) \u2014 Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_outputs.TokenClassifierOutput"
>transformers.modeling_outputs.TokenClassifierOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),cs=new me({props:{$$slots:{default:[uF]},$$scope:{ctx:C}}}),Kn=new Fe({props:{code:`from transformers import DistilBertTokenizer, DistilBertForTokenClassification
import torch

tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = DistilBertForTokenClassification.from_pretrained("distilbert-base-uncased")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
labels = torch.tensor([1] * inputs["input_ids"].size(1)).unsqueeze(0)  # Batch size 1

outputs = model(**inputs, labels=labels)
loss = outputs.loss
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, DistilBertForTokenClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = DistilBertForTokenClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.tensor([<span class="hljs-number">1</span>] * inputs[<span class="hljs-string">&quot;input_ids&quot;</span>].size(<span class="hljs-number">1</span>)).unsqueeze(<span class="hljs-number">0</span>)  <span class="hljs-comment"># Batch size 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, labels=labels)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = outputs.loss
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),Gn=new ve({}),Xn=new U({props:{name:"class transformers.DistilBertForQuestionAnswering",anchor:"transformers.DistilBertForQuestionAnswering",parameters:[{name:"config",val:": PretrainedConfig"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_distilbert.py#L809",parametersDescription:[{anchor:"transformers.DistilBertForQuestionAnswering.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),tr=new U({props:{name:"forward",anchor:"transformers.DistilBertForQuestionAnswering.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"head_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"start_positions",val:": typing.Optional[torch.Tensor] = None"},{name:"end_positions",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_distilbert.py#L841",parametersDescription:[{anchor:"transformers.DistilBertForQuestionAnswering.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, num_choices)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertTokenizer">DistilBertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.DistilBertForQuestionAnswering.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.DistilBertForQuestionAnswering.forward.head_mask",description:`<strong>head_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(num_heads,)</code> or <code>(num_layers, num_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the self-attention modules. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"head_mask"},{anchor:"transformers.DistilBertForQuestionAnswering.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.DistilBertForQuestionAnswering.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.DistilBertForQuestionAnswering.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.DistilBertForQuestionAnswering.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.DistilBertForQuestionAnswering.forward.start_positions",description:`<strong>start_positions</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the start of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"start_positions"},{anchor:"transformers.DistilBertForQuestionAnswering.forward.end_positions",description:`<strong>end_positions</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the end of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"end_positions"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_outputs.QuestionAnsweringModelOutput"
>transformers.modeling_outputs.QuestionAnsweringModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig"
>DistilBertConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.</p>
</li>
<li>
<p><strong>start_logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-start scores (before SoftMax).</p>
</li>
<li>
<p><strong>end_logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-end scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_outputs.QuestionAnsweringModelOutput"
>transformers.modeling_outputs.QuestionAnsweringModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),hs=new me({props:{$$slots:{default:[fF]},$$scope:{ctx:C}}}),or=new Fe({props:{code:`from transformers import DistilBertTokenizer, DistilBertForQuestionAnswering
import torch

torch.manual_seed(0)
tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = DistilBertForQuestionAnswering.from_pretrained("distilbert-base-uncased")

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"
inputs = tokenizer(question, text, return_tensors="pt")
start_positions = torch.tensor([1])
end_positions = torch.tensor([3])

outputs = model(**inputs, start_positions=start_positions, end_positions=end_positions)
loss = outputs.loss
round(loss.item(), 2)


start_scores = outputs.start_logits
list(start_scores.shape)


end_scores = outputs.end_logits
list(end_scores.shape)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, DistilBertForQuestionAnswering
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>torch.manual_seed(<span class="hljs-number">0</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = DistilBertForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(question, text, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>start_positions = torch.tensor([<span class="hljs-number">1</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>end_positions = torch.tensor([<span class="hljs-number">3</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, start_positions=start_positions, end_positions=end_positions)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = outputs.loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(loss.item(), <span class="hljs-number">2</span>)


<span class="hljs-meta">&gt;&gt;&gt; </span>start_scores = outputs.start_logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(start_scores.shape)


<span class="hljs-meta">&gt;&gt;&gt; </span>end_scores = outputs.end_logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(end_scores.shape)
`}}),sr=new ve({}),nr=new U({props:{name:"class transformers.TFDistilBertModel",anchor:"transformers.TFDistilBertModel",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_tf_distilbert.py#L535",parametersDescription:[{anchor:"transformers.TFDistilBertModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),fs=new me({props:{$$slots:{default:[mF]},$$scope:{ctx:C}}}),lr=new U({props:{name:"call",anchor:"transformers.TFDistilBertModel.call",parameters:[{name:"input_ids",val:" = None"},{name:"attention_mask",val:" = None"},{name:"head_mask",val:" = None"},{name:"inputs_embeds",val:" = None"},{name:"output_attentions",val:" = None"},{name:"output_hidden_states",val:" = None"},{name:"return_dict",val:" = None"},{name:"training",val:" = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_tf_distilbert.py#L540",parametersDescription:[{anchor:"transformers.TFDistilBertModel.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertTokenizer">DistilBertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFDistilBertModel.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFDistilBertModel.call.head_mask",description:`<strong>head_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(num_heads,)</code> or <code>(num_layers, num_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the self-attention modules. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"head_mask"},{anchor:"transformers.TFDistilBertModel.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFDistilBertModel.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFDistilBertModel.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFDistilBertModel.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used
in eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFDistilBertModel.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig"
>DistilBertConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),ms=new me({props:{$$slots:{default:[gF]},$$scope:{ctx:C}}}),dr=new Fe({props:{code:`from transformers import DistilBertTokenizer, TFDistilBertModel
import tensorflow as tf

tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = TFDistilBertModel.from_pretrained("distilbert-base-uncased")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")
outputs = model(inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, TFDistilBertModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFDistilBertModel.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),cr=new ve({}),pr=new U({props:{name:"class transformers.TFDistilBertForMaskedLM",anchor:"transformers.TFDistilBertForMaskedLM",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_tf_distilbert.py#L635",parametersDescription:[{anchor:"transformers.TFDistilBertForMaskedLM.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),_s=new me({props:{$$slots:{default:[_F]},$$scope:{ctx:C}}}),gr=new U({props:{name:"call",anchor:"transformers.TFDistilBertForMaskedLM.call",parameters:[{name:"input_ids",val:" = None"},{name:"attention_mask",val:" = None"},{name:"head_mask",val:" = None"},{name:"inputs_embeds",val:" = None"},{name:"output_attentions",val:" = None"},{name:"output_hidden_states",val:" = None"},{name:"return_dict",val:" = None"},{name:"labels",val:" = None"},{name:"training",val:" = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_tf_distilbert.py#L655",parametersDescription:[{anchor:"transformers.TFDistilBertForMaskedLM.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertTokenizer">DistilBertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFDistilBertForMaskedLM.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFDistilBertForMaskedLM.call.head_mask",description:`<strong>head_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(num_heads,)</code> or <code>(num_layers, num_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the self-attention modules. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"head_mask"},{anchor:"transformers.TFDistilBertForMaskedLM.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFDistilBertForMaskedLM.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFDistilBertForMaskedLM.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFDistilBertForMaskedLM.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used
in eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFDistilBertForMaskedLM.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFDistilBertForMaskedLM.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the masked language modeling loss. Indices should be in <code>[-100, 0, ..., config.vocab_size]</code> (see <code>input_ids</code> docstring) Tokens with indices set to <code>-100</code> are ignored (masked), the
loss is only computed for the tokens with labels in <code>[0, ..., config.vocab_size]</code>`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_tf_outputs.TFMaskedLMOutput"
>transformers.modeling_tf_outputs.TFMaskedLMOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig"
>DistilBertConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(n,)</code>, <em>optional</em>, where n is the number of non-masked labels, returned when <code>labels</code> is provided) \u2014 Masked language modeling (MLM) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, config.vocab_size)</code>) \u2014 Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_tf_outputs.TFMaskedLMOutput"
>transformers.modeling_tf_outputs.TFMaskedLMOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),vs=new me({props:{$$slots:{default:[vF]},$$scope:{ctx:C}}}),_r=new Fe({props:{code:`from transformers import DistilBertTokenizer, TFDistilBertForMaskedLM
import tensorflow as tf

tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = TFDistilBertForMaskedLM.from_pretrained("distilbert-base-uncased")

inputs = tokenizer("The capital of France is [MASK].", return_tensors="tf")
inputs["labels"] = tokenizer("The capital of France is Paris.", return_tensors="tf")["input_ids"]

outputs = model(inputs)
loss = outputs.loss
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, TFDistilBertForMaskedLM
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFDistilBertForMaskedLM.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;The capital of France is [MASK].&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs[<span class="hljs-string">&quot;labels&quot;</span>] = tokenizer(<span class="hljs-string">&quot;The capital of France is Paris.&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)[<span class="hljs-string">&quot;input_ids&quot;</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = outputs.loss
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),vr=new ve({}),Tr=new U({props:{name:"class transformers.TFDistilBertForSequenceClassification",anchor:"transformers.TFDistilBertForSequenceClassification",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_tf_distilbert.py#L739",parametersDescription:[{anchor:"transformers.TFDistilBertForSequenceClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),bs=new me({props:{$$slots:{default:[TF]},$$scope:{ctx:C}}}),$r=new U({props:{name:"call",anchor:"transformers.TFDistilBertForSequenceClassification.call",parameters:[{name:"input_ids",val:" = None"},{name:"attention_mask",val:" = None"},{name:"head_mask",val:" = None"},{name:"inputs_embeds",val:" = None"},{name:"output_attentions",val:" = None"},{name:"output_hidden_states",val:" = None"},{name:"return_dict",val:" = None"},{name:"labels",val:" = None"},{name:"training",val:" = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_tf_distilbert.py#L756",parametersDescription:[{anchor:"transformers.TFDistilBertForSequenceClassification.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertTokenizer">DistilBertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFDistilBertForSequenceClassification.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFDistilBertForSequenceClassification.call.head_mask",description:`<strong>head_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(num_heads,)</code> or <code>(num_layers, num_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the self-attention modules. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"head_mask"},{anchor:"transformers.TFDistilBertForSequenceClassification.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFDistilBertForSequenceClassification.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFDistilBertForSequenceClassification.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFDistilBertForSequenceClassification.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used
in eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFDistilBertForSequenceClassification.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFDistilBertForSequenceClassification.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the sequence classification/regression loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>. If <code>config.num_labels == 1</code> a regression loss is computed (Mean-Square loss), If
<code>config.num_labels &gt; 1</code> a classification loss is computed (Cross-Entropy).`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_tf_outputs.TFSequenceClassifierOutput"
>transformers.modeling_tf_outputs.TFSequenceClassifierOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig"
>DistilBertConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, )</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification (or regression if config.num_labels==1) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, config.num_labels)</code>) \u2014 Classification (or regression if config.num_labels==1) scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_tf_outputs.TFSequenceClassifierOutput"
>transformers.modeling_tf_outputs.TFSequenceClassifierOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),ks=new me({props:{$$slots:{default:[bF]},$$scope:{ctx:C}}}),Dr=new Fe({props:{code:`from transformers import DistilBertTokenizer, TFDistilBertForSequenceClassification
import tensorflow as tf

tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = TFDistilBertForSequenceClassification.from_pretrained("distilbert-base-uncased")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")
inputs["labels"] = tf.reshape(tf.constant(1), (-1, 1))  # Batch size 1

outputs = model(inputs)
loss = outputs.loss
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, TFDistilBertForSequenceClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFDistilBertForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs[<span class="hljs-string">&quot;labels&quot;</span>] = tf.reshape(tf.constant(<span class="hljs-number">1</span>), (-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))  <span class="hljs-comment"># Batch size 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = outputs.loss
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),yr=new ve({}),Fr=new U({props:{name:"class transformers.TFDistilBertForMultipleChoice",anchor:"transformers.TFDistilBertForMultipleChoice",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_tf_distilbert.py#L930",parametersDescription:[{anchor:"transformers.TFDistilBertForMultipleChoice.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),$s=new me({props:{$$slots:{default:[kF]},$$scope:{ctx:C}}}),xr=new U({props:{name:"call",anchor:"transformers.TFDistilBertForMultipleChoice.call",parameters:[{name:"input_ids",val:" = None"},{name:"attention_mask",val:" = None"},{name:"head_mask",val:" = None"},{name:"inputs_embeds",val:" = None"},{name:"output_attentions",val:" = None"},{name:"output_hidden_states",val:" = None"},{name:"return_dict",val:" = None"},{name:"labels",val:" = None"},{name:"training",val:" = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_tf_distilbert.py#L956",parametersDescription:[{anchor:"transformers.TFDistilBertForMultipleChoice.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertTokenizer">DistilBertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFDistilBertForMultipleChoice.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFDistilBertForMultipleChoice.call.head_mask",description:`<strong>head_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(num_heads,)</code> or <code>(num_layers, num_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the self-attention modules. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"head_mask"},{anchor:"transformers.TFDistilBertForMultipleChoice.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFDistilBertForMultipleChoice.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFDistilBertForMultipleChoice.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFDistilBertForMultipleChoice.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used
in eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFDistilBertForMultipleChoice.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFDistilBertForMultipleChoice.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the multiple choice classification loss. Indices should be in <code>[0, ..., num_choices]</code>
where <code>num_choices</code> is the size of the second dimension of the input tensors. (See <code>input_ids</code> above)`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput"
>transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig"
>DistilBertConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <em>(batch_size, )</em>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, num_choices)</code>) \u2014 <em>num_choices</em> is the second dimension of the input tensors. (see <em>input_ids</em> above).</p>
<p>Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput"
>transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),Ds=new me({props:{$$slots:{default:[wF]},$$scope:{ctx:C}}}),zr=new Fe({props:{code:`from transformers import DistilBertTokenizer, TFDistilBertForMultipleChoice
import tensorflow as tf

tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = TFDistilBertForMultipleChoice.from_pretrained("distilbert-base-uncased")

prompt = "In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced."
choice0 = "It is eaten with a fork and a knife."
choice1 = "It is eaten while held in the hand."

encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors="tf", padding=True)
inputs = {k: tf.expand_dims(v, 0) for k, v in encoding.items()}
outputs = model(inputs)  # batch size is 1

# the linear classifier still needs to be trained
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, TFDistilBertForMultipleChoice
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFDistilBertForMultipleChoice.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>prompt = <span class="hljs-string">&quot;In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice0 = <span class="hljs-string">&quot;It is eaten with a fork and a knife.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice1 = <span class="hljs-string">&quot;It is eaten while held in the hand.&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors=<span class="hljs-string">&quot;tf&quot;</span>, padding=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = {k: tf.expand_dims(v, <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> encoding.items()}
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(inputs)  <span class="hljs-comment"># batch size is 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># the linear classifier still needs to be trained</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),Cr=new ve({}),jr=new U({props:{name:"class transformers.TFDistilBertForTokenClassification",anchor:"transformers.TFDistilBertForTokenClassification",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_tf_distilbert.py#L840",parametersDescription:[{anchor:"transformers.TFDistilBertForTokenClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Fs=new me({props:{$$slots:{default:[$F]},$$scope:{ctx:C}}}),Or=new U({props:{name:"call",anchor:"transformers.TFDistilBertForTokenClassification.call",parameters:[{name:"input_ids",val:" = None"},{name:"attention_mask",val:" = None"},{name:"head_mask",val:" = None"},{name:"inputs_embeds",val:" = None"},{name:"output_attentions",val:" = None"},{name:"output_hidden_states",val:" = None"},{name:"return_dict",val:" = None"},{name:"labels",val:" = None"},{name:"training",val:" = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_tf_distilbert.py#L851",parametersDescription:[{anchor:"transformers.TFDistilBertForTokenClassification.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertTokenizer">DistilBertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFDistilBertForTokenClassification.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFDistilBertForTokenClassification.call.head_mask",description:`<strong>head_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(num_heads,)</code> or <code>(num_layers, num_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the self-attention modules. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"head_mask"},{anchor:"transformers.TFDistilBertForTokenClassification.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFDistilBertForTokenClassification.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFDistilBertForTokenClassification.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFDistilBertForTokenClassification.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used
in eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFDistilBertForTokenClassification.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFDistilBertForTokenClassification.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the token classification loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>.`,name:"labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_tf_outputs.TFTokenClassifierOutput"
>transformers.modeling_tf_outputs.TFTokenClassifierOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig"
>DistilBertConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(n,)</code>, <em>optional</em>, where n is the number of unmasked labels, returned when <code>labels</code> is provided)  \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, config.num_labels)</code>) \u2014 Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_tf_outputs.TFTokenClassifierOutput"
>transformers.modeling_tf_outputs.TFTokenClassifierOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),Bs=new me({props:{$$slots:{default:[DF]},$$scope:{ctx:C}}}),Ir=new Fe({props:{code:`from transformers import DistilBertTokenizer, TFDistilBertForTokenClassification
import tensorflow as tf

tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = TFDistilBertForTokenClassification.from_pretrained("distilbert-base-uncased")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")
input_ids = inputs["input_ids"]
inputs["labels"] = tf.reshape(
    tf.constant([1] * tf.size(input_ids).numpy()), (-1, tf.size(input_ids))
)  # Batch size 1

outputs = model(inputs)
loss = outputs.loss
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, TFDistilBertForTokenClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFDistilBertForTokenClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>input_ids = inputs[<span class="hljs-string">&quot;input_ids&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs[<span class="hljs-string">&quot;labels&quot;</span>] = tf.reshape(
<span class="hljs-meta">... </span>    tf.constant([<span class="hljs-number">1</span>] * tf.size(input_ids).numpy()), (-<span class="hljs-number">1</span>, tf.size(input_ids))
<span class="hljs-meta">&gt;&gt;&gt; </span>)  <span class="hljs-comment"># Batch size 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = outputs.loss
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),Lr=new ve({}),Sr=new U({props:{name:"class transformers.TFDistilBertForQuestionAnswering",anchor:"transformers.TFDistilBertForQuestionAnswering",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_tf_distilbert.py#L1072",parametersDescription:[{anchor:"transformers.TFDistilBertForQuestionAnswering.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Es=new me({props:{$$slots:{default:[yF]},$$scope:{ctx:C}}}),Hr=new U({props:{name:"call",anchor:"transformers.TFDistilBertForQuestionAnswering.call",parameters:[{name:"input_ids",val:" = None"},{name:"attention_mask",val:" = None"},{name:"head_mask",val:" = None"},{name:"inputs_embeds",val:" = None"},{name:"output_attentions",val:" = None"},{name:"output_hidden_states",val:" = None"},{name:"return_dict",val:" = None"},{name:"start_positions",val:" = None"},{name:"end_positions",val:" = None"},{name:"training",val:" = False"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_tf_distilbert.py#L1083",parametersDescription:[{anchor:"transformers.TFDistilBertForQuestionAnswering.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertTokenizer">DistilBertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFDistilBertForQuestionAnswering.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFDistilBertForQuestionAnswering.call.head_mask",description:`<strong>head_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(num_heads,)</code> or <code>(num_layers, num_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the self-attention modules. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"head_mask"},{anchor:"transformers.TFDistilBertForQuestionAnswering.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFDistilBertForQuestionAnswering.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFDistilBertForQuestionAnswering.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFDistilBertForQuestionAnswering.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used
in eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFDistilBertForQuestionAnswering.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFDistilBertForQuestionAnswering.call.start_positions",description:`<strong>start_positions</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the start of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"start_positions"},{anchor:"transformers.TFDistilBertForQuestionAnswering.call.end_positions",description:`<strong>end_positions</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the end of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"end_positions"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput"
>transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig"
>DistilBertConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, )</code>, <em>optional</em>, returned when <code>start_positions</code> and <code>end_positions</code> are provided) \u2014 Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.</p>
</li>
<li>
<p><strong>start_logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-start scores (before SoftMax).</p>
</li>
<li>
<p><strong>end_logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-end scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput"
>transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),xs=new me({props:{$$slots:{default:[FF]},$$scope:{ctx:C}}}),Qr=new Fe({props:{code:`from transformers import DistilBertTokenizer, TFDistilBertForQuestionAnswering
import tensorflow as tf

tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = TFDistilBertForQuestionAnswering.from_pretrained("distilbert-base-uncased")

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"
input_dict = tokenizer(question, text, return_tensors="tf")
outputs = model(input_dict)
start_logits = outputs.start_logits
end_logits = outputs.end_logits

all_tokens = tokenizer.convert_ids_to_tokens(input_dict["input_ids"].numpy()[0])
answer = " ".join(all_tokens[tf.math.argmax(start_logits, 1)[0] : tf.math.argmax(end_logits, 1)[0] + 1])`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, TFDistilBertForQuestionAnswering
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFDistilBertForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>input_dict = tokenizer(question, text, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(input_dict)
<span class="hljs-meta">&gt;&gt;&gt; </span>start_logits = outputs.start_logits
<span class="hljs-meta">&gt;&gt;&gt; </span>end_logits = outputs.end_logits

<span class="hljs-meta">&gt;&gt;&gt; </span>all_tokens = tokenizer.convert_ids_to_tokens(input_dict[<span class="hljs-string">&quot;input_ids&quot;</span>].numpy()[<span class="hljs-number">0</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>answer = <span class="hljs-string">&quot; &quot;</span>.join(all_tokens[tf.math.argmax(start_logits, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>] : tf.math.argmax(end_logits, <span class="hljs-number">1</span>)[<span class="hljs-number">0</span>] + <span class="hljs-number">1</span>])`}}),Ur=new ve({}),Vr=new U({props:{name:"class transformers.FlaxDistilBertModel",anchor:"transformers.FlaxDistilBertModel",parameters:[{name:"config",val:": DistilBertConfig"},{name:"input_shape",val:": typing.Tuple = (1, 1)"},{name:"seed",val:": int = 0"},{name:"dtype",val:": dtype = <class 'jax._src.numpy.lax_numpy.float32'>"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_flax_distilbert.py#L524",parametersDescription:[{anchor:"transformers.FlaxDistilBertModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),ta=new U({props:{name:"__call__",anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__",parameters:[{name:"input_ids",val:""},{name:"attention_mask",val:" = None"},{name:"head_mask",val:" = None"},{name:"params",val:": dict = None"},{name:"dropout_rng",val:": PRNGKey = None"},{name:"train",val:": bool = False"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_flax_distilbert.py#L447",parametersDescription:[{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.input_ids",description:`<strong>input_ids</strong> (<code>numpy.ndarray</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.attention_mask",description:`<strong>attention_mask</strong> (<code>numpy.ndarray</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}]}}),Cs=new me({props:{$$slots:{default:[BF]},$$scope:{ctx:C}}}),oa=new Fe({props:{code:`from transformers import DistilBertTokenizer, FlaxDistilBertModel

tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = FlaxDistilBertModel.from_pretrained("distilbert-base-uncased")

inputs = tokenizer("Hello, my dog is cute", return_tensors="jax")
outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, FlaxDistilBertModel

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FlaxDistilBertModel.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;jax&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),sa=new ve({}),na=new U({props:{name:"class transformers.FlaxDistilBertForMaskedLM",anchor:"transformers.FlaxDistilBertForMaskedLM",parameters:[{name:"config",val:": DistilBertConfig"},{name:"input_shape",val:": typing.Tuple = (1, 1)"},{name:"seed",val:": int = 0"},{name:"dtype",val:": dtype = <class 'jax._src.numpy.lax_numpy.float32'>"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_flax_distilbert.py#L597",parametersDescription:[{anchor:"transformers.FlaxDistilBertForMaskedLM.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),ua=new U({props:{name:"__call__",anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__",parameters:[{name:"input_ids",val:""},{name:"attention_mask",val:" = None"},{name:"head_mask",val:" = None"},{name:"params",val:": dict = None"},{name:"dropout_rng",val:": PRNGKey = None"},{name:"train",val:": bool = False"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_flax_distilbert.py#L447",parametersDescription:[{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.input_ids",description:`<strong>input_ids</strong> (<code>numpy.ndarray</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.attention_mask",description:`<strong>attention_mask</strong> (<code>numpy.ndarray</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_flax_outputs.FlaxMaskedLMOutput"
>transformers.modeling_flax_outputs.FlaxMaskedLMOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig"
>DistilBertConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>logits</strong> (<code>jnp.ndarray</code> of shape <code>(batch_size, sequence_length, config.vocab_size)</code>) \u2014 Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(jnp.ndarray)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>jnp.ndarray</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(jnp.ndarray)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>jnp.ndarray</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_flax_outputs.FlaxMaskedLMOutput"
>transformers.modeling_flax_outputs.FlaxMaskedLMOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Ps=new me({props:{$$slots:{default:[MF]},$$scope:{ctx:C}}}),fa=new Fe({props:{code:`from transformers import DistilBertTokenizer, FlaxDistilBertForMaskedLM

tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = FlaxDistilBertForMaskedLM.from_pretrained("distilbert-base-uncased")

inputs = tokenizer("The capital of France is [MASK].", return_tensors="jax")

outputs = model(**inputs)
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, FlaxDistilBertForMaskedLM

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FlaxDistilBertForMaskedLM.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;The capital of France is [MASK].&quot;</span>, return_tensors=<span class="hljs-string">&quot;jax&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),ma=new ve({}),ga=new U({props:{name:"class transformers.FlaxDistilBertForSequenceClassification",anchor:"transformers.FlaxDistilBertForSequenceClassification",parameters:[{name:"config",val:": DistilBertConfig"},{name:"input_shape",val:": typing.Tuple = (1, 1)"},{name:"seed",val:": int = 0"},{name:"dtype",val:": dtype = <class 'jax._src.numpy.lax_numpy.float32'>"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_flax_distilbert.py#L666",parametersDescription:[{anchor:"transformers.FlaxDistilBertForSequenceClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Da=new U({props:{name:"__call__",anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__",parameters:[{name:"input_ids",val:""},{name:"attention_mask",val:" = None"},{name:"head_mask",val:" = None"},{name:"params",val:": dict = None"},{name:"dropout_rng",val:": PRNGKey = None"},{name:"train",val:": bool = False"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_flax_distilbert.py#L447",parametersDescription:[{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.input_ids",description:`<strong>input_ids</strong> (<code>numpy.ndarray</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.attention_mask",description:`<strong>attention_mask</strong> (<code>numpy.ndarray</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_flax_outputs.FlaxSequenceClassifierOutput"
>transformers.modeling_flax_outputs.FlaxSequenceClassifierOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig"
>DistilBertConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>logits</strong> (<code>jnp.ndarray</code> of shape <code>(batch_size, config.num_labels)</code>) \u2014 Classification (or regression if config.num_labels==1) scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(jnp.ndarray)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>jnp.ndarray</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(jnp.ndarray)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>jnp.ndarray</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_flax_outputs.FlaxSequenceClassifierOutput"
>transformers.modeling_flax_outputs.FlaxSequenceClassifierOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),As=new me({props:{$$slots:{default:[EF]},$$scope:{ctx:C}}}),ya=new Fe({props:{code:`from transformers import DistilBertTokenizer, FlaxDistilBertForSequenceClassification

tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = FlaxDistilBertForSequenceClassification.from_pretrained("distilbert-base-uncased")

inputs = tokenizer("Hello, my dog is cute", return_tensors="jax")

outputs = model(**inputs)
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, FlaxDistilBertForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FlaxDistilBertForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;jax&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),Fa=new ve({}),Ba=new U({props:{name:"class transformers.FlaxDistilBertForMultipleChoice",anchor:"transformers.FlaxDistilBertForMultipleChoice",parameters:[{name:"config",val:": DistilBertConfig"},{name:"input_shape",val:": typing.Tuple = (1, 1)"},{name:"seed",val:": int = 0"},{name:"dtype",val:": dtype = <class 'jax._src.numpy.lax_numpy.float32'>"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_flax_distilbert.py#L746",parametersDescription:[{anchor:"transformers.FlaxDistilBertForMultipleChoice.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),qa=new U({props:{name:"__call__",anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__",parameters:[{name:"input_ids",val:""},{name:"attention_mask",val:" = None"},{name:"head_mask",val:" = None"},{name:"params",val:": dict = None"},{name:"dropout_rng",val:": PRNGKey = None"},{name:"train",val:": bool = False"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_flax_distilbert.py#L447",parametersDescription:[{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.input_ids",description:`<strong>input_ids</strong> (<code>numpy.ndarray</code> of shape <code>(batch_size, num_choices, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.attention_mask",description:`<strong>attention_mask</strong> (<code>numpy.ndarray</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_flax_outputs.FlaxMultipleChoiceModelOutput"
>transformers.modeling_flax_outputs.FlaxMultipleChoiceModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig"
>DistilBertConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>logits</strong> (<code>jnp.ndarray</code> of shape <code>(batch_size, num_choices)</code>) \u2014 <em>num_choices</em> is the second dimension of the input tensors. (see <em>input_ids</em> above).</p>
<p>Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(jnp.ndarray)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>jnp.ndarray</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(jnp.ndarray)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>jnp.ndarray</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_flax_outputs.FlaxMultipleChoiceModelOutput"
>transformers.modeling_flax_outputs.FlaxMultipleChoiceModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Is=new me({props:{$$slots:{default:[xF]},$$scope:{ctx:C}}}),Aa=new Fe({props:{code:`from transformers import DistilBertTokenizer, FlaxDistilBertForMultipleChoice

tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = FlaxDistilBertForMultipleChoice.from_pretrained("distilbert-base-uncased")

prompt = "In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced."
choice0 = "It is eaten with a fork and a knife."
choice1 = "It is eaten while held in the hand."

encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors="jax", padding=True)
outputs = model(**{k: v[None, :] for k, v in encoding.items()})

logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, FlaxDistilBertForMultipleChoice

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FlaxDistilBertForMultipleChoice.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>prompt = <span class="hljs-string">&quot;In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice0 = <span class="hljs-string">&quot;It is eaten with a fork and a knife.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice1 = <span class="hljs-string">&quot;It is eaten while held in the hand.&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors=<span class="hljs-string">&quot;jax&quot;</span>, padding=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**{k: v[<span class="hljs-literal">None</span>, :] <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> encoding.items()})

<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),Oa=new ve({}),Ia=new U({props:{name:"class transformers.FlaxDistilBertForTokenClassification",anchor:"transformers.FlaxDistilBertForTokenClassification",parameters:[{name:"config",val:": DistilBertConfig"},{name:"input_shape",val:": typing.Tuple = (1, 1)"},{name:"seed",val:": int = 0"},{name:"dtype",val:": dtype = <class 'jax._src.numpy.lax_numpy.float32'>"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_flax_distilbert.py#L812",parametersDescription:[{anchor:"transformers.FlaxDistilBertForTokenClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),Ua=new U({props:{name:"__call__",anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__",parameters:[{name:"input_ids",val:""},{name:"attention_mask",val:" = None"},{name:"head_mask",val:" = None"},{name:"params",val:": dict = None"},{name:"dropout_rng",val:": PRNGKey = None"},{name:"train",val:": bool = False"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_flax_distilbert.py#L447",parametersDescription:[{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.input_ids",description:`<strong>input_ids</strong> (<code>numpy.ndarray</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.attention_mask",description:`<strong>attention_mask</strong> (<code>numpy.ndarray</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_flax_outputs.FlaxTokenClassifierOutput"
>transformers.modeling_flax_outputs.FlaxTokenClassifierOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig"
>DistilBertConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>logits</strong> (<code>jnp.ndarray</code> of shape <code>(batch_size, sequence_length, config.num_labels)</code>) \u2014 Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(jnp.ndarray)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>jnp.ndarray</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(jnp.ndarray)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>jnp.ndarray</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_flax_outputs.FlaxTokenClassifierOutput"
>transformers.modeling_flax_outputs.FlaxTokenClassifierOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Ss=new me({props:{$$slots:{default:[zF]},$$scope:{ctx:C}}}),Va=new Fe({props:{code:`from transformers import DistilBertTokenizer, FlaxDistilBertForTokenClassification

tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = FlaxDistilBertForTokenClassification.from_pretrained("distilbert-base-uncased")

inputs = tokenizer("Hello, my dog is cute", return_tensors="jax")

outputs = model(**inputs)
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, FlaxDistilBertForTokenClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FlaxDistilBertForTokenClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;jax&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),Ja=new ve({}),Ka=new U({props:{name:"class transformers.FlaxDistilBertForQuestionAnswering",anchor:"transformers.FlaxDistilBertForQuestionAnswering",parameters:[{name:"config",val:": DistilBertConfig"},{name:"input_shape",val:": typing.Tuple = (1, 1)"},{name:"seed",val:": int = 0"},{name:"dtype",val:": dtype = <class 'jax._src.numpy.lax_numpy.float32'>"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_flax_distilbert.py#L882",parametersDescription:[{anchor:"transformers.FlaxDistilBertForQuestionAnswering.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig">DistilBertConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),si=new U({props:{name:"__call__",anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__",parameters:[{name:"input_ids",val:""},{name:"attention_mask",val:" = None"},{name:"head_mask",val:" = None"},{name:"params",val:": dict = None"},{name:"dropout_rng",val:": PRNGKey = None"},{name:"train",val:": bool = False"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16090/src/transformers/models/distilbert/modeling_flax_distilbert.py#L447",parametersDescription:[{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.input_ids",description:`<strong>input_ids</strong> (<code>numpy.ndarray</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16090/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16090/en/internal/tokenization_utils#transformers.PreTrainedTokenizerBase.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.attention_mask",description:`<strong>attention_mask</strong> (<code>numpy.ndarray</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FlaxDistilBertPreTrainedModel.__call__.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16090/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_flax_outputs.FlaxQuestionAnsweringModelOutput"
>transformers.modeling_flax_outputs.FlaxQuestionAnsweringModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertConfig"
>DistilBertConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>start_logits</strong> (<code>jnp.ndarray</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-start scores (before SoftMax).</p>
</li>
<li>
<p><strong>end_logits</strong> (<code>jnp.ndarray</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-end scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(jnp.ndarray)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>jnp.ndarray</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(jnp.ndarray)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>jnp.ndarray</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16090/en/main_classes/output#transformers.modeling_flax_outputs.FlaxQuestionAnsweringModelOutput"
>transformers.modeling_flax_outputs.FlaxQuestionAnsweringModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Ws=new me({props:{$$slots:{default:[CF]},$$scope:{ctx:C}}}),ni=new Fe({props:{code:`from transformers import DistilBertTokenizer, FlaxDistilBertForQuestionAnswering

tokenizer = DistilBertTokenizer.from_pretrained("distilbert-base-uncased")
model = FlaxDistilBertForQuestionAnswering.from_pretrained("distilbert-base-uncased")

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"
inputs = tokenizer(question, text, return_tensors="jax")

outputs = model(**inputs)
start_scores = outputs.start_logits
end_scores = outputs.end_logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DistilBertTokenizer, FlaxDistilBertForQuestionAnswering

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = DistilBertTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FlaxDistilBertForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(question, text, return_tensors=<span class="hljs-string">&quot;jax&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>start_scores = outputs.start_logits
<span class="hljs-meta">&gt;&gt;&gt; </span>end_scores = outputs.end_logits`}}),{c(){p=s("meta"),F=l(),g=s("h1"),v=s("a"),T=s("span"),b(_.$$.fragment),f=l(),B=s("span"),de=a("DistilBERT"),V=l(),E=s("h2"),G=s("a"),S=s("span"),b(X.$$.fragment),ce=l(),N=s("span"),pe=a("Overview"),re=l(),I=s("p"),q=a("The DistilBERT model was proposed in the blog post "),Y=s("a"),J=a(`Smaller, faster, cheaper, lighter: Introducing DistilBERT, a
distilled version of BERT`),x=a(", and the paper "),z=s("a"),he=a(`DistilBERT, a
distilled version of BERT: smaller, faster, cheaper and lighter`),W=a(`. DistilBERT is a
small, fast, cheap and light Transformer model trained by distilling BERT base. It has 40% less parameters than
`),oe=s("em"),ue=a("bert-base-uncased"),R=a(`, runs 60% faster while preserving over 95% of BERT\u2019s performances as measured on the GLUE language
understanding benchmark.`),ae=l(),ee=s("p"),A=a("The abstract from the paper is the following:"),ie=l(),L=s("p"),se=s("em"),fe=a(`As Transfer Learning from large-scale pre-trained models becomes more prevalent in Natural Language Processing (NLP),
operating these large models in on-the-edge and/or under constrained computational training or inference budgets
remains challenging. In this work, we propose a method to pre-train a smaller general-purpose language representation
model, called DistilBERT, which can then be fine-tuned with good performances on a wide range of tasks like its larger
counterparts. While most prior work investigated the use of distillation for building task-specific models, we leverage
knowledge distillation during the pretraining phase and show that it is possible to reduce the size of a BERT model by
40%, while retaining 97% of its language understanding capabilities and being 60% faster. To leverage the inductive
biases learned by larger models during pretraining, we introduce a triple loss combining language modeling,
distillation and cosine-distance losses. Our smaller, faster and lighter model is cheaper to pre-train and we
demonstrate its capabilities for on-device computations in a proof-of-concept experiment and a comparative on-device
study.`),P=l(),te=s("p"),H=a("Tips:"),le=l(),h=s("ul"),M=s("li"),K=a("DistilBERT doesn\u2019t have "),ge=s("code"),Te=a("token_type_ids"),O=a(`, you don\u2019t need to indicate which token belongs to which segment. Just
separate your segments with the separation token `),_e=s("code"),be=a("tokenizer.sep_token"),ke=a(" (or "),j=s("code"),Q=a("[SEP]"),we=a(")."),$e=l(),Z=s("li"),De=a("DistilBERT doesn\u2019t have options to select the input positions ("),ne=s("code"),ye=a("position_ids"),hu=a(` input). This could be added if
necessary though, just let us know if you need this option.`),up=l(),Tt=s("p"),uu=a("This model was contributed by "),Ys=s("a"),fu=a("victorsanh"),mu=a(`. This model jax version was
contributed by `),Zs=s("a"),gu=a("kamalkraj"),_u=a(". The original code can be found "),en=s("a"),vu=a("here"),Tu=a("."),fp=l(),ao=s("h2"),Go=s("a"),_l=s("span"),b(tn.$$.fragment),bu=l(),vl=s("span"),ku=a("DistilBertConfig"),mp=l(),Se=s("div"),b(on.$$.fragment),wu=l(),Ft=s("p"),$u=a("This is the configuration class to store the configuration of a "),di=s("a"),Du=a("DistilBertModel"),yu=a(" or a "),ci=s("a"),Fu=a("TFDistilBertModel"),Bu=a(`. It
is used to instantiate a DistilBERT model according to the specified arguments, defining the model architecture.
Instantiating a configuration with the defaults will yield a similar configuration to that of the DistilBERT
`),sn=s("a"),Mu=a("distilbert-base-uncased"),Eu=a(" architecture."),xu=l(),io=s("p"),zu=a("Configuration objects inherit from "),pi=s("a"),Cu=a("PretrainedConfig"),ju=a(` and can be used to control the model outputs. Read the
documentation from `),hi=s("a"),Pu=a("PretrainedConfig"),qu=a(" for more information."),Au=l(),Tl=s("p"),Ou=a("Examples:"),Iu=l(),b(nn.$$.fragment),gp=l(),lo=s("h2"),Xo=s("a"),bl=s("span"),b(rn.$$.fragment),Lu=l(),kl=s("span"),Su=a("DistilBertTokenizer"),_p=l(),_t=s("div"),b(an.$$.fragment),Nu=l(),wl=s("p"),Wu=a("Construct a DistilBERT tokenizer."),Ru=l(),Yo=s("p"),ui=s("a"),Hu=a("DistilBertTokenizer"),Qu=a(" is identical to "),fi=s("a"),Uu=a("BertTokenizer"),Vu=a(` and runs end-to-end tokenization: punctuation splitting
and wordpiece.`),Ju=l(),ln=s("p"),Ku=a("Refer to superclass "),mi=s("a"),Gu=a("BertTokenizer"),Xu=a(" for usage examples and documentation concerning parameters."),vp=l(),co=s("h2"),Zo=s("a"),$l=s("span"),b(dn.$$.fragment),Yu=l(),Dl=s("span"),Zu=a("DistilBertTokenizerFast"),Tp=l(),vt=s("div"),b(cn.$$.fragment),ef=l(),pn=s("p"),tf=a("Construct a \u201Cfast\u201D DistilBERT tokenizer (backed by HuggingFace\u2019s "),yl=s("em"),of=a("tokenizers"),sf=a(" library)."),nf=l(),es=s("p"),gi=s("a"),rf=a("DistilBertTokenizerFast"),af=a(" is identical to "),_i=s("a"),lf=a("BertTokenizerFast"),df=a(` and runs end-to-end tokenization: punctuation
splitting and wordpiece.`),cf=l(),hn=s("p"),pf=a("Refer to superclass "),vi=s("a"),hf=a("BertTokenizerFast"),uf=a(" for usage examples and documentation concerning parameters."),bp=l(),po=s("h2"),ts=s("a"),Fl=s("span"),b(un.$$.fragment),ff=l(),Bl=s("span"),mf=a("DistilBertModel"),kp=l(),Ne=s("div"),b(fn.$$.fragment),gf=l(),Ml=s("p"),_f=a("The bare DistilBERT encoder/transformer outputting raw hidden-states without any specific head on top."),vf=l(),mn=s("p"),Tf=a("This model inherits from "),Ti=s("a"),bf=a("PreTrainedModel"),kf=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),wf=l(),gn=s("p"),$f=a("This model is also a PyTorch "),_n=s("a"),Df=a("torch.nn.Module"),yf=a(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Ff=l(),Ve=s("div"),b(vn.$$.fragment),Bf=l(),ho=s("p"),Mf=a("The "),bi=s("a"),Ef=a("DistilBertModel"),xf=a(" forward method, overrides the "),El=s("code"),zf=a("__call__"),Cf=a(" special method."),jf=l(),b(os.$$.fragment),Pf=l(),xl=s("p"),qf=a("Example:"),Af=l(),b(Tn.$$.fragment),wp=l(),uo=s("h2"),ss=s("a"),zl=s("span"),b(bn.$$.fragment),Of=l(),Cl=s("span"),If=a("DistilBertForMaskedLM"),$p=l(),We=s("div"),b(kn.$$.fragment),Lf=l(),wn=s("p"),Sf=a("DistilBert Model with a "),jl=s("code"),Nf=a("masked language modeling"),Wf=a(" head on top."),Rf=l(),$n=s("p"),Hf=a("This model inherits from "),ki=s("a"),Qf=a("PreTrainedModel"),Uf=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Vf=l(),Dn=s("p"),Jf=a("This model is also a PyTorch "),yn=s("a"),Kf=a("torch.nn.Module"),Gf=a(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Xf=l(),Je=s("div"),b(Fn.$$.fragment),Yf=l(),fo=s("p"),Zf=a("The "),wi=s("a"),em=a("DistilBertForMaskedLM"),tm=a(" forward method, overrides the "),Pl=s("code"),om=a("__call__"),sm=a(" special method."),nm=l(),b(ns.$$.fragment),rm=l(),ql=s("p"),am=a("Example:"),im=l(),b(Bn.$$.fragment),Dp=l(),mo=s("h2"),rs=s("a"),Al=s("span"),b(Mn.$$.fragment),lm=l(),Ol=s("span"),dm=a("DistilBertForSequenceClassification"),yp=l(),Re=s("div"),b(En.$$.fragment),cm=l(),Il=s("p"),pm=a(`DistilBert Model transformer with a sequence classification/regression head on top (a linear layer on top of the
pooled output) e.g. for GLUE tasks.`),hm=l(),xn=s("p"),um=a("This model inherits from "),$i=s("a"),fm=a("PreTrainedModel"),mm=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),gm=l(),zn=s("p"),_m=a("This model is also a PyTorch "),Cn=s("a"),vm=a("torch.nn.Module"),Tm=a(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),bm=l(),je=s("div"),b(jn.$$.fragment),km=l(),go=s("p"),wm=a("The "),Di=s("a"),$m=a("DistilBertForSequenceClassification"),Dm=a(" forward method, overrides the "),Ll=s("code"),ym=a("__call__"),Fm=a(" special method."),Bm=l(),b(as.$$.fragment),Mm=l(),Sl=s("p"),Em=a("Example of single-label classification:"),xm=l(),b(Pn.$$.fragment),zm=l(),Nl=s("p"),Cm=a("Example of multi-label classification:"),jm=l(),b(qn.$$.fragment),Fp=l(),_o=s("h2"),is=s("a"),Wl=s("span"),b(An.$$.fragment),Pm=l(),Rl=s("span"),qm=a("DistilBertForMultipleChoice"),Bp=l(),He=s("div"),b(On.$$.fragment),Am=l(),Hl=s("p"),Om=a(`DistilBert Model with a multiple choice classification head on top (a linear layer on top of the pooled output and
a softmax) e.g. for RocStories/SWAG tasks.`),Im=l(),In=s("p"),Lm=a("This model inherits from "),yi=s("a"),Sm=a("PreTrainedModel"),Nm=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Wm=l(),Ln=s("p"),Rm=a("This model is also a PyTorch "),Sn=s("a"),Hm=a("torch.nn.Module"),Qm=a(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Um=l(),Ke=s("div"),b(Nn.$$.fragment),Vm=l(),vo=s("p"),Jm=a("The "),Fi=s("a"),Km=a("DistilBertForMultipleChoice"),Gm=a(" forward method, overrides the "),Ql=s("code"),Xm=a("__call__"),Ym=a(" special method."),Zm=l(),b(ls.$$.fragment),eg=l(),Ul=s("p"),tg=a("Examples:"),og=l(),b(Wn.$$.fragment),Mp=l(),To=s("h2"),ds=s("a"),Vl=s("span"),b(Rn.$$.fragment),sg=l(),Jl=s("span"),ng=a("DistilBertForTokenClassification"),Ep=l(),Qe=s("div"),b(Hn.$$.fragment),rg=l(),Kl=s("p"),ag=a(`DistilBert Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g.
for Named-Entity-Recognition (NER) tasks.`),ig=l(),Qn=s("p"),lg=a("This model inherits from "),Bi=s("a"),dg=a("PreTrainedModel"),cg=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),pg=l(),Un=s("p"),hg=a("This model is also a PyTorch "),Vn=s("a"),ug=a("torch.nn.Module"),fg=a(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),mg=l(),Ge=s("div"),b(Jn.$$.fragment),gg=l(),bo=s("p"),_g=a("The "),Mi=s("a"),vg=a("DistilBertForTokenClassification"),Tg=a(" forward method, overrides the "),Gl=s("code"),bg=a("__call__"),kg=a(" special method."),wg=l(),b(cs.$$.fragment),$g=l(),Xl=s("p"),Dg=a("Example:"),yg=l(),b(Kn.$$.fragment),xp=l(),ko=s("h2"),ps=s("a"),Yl=s("span"),b(Gn.$$.fragment),Fg=l(),Zl=s("span"),Bg=a("DistilBertForQuestionAnswering"),zp=l(),Ue=s("div"),b(Xn.$$.fragment),Mg=l(),wo=s("p"),Eg=a(`DistilBert Model with a span classification head on top for extractive question-answering tasks like SQuAD (a
linear layers on top of the hidden-states output to compute `),ed=s("code"),xg=a("span start logits"),zg=a(" and "),td=s("code"),Cg=a("span end logits"),jg=a(")."),Pg=l(),Yn=s("p"),qg=a("This model inherits from "),Ei=s("a"),Ag=a("PreTrainedModel"),Og=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Ig=l(),Zn=s("p"),Lg=a("This model is also a PyTorch "),er=s("a"),Sg=a("torch.nn.Module"),Ng=a(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Wg=l(),Xe=s("div"),b(tr.$$.fragment),Rg=l(),$o=s("p"),Hg=a("The "),xi=s("a"),Qg=a("DistilBertForQuestionAnswering"),Ug=a(" forward method, overrides the "),od=s("code"),Vg=a("__call__"),Jg=a(" special method."),Kg=l(),b(hs.$$.fragment),Gg=l(),sd=s("p"),Xg=a("Example:"),Yg=l(),b(or.$$.fragment),Cp=l(),Do=s("h2"),us=s("a"),nd=s("span"),b(sr.$$.fragment),Zg=l(),rd=s("span"),e_=a("TFDistilBertModel"),jp=l(),Pe=s("div"),b(nr.$$.fragment),t_=l(),ad=s("p"),o_=a("The bare DistilBERT encoder/transformer outputting raw hidden-states without any specific head on top."),s_=l(),rr=s("p"),n_=a("This model inherits from "),zi=s("a"),r_=a("TFPreTrainedModel"),a_=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),i_=l(),ar=s("p"),l_=a("This model is also a "),ir=s("a"),d_=a("tf.keras.Model"),c_=a(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),p_=l(),b(fs.$$.fragment),h_=l(),Ye=s("div"),b(lr.$$.fragment),u_=l(),yo=s("p"),f_=a("The "),Ci=s("a"),m_=a("TFDistilBertModel"),g_=a(" forward method, overrides the "),id=s("code"),__=a("__call__"),v_=a(" special method."),T_=l(),b(ms.$$.fragment),b_=l(),ld=s("p"),k_=a("Example:"),w_=l(),b(dr.$$.fragment),Pp=l(),Fo=s("h2"),gs=s("a"),dd=s("span"),b(cr.$$.fragment),$_=l(),cd=s("span"),D_=a("TFDistilBertForMaskedLM"),qp=l(),qe=s("div"),b(pr.$$.fragment),y_=l(),hr=s("p"),F_=a("DistilBert Model with a "),pd=s("code"),B_=a("masked language modeling"),M_=a(" head on top."),E_=l(),ur=s("p"),x_=a("This model inherits from "),ji=s("a"),z_=a("TFPreTrainedModel"),C_=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),j_=l(),fr=s("p"),P_=a("This model is also a "),mr=s("a"),q_=a("tf.keras.Model"),A_=a(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),O_=l(),b(_s.$$.fragment),I_=l(),Ze=s("div"),b(gr.$$.fragment),L_=l(),Bo=s("p"),S_=a("The "),Pi=s("a"),N_=a("TFDistilBertForMaskedLM"),W_=a(" forward method, overrides the "),hd=s("code"),R_=a("__call__"),H_=a(" special method."),Q_=l(),b(vs.$$.fragment),U_=l(),ud=s("p"),V_=a("Example:"),J_=l(),b(_r.$$.fragment),Ap=l(),Mo=s("h2"),Ts=s("a"),fd=s("span"),b(vr.$$.fragment),K_=l(),md=s("span"),G_=a("TFDistilBertForSequenceClassification"),Op=l(),Ae=s("div"),b(Tr.$$.fragment),X_=l(),gd=s("p"),Y_=a(`DistilBert Model transformer with a sequence classification/regression head on top (a linear layer on top of the
pooled output) e.g. for GLUE tasks.`),Z_=l(),br=s("p"),ev=a("This model inherits from "),qi=s("a"),tv=a("TFPreTrainedModel"),ov=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),sv=l(),kr=s("p"),nv=a("This model is also a "),wr=s("a"),rv=a("tf.keras.Model"),av=a(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),iv=l(),b(bs.$$.fragment),lv=l(),et=s("div"),b($r.$$.fragment),dv=l(),Eo=s("p"),cv=a("The "),Ai=s("a"),pv=a("TFDistilBertForSequenceClassification"),hv=a(" forward method, overrides the "),_d=s("code"),uv=a("__call__"),fv=a(" special method."),mv=l(),b(ks.$$.fragment),gv=l(),vd=s("p"),_v=a("Example:"),vv=l(),b(Dr.$$.fragment),Ip=l(),xo=s("h2"),ws=s("a"),Td=s("span"),b(yr.$$.fragment),Tv=l(),bd=s("span"),bv=a("TFDistilBertForMultipleChoice"),Lp=l(),Oe=s("div"),b(Fr.$$.fragment),kv=l(),kd=s("p"),wv=a(`DistilBert Model with a multiple choice classification head on top (a linear layer on top of the pooled output and
a softmax) e.g. for RocStories/SWAG tasks.`),$v=l(),Br=s("p"),Dv=a("This model inherits from "),Oi=s("a"),yv=a("TFPreTrainedModel"),Fv=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Bv=l(),Mr=s("p"),Mv=a("This model is also a "),Er=s("a"),Ev=a("tf.keras.Model"),xv=a(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),zv=l(),b($s.$$.fragment),Cv=l(),tt=s("div"),b(xr.$$.fragment),jv=l(),zo=s("p"),Pv=a("The "),Ii=s("a"),qv=a("TFDistilBertForMultipleChoice"),Av=a(" forward method, overrides the "),wd=s("code"),Ov=a("__call__"),Iv=a(" special method."),Lv=l(),b(Ds.$$.fragment),Sv=l(),$d=s("p"),Nv=a("Example:"),Wv=l(),b(zr.$$.fragment),Sp=l(),Co=s("h2"),ys=s("a"),Dd=s("span"),b(Cr.$$.fragment),Rv=l(),yd=s("span"),Hv=a("TFDistilBertForTokenClassification"),Np=l(),Ie=s("div"),b(jr.$$.fragment),Qv=l(),Fd=s("p"),Uv=a(`DistilBert Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g.
for Named-Entity-Recognition (NER) tasks.`),Vv=l(),Pr=s("p"),Jv=a("This model inherits from "),Li=s("a"),Kv=a("TFPreTrainedModel"),Gv=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Xv=l(),qr=s("p"),Yv=a("This model is also a "),Ar=s("a"),Zv=a("tf.keras.Model"),eT=a(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),tT=l(),b(Fs.$$.fragment),oT=l(),ot=s("div"),b(Or.$$.fragment),sT=l(),jo=s("p"),nT=a("The "),Si=s("a"),rT=a("TFDistilBertForTokenClassification"),aT=a(" forward method, overrides the "),Bd=s("code"),iT=a("__call__"),lT=a(" special method."),dT=l(),b(Bs.$$.fragment),cT=l(),Md=s("p"),pT=a("Example:"),hT=l(),b(Ir.$$.fragment),Wp=l(),Po=s("h2"),Ms=s("a"),Ed=s("span"),b(Lr.$$.fragment),uT=l(),xd=s("span"),fT=a("TFDistilBertForQuestionAnswering"),Rp=l(),Le=s("div"),b(Sr.$$.fragment),mT=l(),qo=s("p"),gT=a(`DistilBert Model with a span classification head on top for extractive question-answering tasks like SQuAD (a
linear layer on top of the hidden-states output to compute `),zd=s("code"),_T=a("span start logits"),vT=a(" and "),Cd=s("code"),TT=a("span end logits"),bT=a(")."),kT=l(),Nr=s("p"),wT=a("This model inherits from "),Ni=s("a"),$T=a("TFPreTrainedModel"),DT=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),yT=l(),Wr=s("p"),FT=a("This model is also a "),Rr=s("a"),BT=a("tf.keras.Model"),MT=a(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),ET=l(),b(Es.$$.fragment),xT=l(),st=s("div"),b(Hr.$$.fragment),zT=l(),Ao=s("p"),CT=a("The "),Wi=s("a"),jT=a("TFDistilBertForQuestionAnswering"),PT=a(" forward method, overrides the "),jd=s("code"),qT=a("__call__"),AT=a(" special method."),OT=l(),b(xs.$$.fragment),IT=l(),Pd=s("p"),LT=a("Example:"),ST=l(),b(Qr.$$.fragment),Hp=l(),Oo=s("h2"),zs=s("a"),qd=s("span"),b(Ur.$$.fragment),NT=l(),Ad=s("span"),WT=a("FlaxDistilBertModel"),Qp=l(),Be=s("div"),b(Vr.$$.fragment),RT=l(),Od=s("p"),HT=a("The bare DistilBert Model transformer outputting raw hidden-states without any specific head on top."),QT=l(),Jr=s("p"),UT=a("This model inherits from "),Ri=s("a"),VT=a("FlaxPreTrainedModel"),JT=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading, saving and converting weights from PyTorch models)`),KT=l(),Kr=s("p"),GT=a("This model is also a Flax Linen "),Gr=s("a"),XT=a("flax.linen.Module"),YT=a(`
subclass. Use it as a regular Flax linen Module and refer to the Flax documentation for all matter related to
general usage and behavior.`),ZT=l(),Id=s("p"),eb=a("Finally, this model supports inherent JAX features such as:"),tb=l(),Bt=s("ul"),Ld=s("li"),Xr=s("a"),ob=a("Just-In-Time (JIT) compilation"),sb=l(),Sd=s("li"),Yr=s("a"),nb=a("Automatic Differentiation"),rb=l(),Nd=s("li"),Zr=s("a"),ab=a("Vectorization"),ib=l(),Wd=s("li"),ea=s("a"),lb=a("Parallelization"),db=l(),nt=s("div"),b(ta.$$.fragment),cb=l(),Io=s("p"),pb=a("The "),Rd=s("code"),hb=a("FlaxDistilBertPreTrainedModel"),ub=a("forward method, overrides the "),Hd=s("code"),fb=a("__call__"),mb=a(" special method."),gb=l(),b(Cs.$$.fragment),_b=l(),Qd=s("p"),vb=a("Example:"),Tb=l(),b(oa.$$.fragment),Up=l(),Lo=s("h2"),js=s("a"),Ud=s("span"),b(sa.$$.fragment),bb=l(),Vd=s("span"),kb=a("FlaxDistilBertForMaskedLM"),Vp=l(),Me=s("div"),b(na.$$.fragment),wb=l(),ra=s("p"),$b=a("DistilBert Model with a "),Jd=s("code"),Db=a("language modeling"),yb=a(" head on top."),Fb=l(),aa=s("p"),Bb=a("This model inherits from "),Hi=s("a"),Mb=a("FlaxPreTrainedModel"),Eb=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading, saving and converting weights from PyTorch models)`),xb=l(),ia=s("p"),zb=a("This model is also a Flax Linen "),la=s("a"),Cb=a("flax.linen.Module"),jb=a(`
subclass. Use it as a regular Flax linen Module and refer to the Flax documentation for all matter related to
general usage and behavior.`),Pb=l(),Kd=s("p"),qb=a("Finally, this model supports inherent JAX features such as:"),Ab=l(),Mt=s("ul"),Gd=s("li"),da=s("a"),Ob=a("Just-In-Time (JIT) compilation"),Ib=l(),Xd=s("li"),ca=s("a"),Lb=a("Automatic Differentiation"),Sb=l(),Yd=s("li"),pa=s("a"),Nb=a("Vectorization"),Wb=l(),Zd=s("li"),ha=s("a"),Rb=a("Parallelization"),Hb=l(),rt=s("div"),b(ua.$$.fragment),Qb=l(),So=s("p"),Ub=a("The "),ec=s("code"),Vb=a("FlaxDistilBertPreTrainedModel"),Jb=a("forward method, overrides the "),tc=s("code"),Kb=a("__call__"),Gb=a(" special method."),Xb=l(),b(Ps.$$.fragment),Yb=l(),oc=s("p"),Zb=a("Example:"),e1=l(),b(fa.$$.fragment),Jp=l(),No=s("h2"),qs=s("a"),sc=s("span"),b(ma.$$.fragment),t1=l(),nc=s("span"),o1=a("FlaxDistilBertForSequenceClassification"),Kp=l(),Ee=s("div"),b(ga.$$.fragment),s1=l(),rc=s("p"),n1=a(`DistilBert Model transformer with a sequence classification/regression head on top (a linear layer on top of the
pooled output) e.g. for GLUE tasks.`),r1=l(),_a=s("p"),a1=a("This model inherits from "),Qi=s("a"),i1=a("FlaxPreTrainedModel"),l1=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading, saving and converting weights from PyTorch models)`),d1=l(),va=s("p"),c1=a("This model is also a Flax Linen "),Ta=s("a"),p1=a("flax.linen.Module"),h1=a(`
subclass. Use it as a regular Flax linen Module and refer to the Flax documentation for all matter related to
general usage and behavior.`),u1=l(),ac=s("p"),f1=a("Finally, this model supports inherent JAX features such as:"),m1=l(),Et=s("ul"),ic=s("li"),ba=s("a"),g1=a("Just-In-Time (JIT) compilation"),_1=l(),lc=s("li"),ka=s("a"),v1=a("Automatic Differentiation"),T1=l(),dc=s("li"),wa=s("a"),b1=a("Vectorization"),k1=l(),cc=s("li"),$a=s("a"),w1=a("Parallelization"),$1=l(),at=s("div"),b(Da.$$.fragment),D1=l(),Wo=s("p"),y1=a("The "),pc=s("code"),F1=a("FlaxDistilBertPreTrainedModel"),B1=a("forward method, overrides the "),hc=s("code"),M1=a("__call__"),E1=a(" special method."),x1=l(),b(As.$$.fragment),z1=l(),uc=s("p"),C1=a("Example:"),j1=l(),b(ya.$$.fragment),Gp=l(),Ro=s("h2"),Os=s("a"),fc=s("span"),b(Fa.$$.fragment),P1=l(),mc=s("span"),q1=a("FlaxDistilBertForMultipleChoice"),Xp=l(),xe=s("div"),b(Ba.$$.fragment),A1=l(),gc=s("p"),O1=a(`DistilBert Model with a multiple choice classification head on top (a linear layer on top of the pooled output and
a softmax) e.g. for RocStories/SWAG tasks.`),I1=l(),Ma=s("p"),L1=a("This model inherits from "),Ui=s("a"),S1=a("FlaxPreTrainedModel"),N1=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading, saving and converting weights from PyTorch models)`),W1=l(),Ea=s("p"),R1=a("This model is also a Flax Linen "),xa=s("a"),H1=a("flax.linen.Module"),Q1=a(`
subclass. Use it as a regular Flax linen Module and refer to the Flax documentation for all matter related to
general usage and behavior.`),U1=l(),_c=s("p"),V1=a("Finally, this model supports inherent JAX features such as:"),J1=l(),xt=s("ul"),vc=s("li"),za=s("a"),K1=a("Just-In-Time (JIT) compilation"),G1=l(),Tc=s("li"),Ca=s("a"),X1=a("Automatic Differentiation"),Y1=l(),bc=s("li"),ja=s("a"),Z1=a("Vectorization"),ek=l(),kc=s("li"),Pa=s("a"),tk=a("Parallelization"),ok=l(),it=s("div"),b(qa.$$.fragment),sk=l(),Ho=s("p"),nk=a("The "),wc=s("code"),rk=a("FlaxDistilBertPreTrainedModel"),ak=a("forward method, overrides the "),$c=s("code"),ik=a("__call__"),lk=a(" special method."),dk=l(),b(Is.$$.fragment),ck=l(),Dc=s("p"),pk=a("Example:"),hk=l(),b(Aa.$$.fragment),Yp=l(),Qo=s("h2"),Ls=s("a"),yc=s("span"),b(Oa.$$.fragment),uk=l(),Fc=s("span"),fk=a("FlaxDistilBertForTokenClassification"),Zp=l(),ze=s("div"),b(Ia.$$.fragment),mk=l(),Bc=s("p"),gk=a(`DistilBert Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g.
for Named-Entity-Recognition (NER) tasks.`),_k=l(),La=s("p"),vk=a("This model inherits from "),Vi=s("a"),Tk=a("FlaxPreTrainedModel"),bk=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading, saving and converting weights from PyTorch models)`),kk=l(),Sa=s("p"),wk=a("This model is also a Flax Linen "),Na=s("a"),$k=a("flax.linen.Module"),Dk=a(`
subclass. Use it as a regular Flax linen Module and refer to the Flax documentation for all matter related to
general usage and behavior.`),yk=l(),Mc=s("p"),Fk=a("Finally, this model supports inherent JAX features such as:"),Bk=l(),zt=s("ul"),Ec=s("li"),Wa=s("a"),Mk=a("Just-In-Time (JIT) compilation"),Ek=l(),xc=s("li"),Ra=s("a"),xk=a("Automatic Differentiation"),zk=l(),zc=s("li"),Ha=s("a"),Ck=a("Vectorization"),jk=l(),Cc=s("li"),Qa=s("a"),Pk=a("Parallelization"),qk=l(),lt=s("div"),b(Ua.$$.fragment),Ak=l(),Uo=s("p"),Ok=a("The "),jc=s("code"),Ik=a("FlaxDistilBertPreTrainedModel"),Lk=a("forward method, overrides the "),Pc=s("code"),Sk=a("__call__"),Nk=a(" special method."),Wk=l(),b(Ss.$$.fragment),Rk=l(),qc=s("p"),Hk=a("Example:"),Qk=l(),b(Va.$$.fragment),eh=l(),Vo=s("h2"),Ns=s("a"),Ac=s("span"),b(Ja.$$.fragment),Uk=l(),Oc=s("span"),Vk=a("FlaxDistilBertForQuestionAnswering"),th=l(),Ce=s("div"),b(Ka.$$.fragment),Jk=l(),Jo=s("p"),Kk=a(`DistilBert Model with a span classification head on top for extractive question-answering tasks like SQuAD (a
linear layers on top of the hidden-states output to compute `),Ic=s("code"),Gk=a("span start logits"),Xk=a(" and "),Lc=s("code"),Yk=a("span end logits"),Zk=a(")."),e0=l(),Ga=s("p"),t0=a("This model inherits from "),Ji=s("a"),o0=a("FlaxPreTrainedModel"),s0=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading, saving and converting weights from PyTorch models)`),n0=l(),Xa=s("p"),r0=a("This model is also a Flax Linen "),Ya=s("a"),a0=a("flax.linen.Module"),i0=a(`
subclass. Use it as a regular Flax linen Module and refer to the Flax documentation for all matter related to
general usage and behavior.`),l0=l(),Sc=s("p"),d0=a("Finally, this model supports inherent JAX features such as:"),c0=l(),Ct=s("ul"),Nc=s("li"),Za=s("a"),p0=a("Just-In-Time (JIT) compilation"),h0=l(),Wc=s("li"),ei=s("a"),u0=a("Automatic Differentiation"),f0=l(),Rc=s("li"),ti=s("a"),m0=a("Vectorization"),g0=l(),Hc=s("li"),oi=s("a"),_0=a("Parallelization"),v0=l(),dt=s("div"),b(si.$$.fragment),T0=l(),Ko=s("p"),b0=a("The "),Qc=s("code"),k0=a("FlaxDistilBertPreTrainedModel"),w0=a("forward method, overrides the "),Uc=s("code"),$0=a("__call__"),D0=a(" special method."),y0=l(),b(Ws.$$.fragment),F0=l(),Vc=s("p"),B0=a("Example:"),M0=l(),b(ni.$$.fragment),this.h()},l(o){const m=lF('[data-svelte="svelte-1phssyn"]',document.head);p=n(m,"META",{name:!0,content:!0}),m.forEach(t),F=d(o),g=n(o,"H1",{class:!0});var ri=r(g);v=n(ri,"A",{id:!0,class:!0,href:!0});var Jc=r(v);T=n(Jc,"SPAN",{});var Kc=r(T);k(_.$$.fragment,Kc),Kc.forEach(t),Jc.forEach(t),f=d(ri),B=n(ri,"SPAN",{});var Gc=r(B);de=i(Gc,"DistilBERT"),Gc.forEach(t),ri.forEach(t),V=d(o),E=n(o,"H2",{class:!0});var ai=r(E);G=n(ai,"A",{id:!0,class:!0,href:!0});var Xc=r(G);S=n(Xc,"SPAN",{});var Yc=r(S);k(X.$$.fragment,Yc),Yc.forEach(t),Xc.forEach(t),ce=d(ai),N=n(ai,"SPAN",{});var Zc=r(N);pe=i(Zc,"Overview"),Zc.forEach(t),ai.forEach(t),re=d(o),I=n(o,"P",{});var jt=r(I);q=i(jt,"The DistilBERT model was proposed in the blog post "),Y=n(jt,"A",{href:!0,rel:!0});var ep=r(Y);J=i(ep,`Smaller, faster, cheaper, lighter: Introducing DistilBERT, a
distilled version of BERT`),ep.forEach(t),x=i(jt,", and the paper "),z=n(jt,"A",{href:!0,rel:!0});var tp=r(z);he=i(tp,`DistilBERT, a
distilled version of BERT: smaller, faster, cheaper and lighter`),tp.forEach(t),W=i(jt,`. DistilBERT is a
small, fast, cheap and light Transformer model trained by distilling BERT base. It has 40% less parameters than
`),oe=n(jt,"EM",{});var op=r(oe);ue=i(op,"bert-base-uncased"),op.forEach(t),R=i(jt,`, runs 60% faster while preserving over 95% of BERT\u2019s performances as measured on the GLUE language
understanding benchmark.`),jt.forEach(t),ae=d(o),ee=n(o,"P",{});var sp=r(ee);A=i(sp,"The abstract from the paper is the following:"),sp.forEach(t),ie=d(o),L=n(o,"P",{});var np=r(L);se=n(np,"EM",{});var rp=r(se);fe=i(rp,`As Transfer Learning from large-scale pre-trained models becomes more prevalent in Natural Language Processing (NLP),
operating these large models in on-the-edge and/or under constrained computational training or inference budgets
remains challenging. In this work, we propose a method to pre-train a smaller general-purpose language representation
model, called DistilBERT, which can then be fine-tuned with good performances on a wide range of tasks like its larger
counterparts. While most prior work investigated the use of distillation for building task-specific models, we leverage
knowledge distillation during the pretraining phase and show that it is possible to reduce the size of a BERT model by
40%, while retaining 97% of its language understanding capabilities and being 60% faster. To leverage the inductive
biases learned by larger models during pretraining, we introduce a triple loss combining language modeling,
distillation and cosine-distance losses. Our smaller, faster and lighter model is cheaper to pre-train and we
demonstrate its capabilities for on-device computations in a proof-of-concept experiment and a comparative on-device
study.`),rp.forEach(t),np.forEach(t),P=d(o),te=n(o,"P",{});var ap=r(te);H=i(ap,"Tips:"),ap.forEach(t),le=d(o),h=n(o,"UL",{});var ii=r(h);M=n(ii,"LI",{});var Pt=r(M);K=i(Pt,"DistilBERT doesn\u2019t have "),ge=n(Pt,"CODE",{});var ip=r(ge);Te=i(ip,"token_type_ids"),ip.forEach(t),O=i(Pt,`, you don\u2019t need to indicate which token belongs to which segment. Just
separate your segments with the separation token `),_e=n(Pt,"CODE",{});var lp=r(_e);be=i(lp,"tokenizer.sep_token"),lp.forEach(t),ke=i(Pt," (or "),j=n(Pt,"CODE",{});var dp=r(j);Q=i(dp,"[SEP]"),dp.forEach(t),we=i(Pt,")."),Pt.forEach(t),$e=d(ii),Z=n(ii,"LI",{});var li=r(Z);De=i(li,"DistilBERT doesn\u2019t have options to select the input positions ("),ne=n(li,"CODE",{});var cp=r(ne);ye=i(cp,"position_ids"),cp.forEach(t),hu=i(li,` input). This could be added if
necessary though, just let us know if you need this option.`),li.forEach(t),ii.forEach(t),up=d(o),Tt=n(o,"P",{});var qt=r(Tt);uu=i(qt,"This model was contributed by "),Ys=n(qt,"A",{href:!0,rel:!0});var E0=r(Ys);fu=i(E0,"victorsanh"),E0.forEach(t),mu=i(qt,`. This model jax version was
contributed by `),Zs=n(qt,"A",{href:!0,rel:!0});var x0=r(Zs);gu=i(x0,"kamalkraj"),x0.forEach(t),_u=i(qt,". The original code can be found "),en=n(qt,"A",{href:!0,rel:!0});var z0=r(en);vu=i(z0,"here"),z0.forEach(t),Tu=i(qt,"."),qt.forEach(t),fp=d(o),ao=n(o,"H2",{class:!0});var sh=r(ao);Go=n(sh,"A",{id:!0,class:!0,href:!0});var C0=r(Go);_l=n(C0,"SPAN",{});var j0=r(_l);k(tn.$$.fragment,j0),j0.forEach(t),C0.forEach(t),bu=d(sh),vl=n(sh,"SPAN",{});var P0=r(vl);ku=i(P0,"DistilBertConfig"),P0.forEach(t),sh.forEach(t),mp=d(o),Se=n(o,"DIV",{class:!0});var At=r(Se);k(on.$$.fragment,At),wu=d(At),Ft=n(At,"P",{});var Rs=r(Ft);$u=i(Rs,"This is the configuration class to store the configuration of a "),di=n(Rs,"A",{href:!0});var q0=r(di);Du=i(q0,"DistilBertModel"),q0.forEach(t),yu=i(Rs," or a "),ci=n(Rs,"A",{href:!0});var A0=r(ci);Fu=i(A0,"TFDistilBertModel"),A0.forEach(t),Bu=i(Rs,`. It
is used to instantiate a DistilBERT model according to the specified arguments, defining the model architecture.
Instantiating a configuration with the defaults will yield a similar configuration to that of the DistilBERT
`),sn=n(Rs,"A",{href:!0,rel:!0});var O0=r(sn);Mu=i(O0,"distilbert-base-uncased"),O0.forEach(t),Eu=i(Rs," architecture."),Rs.forEach(t),xu=d(At),io=n(At,"P",{});var Ki=r(io);zu=i(Ki,"Configuration objects inherit from "),pi=n(Ki,"A",{href:!0});var I0=r(pi);Cu=i(I0,"PretrainedConfig"),I0.forEach(t),ju=i(Ki,` and can be used to control the model outputs. Read the
documentation from `),hi=n(Ki,"A",{href:!0});var L0=r(hi);Pu=i(L0,"PretrainedConfig"),L0.forEach(t),qu=i(Ki," for more information."),Ki.forEach(t),Au=d(At),Tl=n(At,"P",{});var S0=r(Tl);Ou=i(S0,"Examples:"),S0.forEach(t),Iu=d(At),k(nn.$$.fragment,At),At.forEach(t),gp=d(o),lo=n(o,"H2",{class:!0});var nh=r(lo);Xo=n(nh,"A",{id:!0,class:!0,href:!0});var N0=r(Xo);bl=n(N0,"SPAN",{});var W0=r(bl);k(rn.$$.fragment,W0),W0.forEach(t),N0.forEach(t),Lu=d(nh),kl=n(nh,"SPAN",{});var R0=r(kl);Su=i(R0,"DistilBertTokenizer"),R0.forEach(t),nh.forEach(t),_p=d(o),_t=n(o,"DIV",{class:!0});var Hs=r(_t);k(an.$$.fragment,Hs),Nu=d(Hs),wl=n(Hs,"P",{});var H0=r(wl);Wu=i(H0,"Construct a DistilBERT tokenizer."),H0.forEach(t),Ru=d(Hs),Yo=n(Hs,"P",{});var pp=r(Yo);ui=n(pp,"A",{href:!0});var Q0=r(ui);Hu=i(Q0,"DistilBertTokenizer"),Q0.forEach(t),Qu=i(pp," is identical to "),fi=n(pp,"A",{href:!0});var U0=r(fi);Uu=i(U0,"BertTokenizer"),U0.forEach(t),Vu=i(pp,` and runs end-to-end tokenization: punctuation splitting
and wordpiece.`),pp.forEach(t),Ju=d(Hs),ln=n(Hs,"P",{});var rh=r(ln);Ku=i(rh,"Refer to superclass "),mi=n(rh,"A",{href:!0});var V0=r(mi);Gu=i(V0,"BertTokenizer"),V0.forEach(t),Xu=i(rh," for usage examples and documentation concerning parameters."),rh.forEach(t),Hs.forEach(t),vp=d(o),co=n(o,"H2",{class:!0});var ah=r(co);Zo=n(ah,"A",{id:!0,class:!0,href:!0});var J0=r(Zo);$l=n(J0,"SPAN",{});var K0=r($l);k(dn.$$.fragment,K0),K0.forEach(t),J0.forEach(t),Yu=d(ah),Dl=n(ah,"SPAN",{});var G0=r(Dl);Zu=i(G0,"DistilBertTokenizerFast"),G0.forEach(t),ah.forEach(t),Tp=d(o),vt=n(o,"DIV",{class:!0});var Qs=r(vt);k(cn.$$.fragment,Qs),ef=d(Qs),pn=n(Qs,"P",{});var ih=r(pn);tf=i(ih,"Construct a \u201Cfast\u201D DistilBERT tokenizer (backed by HuggingFace\u2019s "),yl=n(ih,"EM",{});var X0=r(yl);of=i(X0,"tokenizers"),X0.forEach(t),sf=i(ih," library)."),ih.forEach(t),nf=d(Qs),es=n(Qs,"P",{});var hp=r(es);gi=n(hp,"A",{href:!0});var Y0=r(gi);rf=i(Y0,"DistilBertTokenizerFast"),Y0.forEach(t),af=i(hp," is identical to "),_i=n(hp,"A",{href:!0});var Z0=r(_i);lf=i(Z0,"BertTokenizerFast"),Z0.forEach(t),df=i(hp,` and runs end-to-end tokenization: punctuation
splitting and wordpiece.`),hp.forEach(t),cf=d(Qs),hn=n(Qs,"P",{});var lh=r(hn);pf=i(lh,"Refer to superclass "),vi=n(lh,"A",{href:!0});var ew=r(vi);hf=i(ew,"BertTokenizerFast"),ew.forEach(t),uf=i(lh," for usage examples and documentation concerning parameters."),lh.forEach(t),Qs.forEach(t),bp=d(o),po=n(o,"H2",{class:!0});var dh=r(po);ts=n(dh,"A",{id:!0,class:!0,href:!0});var tw=r(ts);Fl=n(tw,"SPAN",{});var ow=r(Fl);k(un.$$.fragment,ow),ow.forEach(t),tw.forEach(t),ff=d(dh),Bl=n(dh,"SPAN",{});var sw=r(Bl);mf=i(sw,"DistilBertModel"),sw.forEach(t),dh.forEach(t),kp=d(o),Ne=n(o,"DIV",{class:!0});var Ot=r(Ne);k(fn.$$.fragment,Ot),gf=d(Ot),Ml=n(Ot,"P",{});var nw=r(Ml);_f=i(nw,"The bare DistilBERT encoder/transformer outputting raw hidden-states without any specific head on top."),nw.forEach(t),vf=d(Ot),mn=n(Ot,"P",{});var ch=r(mn);Tf=i(ch,"This model inherits from "),Ti=n(ch,"A",{href:!0});var rw=r(Ti);bf=i(rw,"PreTrainedModel"),rw.forEach(t),kf=i(ch,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),ch.forEach(t),wf=d(Ot),gn=n(Ot,"P",{});var ph=r(gn);$f=i(ph,"This model is also a PyTorch "),_n=n(ph,"A",{href:!0,rel:!0});var aw=r(_n);Df=i(aw,"torch.nn.Module"),aw.forEach(t),yf=i(ph,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),ph.forEach(t),Ff=d(Ot),Ve=n(Ot,"DIV",{class:!0});var It=r(Ve);k(vn.$$.fragment,It),Bf=d(It),ho=n(It,"P",{});var Gi=r(ho);Mf=i(Gi,"The "),bi=n(Gi,"A",{href:!0});var iw=r(bi);Ef=i(iw,"DistilBertModel"),iw.forEach(t),xf=i(Gi," forward method, overrides the "),El=n(Gi,"CODE",{});var lw=r(El);zf=i(lw,"__call__"),lw.forEach(t),Cf=i(Gi," special method."),Gi.forEach(t),jf=d(It),k(os.$$.fragment,It),Pf=d(It),xl=n(It,"P",{});var dw=r(xl);qf=i(dw,"Example:"),dw.forEach(t),Af=d(It),k(Tn.$$.fragment,It),It.forEach(t),Ot.forEach(t),wp=d(o),uo=n(o,"H2",{class:!0});var hh=r(uo);ss=n(hh,"A",{id:!0,class:!0,href:!0});var cw=r(ss);zl=n(cw,"SPAN",{});var pw=r(zl);k(bn.$$.fragment,pw),pw.forEach(t),cw.forEach(t),Of=d(hh),Cl=n(hh,"SPAN",{});var hw=r(Cl);If=i(hw,"DistilBertForMaskedLM"),hw.forEach(t),hh.forEach(t),$p=d(o),We=n(o,"DIV",{class:!0});var Lt=r(We);k(kn.$$.fragment,Lt),Lf=d(Lt),wn=n(Lt,"P",{});var uh=r(wn);Sf=i(uh,"DistilBert Model with a "),jl=n(uh,"CODE",{});var uw=r(jl);Nf=i(uw,"masked language modeling"),uw.forEach(t),Wf=i(uh," head on top."),uh.forEach(t),Rf=d(Lt),$n=n(Lt,"P",{});var fh=r($n);Hf=i(fh,"This model inherits from "),ki=n(fh,"A",{href:!0});var fw=r(ki);Qf=i(fw,"PreTrainedModel"),fw.forEach(t),Uf=i(fh,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),fh.forEach(t),Vf=d(Lt),Dn=n(Lt,"P",{});var mh=r(Dn);Jf=i(mh,"This model is also a PyTorch "),yn=n(mh,"A",{href:!0,rel:!0});var mw=r(yn);Kf=i(mw,"torch.nn.Module"),mw.forEach(t),Gf=i(mh,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),mh.forEach(t),Xf=d(Lt),Je=n(Lt,"DIV",{class:!0});var St=r(Je);k(Fn.$$.fragment,St),Yf=d(St),fo=n(St,"P",{});var Xi=r(fo);Zf=i(Xi,"The "),wi=n(Xi,"A",{href:!0});var gw=r(wi);em=i(gw,"DistilBertForMaskedLM"),gw.forEach(t),tm=i(Xi," forward method, overrides the "),Pl=n(Xi,"CODE",{});var _w=r(Pl);om=i(_w,"__call__"),_w.forEach(t),sm=i(Xi," special method."),Xi.forEach(t),nm=d(St),k(ns.$$.fragment,St),rm=d(St),ql=n(St,"P",{});var vw=r(ql);am=i(vw,"Example:"),vw.forEach(t),im=d(St),k(Bn.$$.fragment,St),St.forEach(t),Lt.forEach(t),Dp=d(o),mo=n(o,"H2",{class:!0});var gh=r(mo);rs=n(gh,"A",{id:!0,class:!0,href:!0});var Tw=r(rs);Al=n(Tw,"SPAN",{});var bw=r(Al);k(Mn.$$.fragment,bw),bw.forEach(t),Tw.forEach(t),lm=d(gh),Ol=n(gh,"SPAN",{});var kw=r(Ol);dm=i(kw,"DistilBertForSequenceClassification"),kw.forEach(t),gh.forEach(t),yp=d(o),Re=n(o,"DIV",{class:!0});var Nt=r(Re);k(En.$$.fragment,Nt),cm=d(Nt),Il=n(Nt,"P",{});var ww=r(Il);pm=i(ww,`DistilBert Model transformer with a sequence classification/regression head on top (a linear layer on top of the
pooled output) e.g. for GLUE tasks.`),ww.forEach(t),hm=d(Nt),xn=n(Nt,"P",{});var _h=r(xn);um=i(_h,"This model inherits from "),$i=n(_h,"A",{href:!0});var $w=r($i);fm=i($w,"PreTrainedModel"),$w.forEach(t),mm=i(_h,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),_h.forEach(t),gm=d(Nt),zn=n(Nt,"P",{});var vh=r(zn);_m=i(vh,"This model is also a PyTorch "),Cn=n(vh,"A",{href:!0,rel:!0});var Dw=r(Cn);vm=i(Dw,"torch.nn.Module"),Dw.forEach(t),Tm=i(vh,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),vh.forEach(t),bm=d(Nt),je=n(Nt,"DIV",{class:!0});var ct=r(je);k(jn.$$.fragment,ct),km=d(ct),go=n(ct,"P",{});var Yi=r(go);wm=i(Yi,"The "),Di=n(Yi,"A",{href:!0});var yw=r(Di);$m=i(yw,"DistilBertForSequenceClassification"),yw.forEach(t),Dm=i(Yi," forward method, overrides the "),Ll=n(Yi,"CODE",{});var Fw=r(Ll);ym=i(Fw,"__call__"),Fw.forEach(t),Fm=i(Yi," special method."),Yi.forEach(t),Bm=d(ct),k(as.$$.fragment,ct),Mm=d(ct),Sl=n(ct,"P",{});var Bw=r(Sl);Em=i(Bw,"Example of single-label classification:"),Bw.forEach(t),xm=d(ct),k(Pn.$$.fragment,ct),zm=d(ct),Nl=n(ct,"P",{});var Mw=r(Nl);Cm=i(Mw,"Example of multi-label classification:"),Mw.forEach(t),jm=d(ct),k(qn.$$.fragment,ct),ct.forEach(t),Nt.forEach(t),Fp=d(o),_o=n(o,"H2",{class:!0});var Th=r(_o);is=n(Th,"A",{id:!0,class:!0,href:!0});var Ew=r(is);Wl=n(Ew,"SPAN",{});var xw=r(Wl);k(An.$$.fragment,xw),xw.forEach(t),Ew.forEach(t),Pm=d(Th),Rl=n(Th,"SPAN",{});var zw=r(Rl);qm=i(zw,"DistilBertForMultipleChoice"),zw.forEach(t),Th.forEach(t),Bp=d(o),He=n(o,"DIV",{class:!0});var Wt=r(He);k(On.$$.fragment,Wt),Am=d(Wt),Hl=n(Wt,"P",{});var Cw=r(Hl);Om=i(Cw,`DistilBert Model with a multiple choice classification head on top (a linear layer on top of the pooled output and
a softmax) e.g. for RocStories/SWAG tasks.`),Cw.forEach(t),Im=d(Wt),In=n(Wt,"P",{});var bh=r(In);Lm=i(bh,"This model inherits from "),yi=n(bh,"A",{href:!0});var jw=r(yi);Sm=i(jw,"PreTrainedModel"),jw.forEach(t),Nm=i(bh,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),bh.forEach(t),Wm=d(Wt),Ln=n(Wt,"P",{});var kh=r(Ln);Rm=i(kh,"This model is also a PyTorch "),Sn=n(kh,"A",{href:!0,rel:!0});var Pw=r(Sn);Hm=i(Pw,"torch.nn.Module"),Pw.forEach(t),Qm=i(kh,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),kh.forEach(t),Um=d(Wt),Ke=n(Wt,"DIV",{class:!0});var Rt=r(Ke);k(Nn.$$.fragment,Rt),Vm=d(Rt),vo=n(Rt,"P",{});var Zi=r(vo);Jm=i(Zi,"The "),Fi=n(Zi,"A",{href:!0});var qw=r(Fi);Km=i(qw,"DistilBertForMultipleChoice"),qw.forEach(t),Gm=i(Zi," forward method, overrides the "),Ql=n(Zi,"CODE",{});var Aw=r(Ql);Xm=i(Aw,"__call__"),Aw.forEach(t),Ym=i(Zi," special method."),Zi.forEach(t),Zm=d(Rt),k(ls.$$.fragment,Rt),eg=d(Rt),Ul=n(Rt,"P",{});var Ow=r(Ul);tg=i(Ow,"Examples:"),Ow.forEach(t),og=d(Rt),k(Wn.$$.fragment,Rt),Rt.forEach(t),Wt.forEach(t),Mp=d(o),To=n(o,"H2",{class:!0});var wh=r(To);ds=n(wh,"A",{id:!0,class:!0,href:!0});var Iw=r(ds);Vl=n(Iw,"SPAN",{});var Lw=r(Vl);k(Rn.$$.fragment,Lw),Lw.forEach(t),Iw.forEach(t),sg=d(wh),Jl=n(wh,"SPAN",{});var Sw=r(Jl);ng=i(Sw,"DistilBertForTokenClassification"),Sw.forEach(t),wh.forEach(t),Ep=d(o),Qe=n(o,"DIV",{class:!0});var Ht=r(Qe);k(Hn.$$.fragment,Ht),rg=d(Ht),Kl=n(Ht,"P",{});var Nw=r(Kl);ag=i(Nw,`DistilBert Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g.
for Named-Entity-Recognition (NER) tasks.`),Nw.forEach(t),ig=d(Ht),Qn=n(Ht,"P",{});var $h=r(Qn);lg=i($h,"This model inherits from "),Bi=n($h,"A",{href:!0});var Ww=r(Bi);dg=i(Ww,"PreTrainedModel"),Ww.forEach(t),cg=i($h,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),$h.forEach(t),pg=d(Ht),Un=n(Ht,"P",{});var Dh=r(Un);hg=i(Dh,"This model is also a PyTorch "),Vn=n(Dh,"A",{href:!0,rel:!0});var Rw=r(Vn);ug=i(Rw,"torch.nn.Module"),Rw.forEach(t),fg=i(Dh,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Dh.forEach(t),mg=d(Ht),Ge=n(Ht,"DIV",{class:!0});var Qt=r(Ge);k(Jn.$$.fragment,Qt),gg=d(Qt),bo=n(Qt,"P",{});var el=r(bo);_g=i(el,"The "),Mi=n(el,"A",{href:!0});var Hw=r(Mi);vg=i(Hw,"DistilBertForTokenClassification"),Hw.forEach(t),Tg=i(el," forward method, overrides the "),Gl=n(el,"CODE",{});var Qw=r(Gl);bg=i(Qw,"__call__"),Qw.forEach(t),kg=i(el," special method."),el.forEach(t),wg=d(Qt),k(cs.$$.fragment,Qt),$g=d(Qt),Xl=n(Qt,"P",{});var Uw=r(Xl);Dg=i(Uw,"Example:"),Uw.forEach(t),yg=d(Qt),k(Kn.$$.fragment,Qt),Qt.forEach(t),Ht.forEach(t),xp=d(o),ko=n(o,"H2",{class:!0});var yh=r(ko);ps=n(yh,"A",{id:!0,class:!0,href:!0});var Vw=r(ps);Yl=n(Vw,"SPAN",{});var Jw=r(Yl);k(Gn.$$.fragment,Jw),Jw.forEach(t),Vw.forEach(t),Fg=d(yh),Zl=n(yh,"SPAN",{});var Kw=r(Zl);Bg=i(Kw,"DistilBertForQuestionAnswering"),Kw.forEach(t),yh.forEach(t),zp=d(o),Ue=n(o,"DIV",{class:!0});var Ut=r(Ue);k(Xn.$$.fragment,Ut),Mg=d(Ut),wo=n(Ut,"P",{});var tl=r(wo);Eg=i(tl,`DistilBert Model with a span classification head on top for extractive question-answering tasks like SQuAD (a
linear layers on top of the hidden-states output to compute `),ed=n(tl,"CODE",{});var Gw=r(ed);xg=i(Gw,"span start logits"),Gw.forEach(t),zg=i(tl," and "),td=n(tl,"CODE",{});var Xw=r(td);Cg=i(Xw,"span end logits"),Xw.forEach(t),jg=i(tl,")."),tl.forEach(t),Pg=d(Ut),Yn=n(Ut,"P",{});var Fh=r(Yn);qg=i(Fh,"This model inherits from "),Ei=n(Fh,"A",{href:!0});var Yw=r(Ei);Ag=i(Yw,"PreTrainedModel"),Yw.forEach(t),Og=i(Fh,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Fh.forEach(t),Ig=d(Ut),Zn=n(Ut,"P",{});var Bh=r(Zn);Lg=i(Bh,"This model is also a PyTorch "),er=n(Bh,"A",{href:!0,rel:!0});var Zw=r(er);Sg=i(Zw,"torch.nn.Module"),Zw.forEach(t),Ng=i(Bh,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Bh.forEach(t),Wg=d(Ut),Xe=n(Ut,"DIV",{class:!0});var Vt=r(Xe);k(tr.$$.fragment,Vt),Rg=d(Vt),$o=n(Vt,"P",{});var ol=r($o);Hg=i(ol,"The "),xi=n(ol,"A",{href:!0});var e$=r(xi);Qg=i(e$,"DistilBertForQuestionAnswering"),e$.forEach(t),Ug=i(ol," forward method, overrides the "),od=n(ol,"CODE",{});var t$=r(od);Vg=i(t$,"__call__"),t$.forEach(t),Jg=i(ol," special method."),ol.forEach(t),Kg=d(Vt),k(hs.$$.fragment,Vt),Gg=d(Vt),sd=n(Vt,"P",{});var o$=r(sd);Xg=i(o$,"Example:"),o$.forEach(t),Yg=d(Vt),k(or.$$.fragment,Vt),Vt.forEach(t),Ut.forEach(t),Cp=d(o),Do=n(o,"H2",{class:!0});var Mh=r(Do);us=n(Mh,"A",{id:!0,class:!0,href:!0});var s$=r(us);nd=n(s$,"SPAN",{});var n$=r(nd);k(sr.$$.fragment,n$),n$.forEach(t),s$.forEach(t),Zg=d(Mh),rd=n(Mh,"SPAN",{});var r$=r(rd);e_=i(r$,"TFDistilBertModel"),r$.forEach(t),Mh.forEach(t),jp=d(o),Pe=n(o,"DIV",{class:!0});var bt=r(Pe);k(nr.$$.fragment,bt),t_=d(bt),ad=n(bt,"P",{});var a$=r(ad);o_=i(a$,"The bare DistilBERT encoder/transformer outputting raw hidden-states without any specific head on top."),a$.forEach(t),s_=d(bt),rr=n(bt,"P",{});var Eh=r(rr);n_=i(Eh,"This model inherits from "),zi=n(Eh,"A",{href:!0});var i$=r(zi);r_=i(i$,"TFPreTrainedModel"),i$.forEach(t),a_=i(Eh,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Eh.forEach(t),i_=d(bt),ar=n(bt,"P",{});var xh=r(ar);l_=i(xh,"This model is also a "),ir=n(xh,"A",{href:!0,rel:!0});var l$=r(ir);d_=i(l$,"tf.keras.Model"),l$.forEach(t),c_=i(xh,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),xh.forEach(t),p_=d(bt),k(fs.$$.fragment,bt),h_=d(bt),Ye=n(bt,"DIV",{class:!0});var Jt=r(Ye);k(lr.$$.fragment,Jt),u_=d(Jt),yo=n(Jt,"P",{});var sl=r(yo);f_=i(sl,"The "),Ci=n(sl,"A",{href:!0});var d$=r(Ci);m_=i(d$,"TFDistilBertModel"),d$.forEach(t),g_=i(sl," forward method, overrides the "),id=n(sl,"CODE",{});var c$=r(id);__=i(c$,"__call__"),c$.forEach(t),v_=i(sl," special method."),sl.forEach(t),T_=d(Jt),k(ms.$$.fragment,Jt),b_=d(Jt),ld=n(Jt,"P",{});var p$=r(ld);k_=i(p$,"Example:"),p$.forEach(t),w_=d(Jt),k(dr.$$.fragment,Jt),Jt.forEach(t),bt.forEach(t),Pp=d(o),Fo=n(o,"H2",{class:!0});var zh=r(Fo);gs=n(zh,"A",{id:!0,class:!0,href:!0});var h$=r(gs);dd=n(h$,"SPAN",{});var u$=r(dd);k(cr.$$.fragment,u$),u$.forEach(t),h$.forEach(t),$_=d(zh),cd=n(zh,"SPAN",{});var f$=r(cd);D_=i(f$,"TFDistilBertForMaskedLM"),f$.forEach(t),zh.forEach(t),qp=d(o),qe=n(o,"DIV",{class:!0});var kt=r(qe);k(pr.$$.fragment,kt),y_=d(kt),hr=n(kt,"P",{});var Ch=r(hr);F_=i(Ch,"DistilBert Model with a "),pd=n(Ch,"CODE",{});var m$=r(pd);B_=i(m$,"masked language modeling"),m$.forEach(t),M_=i(Ch," head on top."),Ch.forEach(t),E_=d(kt),ur=n(kt,"P",{});var jh=r(ur);x_=i(jh,"This model inherits from "),ji=n(jh,"A",{href:!0});var g$=r(ji);z_=i(g$,"TFPreTrainedModel"),g$.forEach(t),C_=i(jh,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),jh.forEach(t),j_=d(kt),fr=n(kt,"P",{});var Ph=r(fr);P_=i(Ph,"This model is also a "),mr=n(Ph,"A",{href:!0,rel:!0});var _$=r(mr);q_=i(_$,"tf.keras.Model"),_$.forEach(t),A_=i(Ph,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Ph.forEach(t),O_=d(kt),k(_s.$$.fragment,kt),I_=d(kt),Ze=n(kt,"DIV",{class:!0});var Kt=r(Ze);k(gr.$$.fragment,Kt),L_=d(Kt),Bo=n(Kt,"P",{});var nl=r(Bo);S_=i(nl,"The "),Pi=n(nl,"A",{href:!0});var v$=r(Pi);N_=i(v$,"TFDistilBertForMaskedLM"),v$.forEach(t),W_=i(nl," forward method, overrides the "),hd=n(nl,"CODE",{});var T$=r(hd);R_=i(T$,"__call__"),T$.forEach(t),H_=i(nl," special method."),nl.forEach(t),Q_=d(Kt),k(vs.$$.fragment,Kt),U_=d(Kt),ud=n(Kt,"P",{});var b$=r(ud);V_=i(b$,"Example:"),b$.forEach(t),J_=d(Kt),k(_r.$$.fragment,Kt),Kt.forEach(t),kt.forEach(t),Ap=d(o),Mo=n(o,"H2",{class:!0});var qh=r(Mo);Ts=n(qh,"A",{id:!0,class:!0,href:!0});var k$=r(Ts);fd=n(k$,"SPAN",{});var w$=r(fd);k(vr.$$.fragment,w$),w$.forEach(t),k$.forEach(t),K_=d(qh),md=n(qh,"SPAN",{});var $$=r(md);G_=i($$,"TFDistilBertForSequenceClassification"),$$.forEach(t),qh.forEach(t),Op=d(o),Ae=n(o,"DIV",{class:!0});var wt=r(Ae);k(Tr.$$.fragment,wt),X_=d(wt),gd=n(wt,"P",{});var D$=r(gd);Y_=i(D$,`DistilBert Model transformer with a sequence classification/regression head on top (a linear layer on top of the
pooled output) e.g. for GLUE tasks.`),D$.forEach(t),Z_=d(wt),br=n(wt,"P",{});var Ah=r(br);ev=i(Ah,"This model inherits from "),qi=n(Ah,"A",{href:!0});var y$=r(qi);tv=i(y$,"TFPreTrainedModel"),y$.forEach(t),ov=i(Ah,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Ah.forEach(t),sv=d(wt),kr=n(wt,"P",{});var Oh=r(kr);nv=i(Oh,"This model is also a "),wr=n(Oh,"A",{href:!0,rel:!0});var F$=r(wr);rv=i(F$,"tf.keras.Model"),F$.forEach(t),av=i(Oh,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Oh.forEach(t),iv=d(wt),k(bs.$$.fragment,wt),lv=d(wt),et=n(wt,"DIV",{class:!0});var Gt=r(et);k($r.$$.fragment,Gt),dv=d(Gt),Eo=n(Gt,"P",{});var rl=r(Eo);cv=i(rl,"The "),Ai=n(rl,"A",{href:!0});var B$=r(Ai);pv=i(B$,"TFDistilBertForSequenceClassification"),B$.forEach(t),hv=i(rl," forward method, overrides the "),_d=n(rl,"CODE",{});var M$=r(_d);uv=i(M$,"__call__"),M$.forEach(t),fv=i(rl," special method."),rl.forEach(t),mv=d(Gt),k(ks.$$.fragment,Gt),gv=d(Gt),vd=n(Gt,"P",{});var E$=r(vd);_v=i(E$,"Example:"),E$.forEach(t),vv=d(Gt),k(Dr.$$.fragment,Gt),Gt.forEach(t),wt.forEach(t),Ip=d(o),xo=n(o,"H2",{class:!0});var Ih=r(xo);ws=n(Ih,"A",{id:!0,class:!0,href:!0});var x$=r(ws);Td=n(x$,"SPAN",{});var z$=r(Td);k(yr.$$.fragment,z$),z$.forEach(t),x$.forEach(t),Tv=d(Ih),bd=n(Ih,"SPAN",{});var C$=r(bd);bv=i(C$,"TFDistilBertForMultipleChoice"),C$.forEach(t),Ih.forEach(t),Lp=d(o),Oe=n(o,"DIV",{class:!0});var $t=r(Oe);k(Fr.$$.fragment,$t),kv=d($t),kd=n($t,"P",{});var j$=r(kd);wv=i(j$,`DistilBert Model with a multiple choice classification head on top (a linear layer on top of the pooled output and
a softmax) e.g. for RocStories/SWAG tasks.`),j$.forEach(t),$v=d($t),Br=n($t,"P",{});var Lh=r(Br);Dv=i(Lh,"This model inherits from "),Oi=n(Lh,"A",{href:!0});var P$=r(Oi);yv=i(P$,"TFPreTrainedModel"),P$.forEach(t),Fv=i(Lh,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Lh.forEach(t),Bv=d($t),Mr=n($t,"P",{});var Sh=r(Mr);Mv=i(Sh,"This model is also a "),Er=n(Sh,"A",{href:!0,rel:!0});var q$=r(Er);Ev=i(q$,"tf.keras.Model"),q$.forEach(t),xv=i(Sh,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Sh.forEach(t),zv=d($t),k($s.$$.fragment,$t),Cv=d($t),tt=n($t,"DIV",{class:!0});var Xt=r(tt);k(xr.$$.fragment,Xt),jv=d(Xt),zo=n(Xt,"P",{});var al=r(zo);Pv=i(al,"The "),Ii=n(al,"A",{href:!0});var A$=r(Ii);qv=i(A$,"TFDistilBertForMultipleChoice"),A$.forEach(t),Av=i(al," forward method, overrides the "),wd=n(al,"CODE",{});var O$=r(wd);Ov=i(O$,"__call__"),O$.forEach(t),Iv=i(al," special method."),al.forEach(t),Lv=d(Xt),k(Ds.$$.fragment,Xt),Sv=d(Xt),$d=n(Xt,"P",{});var I$=r($d);Nv=i(I$,"Example:"),I$.forEach(t),Wv=d(Xt),k(zr.$$.fragment,Xt),Xt.forEach(t),$t.forEach(t),Sp=d(o),Co=n(o,"H2",{class:!0});var Nh=r(Co);ys=n(Nh,"A",{id:!0,class:!0,href:!0});var L$=r(ys);Dd=n(L$,"SPAN",{});var S$=r(Dd);k(Cr.$$.fragment,S$),S$.forEach(t),L$.forEach(t),Rv=d(Nh),yd=n(Nh,"SPAN",{});var N$=r(yd);Hv=i(N$,"TFDistilBertForTokenClassification"),N$.forEach(t),Nh.forEach(t),Np=d(o),Ie=n(o,"DIV",{class:!0});var Dt=r(Ie);k(jr.$$.fragment,Dt),Qv=d(Dt),Fd=n(Dt,"P",{});var W$=r(Fd);Uv=i(W$,`DistilBert Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g.
for Named-Entity-Recognition (NER) tasks.`),W$.forEach(t),Vv=d(Dt),Pr=n(Dt,"P",{});var Wh=r(Pr);Jv=i(Wh,"This model inherits from "),Li=n(Wh,"A",{href:!0});var R$=r(Li);Kv=i(R$,"TFPreTrainedModel"),R$.forEach(t),Gv=i(Wh,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Wh.forEach(t),Xv=d(Dt),qr=n(Dt,"P",{});var Rh=r(qr);Yv=i(Rh,"This model is also a "),Ar=n(Rh,"A",{href:!0,rel:!0});var H$=r(Ar);Zv=i(H$,"tf.keras.Model"),H$.forEach(t),eT=i(Rh,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Rh.forEach(t),tT=d(Dt),k(Fs.$$.fragment,Dt),oT=d(Dt),ot=n(Dt,"DIV",{class:!0});var Yt=r(ot);k(Or.$$.fragment,Yt),sT=d(Yt),jo=n(Yt,"P",{});var il=r(jo);nT=i(il,"The "),Si=n(il,"A",{href:!0});var Q$=r(Si);rT=i(Q$,"TFDistilBertForTokenClassification"),Q$.forEach(t),aT=i(il," forward method, overrides the "),Bd=n(il,"CODE",{});var U$=r(Bd);iT=i(U$,"__call__"),U$.forEach(t),lT=i(il," special method."),il.forEach(t),dT=d(Yt),k(Bs.$$.fragment,Yt),cT=d(Yt),Md=n(Yt,"P",{});var V$=r(Md);pT=i(V$,"Example:"),V$.forEach(t),hT=d(Yt),k(Ir.$$.fragment,Yt),Yt.forEach(t),Dt.forEach(t),Wp=d(o),Po=n(o,"H2",{class:!0});var Hh=r(Po);Ms=n(Hh,"A",{id:!0,class:!0,href:!0});var J$=r(Ms);Ed=n(J$,"SPAN",{});var K$=r(Ed);k(Lr.$$.fragment,K$),K$.forEach(t),J$.forEach(t),uT=d(Hh),xd=n(Hh,"SPAN",{});var G$=r(xd);fT=i(G$,"TFDistilBertForQuestionAnswering"),G$.forEach(t),Hh.forEach(t),Rp=d(o),Le=n(o,"DIV",{class:!0});var yt=r(Le);k(Sr.$$.fragment,yt),mT=d(yt),qo=n(yt,"P",{});var ll=r(qo);gT=i(ll,`DistilBert Model with a span classification head on top for extractive question-answering tasks like SQuAD (a
linear layer on top of the hidden-states output to compute `),zd=n(ll,"CODE",{});var X$=r(zd);_T=i(X$,"span start logits"),X$.forEach(t),vT=i(ll," and "),Cd=n(ll,"CODE",{});var Y$=r(Cd);TT=i(Y$,"span end logits"),Y$.forEach(t),bT=i(ll,")."),ll.forEach(t),kT=d(yt),Nr=n(yt,"P",{});var Qh=r(Nr);wT=i(Qh,"This model inherits from "),Ni=n(Qh,"A",{href:!0});var Z$=r(Ni);$T=i(Z$,"TFPreTrainedModel"),Z$.forEach(t),DT=i(Qh,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Qh.forEach(t),yT=d(yt),Wr=n(yt,"P",{});var Uh=r(Wr);FT=i(Uh,"This model is also a "),Rr=n(Uh,"A",{href:!0,rel:!0});var eD=r(Rr);BT=i(eD,"tf.keras.Model"),eD.forEach(t),MT=i(Uh,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Uh.forEach(t),ET=d(yt),k(Es.$$.fragment,yt),xT=d(yt),st=n(yt,"DIV",{class:!0});var Zt=r(st);k(Hr.$$.fragment,Zt),zT=d(Zt),Ao=n(Zt,"P",{});var dl=r(Ao);CT=i(dl,"The "),Wi=n(dl,"A",{href:!0});var tD=r(Wi);jT=i(tD,"TFDistilBertForQuestionAnswering"),tD.forEach(t),PT=i(dl," forward method, overrides the "),jd=n(dl,"CODE",{});var oD=r(jd);qT=i(oD,"__call__"),oD.forEach(t),AT=i(dl," special method."),dl.forEach(t),OT=d(Zt),k(xs.$$.fragment,Zt),IT=d(Zt),Pd=n(Zt,"P",{});var sD=r(Pd);LT=i(sD,"Example:"),sD.forEach(t),ST=d(Zt),k(Qr.$$.fragment,Zt),Zt.forEach(t),yt.forEach(t),Hp=d(o),Oo=n(o,"H2",{class:!0});var Vh=r(Oo);zs=n(Vh,"A",{id:!0,class:!0,href:!0});var nD=r(zs);qd=n(nD,"SPAN",{});var rD=r(qd);k(Ur.$$.fragment,rD),rD.forEach(t),nD.forEach(t),NT=d(Vh),Ad=n(Vh,"SPAN",{});var aD=r(Ad);WT=i(aD,"FlaxDistilBertModel"),aD.forEach(t),Vh.forEach(t),Qp=d(o),Be=n(o,"DIV",{class:!0});var pt=r(Be);k(Vr.$$.fragment,pt),RT=d(pt),Od=n(pt,"P",{});var iD=r(Od);HT=i(iD,"The bare DistilBert Model transformer outputting raw hidden-states without any specific head on top."),iD.forEach(t),QT=d(pt),Jr=n(pt,"P",{});var Jh=r(Jr);UT=i(Jh,"This model inherits from "),Ri=n(Jh,"A",{href:!0});var lD=r(Ri);VT=i(lD,"FlaxPreTrainedModel"),lD.forEach(t),JT=i(Jh,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading, saving and converting weights from PyTorch models)`),Jh.forEach(t),KT=d(pt),Kr=n(pt,"P",{});var Kh=r(Kr);GT=i(Kh,"This model is also a Flax Linen "),Gr=n(Kh,"A",{href:!0,rel:!0});var dD=r(Gr);XT=i(dD,"flax.linen.Module"),dD.forEach(t),YT=i(Kh,`
subclass. Use it as a regular Flax linen Module and refer to the Flax documentation for all matter related to
general usage and behavior.`),Kh.forEach(t),ZT=d(pt),Id=n(pt,"P",{});var cD=r(Id);eb=i(cD,"Finally, this model supports inherent JAX features such as:"),cD.forEach(t),tb=d(pt),Bt=n(pt,"UL",{});var Us=r(Bt);Ld=n(Us,"LI",{});var pD=r(Ld);Xr=n(pD,"A",{href:!0,rel:!0});var hD=r(Xr);ob=i(hD,"Just-In-Time (JIT) compilation"),hD.forEach(t),pD.forEach(t),sb=d(Us),Sd=n(Us,"LI",{});var uD=r(Sd);Yr=n(uD,"A",{href:!0,rel:!0});var fD=r(Yr);nb=i(fD,"Automatic Differentiation"),fD.forEach(t),uD.forEach(t),rb=d(Us),Nd=n(Us,"LI",{});var mD=r(Nd);Zr=n(mD,"A",{href:!0,rel:!0});var gD=r(Zr);ab=i(gD,"Vectorization"),gD.forEach(t),mD.forEach(t),ib=d(Us),Wd=n(Us,"LI",{});var _D=r(Wd);ea=n(_D,"A",{href:!0,rel:!0});var vD=r(ea);lb=i(vD,"Parallelization"),vD.forEach(t),_D.forEach(t),Us.forEach(t),db=d(pt),nt=n(pt,"DIV",{class:!0});var eo=r(nt);k(ta.$$.fragment,eo),cb=d(eo),Io=n(eo,"P",{});var cl=r(Io);pb=i(cl,"The "),Rd=n(cl,"CODE",{});var TD=r(Rd);hb=i(TD,"FlaxDistilBertPreTrainedModel"),TD.forEach(t),ub=i(cl,"forward method, overrides the "),Hd=n(cl,"CODE",{});var bD=r(Hd);fb=i(bD,"__call__"),bD.forEach(t),mb=i(cl," special method."),cl.forEach(t),gb=d(eo),k(Cs.$$.fragment,eo),_b=d(eo),Qd=n(eo,"P",{});var kD=r(Qd);vb=i(kD,"Example:"),kD.forEach(t),Tb=d(eo),k(oa.$$.fragment,eo),eo.forEach(t),pt.forEach(t),Up=d(o),Lo=n(o,"H2",{class:!0});var Gh=r(Lo);js=n(Gh,"A",{id:!0,class:!0,href:!0});var wD=r(js);Ud=n(wD,"SPAN",{});var $D=r(Ud);k(sa.$$.fragment,$D),$D.forEach(t),wD.forEach(t),bb=d(Gh),Vd=n(Gh,"SPAN",{});var DD=r(Vd);kb=i(DD,"FlaxDistilBertForMaskedLM"),DD.forEach(t),Gh.forEach(t),Vp=d(o),Me=n(o,"DIV",{class:!0});var ht=r(Me);k(na.$$.fragment,ht),wb=d(ht),ra=n(ht,"P",{});var Xh=r(ra);$b=i(Xh,"DistilBert Model with a "),Jd=n(Xh,"CODE",{});var yD=r(Jd);Db=i(yD,"language modeling"),yD.forEach(t),yb=i(Xh," head on top."),Xh.forEach(t),Fb=d(ht),aa=n(ht,"P",{});var Yh=r(aa);Bb=i(Yh,"This model inherits from "),Hi=n(Yh,"A",{href:!0});var FD=r(Hi);Mb=i(FD,"FlaxPreTrainedModel"),FD.forEach(t),Eb=i(Yh,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading, saving and converting weights from PyTorch models)`),Yh.forEach(t),xb=d(ht),ia=n(ht,"P",{});var Zh=r(ia);zb=i(Zh,"This model is also a Flax Linen "),la=n(Zh,"A",{href:!0,rel:!0});var BD=r(la);Cb=i(BD,"flax.linen.Module"),BD.forEach(t),jb=i(Zh,`
subclass. Use it as a regular Flax linen Module and refer to the Flax documentation for all matter related to
general usage and behavior.`),Zh.forEach(t),Pb=d(ht),Kd=n(ht,"P",{});var MD=r(Kd);qb=i(MD,"Finally, this model supports inherent JAX features such as:"),MD.forEach(t),Ab=d(ht),Mt=n(ht,"UL",{});var Vs=r(Mt);Gd=n(Vs,"LI",{});var ED=r(Gd);da=n(ED,"A",{href:!0,rel:!0});var xD=r(da);Ob=i(xD,"Just-In-Time (JIT) compilation"),xD.forEach(t),ED.forEach(t),Ib=d(Vs),Xd=n(Vs,"LI",{});var zD=r(Xd);ca=n(zD,"A",{href:!0,rel:!0});var CD=r(ca);Lb=i(CD,"Automatic Differentiation"),CD.forEach(t),zD.forEach(t),Sb=d(Vs),Yd=n(Vs,"LI",{});var jD=r(Yd);pa=n(jD,"A",{href:!0,rel:!0});var PD=r(pa);Nb=i(PD,"Vectorization"),PD.forEach(t),jD.forEach(t),Wb=d(Vs),Zd=n(Vs,"LI",{});var qD=r(Zd);ha=n(qD,"A",{href:!0,rel:!0});var AD=r(ha);Rb=i(AD,"Parallelization"),AD.forEach(t),qD.forEach(t),Vs.forEach(t),Hb=d(ht),rt=n(ht,"DIV",{class:!0});var to=r(rt);k(ua.$$.fragment,to),Qb=d(to),So=n(to,"P",{});var pl=r(So);Ub=i(pl,"The "),ec=n(pl,"CODE",{});var OD=r(ec);Vb=i(OD,"FlaxDistilBertPreTrainedModel"),OD.forEach(t),Jb=i(pl,"forward method, overrides the "),tc=n(pl,"CODE",{});var ID=r(tc);Kb=i(ID,"__call__"),ID.forEach(t),Gb=i(pl," special method."),pl.forEach(t),Xb=d(to),k(Ps.$$.fragment,to),Yb=d(to),oc=n(to,"P",{});var LD=r(oc);Zb=i(LD,"Example:"),LD.forEach(t),e1=d(to),k(fa.$$.fragment,to),to.forEach(t),ht.forEach(t),Jp=d(o),No=n(o,"H2",{class:!0});var eu=r(No);qs=n(eu,"A",{id:!0,class:!0,href:!0});var SD=r(qs);sc=n(SD,"SPAN",{});var ND=r(sc);k(ma.$$.fragment,ND),ND.forEach(t),SD.forEach(t),t1=d(eu),nc=n(eu,"SPAN",{});var WD=r(nc);o1=i(WD,"FlaxDistilBertForSequenceClassification"),WD.forEach(t),eu.forEach(t),Kp=d(o),Ee=n(o,"DIV",{class:!0});var ut=r(Ee);k(ga.$$.fragment,ut),s1=d(ut),rc=n(ut,"P",{});var RD=r(rc);n1=i(RD,`DistilBert Model transformer with a sequence classification/regression head on top (a linear layer on top of the
pooled output) e.g. for GLUE tasks.`),RD.forEach(t),r1=d(ut),_a=n(ut,"P",{});var tu=r(_a);a1=i(tu,"This model inherits from "),Qi=n(tu,"A",{href:!0});var HD=r(Qi);i1=i(HD,"FlaxPreTrainedModel"),HD.forEach(t),l1=i(tu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading, saving and converting weights from PyTorch models)`),tu.forEach(t),d1=d(ut),va=n(ut,"P",{});var ou=r(va);c1=i(ou,"This model is also a Flax Linen "),Ta=n(ou,"A",{href:!0,rel:!0});var QD=r(Ta);p1=i(QD,"flax.linen.Module"),QD.forEach(t),h1=i(ou,`
subclass. Use it as a regular Flax linen Module and refer to the Flax documentation for all matter related to
general usage and behavior.`),ou.forEach(t),u1=d(ut),ac=n(ut,"P",{});var UD=r(ac);f1=i(UD,"Finally, this model supports inherent JAX features such as:"),UD.forEach(t),m1=d(ut),Et=n(ut,"UL",{});var Js=r(Et);ic=n(Js,"LI",{});var VD=r(ic);ba=n(VD,"A",{href:!0,rel:!0});var JD=r(ba);g1=i(JD,"Just-In-Time (JIT) compilation"),JD.forEach(t),VD.forEach(t),_1=d(Js),lc=n(Js,"LI",{});var KD=r(lc);ka=n(KD,"A",{href:!0,rel:!0});var GD=r(ka);v1=i(GD,"Automatic Differentiation"),GD.forEach(t),KD.forEach(t),T1=d(Js),dc=n(Js,"LI",{});var XD=r(dc);wa=n(XD,"A",{href:!0,rel:!0});var YD=r(wa);b1=i(YD,"Vectorization"),YD.forEach(t),XD.forEach(t),k1=d(Js),cc=n(Js,"LI",{});var ZD=r(cc);$a=n(ZD,"A",{href:!0,rel:!0});var ey=r($a);w1=i(ey,"Parallelization"),ey.forEach(t),ZD.forEach(t),Js.forEach(t),$1=d(ut),at=n(ut,"DIV",{class:!0});var oo=r(at);k(Da.$$.fragment,oo),D1=d(oo),Wo=n(oo,"P",{});var hl=r(Wo);y1=i(hl,"The "),pc=n(hl,"CODE",{});var ty=r(pc);F1=i(ty,"FlaxDistilBertPreTrainedModel"),ty.forEach(t),B1=i(hl,"forward method, overrides the "),hc=n(hl,"CODE",{});var oy=r(hc);M1=i(oy,"__call__"),oy.forEach(t),E1=i(hl," special method."),hl.forEach(t),x1=d(oo),k(As.$$.fragment,oo),z1=d(oo),uc=n(oo,"P",{});var sy=r(uc);C1=i(sy,"Example:"),sy.forEach(t),j1=d(oo),k(ya.$$.fragment,oo),oo.forEach(t),ut.forEach(t),Gp=d(o),Ro=n(o,"H2",{class:!0});var su=r(Ro);Os=n(su,"A",{id:!0,class:!0,href:!0});var ny=r(Os);fc=n(ny,"SPAN",{});var ry=r(fc);k(Fa.$$.fragment,ry),ry.forEach(t),ny.forEach(t),P1=d(su),mc=n(su,"SPAN",{});var ay=r(mc);q1=i(ay,"FlaxDistilBertForMultipleChoice"),ay.forEach(t),su.forEach(t),Xp=d(o),xe=n(o,"DIV",{class:!0});var ft=r(xe);k(Ba.$$.fragment,ft),A1=d(ft),gc=n(ft,"P",{});var iy=r(gc);O1=i(iy,`DistilBert Model with a multiple choice classification head on top (a linear layer on top of the pooled output and
a softmax) e.g. for RocStories/SWAG tasks.`),iy.forEach(t),I1=d(ft),Ma=n(ft,"P",{});var nu=r(Ma);L1=i(nu,"This model inherits from "),Ui=n(nu,"A",{href:!0});var ly=r(Ui);S1=i(ly,"FlaxPreTrainedModel"),ly.forEach(t),N1=i(nu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading, saving and converting weights from PyTorch models)`),nu.forEach(t),W1=d(ft),Ea=n(ft,"P",{});var ru=r(Ea);R1=i(ru,"This model is also a Flax Linen "),xa=n(ru,"A",{href:!0,rel:!0});var dy=r(xa);H1=i(dy,"flax.linen.Module"),dy.forEach(t),Q1=i(ru,`
subclass. Use it as a regular Flax linen Module and refer to the Flax documentation for all matter related to
general usage and behavior.`),ru.forEach(t),U1=d(ft),_c=n(ft,"P",{});var cy=r(_c);V1=i(cy,"Finally, this model supports inherent JAX features such as:"),cy.forEach(t),J1=d(ft),xt=n(ft,"UL",{});var Ks=r(xt);vc=n(Ks,"LI",{});var py=r(vc);za=n(py,"A",{href:!0,rel:!0});var hy=r(za);K1=i(hy,"Just-In-Time (JIT) compilation"),hy.forEach(t),py.forEach(t),G1=d(Ks),Tc=n(Ks,"LI",{});var uy=r(Tc);Ca=n(uy,"A",{href:!0,rel:!0});var fy=r(Ca);X1=i(fy,"Automatic Differentiation"),fy.forEach(t),uy.forEach(t),Y1=d(Ks),bc=n(Ks,"LI",{});var my=r(bc);ja=n(my,"A",{href:!0,rel:!0});var gy=r(ja);Z1=i(gy,"Vectorization"),gy.forEach(t),my.forEach(t),ek=d(Ks),kc=n(Ks,"LI",{});var _y=r(kc);Pa=n(_y,"A",{href:!0,rel:!0});var vy=r(Pa);tk=i(vy,"Parallelization"),vy.forEach(t),_y.forEach(t),Ks.forEach(t),ok=d(ft),it=n(ft,"DIV",{class:!0});var so=r(it);k(qa.$$.fragment,so),sk=d(so),Ho=n(so,"P",{});var ul=r(Ho);nk=i(ul,"The "),wc=n(ul,"CODE",{});var Ty=r(wc);rk=i(Ty,"FlaxDistilBertPreTrainedModel"),Ty.forEach(t),ak=i(ul,"forward method, overrides the "),$c=n(ul,"CODE",{});var by=r($c);ik=i(by,"__call__"),by.forEach(t),lk=i(ul," special method."),ul.forEach(t),dk=d(so),k(Is.$$.fragment,so),ck=d(so),Dc=n(so,"P",{});var ky=r(Dc);pk=i(ky,"Example:"),ky.forEach(t),hk=d(so),k(Aa.$$.fragment,so),so.forEach(t),ft.forEach(t),Yp=d(o),Qo=n(o,"H2",{class:!0});var au=r(Qo);Ls=n(au,"A",{id:!0,class:!0,href:!0});var wy=r(Ls);yc=n(wy,"SPAN",{});var $y=r(yc);k(Oa.$$.fragment,$y),$y.forEach(t),wy.forEach(t),uk=d(au),Fc=n(au,"SPAN",{});var Dy=r(Fc);fk=i(Dy,"FlaxDistilBertForTokenClassification"),Dy.forEach(t),au.forEach(t),Zp=d(o),ze=n(o,"DIV",{class:!0});var mt=r(ze);k(Ia.$$.fragment,mt),mk=d(mt),Bc=n(mt,"P",{});var yy=r(Bc);gk=i(yy,`DistilBert Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g.
for Named-Entity-Recognition (NER) tasks.`),yy.forEach(t),_k=d(mt),La=n(mt,"P",{});var iu=r(La);vk=i(iu,"This model inherits from "),Vi=n(iu,"A",{href:!0});var Fy=r(Vi);Tk=i(Fy,"FlaxPreTrainedModel"),Fy.forEach(t),bk=i(iu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading, saving and converting weights from PyTorch models)`),iu.forEach(t),kk=d(mt),Sa=n(mt,"P",{});var lu=r(Sa);wk=i(lu,"This model is also a Flax Linen "),Na=n(lu,"A",{href:!0,rel:!0});var By=r(Na);$k=i(By,"flax.linen.Module"),By.forEach(t),Dk=i(lu,`
subclass. Use it as a regular Flax linen Module and refer to the Flax documentation for all matter related to
general usage and behavior.`),lu.forEach(t),yk=d(mt),Mc=n(mt,"P",{});var My=r(Mc);Fk=i(My,"Finally, this model supports inherent JAX features such as:"),My.forEach(t),Bk=d(mt),zt=n(mt,"UL",{});var Gs=r(zt);Ec=n(Gs,"LI",{});var Ey=r(Ec);Wa=n(Ey,"A",{href:!0,rel:!0});var xy=r(Wa);Mk=i(xy,"Just-In-Time (JIT) compilation"),xy.forEach(t),Ey.forEach(t),Ek=d(Gs),xc=n(Gs,"LI",{});var zy=r(xc);Ra=n(zy,"A",{href:!0,rel:!0});var Cy=r(Ra);xk=i(Cy,"Automatic Differentiation"),Cy.forEach(t),zy.forEach(t),zk=d(Gs),zc=n(Gs,"LI",{});var jy=r(zc);Ha=n(jy,"A",{href:!0,rel:!0});var Py=r(Ha);Ck=i(Py,"Vectorization"),Py.forEach(t),jy.forEach(t),jk=d(Gs),Cc=n(Gs,"LI",{});var qy=r(Cc);Qa=n(qy,"A",{href:!0,rel:!0});var Ay=r(Qa);Pk=i(Ay,"Parallelization"),Ay.forEach(t),qy.forEach(t),Gs.forEach(t),qk=d(mt),lt=n(mt,"DIV",{class:!0});var no=r(lt);k(Ua.$$.fragment,no),Ak=d(no),Uo=n(no,"P",{});var fl=r(Uo);Ok=i(fl,"The "),jc=n(fl,"CODE",{});var Oy=r(jc);Ik=i(Oy,"FlaxDistilBertPreTrainedModel"),Oy.forEach(t),Lk=i(fl,"forward method, overrides the "),Pc=n(fl,"CODE",{});var Iy=r(Pc);Sk=i(Iy,"__call__"),Iy.forEach(t),Nk=i(fl," special method."),fl.forEach(t),Wk=d(no),k(Ss.$$.fragment,no),Rk=d(no),qc=n(no,"P",{});var Ly=r(qc);Hk=i(Ly,"Example:"),Ly.forEach(t),Qk=d(no),k(Va.$$.fragment,no),no.forEach(t),mt.forEach(t),eh=d(o),Vo=n(o,"H2",{class:!0});var du=r(Vo);Ns=n(du,"A",{id:!0,class:!0,href:!0});var Sy=r(Ns);Ac=n(Sy,"SPAN",{});var Ny=r(Ac);k(Ja.$$.fragment,Ny),Ny.forEach(t),Sy.forEach(t),Uk=d(du),Oc=n(du,"SPAN",{});var Wy=r(Oc);Vk=i(Wy,"FlaxDistilBertForQuestionAnswering"),Wy.forEach(t),du.forEach(t),th=d(o),Ce=n(o,"DIV",{class:!0});var gt=r(Ce);k(Ka.$$.fragment,gt),Jk=d(gt),Jo=n(gt,"P",{});var ml=r(Jo);Kk=i(ml,`DistilBert Model with a span classification head on top for extractive question-answering tasks like SQuAD (a
linear layers on top of the hidden-states output to compute `),Ic=n(ml,"CODE",{});var Ry=r(Ic);Gk=i(Ry,"span start logits"),Ry.forEach(t),Xk=i(ml," and "),Lc=n(ml,"CODE",{});var Hy=r(Lc);Yk=i(Hy,"span end logits"),Hy.forEach(t),Zk=i(ml,")."),ml.forEach(t),e0=d(gt),Ga=n(gt,"P",{});var cu=r(Ga);t0=i(cu,"This model inherits from "),Ji=n(cu,"A",{href:!0});var Qy=r(Ji);o0=i(Qy,"FlaxPreTrainedModel"),Qy.forEach(t),s0=i(cu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading, saving and converting weights from PyTorch models)`),cu.forEach(t),n0=d(gt),Xa=n(gt,"P",{});var pu=r(Xa);r0=i(pu,"This model is also a Flax Linen "),Ya=n(pu,"A",{href:!0,rel:!0});var Uy=r(Ya);a0=i(Uy,"flax.linen.Module"),Uy.forEach(t),i0=i(pu,`
subclass. Use it as a regular Flax linen Module and refer to the Flax documentation for all matter related to
general usage and behavior.`),pu.forEach(t),l0=d(gt),Sc=n(gt,"P",{});var Vy=r(Sc);d0=i(Vy,"Finally, this model supports inherent JAX features such as:"),Vy.forEach(t),c0=d(gt),Ct=n(gt,"UL",{});var Xs=r(Ct);Nc=n(Xs,"LI",{});var Jy=r(Nc);Za=n(Jy,"A",{href:!0,rel:!0});var Ky=r(Za);p0=i(Ky,"Just-In-Time (JIT) compilation"),Ky.forEach(t),Jy.forEach(t),h0=d(Xs),Wc=n(Xs,"LI",{});var Gy=r(Wc);ei=n(Gy,"A",{href:!0,rel:!0});var Xy=r(ei);u0=i(Xy,"Automatic Differentiation"),Xy.forEach(t),Gy.forEach(t),f0=d(Xs),Rc=n(Xs,"LI",{});var Yy=r(Rc);ti=n(Yy,"A",{href:!0,rel:!0});var Zy=r(ti);m0=i(Zy,"Vectorization"),Zy.forEach(t),Yy.forEach(t),g0=d(Xs),Hc=n(Xs,"LI",{});var eF=r(Hc);oi=n(eF,"A",{href:!0,rel:!0});var tF=r(oi);_0=i(tF,"Parallelization"),tF.forEach(t),eF.forEach(t),Xs.forEach(t),v0=d(gt),dt=n(gt,"DIV",{class:!0});var ro=r(dt);k(si.$$.fragment,ro),T0=d(ro),Ko=n(ro,"P",{});var gl=r(Ko);b0=i(gl,"The "),Qc=n(gl,"CODE",{});var oF=r(Qc);k0=i(oF,"FlaxDistilBertPreTrainedModel"),oF.forEach(t),w0=i(gl,"forward method, overrides the "),Uc=n(gl,"CODE",{});var sF=r(Uc);$0=i(sF,"__call__"),sF.forEach(t),D0=i(gl," special method."),gl.forEach(t),y0=d(ro),k(Ws.$$.fragment,ro),F0=d(ro),Vc=n(ro,"P",{});var nF=r(Vc);B0=i(nF,"Example:"),nF.forEach(t),M0=d(ro),k(ni.$$.fragment,ro),ro.forEach(t),gt.forEach(t),this.h()},h(){c(p,"name","hf:doc:metadata"),c(p,"content",JSON.stringify(PF)),c(v,"id","distilbert"),c(v,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(v,"href","#distilbert"),c(g,"class","relative group"),c(G,"id","overview"),c(G,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(G,"href","#overview"),c(E,"class","relative group"),c(Y,"href","https://medium.com/huggingface/distilbert-8cf3380435b5"),c(Y,"rel","nofollow"),c(z,"href","https://arxiv.org/abs/1910.01108"),c(z,"rel","nofollow"),c(Ys,"href","https://huggingface.co/victorsanh"),c(Ys,"rel","nofollow"),c(Zs,"href","https://huggingface.co/kamalkraj"),c(Zs,"rel","nofollow"),c(en,"href","https://github.com/huggingface/transformers/tree/master/examples/research_projects/distillation"),c(en,"rel","nofollow"),c(Go,"id","transformers.DistilBertConfig"),c(Go,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Go,"href","#transformers.DistilBertConfig"),c(ao,"class","relative group"),c(di,"href","/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertModel"),c(ci,"href","/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.TFDistilBertModel"),c(sn,"href","https://huggingface.co/distilbert-base-uncased"),c(sn,"rel","nofollow"),c(pi,"href","/docs/transformers/pr_16090/en/main_classes/configuration#transformers.PretrainedConfig"),c(hi,"href","/docs/transformers/pr_16090/en/main_classes/configuration#transformers.PretrainedConfig"),c(Se,"class","docstring"),c(Xo,"id","transformers.DistilBertTokenizer"),c(Xo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Xo,"href","#transformers.DistilBertTokenizer"),c(lo,"class","relative group"),c(ui,"href","/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertTokenizer"),c(fi,"href","/docs/transformers/pr_16090/en/model_doc/bert#transformers.BertTokenizer"),c(mi,"href","/docs/transformers/pr_16090/en/model_doc/bert#transformers.BertTokenizer"),c(_t,"class","docstring"),c(Zo,"id","transformers.DistilBertTokenizerFast"),c(Zo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Zo,"href","#transformers.DistilBertTokenizerFast"),c(co,"class","relative group"),c(gi,"href","/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertTokenizerFast"),c(_i,"href","/docs/transformers/pr_16090/en/model_doc/bert#transformers.BertTokenizerFast"),c(vi,"href","/docs/transformers/pr_16090/en/model_doc/bert#transformers.BertTokenizerFast"),c(vt,"class","docstring"),c(ts,"id","transformers.DistilBertModel"),c(ts,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ts,"href","#transformers.DistilBertModel"),c(po,"class","relative group"),c(Ti,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel"),c(_n,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(_n,"rel","nofollow"),c(bi,"href","/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertModel"),c(Ve,"class","docstring"),c(Ne,"class","docstring"),c(ss,"id","transformers.DistilBertForMaskedLM"),c(ss,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ss,"href","#transformers.DistilBertForMaskedLM"),c(uo,"class","relative group"),c(ki,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel"),c(yn,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(yn,"rel","nofollow"),c(wi,"href","/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertForMaskedLM"),c(Je,"class","docstring"),c(We,"class","docstring"),c(rs,"id","transformers.DistilBertForSequenceClassification"),c(rs,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(rs,"href","#transformers.DistilBertForSequenceClassification"),c(mo,"class","relative group"),c($i,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel"),c(Cn,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Cn,"rel","nofollow"),c(Di,"href","/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertForSequenceClassification"),c(je,"class","docstring"),c(Re,"class","docstring"),c(is,"id","transformers.DistilBertForMultipleChoice"),c(is,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(is,"href","#transformers.DistilBertForMultipleChoice"),c(_o,"class","relative group"),c(yi,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel"),c(Sn,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Sn,"rel","nofollow"),c(Fi,"href","/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertForMultipleChoice"),c(Ke,"class","docstring"),c(He,"class","docstring"),c(ds,"id","transformers.DistilBertForTokenClassification"),c(ds,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ds,"href","#transformers.DistilBertForTokenClassification"),c(To,"class","relative group"),c(Bi,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel"),c(Vn,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Vn,"rel","nofollow"),c(Mi,"href","/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertForTokenClassification"),c(Ge,"class","docstring"),c(Qe,"class","docstring"),c(ps,"id","transformers.DistilBertForQuestionAnswering"),c(ps,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ps,"href","#transformers.DistilBertForQuestionAnswering"),c(ko,"class","relative group"),c(Ei,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.PreTrainedModel"),c(er,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(er,"rel","nofollow"),c(xi,"href","/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.DistilBertForQuestionAnswering"),c(Xe,"class","docstring"),c(Ue,"class","docstring"),c(us,"id","transformers.TFDistilBertModel"),c(us,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(us,"href","#transformers.TFDistilBertModel"),c(Do,"class","relative group"),c(zi,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.TFPreTrainedModel"),c(ir,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(ir,"rel","nofollow"),c(Ci,"href","/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.TFDistilBertModel"),c(Ye,"class","docstring"),c(Pe,"class","docstring"),c(gs,"id","transformers.TFDistilBertForMaskedLM"),c(gs,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(gs,"href","#transformers.TFDistilBertForMaskedLM"),c(Fo,"class","relative group"),c(ji,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.TFPreTrainedModel"),c(mr,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(mr,"rel","nofollow"),c(Pi,"href","/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.TFDistilBertForMaskedLM"),c(Ze,"class","docstring"),c(qe,"class","docstring"),c(Ts,"id","transformers.TFDistilBertForSequenceClassification"),c(Ts,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Ts,"href","#transformers.TFDistilBertForSequenceClassification"),c(Mo,"class","relative group"),c(qi,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.TFPreTrainedModel"),c(wr,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(wr,"rel","nofollow"),c(Ai,"href","/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.TFDistilBertForSequenceClassification"),c(et,"class","docstring"),c(Ae,"class","docstring"),c(ws,"id","transformers.TFDistilBertForMultipleChoice"),c(ws,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ws,"href","#transformers.TFDistilBertForMultipleChoice"),c(xo,"class","relative group"),c(Oi,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.TFPreTrainedModel"),c(Er,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Er,"rel","nofollow"),c(Ii,"href","/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.TFDistilBertForMultipleChoice"),c(tt,"class","docstring"),c(Oe,"class","docstring"),c(ys,"id","transformers.TFDistilBertForTokenClassification"),c(ys,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ys,"href","#transformers.TFDistilBertForTokenClassification"),c(Co,"class","relative group"),c(Li,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.TFPreTrainedModel"),c(Ar,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Ar,"rel","nofollow"),c(Si,"href","/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.TFDistilBertForTokenClassification"),c(ot,"class","docstring"),c(Ie,"class","docstring"),c(Ms,"id","transformers.TFDistilBertForQuestionAnswering"),c(Ms,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Ms,"href","#transformers.TFDistilBertForQuestionAnswering"),c(Po,"class","relative group"),c(Ni,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.TFPreTrainedModel"),c(Rr,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Rr,"rel","nofollow"),c(Wi,"href","/docs/transformers/pr_16090/en/model_doc/distilbert#transformers.TFDistilBertForQuestionAnswering"),c(st,"class","docstring"),c(Le,"class","docstring"),c(zs,"id","transformers.FlaxDistilBertModel"),c(zs,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(zs,"href","#transformers.FlaxDistilBertModel"),c(Oo,"class","relative group"),c(Ri,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.FlaxPreTrainedModel"),c(Gr,"href","https://flax.readthedocs.io/en/latest/flax.linen.html#module"),c(Gr,"rel","nofollow"),c(Xr,"href","https://jax.readthedocs.io/en/latest/jax.html#just-in-time-compilation-jit"),c(Xr,"rel","nofollow"),c(Yr,"href","https://jax.readthedocs.io/en/latest/jax.html#automatic-differentiation"),c(Yr,"rel","nofollow"),c(Zr,"href","https://jax.readthedocs.io/en/latest/jax.html#vectorization-vmap"),c(Zr,"rel","nofollow"),c(ea,"href","https://jax.readthedocs.io/en/latest/jax.html#parallelization-pmap"),c(ea,"rel","nofollow"),c(nt,"class","docstring"),c(Be,"class","docstring"),c(js,"id","transformers.FlaxDistilBertForMaskedLM"),c(js,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(js,"href","#transformers.FlaxDistilBertForMaskedLM"),c(Lo,"class","relative group"),c(Hi,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.FlaxPreTrainedModel"),c(la,"href","https://flax.readthedocs.io/en/latest/flax.linen.html#module"),c(la,"rel","nofollow"),c(da,"href","https://jax.readthedocs.io/en/latest/jax.html#just-in-time-compilation-jit"),c(da,"rel","nofollow"),c(ca,"href","https://jax.readthedocs.io/en/latest/jax.html#automatic-differentiation"),c(ca,"rel","nofollow"),c(pa,"href","https://jax.readthedocs.io/en/latest/jax.html#vectorization-vmap"),c(pa,"rel","nofollow"),c(ha,"href","https://jax.readthedocs.io/en/latest/jax.html#parallelization-pmap"),c(ha,"rel","nofollow"),c(rt,"class","docstring"),c(Me,"class","docstring"),c(qs,"id","transformers.FlaxDistilBertForSequenceClassification"),c(qs,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(qs,"href","#transformers.FlaxDistilBertForSequenceClassification"),c(No,"class","relative group"),c(Qi,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.FlaxPreTrainedModel"),c(Ta,"href","https://flax.readthedocs.io/en/latest/flax.linen.html#module"),c(Ta,"rel","nofollow"),c(ba,"href","https://jax.readthedocs.io/en/latest/jax.html#just-in-time-compilation-jit"),c(ba,"rel","nofollow"),c(ka,"href","https://jax.readthedocs.io/en/latest/jax.html#automatic-differentiation"),c(ka,"rel","nofollow"),c(wa,"href","https://jax.readthedocs.io/en/latest/jax.html#vectorization-vmap"),c(wa,"rel","nofollow"),c($a,"href","https://jax.readthedocs.io/en/latest/jax.html#parallelization-pmap"),c($a,"rel","nofollow"),c(at,"class","docstring"),c(Ee,"class","docstring"),c(Os,"id","transformers.FlaxDistilBertForMultipleChoice"),c(Os,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Os,"href","#transformers.FlaxDistilBertForMultipleChoice"),c(Ro,"class","relative group"),c(Ui,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.FlaxPreTrainedModel"),c(xa,"href","https://flax.readthedocs.io/en/latest/flax.linen.html#module"),c(xa,"rel","nofollow"),c(za,"href","https://jax.readthedocs.io/en/latest/jax.html#just-in-time-compilation-jit"),c(za,"rel","nofollow"),c(Ca,"href","https://jax.readthedocs.io/en/latest/jax.html#automatic-differentiation"),c(Ca,"rel","nofollow"),c(ja,"href","https://jax.readthedocs.io/en/latest/jax.html#vectorization-vmap"),c(ja,"rel","nofollow"),c(Pa,"href","https://jax.readthedocs.io/en/latest/jax.html#parallelization-pmap"),c(Pa,"rel","nofollow"),c(it,"class","docstring"),c(xe,"class","docstring"),c(Ls,"id","transformers.FlaxDistilBertForTokenClassification"),c(Ls,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Ls,"href","#transformers.FlaxDistilBertForTokenClassification"),c(Qo,"class","relative group"),c(Vi,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.FlaxPreTrainedModel"),c(Na,"href","https://flax.readthedocs.io/en/latest/flax.linen.html#module"),c(Na,"rel","nofollow"),c(Wa,"href","https://jax.readthedocs.io/en/latest/jax.html#just-in-time-compilation-jit"),c(Wa,"rel","nofollow"),c(Ra,"href","https://jax.readthedocs.io/en/latest/jax.html#automatic-differentiation"),c(Ra,"rel","nofollow"),c(Ha,"href","https://jax.readthedocs.io/en/latest/jax.html#vectorization-vmap"),c(Ha,"rel","nofollow"),c(Qa,"href","https://jax.readthedocs.io/en/latest/jax.html#parallelization-pmap"),c(Qa,"rel","nofollow"),c(lt,"class","docstring"),c(ze,"class","docstring"),c(Ns,"id","transformers.FlaxDistilBertForQuestionAnswering"),c(Ns,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Ns,"href","#transformers.FlaxDistilBertForQuestionAnswering"),c(Vo,"class","relative group"),c(Ji,"href","/docs/transformers/pr_16090/en/main_classes/model#transformers.FlaxPreTrainedModel"),c(Ya,"href","https://flax.readthedocs.io/en/latest/flax.linen.html#module"),c(Ya,"rel","nofollow"),c(Za,"href","https://jax.readthedocs.io/en/latest/jax.html#just-in-time-compilation-jit"),c(Za,"rel","nofollow"),c(ei,"href","https://jax.readthedocs.io/en/latest/jax.html#automatic-differentiation"),c(ei,"rel","nofollow"),c(ti,"href","https://jax.readthedocs.io/en/latest/jax.html#vectorization-vmap"),c(ti,"rel","nofollow"),c(oi,"href","https://jax.readthedocs.io/en/latest/jax.html#parallelization-pmap"),c(oi,"rel","nofollow"),c(dt,"class","docstring"),c(Ce,"class","docstring")},m(o,m){e(document.head,p),u(o,F,m),u(o,g,m),e(g,v),e(v,T),w(_,T,null),e(g,f),e(g,B),e(B,de),u(o,V,m),u(o,E,m),e(E,G),e(G,S),w(X,S,null),e(E,ce),e(E,N),e(N,pe),u(o,re,m),u(o,I,m),e(I,q),e(I,Y),e(Y,J),e(I,x),e(I,z),e(z,he),e(I,W),e(I,oe),e(oe,ue),e(I,R),u(o,ae,m),u(o,ee,m),e(ee,A),u(o,ie,m),u(o,L,m),e(L,se),e(se,fe),u(o,P,m),u(o,te,m),e(te,H),u(o,le,m),u(o,h,m),e(h,M),e(M,K),e(M,ge),e(ge,Te),e(M,O),e(M,_e),e(_e,be),e(M,ke),e(M,j),e(j,Q),e(M,we),e(h,$e),e(h,Z),e(Z,De),e(Z,ne),e(ne,ye),e(Z,hu),u(o,up,m),u(o,Tt,m),e(Tt,uu),e(Tt,Ys),e(Ys,fu),e(Tt,mu),e(Tt,Zs),e(Zs,gu),e(Tt,_u),e(Tt,en),e(en,vu),e(Tt,Tu),u(o,fp,m),u(o,ao,m),e(ao,Go),e(Go,_l),w(tn,_l,null),e(ao,bu),e(ao,vl),e(vl,ku),u(o,mp,m),u(o,Se,m),w(on,Se,null),e(Se,wu),e(Se,Ft),e(Ft,$u),e(Ft,di),e(di,Du),e(Ft,yu),e(Ft,ci),e(ci,Fu),e(Ft,Bu),e(Ft,sn),e(sn,Mu),e(Ft,Eu),e(Se,xu),e(Se,io),e(io,zu),e(io,pi),e(pi,Cu),e(io,ju),e(io,hi),e(hi,Pu),e(io,qu),e(Se,Au),e(Se,Tl),e(Tl,Ou),e(Se,Iu),w(nn,Se,null),u(o,gp,m),u(o,lo,m),e(lo,Xo),e(Xo,bl),w(rn,bl,null),e(lo,Lu),e(lo,kl),e(kl,Su),u(o,_p,m),u(o,_t,m),w(an,_t,null),e(_t,Nu),e(_t,wl),e(wl,Wu),e(_t,Ru),e(_t,Yo),e(Yo,ui),e(ui,Hu),e(Yo,Qu),e(Yo,fi),e(fi,Uu),e(Yo,Vu),e(_t,Ju),e(_t,ln),e(ln,Ku),e(ln,mi),e(mi,Gu),e(ln,Xu),u(o,vp,m),u(o,co,m),e(co,Zo),e(Zo,$l),w(dn,$l,null),e(co,Yu),e(co,Dl),e(Dl,Zu),u(o,Tp,m),u(o,vt,m),w(cn,vt,null),e(vt,ef),e(vt,pn),e(pn,tf),e(pn,yl),e(yl,of),e(pn,sf),e(vt,nf),e(vt,es),e(es,gi),e(gi,rf),e(es,af),e(es,_i),e(_i,lf),e(es,df),e(vt,cf),e(vt,hn),e(hn,pf),e(hn,vi),e(vi,hf),e(hn,uf),u(o,bp,m),u(o,po,m),e(po,ts),e(ts,Fl),w(un,Fl,null),e(po,ff),e(po,Bl),e(Bl,mf),u(o,kp,m),u(o,Ne,m),w(fn,Ne,null),e(Ne,gf),e(Ne,Ml),e(Ml,_f),e(Ne,vf),e(Ne,mn),e(mn,Tf),e(mn,Ti),e(Ti,bf),e(mn,kf),e(Ne,wf),e(Ne,gn),e(gn,$f),e(gn,_n),e(_n,Df),e(gn,yf),e(Ne,Ff),e(Ne,Ve),w(vn,Ve,null),e(Ve,Bf),e(Ve,ho),e(ho,Mf),e(ho,bi),e(bi,Ef),e(ho,xf),e(ho,El),e(El,zf),e(ho,Cf),e(Ve,jf),w(os,Ve,null),e(Ve,Pf),e(Ve,xl),e(xl,qf),e(Ve,Af),w(Tn,Ve,null),u(o,wp,m),u(o,uo,m),e(uo,ss),e(ss,zl),w(bn,zl,null),e(uo,Of),e(uo,Cl),e(Cl,If),u(o,$p,m),u(o,We,m),w(kn,We,null),e(We,Lf),e(We,wn),e(wn,Sf),e(wn,jl),e(jl,Nf),e(wn,Wf),e(We,Rf),e(We,$n),e($n,Hf),e($n,ki),e(ki,Qf),e($n,Uf),e(We,Vf),e(We,Dn),e(Dn,Jf),e(Dn,yn),e(yn,Kf),e(Dn,Gf),e(We,Xf),e(We,Je),w(Fn,Je,null),e(Je,Yf),e(Je,fo),e(fo,Zf),e(fo,wi),e(wi,em),e(fo,tm),e(fo,Pl),e(Pl,om),e(fo,sm),e(Je,nm),w(ns,Je,null),e(Je,rm),e(Je,ql),e(ql,am),e(Je,im),w(Bn,Je,null),u(o,Dp,m),u(o,mo,m),e(mo,rs),e(rs,Al),w(Mn,Al,null),e(mo,lm),e(mo,Ol),e(Ol,dm),u(o,yp,m),u(o,Re,m),w(En,Re,null),e(Re,cm),e(Re,Il),e(Il,pm),e(Re,hm),e(Re,xn),e(xn,um),e(xn,$i),e($i,fm),e(xn,mm),e(Re,gm),e(Re,zn),e(zn,_m),e(zn,Cn),e(Cn,vm),e(zn,Tm),e(Re,bm),e(Re,je),w(jn,je,null),e(je,km),e(je,go),e(go,wm),e(go,Di),e(Di,$m),e(go,Dm),e(go,Ll),e(Ll,ym),e(go,Fm),e(je,Bm),w(as,je,null),e(je,Mm),e(je,Sl),e(Sl,Em),e(je,xm),w(Pn,je,null),e(je,zm),e(je,Nl),e(Nl,Cm),e(je,jm),w(qn,je,null),u(o,Fp,m),u(o,_o,m),e(_o,is),e(is,Wl),w(An,Wl,null),e(_o,Pm),e(_o,Rl),e(Rl,qm),u(o,Bp,m),u(o,He,m),w(On,He,null),e(He,Am),e(He,Hl),e(Hl,Om),e(He,Im),e(He,In),e(In,Lm),e(In,yi),e(yi,Sm),e(In,Nm),e(He,Wm),e(He,Ln),e(Ln,Rm),e(Ln,Sn),e(Sn,Hm),e(Ln,Qm),e(He,Um),e(He,Ke),w(Nn,Ke,null),e(Ke,Vm),e(Ke,vo),e(vo,Jm),e(vo,Fi),e(Fi,Km),e(vo,Gm),e(vo,Ql),e(Ql,Xm),e(vo,Ym),e(Ke,Zm),w(ls,Ke,null),e(Ke,eg),e(Ke,Ul),e(Ul,tg),e(Ke,og),w(Wn,Ke,null),u(o,Mp,m),u(o,To,m),e(To,ds),e(ds,Vl),w(Rn,Vl,null),e(To,sg),e(To,Jl),e(Jl,ng),u(o,Ep,m),u(o,Qe,m),w(Hn,Qe,null),e(Qe,rg),e(Qe,Kl),e(Kl,ag),e(Qe,ig),e(Qe,Qn),e(Qn,lg),e(Qn,Bi),e(Bi,dg),e(Qn,cg),e(Qe,pg),e(Qe,Un),e(Un,hg),e(Un,Vn),e(Vn,ug),e(Un,fg),e(Qe,mg),e(Qe,Ge),w(Jn,Ge,null),e(Ge,gg),e(Ge,bo),e(bo,_g),e(bo,Mi),e(Mi,vg),e(bo,Tg),e(bo,Gl),e(Gl,bg),e(bo,kg),e(Ge,wg),w(cs,Ge,null),e(Ge,$g),e(Ge,Xl),e(Xl,Dg),e(Ge,yg),w(Kn,Ge,null),u(o,xp,m),u(o,ko,m),e(ko,ps),e(ps,Yl),w(Gn,Yl,null),e(ko,Fg),e(ko,Zl),e(Zl,Bg),u(o,zp,m),u(o,Ue,m),w(Xn,Ue,null),e(Ue,Mg),e(Ue,wo),e(wo,Eg),e(wo,ed),e(ed,xg),e(wo,zg),e(wo,td),e(td,Cg),e(wo,jg),e(Ue,Pg),e(Ue,Yn),e(Yn,qg),e(Yn,Ei),e(Ei,Ag),e(Yn,Og),e(Ue,Ig),e(Ue,Zn),e(Zn,Lg),e(Zn,er),e(er,Sg),e(Zn,Ng),e(Ue,Wg),e(Ue,Xe),w(tr,Xe,null),e(Xe,Rg),e(Xe,$o),e($o,Hg),e($o,xi),e(xi,Qg),e($o,Ug),e($o,od),e(od,Vg),e($o,Jg),e(Xe,Kg),w(hs,Xe,null),e(Xe,Gg),e(Xe,sd),e(sd,Xg),e(Xe,Yg),w(or,Xe,null),u(o,Cp,m),u(o,Do,m),e(Do,us),e(us,nd),w(sr,nd,null),e(Do,Zg),e(Do,rd),e(rd,e_),u(o,jp,m),u(o,Pe,m),w(nr,Pe,null),e(Pe,t_),e(Pe,ad),e(ad,o_),e(Pe,s_),e(Pe,rr),e(rr,n_),e(rr,zi),e(zi,r_),e(rr,a_),e(Pe,i_),e(Pe,ar),e(ar,l_),e(ar,ir),e(ir,d_),e(ar,c_),e(Pe,p_),w(fs,Pe,null),e(Pe,h_),e(Pe,Ye),w(lr,Ye,null),e(Ye,u_),e(Ye,yo),e(yo,f_),e(yo,Ci),e(Ci,m_),e(yo,g_),e(yo,id),e(id,__),e(yo,v_),e(Ye,T_),w(ms,Ye,null),e(Ye,b_),e(Ye,ld),e(ld,k_),e(Ye,w_),w(dr,Ye,null),u(o,Pp,m),u(o,Fo,m),e(Fo,gs),e(gs,dd),w(cr,dd,null),e(Fo,$_),e(Fo,cd),e(cd,D_),u(o,qp,m),u(o,qe,m),w(pr,qe,null),e(qe,y_),e(qe,hr),e(hr,F_),e(hr,pd),e(pd,B_),e(hr,M_),e(qe,E_),e(qe,ur),e(ur,x_),e(ur,ji),e(ji,z_),e(ur,C_),e(qe,j_),e(qe,fr),e(fr,P_),e(fr,mr),e(mr,q_),e(fr,A_),e(qe,O_),w(_s,qe,null),e(qe,I_),e(qe,Ze),w(gr,Ze,null),e(Ze,L_),e(Ze,Bo),e(Bo,S_),e(Bo,Pi),e(Pi,N_),e(Bo,W_),e(Bo,hd),e(hd,R_),e(Bo,H_),e(Ze,Q_),w(vs,Ze,null),e(Ze,U_),e(Ze,ud),e(ud,V_),e(Ze,J_),w(_r,Ze,null),u(o,Ap,m),u(o,Mo,m),e(Mo,Ts),e(Ts,fd),w(vr,fd,null),e(Mo,K_),e(Mo,md),e(md,G_),u(o,Op,m),u(o,Ae,m),w(Tr,Ae,null),e(Ae,X_),e(Ae,gd),e(gd,Y_),e(Ae,Z_),e(Ae,br),e(br,ev),e(br,qi),e(qi,tv),e(br,ov),e(Ae,sv),e(Ae,kr),e(kr,nv),e(kr,wr),e(wr,rv),e(kr,av),e(Ae,iv),w(bs,Ae,null),e(Ae,lv),e(Ae,et),w($r,et,null),e(et,dv),e(et,Eo),e(Eo,cv),e(Eo,Ai),e(Ai,pv),e(Eo,hv),e(Eo,_d),e(_d,uv),e(Eo,fv),e(et,mv),w(ks,et,null),e(et,gv),e(et,vd),e(vd,_v),e(et,vv),w(Dr,et,null),u(o,Ip,m),u(o,xo,m),e(xo,ws),e(ws,Td),w(yr,Td,null),e(xo,Tv),e(xo,bd),e(bd,bv),u(o,Lp,m),u(o,Oe,m),w(Fr,Oe,null),e(Oe,kv),e(Oe,kd),e(kd,wv),e(Oe,$v),e(Oe,Br),e(Br,Dv),e(Br,Oi),e(Oi,yv),e(Br,Fv),e(Oe,Bv),e(Oe,Mr),e(Mr,Mv),e(Mr,Er),e(Er,Ev),e(Mr,xv),e(Oe,zv),w($s,Oe,null),e(Oe,Cv),e(Oe,tt),w(xr,tt,null),e(tt,jv),e(tt,zo),e(zo,Pv),e(zo,Ii),e(Ii,qv),e(zo,Av),e(zo,wd),e(wd,Ov),e(zo,Iv),e(tt,Lv),w(Ds,tt,null),e(tt,Sv),e(tt,$d),e($d,Nv),e(tt,Wv),w(zr,tt,null),u(o,Sp,m),u(o,Co,m),e(Co,ys),e(ys,Dd),w(Cr,Dd,null),e(Co,Rv),e(Co,yd),e(yd,Hv),u(o,Np,m),u(o,Ie,m),w(jr,Ie,null),e(Ie,Qv),e(Ie,Fd),e(Fd,Uv),e(Ie,Vv),e(Ie,Pr),e(Pr,Jv),e(Pr,Li),e(Li,Kv),e(Pr,Gv),e(Ie,Xv),e(Ie,qr),e(qr,Yv),e(qr,Ar),e(Ar,Zv),e(qr,eT),e(Ie,tT),w(Fs,Ie,null),e(Ie,oT),e(Ie,ot),w(Or,ot,null),e(ot,sT),e(ot,jo),e(jo,nT),e(jo,Si),e(Si,rT),e(jo,aT),e(jo,Bd),e(Bd,iT),e(jo,lT),e(ot,dT),w(Bs,ot,null),e(ot,cT),e(ot,Md),e(Md,pT),e(ot,hT),w(Ir,ot,null),u(o,Wp,m),u(o,Po,m),e(Po,Ms),e(Ms,Ed),w(Lr,Ed,null),e(Po,uT),e(Po,xd),e(xd,fT),u(o,Rp,m),u(o,Le,m),w(Sr,Le,null),e(Le,mT),e(Le,qo),e(qo,gT),e(qo,zd),e(zd,_T),e(qo,vT),e(qo,Cd),e(Cd,TT),e(qo,bT),e(Le,kT),e(Le,Nr),e(Nr,wT),e(Nr,Ni),e(Ni,$T),e(Nr,DT),e(Le,yT),e(Le,Wr),e(Wr,FT),e(Wr,Rr),e(Rr,BT),e(Wr,MT),e(Le,ET),w(Es,Le,null),e(Le,xT),e(Le,st),w(Hr,st,null),e(st,zT),e(st,Ao),e(Ao,CT),e(Ao,Wi),e(Wi,jT),e(Ao,PT),e(Ao,jd),e(jd,qT),e(Ao,AT),e(st,OT),w(xs,st,null),e(st,IT),e(st,Pd),e(Pd,LT),e(st,ST),w(Qr,st,null),u(o,Hp,m),u(o,Oo,m),e(Oo,zs),e(zs,qd),w(Ur,qd,null),e(Oo,NT),e(Oo,Ad),e(Ad,WT),u(o,Qp,m),u(o,Be,m),w(Vr,Be,null),e(Be,RT),e(Be,Od),e(Od,HT),e(Be,QT),e(Be,Jr),e(Jr,UT),e(Jr,Ri),e(Ri,VT),e(Jr,JT),e(Be,KT),e(Be,Kr),e(Kr,GT),e(Kr,Gr),e(Gr,XT),e(Kr,YT),e(Be,ZT),e(Be,Id),e(Id,eb),e(Be,tb),e(Be,Bt),e(Bt,Ld),e(Ld,Xr),e(Xr,ob),e(Bt,sb),e(Bt,Sd),e(Sd,Yr),e(Yr,nb),e(Bt,rb),e(Bt,Nd),e(Nd,Zr),e(Zr,ab),e(Bt,ib),e(Bt,Wd),e(Wd,ea),e(ea,lb),e(Be,db),e(Be,nt),w(ta,nt,null),e(nt,cb),e(nt,Io),e(Io,pb),e(Io,Rd),e(Rd,hb),e(Io,ub),e(Io,Hd),e(Hd,fb),e(Io,mb),e(nt,gb),w(Cs,nt,null),e(nt,_b),e(nt,Qd),e(Qd,vb),e(nt,Tb),w(oa,nt,null),u(o,Up,m),u(o,Lo,m),e(Lo,js),e(js,Ud),w(sa,Ud,null),e(Lo,bb),e(Lo,Vd),e(Vd,kb),u(o,Vp,m),u(o,Me,m),w(na,Me,null),e(Me,wb),e(Me,ra),e(ra,$b),e(ra,Jd),e(Jd,Db),e(ra,yb),e(Me,Fb),e(Me,aa),e(aa,Bb),e(aa,Hi),e(Hi,Mb),e(aa,Eb),e(Me,xb),e(Me,ia),e(ia,zb),e(ia,la),e(la,Cb),e(ia,jb),e(Me,Pb),e(Me,Kd),e(Kd,qb),e(Me,Ab),e(Me,Mt),e(Mt,Gd),e(Gd,da),e(da,Ob),e(Mt,Ib),e(Mt,Xd),e(Xd,ca),e(ca,Lb),e(Mt,Sb),e(Mt,Yd),e(Yd,pa),e(pa,Nb),e(Mt,Wb),e(Mt,Zd),e(Zd,ha),e(ha,Rb),e(Me,Hb),e(Me,rt),w(ua,rt,null),e(rt,Qb),e(rt,So),e(So,Ub),e(So,ec),e(ec,Vb),e(So,Jb),e(So,tc),e(tc,Kb),e(So,Gb),e(rt,Xb),w(Ps,rt,null),e(rt,Yb),e(rt,oc),e(oc,Zb),e(rt,e1),w(fa,rt,null),u(o,Jp,m),u(o,No,m),e(No,qs),e(qs,sc),w(ma,sc,null),e(No,t1),e(No,nc),e(nc,o1),u(o,Kp,m),u(o,Ee,m),w(ga,Ee,null),e(Ee,s1),e(Ee,rc),e(rc,n1),e(Ee,r1),e(Ee,_a),e(_a,a1),e(_a,Qi),e(Qi,i1),e(_a,l1),e(Ee,d1),e(Ee,va),e(va,c1),e(va,Ta),e(Ta,p1),e(va,h1),e(Ee,u1),e(Ee,ac),e(ac,f1),e(Ee,m1),e(Ee,Et),e(Et,ic),e(ic,ba),e(ba,g1),e(Et,_1),e(Et,lc),e(lc,ka),e(ka,v1),e(Et,T1),e(Et,dc),e(dc,wa),e(wa,b1),e(Et,k1),e(Et,cc),e(cc,$a),e($a,w1),e(Ee,$1),e(Ee,at),w(Da,at,null),e(at,D1),e(at,Wo),e(Wo,y1),e(Wo,pc),e(pc,F1),e(Wo,B1),e(Wo,hc),e(hc,M1),e(Wo,E1),e(at,x1),w(As,at,null),e(at,z1),e(at,uc),e(uc,C1),e(at,j1),w(ya,at,null),u(o,Gp,m),u(o,Ro,m),e(Ro,Os),e(Os,fc),w(Fa,fc,null),e(Ro,P1),e(Ro,mc),e(mc,q1),u(o,Xp,m),u(o,xe,m),w(Ba,xe,null),e(xe,A1),e(xe,gc),e(gc,O1),e(xe,I1),e(xe,Ma),e(Ma,L1),e(Ma,Ui),e(Ui,S1),e(Ma,N1),e(xe,W1),e(xe,Ea),e(Ea,R1),e(Ea,xa),e(xa,H1),e(Ea,Q1),e(xe,U1),e(xe,_c),e(_c,V1),e(xe,J1),e(xe,xt),e(xt,vc),e(vc,za),e(za,K1),e(xt,G1),e(xt,Tc),e(Tc,Ca),e(Ca,X1),e(xt,Y1),e(xt,bc),e(bc,ja),e(ja,Z1),e(xt,ek),e(xt,kc),e(kc,Pa),e(Pa,tk),e(xe,ok),e(xe,it),w(qa,it,null),e(it,sk),e(it,Ho),e(Ho,nk),e(Ho,wc),e(wc,rk),e(Ho,ak),e(Ho,$c),e($c,ik),e(Ho,lk),e(it,dk),w(Is,it,null),e(it,ck),e(it,Dc),e(Dc,pk),e(it,hk),w(Aa,it,null),u(o,Yp,m),u(o,Qo,m),e(Qo,Ls),e(Ls,yc),w(Oa,yc,null),e(Qo,uk),e(Qo,Fc),e(Fc,fk),u(o,Zp,m),u(o,ze,m),w(Ia,ze,null),e(ze,mk),e(ze,Bc),e(Bc,gk),e(ze,_k),e(ze,La),e(La,vk),e(La,Vi),e(Vi,Tk),e(La,bk),e(ze,kk),e(ze,Sa),e(Sa,wk),e(Sa,Na),e(Na,$k),e(Sa,Dk),e(ze,yk),e(ze,Mc),e(Mc,Fk),e(ze,Bk),e(ze,zt),e(zt,Ec),e(Ec,Wa),e(Wa,Mk),e(zt,Ek),e(zt,xc),e(xc,Ra),e(Ra,xk),e(zt,zk),e(zt,zc),e(zc,Ha),e(Ha,Ck),e(zt,jk),e(zt,Cc),e(Cc,Qa),e(Qa,Pk),e(ze,qk),e(ze,lt),w(Ua,lt,null),e(lt,Ak),e(lt,Uo),e(Uo,Ok),e(Uo,jc),e(jc,Ik),e(Uo,Lk),e(Uo,Pc),e(Pc,Sk),e(Uo,Nk),e(lt,Wk),w(Ss,lt,null),e(lt,Rk),e(lt,qc),e(qc,Hk),e(lt,Qk),w(Va,lt,null),u(o,eh,m),u(o,Vo,m),e(Vo,Ns),e(Ns,Ac),w(Ja,Ac,null),e(Vo,Uk),e(Vo,Oc),e(Oc,Vk),u(o,th,m),u(o,Ce,m),w(Ka,Ce,null),e(Ce,Jk),e(Ce,Jo),e(Jo,Kk),e(Jo,Ic),e(Ic,Gk),e(Jo,Xk),e(Jo,Lc),e(Lc,Yk),e(Jo,Zk),e(Ce,e0),e(Ce,Ga),e(Ga,t0),e(Ga,Ji),e(Ji,o0),e(Ga,s0),e(Ce,n0),e(Ce,Xa),e(Xa,r0),e(Xa,Ya),e(Ya,a0),e(Xa,i0),e(Ce,l0),e(Ce,Sc),e(Sc,d0),e(Ce,c0),e(Ce,Ct),e(Ct,Nc),e(Nc,Za),e(Za,p0),e(Ct,h0),e(Ct,Wc),e(Wc,ei),e(ei,u0),e(Ct,f0),e(Ct,Rc),e(Rc,ti),e(ti,m0),e(Ct,g0),e(Ct,Hc),e(Hc,oi),e(oi,_0),e(Ce,v0),e(Ce,dt),w(si,dt,null),e(dt,T0),e(dt,Ko),e(Ko,b0),e(Ko,Qc),e(Qc,k0),e(Ko,w0),e(Ko,Uc),e(Uc,$0),e(Ko,D0),e(dt,y0),w(Ws,dt,null),e(dt,F0),e(dt,Vc),e(Vc,B0),e(dt,M0),w(ni,dt,null),oh=!0},p(o,[m]){const ri={};m&2&&(ri.$$scope={dirty:m,ctx:o}),os.$set(ri);const Jc={};m&2&&(Jc.$$scope={dirty:m,ctx:o}),ns.$set(Jc);const Kc={};m&2&&(Kc.$$scope={dirty:m,ctx:o}),as.$set(Kc);const Gc={};m&2&&(Gc.$$scope={dirty:m,ctx:o}),ls.$set(Gc);const ai={};m&2&&(ai.$$scope={dirty:m,ctx:o}),cs.$set(ai);const Xc={};m&2&&(Xc.$$scope={dirty:m,ctx:o}),hs.$set(Xc);const Yc={};m&2&&(Yc.$$scope={dirty:m,ctx:o}),fs.$set(Yc);const Zc={};m&2&&(Zc.$$scope={dirty:m,ctx:o}),ms.$set(Zc);const jt={};m&2&&(jt.$$scope={dirty:m,ctx:o}),_s.$set(jt);const ep={};m&2&&(ep.$$scope={dirty:m,ctx:o}),vs.$set(ep);const tp={};m&2&&(tp.$$scope={dirty:m,ctx:o}),bs.$set(tp);const op={};m&2&&(op.$$scope={dirty:m,ctx:o}),ks.$set(op);const sp={};m&2&&(sp.$$scope={dirty:m,ctx:o}),$s.$set(sp);const np={};m&2&&(np.$$scope={dirty:m,ctx:o}),Ds.$set(np);const rp={};m&2&&(rp.$$scope={dirty:m,ctx:o}),Fs.$set(rp);const ap={};m&2&&(ap.$$scope={dirty:m,ctx:o}),Bs.$set(ap);const ii={};m&2&&(ii.$$scope={dirty:m,ctx:o}),Es.$set(ii);const Pt={};m&2&&(Pt.$$scope={dirty:m,ctx:o}),xs.$set(Pt);const ip={};m&2&&(ip.$$scope={dirty:m,ctx:o}),Cs.$set(ip);const lp={};m&2&&(lp.$$scope={dirty:m,ctx:o}),Ps.$set(lp);const dp={};m&2&&(dp.$$scope={dirty:m,ctx:o}),As.$set(dp);const li={};m&2&&(li.$$scope={dirty:m,ctx:o}),Is.$set(li);const cp={};m&2&&(cp.$$scope={dirty:m,ctx:o}),Ss.$set(cp);const qt={};m&2&&(qt.$$scope={dirty:m,ctx:o}),Ws.$set(qt)},i(o){oh||($(_.$$.fragment,o),$(X.$$.fragment,o),$(tn.$$.fragment,o),$(on.$$.fragment,o),$(nn.$$.fragment,o),$(rn.$$.fragment,o),$(an.$$.fragment,o),$(dn.$$.fragment,o),$(cn.$$.fragment,o),$(un.$$.fragment,o),$(fn.$$.fragment,o),$(vn.$$.fragment,o),$(os.$$.fragment,o),$(Tn.$$.fragment,o),$(bn.$$.fragment,o),$(kn.$$.fragment,o),$(Fn.$$.fragment,o),$(ns.$$.fragment,o),$(Bn.$$.fragment,o),$(Mn.$$.fragment,o),$(En.$$.fragment,o),$(jn.$$.fragment,o),$(as.$$.fragment,o),$(Pn.$$.fragment,o),$(qn.$$.fragment,o),$(An.$$.fragment,o),$(On.$$.fragment,o),$(Nn.$$.fragment,o),$(ls.$$.fragment,o),$(Wn.$$.fragment,o),$(Rn.$$.fragment,o),$(Hn.$$.fragment,o),$(Jn.$$.fragment,o),$(cs.$$.fragment,o),$(Kn.$$.fragment,o),$(Gn.$$.fragment,o),$(Xn.$$.fragment,o),$(tr.$$.fragment,o),$(hs.$$.fragment,o),$(or.$$.fragment,o),$(sr.$$.fragment,o),$(nr.$$.fragment,o),$(fs.$$.fragment,o),$(lr.$$.fragment,o),$(ms.$$.fragment,o),$(dr.$$.fragment,o),$(cr.$$.fragment,o),$(pr.$$.fragment,o),$(_s.$$.fragment,o),$(gr.$$.fragment,o),$(vs.$$.fragment,o),$(_r.$$.fragment,o),$(vr.$$.fragment,o),$(Tr.$$.fragment,o),$(bs.$$.fragment,o),$($r.$$.fragment,o),$(ks.$$.fragment,o),$(Dr.$$.fragment,o),$(yr.$$.fragment,o),$(Fr.$$.fragment,o),$($s.$$.fragment,o),$(xr.$$.fragment,o),$(Ds.$$.fragment,o),$(zr.$$.fragment,o),$(Cr.$$.fragment,o),$(jr.$$.fragment,o),$(Fs.$$.fragment,o),$(Or.$$.fragment,o),$(Bs.$$.fragment,o),$(Ir.$$.fragment,o),$(Lr.$$.fragment,o),$(Sr.$$.fragment,o),$(Es.$$.fragment,o),$(Hr.$$.fragment,o),$(xs.$$.fragment,o),$(Qr.$$.fragment,o),$(Ur.$$.fragment,o),$(Vr.$$.fragment,o),$(ta.$$.fragment,o),$(Cs.$$.fragment,o),$(oa.$$.fragment,o),$(sa.$$.fragment,o),$(na.$$.fragment,o),$(ua.$$.fragment,o),$(Ps.$$.fragment,o),$(fa.$$.fragment,o),$(ma.$$.fragment,o),$(ga.$$.fragment,o),$(Da.$$.fragment,o),$(As.$$.fragment,o),$(ya.$$.fragment,o),$(Fa.$$.fragment,o),$(Ba.$$.fragment,o),$(qa.$$.fragment,o),$(Is.$$.fragment,o),$(Aa.$$.fragment,o),$(Oa.$$.fragment,o),$(Ia.$$.fragment,o),$(Ua.$$.fragment,o),$(Ss.$$.fragment,o),$(Va.$$.fragment,o),$(Ja.$$.fragment,o),$(Ka.$$.fragment,o),$(si.$$.fragment,o),$(Ws.$$.fragment,o),$(ni.$$.fragment,o),oh=!0)},o(o){D(_.$$.fragment,o),D(X.$$.fragment,o),D(tn.$$.fragment,o),D(on.$$.fragment,o),D(nn.$$.fragment,o),D(rn.$$.fragment,o),D(an.$$.fragment,o),D(dn.$$.fragment,o),D(cn.$$.fragment,o),D(un.$$.fragment,o),D(fn.$$.fragment,o),D(vn.$$.fragment,o),D(os.$$.fragment,o),D(Tn.$$.fragment,o),D(bn.$$.fragment,o),D(kn.$$.fragment,o),D(Fn.$$.fragment,o),D(ns.$$.fragment,o),D(Bn.$$.fragment,o),D(Mn.$$.fragment,o),D(En.$$.fragment,o),D(jn.$$.fragment,o),D(as.$$.fragment,o),D(Pn.$$.fragment,o),D(qn.$$.fragment,o),D(An.$$.fragment,o),D(On.$$.fragment,o),D(Nn.$$.fragment,o),D(ls.$$.fragment,o),D(Wn.$$.fragment,o),D(Rn.$$.fragment,o),D(Hn.$$.fragment,o),D(Jn.$$.fragment,o),D(cs.$$.fragment,o),D(Kn.$$.fragment,o),D(Gn.$$.fragment,o),D(Xn.$$.fragment,o),D(tr.$$.fragment,o),D(hs.$$.fragment,o),D(or.$$.fragment,o),D(sr.$$.fragment,o),D(nr.$$.fragment,o),D(fs.$$.fragment,o),D(lr.$$.fragment,o),D(ms.$$.fragment,o),D(dr.$$.fragment,o),D(cr.$$.fragment,o),D(pr.$$.fragment,o),D(_s.$$.fragment,o),D(gr.$$.fragment,o),D(vs.$$.fragment,o),D(_r.$$.fragment,o),D(vr.$$.fragment,o),D(Tr.$$.fragment,o),D(bs.$$.fragment,o),D($r.$$.fragment,o),D(ks.$$.fragment,o),D(Dr.$$.fragment,o),D(yr.$$.fragment,o),D(Fr.$$.fragment,o),D($s.$$.fragment,o),D(xr.$$.fragment,o),D(Ds.$$.fragment,o),D(zr.$$.fragment,o),D(Cr.$$.fragment,o),D(jr.$$.fragment,o),D(Fs.$$.fragment,o),D(Or.$$.fragment,o),D(Bs.$$.fragment,o),D(Ir.$$.fragment,o),D(Lr.$$.fragment,o),D(Sr.$$.fragment,o),D(Es.$$.fragment,o),D(Hr.$$.fragment,o),D(xs.$$.fragment,o),D(Qr.$$.fragment,o),D(Ur.$$.fragment,o),D(Vr.$$.fragment,o),D(ta.$$.fragment,o),D(Cs.$$.fragment,o),D(oa.$$.fragment,o),D(sa.$$.fragment,o),D(na.$$.fragment,o),D(ua.$$.fragment,o),D(Ps.$$.fragment,o),D(fa.$$.fragment,o),D(ma.$$.fragment,o),D(ga.$$.fragment,o),D(Da.$$.fragment,o),D(As.$$.fragment,o),D(ya.$$.fragment,o),D(Fa.$$.fragment,o),D(Ba.$$.fragment,o),D(qa.$$.fragment,o),D(Is.$$.fragment,o),D(Aa.$$.fragment,o),D(Oa.$$.fragment,o),D(Ia.$$.fragment,o),D(Ua.$$.fragment,o),D(Ss.$$.fragment,o),D(Va.$$.fragment,o),D(Ja.$$.fragment,o),D(Ka.$$.fragment,o),D(si.$$.fragment,o),D(Ws.$$.fragment,o),D(ni.$$.fragment,o),oh=!1},d(o){t(p),o&&t(F),o&&t(g),y(_),o&&t(V),o&&t(E),y(X),o&&t(re),o&&t(I),o&&t(ae),o&&t(ee),o&&t(ie),o&&t(L),o&&t(P),o&&t(te),o&&t(le),o&&t(h),o&&t(up),o&&t(Tt),o&&t(fp),o&&t(ao),y(tn),o&&t(mp),o&&t(Se),y(on),y(nn),o&&t(gp),o&&t(lo),y(rn),o&&t(_p),o&&t(_t),y(an),o&&t(vp),o&&t(co),y(dn),o&&t(Tp),o&&t(vt),y(cn),o&&t(bp),o&&t(po),y(un),o&&t(kp),o&&t(Ne),y(fn),y(vn),y(os),y(Tn),o&&t(wp),o&&t(uo),y(bn),o&&t($p),o&&t(We),y(kn),y(Fn),y(ns),y(Bn),o&&t(Dp),o&&t(mo),y(Mn),o&&t(yp),o&&t(Re),y(En),y(jn),y(as),y(Pn),y(qn),o&&t(Fp),o&&t(_o),y(An),o&&t(Bp),o&&t(He),y(On),y(Nn),y(ls),y(Wn),o&&t(Mp),o&&t(To),y(Rn),o&&t(Ep),o&&t(Qe),y(Hn),y(Jn),y(cs),y(Kn),o&&t(xp),o&&t(ko),y(Gn),o&&t(zp),o&&t(Ue),y(Xn),y(tr),y(hs),y(or),o&&t(Cp),o&&t(Do),y(sr),o&&t(jp),o&&t(Pe),y(nr),y(fs),y(lr),y(ms),y(dr),o&&t(Pp),o&&t(Fo),y(cr),o&&t(qp),o&&t(qe),y(pr),y(_s),y(gr),y(vs),y(_r),o&&t(Ap),o&&t(Mo),y(vr),o&&t(Op),o&&t(Ae),y(Tr),y(bs),y($r),y(ks),y(Dr),o&&t(Ip),o&&t(xo),y(yr),o&&t(Lp),o&&t(Oe),y(Fr),y($s),y(xr),y(Ds),y(zr),o&&t(Sp),o&&t(Co),y(Cr),o&&t(Np),o&&t(Ie),y(jr),y(Fs),y(Or),y(Bs),y(Ir),o&&t(Wp),o&&t(Po),y(Lr),o&&t(Rp),o&&t(Le),y(Sr),y(Es),y(Hr),y(xs),y(Qr),o&&t(Hp),o&&t(Oo),y(Ur),o&&t(Qp),o&&t(Be),y(Vr),y(ta),y(Cs),y(oa),o&&t(Up),o&&t(Lo),y(sa),o&&t(Vp),o&&t(Me),y(na),y(ua),y(Ps),y(fa),o&&t(Jp),o&&t(No),y(ma),o&&t(Kp),o&&t(Ee),y(ga),y(Da),y(As),y(ya),o&&t(Gp),o&&t(Ro),y(Fa),o&&t(Xp),o&&t(xe),y(Ba),y(qa),y(Is),y(Aa),o&&t(Yp),o&&t(Qo),y(Oa),o&&t(Zp),o&&t(ze),y(Ia),y(Ua),y(Ss),y(Va),o&&t(eh),o&&t(Vo),y(Ja),o&&t(th),o&&t(Ce),y(Ka),y(si),y(Ws),y(ni)}}}const PF={local:"distilbert",sections:[{local:"overview",title:"Overview"},{local:"transformers.DistilBertConfig",title:"DistilBertConfig"},{local:"transformers.DistilBertTokenizer",title:"DistilBertTokenizer"},{local:"transformers.DistilBertTokenizerFast",title:"DistilBertTokenizerFast"},{local:"transformers.DistilBertModel",title:"DistilBertModel"},{local:"transformers.DistilBertForMaskedLM",title:"DistilBertForMaskedLM"},{local:"transformers.DistilBertForSequenceClassification",title:"DistilBertForSequenceClassification"},{local:"transformers.DistilBertForMultipleChoice",title:"DistilBertForMultipleChoice"},{local:"transformers.DistilBertForTokenClassification",title:"DistilBertForTokenClassification"},{local:"transformers.DistilBertForQuestionAnswering",title:"DistilBertForQuestionAnswering"},{local:"transformers.TFDistilBertModel",title:"TFDistilBertModel"},{local:"transformers.TFDistilBertForMaskedLM",title:"TFDistilBertForMaskedLM"},{local:"transformers.TFDistilBertForSequenceClassification",title:"TFDistilBertForSequenceClassification"},{local:"transformers.TFDistilBertForMultipleChoice",title:"TFDistilBertForMultipleChoice"},{local:"transformers.TFDistilBertForTokenClassification",title:"TFDistilBertForTokenClassification"},{local:"transformers.TFDistilBertForQuestionAnswering",title:"TFDistilBertForQuestionAnswering"},{local:"transformers.FlaxDistilBertModel",title:"FlaxDistilBertModel"},{local:"transformers.FlaxDistilBertForMaskedLM",title:"FlaxDistilBertForMaskedLM"},{local:"transformers.FlaxDistilBertForSequenceClassification",title:"FlaxDistilBertForSequenceClassification"},{local:"transformers.FlaxDistilBertForMultipleChoice",title:"FlaxDistilBertForMultipleChoice"},{local:"transformers.FlaxDistilBertForTokenClassification",title:"FlaxDistilBertForTokenClassification"},{local:"transformers.FlaxDistilBertForQuestionAnswering",title:"FlaxDistilBertForQuestionAnswering"}],title:"DistilBERT"};function qF(C,p,F){let{fw:g}=p;return C.$$set=v=>{"fw"in v&&F(0,g=v.fw)},[g]}class WF extends rF{constructor(p){super();aF(this,p,qF,jF,iF,{fw:0})}}export{WF as default,PF as metadata};
