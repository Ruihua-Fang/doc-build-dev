import{S as Po,i as Io,s as No,e as o,k as d,w,t as r,M as qo,c as n,d as a,m as h,a as s,x as b,h as i,b as l,F as t,g as f,y as $,q as y,o as V,B as x}from"../../chunks/vendor-4833417e.js";import{T as Fo}from"../../chunks/Tip-fffd6df1.js";import{D as tt}from"../../chunks/Docstring-4f315ed9.js";import{C as Ra}from"../../chunks/CodeBlock-6a3d1b46.js";import{I as at}from"../../chunks/IconCopyLink-4b81c553.js";import"../../chunks/CopyButton-dacfbfaf.js";function zo(Q){let p,E,m,u,j;return{c(){p=o("p"),E=r("Although the recipe for forward pass needs to be defined within this function, one should call the "),m=o("code"),u=r("Module"),j=r(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(g){p=n(g,"P",{});var _=s(p);E=i(_,"Although the recipe for forward pass needs to be defined within this function, one should call the "),m=n(_,"CODE",{});var M=s(m);u=i(M,"Module"),M.forEach(a),j=i(_,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),_.forEach(a)},m(g,_){f(g,p,_),t(p,E),t(p,m),t(m,u),t(p,j)},d(g){g&&a(p)}}}function Do(Q){let p,E,m,u,j;return{c(){p=o("p"),E=r("Although the recipe for forward pass needs to be defined within this function, one should call the "),m=o("code"),u=r("Module"),j=r(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(g){p=n(g,"P",{});var _=s(p);E=i(_,"Although the recipe for forward pass needs to be defined within this function, one should call the "),m=n(_,"CODE",{});var M=s(m);u=i(M,"Module"),M.forEach(a),j=i(_,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),_.forEach(a)},m(g,_){f(g,p,_),t(p,E),t(p,m),t(m,u),t(p,j)},d(g){g&&a(p)}}}function Lo(Q){let p,E,m,u,j,g,_,M,Tt,ot,q,U,Le,Y,jt,Se,At,nt,K,Mt,ee,kt,Ft,st,Ve,Pt,rt,xe,It,it,Ee,te,Nt,ae,qt,zt,lt,Ce,Dt,ct,Te,oe,Lt,Oe,St,Ot,dt,F,Ht,ne,Wt,Ut,se,Kt,Rt,ht,z,R,He,re,Zt,We,Gt,ft,v,ie,Bt,D,Xt,je,Jt,Qt,le,Yt,ea,ta,L,aa,Ae,oa,na,Me,sa,ra,ia,Ue,la,ca,ce,pt,S,Z,Ke,de,da,Re,ha,mt,k,he,fa,fe,pa,pe,ma,ua,ga,C,me,_a,O,va,ke,wa,ba,Ze,$a,ya,Va,G,xa,Ge,Ea,Ca,ue,ut,H,B,Be,ge,Ta,Xe,ja,gt,A,_e,Aa,Je,Ma,ka,ve,Fa,we,Pa,Ia,Na,T,be,qa,W,za,Fe,Da,La,Qe,Sa,Oa,Ha,X,Wa,Ye,Ua,Ka,$e,_t;return g=new at({}),Y=new at({}),re=new at({}),ie=new tt({props:{name:"class transformers.VanConfig",anchor:"transformers.VanConfig",parameters:[{name:"image_size",val:" = 224"},{name:"num_channels",val:" = 3"},{name:"patch_sizes",val:" = [7, 3, 3, 3]"},{name:"strides",val:" = [4, 2, 2, 2]"},{name:"hidden_sizes",val:" = [64, 128, 320, 512]"},{name:"depths",val:" = [3, 3, 12, 3]"},{name:"mlp_expansions",val:" = [8, 8, 4, 4]"},{name:"hidden_act",val:" = 'gelu'"},{name:"initializer_range",val:" = 0.02"},{name:"layer_norm_eps",val:" = 1e-06"},{name:"layer_scale_init_value",val:" = 0.01"},{name:"drop_path_rate",val:" = 0.0"},{name:"dropout_rate",val:" = 0.0"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16027/src/transformers/models/van/configuration_van.py#L28",parametersDescription:[{anchor:"transformers.VanConfig.image_size",description:`<strong>image_size</strong> (<code>int</code>, <em>optional</em>, defaults to 224) &#x2014;
The image size the network is train on.`,name:"image_size"},{anchor:"transformers.VanConfig.num_channels",description:`<strong>num_channels</strong> (<code>int</code>, <em>optional</em>, defaults to 3) &#x2014;
The number of input channels.`,name:"num_channels"},{anchor:"transformers.VanConfig.patch_sizes",description:`<strong>patch_sizes</strong> (<code>List[int]</code>, <em>optional</em>, defaults to [7, 3, 3, 3]) &#x2014;
Patch size to use in each stage&#x2019;s embedding layer.`,name:"patch_sizes"},{anchor:"transformers.VanConfig.strides",description:`<strong>strides</strong> (<code>List[int]</code>, <em>optional</em>, defaults to [4, 2, 2, 2]) &#x2014;
Stride size to use in each stage&#x2019;s embedding layer to downsample the input.`,name:"strides"},{anchor:"transformers.VanConfig.hidden_sizes",description:`<strong>hidden_sizes</strong> (<code>List[int]</code>, <em>optional</em>, defaults to [64, 128, 320, 512]) &#x2014;
Dimensionality (hidden size) at each stage.`,name:"hidden_sizes"},{anchor:"transformers.VanConfig.depths",description:`<strong>depths</strong> (<code>List[int]</code>, <em>optional</em>, defaults to [3, 3, 12, 3]) &#x2014;
Depth (number of layers) for each stage.`,name:"depths"},{anchor:"transformers.VanConfig.mlp_expansions",description:`<strong>mlp_expansions</strong> (<code>List[int]</code>, <em>optional</em>, defaults to [8, 8, 4, 4]) &#x2014;
The expansion factor for mlp layer at each stage.`,name:"mlp_expansions"},{anchor:"transformers.VanConfig.hidden_act",description:`<strong>hidden_act</strong> (<code>str</code> or <code>function</code>, <em>optional</em>, defaults to <code>&quot;gelu&quot;</code>) &#x2014;
The non-linear activation function (function or string) in each block. If string, <code>&quot;gelu&quot;</code>, <code>&quot;relu&quot;</code>,
<code>&quot;selu&quot;</code> and <code>&quot;gelu_new&quot;</code> are supported.`,name:"hidden_act"},{anchor:"transformers.VanConfig.initializer_range",description:`<strong>initializer_range</strong> (<code>float</code>, <em>optional</em>, defaults to 0.02) &#x2014;
The standard deviation of the truncated_normal_initializer for initializing all weight matrices.`,name:"initializer_range"},{anchor:"transformers.VanConfig.layer_norm_eps",description:`<strong>layer_norm_eps</strong> (<code>float</code>, <em>optional</em>, defaults to 1e-12) &#x2014;
The epsilon used by the layer normalization layers.`,name:"layer_norm_eps"},{anchor:"transformers.VanConfig.layer_scale_init_value",description:`<strong>layer_scale_init_value</strong> (<code>float</code>, <em>optional</em>, defaults to 1e-2) &#x2014;
The initial value for layer scaling.`,name:"layer_scale_init_value"},{anchor:"transformers.VanConfig.drop_path_rate",description:`<strong>drop_path_rate</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
The drop rate for stochastic depth.`,name:"drop_path_rate"},{anchor:"transformers.VanConfig.dropout_rate",description:`<strong>dropout_rate</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
The drop rate for dropout.`,name:"dropout_rate"}]}}),ce=new Ra({props:{code:`from transformers import VanModel, VanConfig

# Initializing a Van van-base style configuration
configuration = VanConfig()
# Initializing a model from the van-base style configuration
model = VanModel(configuration)
# Accessing the model configuration
configuration = model.config`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> VanModel, VanConfig

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a Van van-base style configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = VanConfig()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a model from the van-base style configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = VanModel(configuration)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Accessing the model configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = model.config`}}),de=new at({}),he=new tt({props:{name:"class transformers.VanModel",anchor:"transformers.VanModel",parameters:[{name:"config",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16027/src/transformers/models/van/modeling_van.py#L467",parametersDescription:[{anchor:"transformers.VanModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16027/en/model_doc/van#transformers.VanConfig">VanConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16027/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),me=new tt({props:{name:"forward",anchor:"transformers.VanModel.forward",parameters:[{name:"pixel_values",val:""},{name:"output_hidden_states",val:" = None"},{name:"return_dict",val:" = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16027/src/transformers/models/van/modeling_van.py#L477",parametersDescription:[{anchor:"transformers.VanModel.forward.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Pixel values can be obtained using <a href="/docs/transformers/pr_16027/en/model_doc/auto#transformers.AutoFeatureExtractor">AutoFeatureExtractor</a>. See
<code>AutoFeatureExtractor.__call__()</code>for details.`,name:"pixel_values"},{anchor:"transformers.VanModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.VanModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16027/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],returnDescription:`
<p>A <code>transformers.models.van.modeling_van.VanModelOutput</code>or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16027/en/model_doc/van#transformers.VanConfig"
>VanConfig</a>) and inputs.</p>
<ul>
<li><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) \u2014 Last hidden states (final feature map) of the last stage of the model.</li>
<li><strong>pooler_output</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.dim[-1])</code>) \u2014 Global average pooling of the last feature map followed by a layernorm.</li>
<li><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of each stage) of shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the model at the output of each stage.</li>
</ul>
`}}),G=new Fo({props:{$$slots:{default:[zo]},$$scope:{ctx:Q}}}),ue=new Ra({props:{code:`from transformers import AutoFeatureExtractor, VanModel
import torch
from datasets import load_dataset

dataset = load_dataset("huggingface/cats-image")
image = dataset["test"]["image"][0]

feature_extractor = AutoFeatureExtractor.from_pretrained("van-base")
model = VanModel.from_pretrained("van-base")

inputs = feature_extractor(image, return_tensors="pt")

with torch.no_grad():
    outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state
list(last_hidden_states.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoFeatureExtractor, VanModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;huggingface/cats-image&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>image = dataset[<span class="hljs-string">&quot;test&quot;</span>][<span class="hljs-string">&quot;image&quot;</span>][<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = AutoFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;van-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = VanModel.from_pretrained(<span class="hljs-string">&quot;van-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = feature_extractor(image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(last_hidden_states.shape)
[<span class="hljs-number">1</span>, <span class="hljs-number">512</span>, <span class="hljs-number">7</span>, <span class="hljs-number">7</span>]`}}),ge=new at({}),_e=new tt({props:{name:"class transformers.VanForImageClassification",anchor:"transformers.VanForImageClassification",parameters:[{name:"config",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16027/src/transformers/models/van/modeling_van.py#L518",parametersDescription:[{anchor:"transformers.VanForImageClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16027/en/model_doc/van#transformers.VanConfig">VanConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16027/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),be=new tt({props:{name:"forward",anchor:"transformers.VanForImageClassification.forward",parameters:[{name:"pixel_values",val:" = None"},{name:"labels",val:" = None"},{name:"output_hidden_states",val:" = None"},{name:"return_dict",val:" = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16027/src/transformers/models/van/modeling_van.py#L555",parametersDescription:[{anchor:"transformers.VanForImageClassification.forward.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Pixel values can be obtained using <a href="/docs/transformers/pr_16027/en/model_doc/auto#transformers.AutoFeatureExtractor">AutoFeatureExtractor</a>. See
<code>AutoFeatureExtractor.__call__()</code>for details.`,name:"pixel_values"},{anchor:"transformers.VanForImageClassification.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.VanForImageClassification.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16027/en/main_classes/output#transformers.file_utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.VanForImageClassification.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the image classification/regression loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>. If <code>config.num_labels == 1</code> a regression loss is computed (Mean-Square loss), If
<code>config.num_labels &gt; 1</code> a classification loss is computed (Cross-Entropy).`,name:"labels"}],returnDescription:`
<p>A <code>transformers.models.van.modeling_van.VanClassifierOutput</code>or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16027/en/model_doc/van#transformers.VanConfig"
>VanConfig</a>) and inputs.</p>
<ul>
<li><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification (or regression if config.num_labels==1) loss.</li>
<li><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.num_labels)</code>) \u2014 Classification (or regression if config.num_labels==1) scores (before SoftMax).</li>
<li><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of each stage) of shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the model at the output of each stage.</li>
</ul>
`}}),X=new Fo({props:{$$slots:{default:[Do]},$$scope:{ctx:Q}}}),$e=new Ra({props:{code:`from transformers import AutoFeatureExtractor, VanForImageClassification
import torch
from datasets import load_dataset

dataset = load_dataset("huggingface/cats-image")
image = dataset["test"]["image"][0]

feature_extractor = AutoFeatureExtractor.from_pretrained("van-base")
model = VanForImageClassification.from_pretrained("van-base")

inputs = feature_extractor(image, return_tensors="pt")

with torch.no_grad():
    logits = model(**inputs).logits

# model predicts one of the 1000 ImageNet classes
predicted_label = logits.argmax(-1).item()
print(model.config.id2label[predicted_label])`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoFeatureExtractor, VanForImageClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;huggingface/cats-image&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>image = dataset[<span class="hljs-string">&quot;test&quot;</span>][<span class="hljs-string">&quot;image&quot;</span>][<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = AutoFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;van-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = VanForImageClassification.from_pretrained(<span class="hljs-string">&quot;van-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = feature_extractor(image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># model predicts one of the 1000 ImageNet classes</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_label = logits.argmax(-<span class="hljs-number">1</span>).item()
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(model.config.id2label[predicted_label])
tabby, tabby cat`}}),{c(){p=o("meta"),E=d(),m=o("h1"),u=o("a"),j=o("span"),w(g.$$.fragment),_=d(),M=o("span"),Tt=r("VAN"),ot=d(),q=o("h2"),U=o("a"),Le=o("span"),w(Y.$$.fragment),jt=d(),Se=o("span"),At=r("Overview"),nt=d(),K=o("p"),Mt=r("The VAN model was proposed in "),ee=o("a"),kt=r("Visual Attention Network"),Ft=r(" by Meng-Hao Guo, Cheng-Ze Lu, Zheng-Ning Liu, Ming-Ming Cheng, Shi-Min Hu."),st=d(),Ve=o("p"),Pt=r("This paper introduces a new attention layer based on convolution operations able to capture both local and distant relationships. This is done by combining normal and large kernels convolution layers. The later uses a dilated convolution to capture distant correlations."),rt=d(),xe=o("p"),It=r("The abstract from the paper is the following:"),it=d(),Ee=o("p"),te=o("em"),Nt=r("While originally designed for natural language processing tasks, the self-attention mechanism has recently taken various computer vision areas by storm. However, the 2D nature of images brings three challenges for applying self-attention in computer vision. (1) Treating images as 1D sequences neglects their 2D structures. (2) The quadratic complexity is too expensive for high-resolution images. (3) It only captures spatial adaptability but ignores channel adaptability. In this paper, we propose a novel large kernel attention (LKA) module to enable self-adaptive and long-range correlations in self-attention while avoiding the above issues. We further introduce a novel neural network based on LKA, namely Visual Attention Network (VAN). While extremely simple, VAN outperforms the state-of-the-art vision transformers and convolutional neural networks with a large margin in extensive experiments, including image classification, object detection, semantic segmentation, instance segmentation, etc. Code is available at "),ae=o("a"),qt=r("this https URL"),zt=r("."),lt=d(),Ce=o("p"),Dt=r("Tips:"),ct=d(),Te=o("ul"),oe=o("li"),Lt=r("VAN doesn not have an embedding layer, thus the "),Oe=o("code"),St=r("hidden_states"),Ot=r(" will have a length equal to the number of stages."),dt=d(),F=o("p"),Ht=r("This model was contributed by "),ne=o("a"),Wt=r("Francesco"),Ut=r(". The original code can be found "),se=o("a"),Kt=r("here"),Rt=r("."),ht=d(),z=o("h2"),R=o("a"),He=o("span"),w(re.$$.fragment),Zt=d(),We=o("span"),Gt=r("VanConfig"),ft=d(),v=o("div"),w(ie.$$.fragment),Bt=d(),D=o("p"),Xt=r("This is the configuration class to store the configuration of a "),je=o("a"),Jt=r("VanModel"),Qt=r(`. It is used to instantiate a Van model
according to the specified arguments, defining the model architecture. Instantiating a configuration with the
defaults will yield a similar configuration to that of the ConvNeXT `),le=o("a"),Yt=r("van-base"),ea=r(`
architecture.`),ta=d(),L=o("p"),aa=r("Configuration objects inherit from "),Ae=o("a"),oa=r("PretrainedConfig"),na=r(` and can be used to control the model outputs. Read the
documentation from `),Me=o("a"),sa=r("PretrainedConfig"),ra=r(" for more information."),ia=d(),Ue=o("p"),la=r("Example:"),ca=d(),w(ce.$$.fragment),pt=d(),S=o("h2"),Z=o("a"),Ke=o("span"),w(de.$$.fragment),da=d(),Re=o("span"),ha=r("VanModel"),mt=d(),k=o("div"),w(he.$$.fragment),fa=d(),fe=o("p"),pa=r(`The bare Van model outputting raw features without any specific head on top. Note, van does not have an embedding layer.
This model is a PyTorch `),pe=o("a"),ma=r("torch.nn.Module"),ua=r(` subclass. Use it
as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),ga=d(),C=o("div"),w(me.$$.fragment),_a=d(),O=o("p"),va=r("The "),ke=o("a"),wa=r("VanModel"),ba=r(" forward method, overrides the "),Ze=o("code"),$a=r("__call__"),ya=r(" special method."),Va=d(),w(G.$$.fragment),xa=d(),Ge=o("p"),Ea=r("Example:"),Ca=d(),w(ue.$$.fragment),ut=d(),H=o("h2"),B=o("a"),Be=o("span"),w(ge.$$.fragment),Ta=d(),Xe=o("span"),ja=r("VanForImageClassification"),gt=d(),A=o("div"),w(_e.$$.fragment),Aa=d(),Je=o("p"),Ma=r(`Van Model with an image classification head on top (a linear layer on top of the pooled features), e.g. for
ImageNet.`),ka=d(),ve=o("p"),Fa=r("This model is a PyTorch "),we=o("a"),Pa=r("torch.nn.Module"),Ia=r(` subclass. Use it
as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),Na=d(),T=o("div"),w(be.$$.fragment),qa=d(),W=o("p"),za=r("The "),Fe=o("a"),Da=r("VanForImageClassification"),La=r(" forward method, overrides the "),Qe=o("code"),Sa=r("__call__"),Oa=r(" special method."),Ha=d(),w(X.$$.fragment),Wa=d(),Ye=o("p"),Ua=r("Example:"),Ka=d(),w($e.$$.fragment),this.h()},l(e){const c=qo('[data-svelte="svelte-1phssyn"]',document.head);p=n(c,"META",{name:!0,content:!0}),c.forEach(a),E=h(e),m=n(e,"H1",{class:!0});var ye=s(m);u=n(ye,"A",{id:!0,class:!0,href:!0});var et=s(u);j=n(et,"SPAN",{});var Za=s(j);b(g.$$.fragment,Za),Za.forEach(a),et.forEach(a),_=h(ye),M=n(ye,"SPAN",{});var Ga=s(M);Tt=i(Ga,"VAN"),Ga.forEach(a),ye.forEach(a),ot=h(e),q=n(e,"H2",{class:!0});var vt=s(q);U=n(vt,"A",{id:!0,class:!0,href:!0});var Ba=s(U);Le=n(Ba,"SPAN",{});var Xa=s(Le);b(Y.$$.fragment,Xa),Xa.forEach(a),Ba.forEach(a),jt=h(vt),Se=n(vt,"SPAN",{});var Ja=s(Se);At=i(Ja,"Overview"),Ja.forEach(a),vt.forEach(a),nt=h(e),K=n(e,"P",{});var wt=s(K);Mt=i(wt,"The VAN model was proposed in "),ee=n(wt,"A",{href:!0,rel:!0});var Qa=s(ee);kt=i(Qa,"Visual Attention Network"),Qa.forEach(a),Ft=i(wt," by Meng-Hao Guo, Cheng-Ze Lu, Zheng-Ning Liu, Ming-Ming Cheng, Shi-Min Hu."),wt.forEach(a),st=h(e),Ve=n(e,"P",{});var Ya=s(Ve);Pt=i(Ya,"This paper introduces a new attention layer based on convolution operations able to capture both local and distant relationships. This is done by combining normal and large kernels convolution layers. The later uses a dilated convolution to capture distant correlations."),Ya.forEach(a),rt=h(e),xe=n(e,"P",{});var eo=s(xe);It=i(eo,"The abstract from the paper is the following:"),eo.forEach(a),it=h(e),Ee=n(e,"P",{});var to=s(Ee);te=n(to,"EM",{});var bt=s(te);Nt=i(bt,"While originally designed for natural language processing tasks, the self-attention mechanism has recently taken various computer vision areas by storm. However, the 2D nature of images brings three challenges for applying self-attention in computer vision. (1) Treating images as 1D sequences neglects their 2D structures. (2) The quadratic complexity is too expensive for high-resolution images. (3) It only captures spatial adaptability but ignores channel adaptability. In this paper, we propose a novel large kernel attention (LKA) module to enable self-adaptive and long-range correlations in self-attention while avoiding the above issues. We further introduce a novel neural network based on LKA, namely Visual Attention Network (VAN). While extremely simple, VAN outperforms the state-of-the-art vision transformers and convolutional neural networks with a large margin in extensive experiments, including image classification, object detection, semantic segmentation, instance segmentation, etc. Code is available at "),ae=n(bt,"A",{href:!0,rel:!0});var ao=s(ae);qt=i(ao,"this https URL"),ao.forEach(a),zt=i(bt,"."),bt.forEach(a),to.forEach(a),lt=h(e),Ce=n(e,"P",{});var oo=s(Ce);Dt=i(oo,"Tips:"),oo.forEach(a),ct=h(e),Te=n(e,"UL",{});var no=s(Te);oe=n(no,"LI",{});var $t=s(oe);Lt=i($t,"VAN doesn not have an embedding layer, thus the "),Oe=n($t,"CODE",{});var so=s(Oe);St=i(so,"hidden_states"),so.forEach(a),Ot=i($t," will have a length equal to the number of stages."),$t.forEach(a),no.forEach(a),dt=h(e),F=n(e,"P",{});var Pe=s(F);Ht=i(Pe,"This model was contributed by "),ne=n(Pe,"A",{href:!0,rel:!0});var ro=s(ne);Wt=i(ro,"Francesco"),ro.forEach(a),Ut=i(Pe,". The original code can be found "),se=n(Pe,"A",{href:!0,rel:!0});var io=s(se);Kt=i(io,"here"),io.forEach(a),Rt=i(Pe,"."),Pe.forEach(a),ht=h(e),z=n(e,"H2",{class:!0});var yt=s(z);R=n(yt,"A",{id:!0,class:!0,href:!0});var lo=s(R);He=n(lo,"SPAN",{});var co=s(He);b(re.$$.fragment,co),co.forEach(a),lo.forEach(a),Zt=h(yt),We=n(yt,"SPAN",{});var ho=s(We);Gt=i(ho,"VanConfig"),ho.forEach(a),yt.forEach(a),ft=h(e),v=n(e,"DIV",{class:!0});var P=s(v);b(ie.$$.fragment,P),Bt=h(P),D=n(P,"P",{});var Ie=s(D);Xt=i(Ie,"This is the configuration class to store the configuration of a "),je=n(Ie,"A",{href:!0});var fo=s(je);Jt=i(fo,"VanModel"),fo.forEach(a),Qt=i(Ie,`. It is used to instantiate a Van model
according to the specified arguments, defining the model architecture. Instantiating a configuration with the
defaults will yield a similar configuration to that of the ConvNeXT `),le=n(Ie,"A",{href:!0,rel:!0});var po=s(le);Yt=i(po,"van-base"),po.forEach(a),ea=i(Ie,`
architecture.`),Ie.forEach(a),ta=h(P),L=n(P,"P",{});var Ne=s(L);aa=i(Ne,"Configuration objects inherit from "),Ae=n(Ne,"A",{href:!0});var mo=s(Ae);oa=i(mo,"PretrainedConfig"),mo.forEach(a),na=i(Ne,` and can be used to control the model outputs. Read the
documentation from `),Me=n(Ne,"A",{href:!0});var uo=s(Me);sa=i(uo,"PretrainedConfig"),uo.forEach(a),ra=i(Ne," for more information."),Ne.forEach(a),ia=h(P),Ue=n(P,"P",{});var go=s(Ue);la=i(go,"Example:"),go.forEach(a),ca=h(P),b(ce.$$.fragment,P),P.forEach(a),pt=h(e),S=n(e,"H2",{class:!0});var Vt=s(S);Z=n(Vt,"A",{id:!0,class:!0,href:!0});var _o=s(Z);Ke=n(_o,"SPAN",{});var vo=s(Ke);b(de.$$.fragment,vo),vo.forEach(a),_o.forEach(a),da=h(Vt),Re=n(Vt,"SPAN",{});var wo=s(Re);ha=i(wo,"VanModel"),wo.forEach(a),Vt.forEach(a),mt=h(e),k=n(e,"DIV",{class:!0});var qe=s(k);b(he.$$.fragment,qe),fa=h(qe),fe=n(qe,"P",{});var xt=s(fe);pa=i(xt,`The bare Van model outputting raw features without any specific head on top. Note, van does not have an embedding layer.
This model is a PyTorch `),pe=n(xt,"A",{href:!0,rel:!0});var bo=s(pe);ma=i(bo,"torch.nn.Module"),bo.forEach(a),ua=i(xt,` subclass. Use it
as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),xt.forEach(a),ga=h(qe),C=n(qe,"DIV",{class:!0});var I=s(C);b(me.$$.fragment,I),_a=h(I),O=n(I,"P",{});var ze=s(O);va=i(ze,"The "),ke=n(ze,"A",{href:!0});var $o=s(ke);wa=i($o,"VanModel"),$o.forEach(a),ba=i(ze," forward method, overrides the "),Ze=n(ze,"CODE",{});var yo=s(Ze);$a=i(yo,"__call__"),yo.forEach(a),ya=i(ze," special method."),ze.forEach(a),Va=h(I),b(G.$$.fragment,I),xa=h(I),Ge=n(I,"P",{});var Vo=s(Ge);Ea=i(Vo,"Example:"),Vo.forEach(a),Ca=h(I),b(ue.$$.fragment,I),I.forEach(a),qe.forEach(a),ut=h(e),H=n(e,"H2",{class:!0});var Et=s(H);B=n(Et,"A",{id:!0,class:!0,href:!0});var xo=s(B);Be=n(xo,"SPAN",{});var Eo=s(Be);b(ge.$$.fragment,Eo),Eo.forEach(a),xo.forEach(a),Ta=h(Et),Xe=n(Et,"SPAN",{});var Co=s(Xe);ja=i(Co,"VanForImageClassification"),Co.forEach(a),Et.forEach(a),gt=h(e),A=n(e,"DIV",{class:!0});var J=s(A);b(_e.$$.fragment,J),Aa=h(J),Je=n(J,"P",{});var To=s(Je);Ma=i(To,`Van Model with an image classification head on top (a linear layer on top of the pooled features), e.g. for
ImageNet.`),To.forEach(a),ka=h(J),ve=n(J,"P",{});var Ct=s(ve);Fa=i(Ct,"This model is a PyTorch "),we=n(Ct,"A",{href:!0,rel:!0});var jo=s(we);Pa=i(jo,"torch.nn.Module"),jo.forEach(a),Ia=i(Ct,` subclass. Use it
as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),Ct.forEach(a),Na=h(J),T=n(J,"DIV",{class:!0});var N=s(T);b(be.$$.fragment,N),qa=h(N),W=n(N,"P",{});var De=s(W);za=i(De,"The "),Fe=n(De,"A",{href:!0});var Ao=s(Fe);Da=i(Ao,"VanForImageClassification"),Ao.forEach(a),La=i(De," forward method, overrides the "),Qe=n(De,"CODE",{});var Mo=s(Qe);Sa=i(Mo,"__call__"),Mo.forEach(a),Oa=i(De," special method."),De.forEach(a),Ha=h(N),b(X.$$.fragment,N),Wa=h(N),Ye=n(N,"P",{});var ko=s(Ye);Ua=i(ko,"Example:"),ko.forEach(a),Ka=h(N),b($e.$$.fragment,N),N.forEach(a),J.forEach(a),this.h()},h(){l(p,"name","hf:doc:metadata"),l(p,"content",JSON.stringify(So)),l(u,"id","van"),l(u,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(u,"href","#van"),l(m,"class","relative group"),l(U,"id","overview"),l(U,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(U,"href","#overview"),l(q,"class","relative group"),l(ee,"href","https://arxiv.org/abs/2202.09741"),l(ee,"rel","nofollow"),l(ae,"href","https://github.com/Visual-Attention-Network/VAN-Classification"),l(ae,"rel","nofollow"),l(ne,"href","https://huggingface.co/Francesco"),l(ne,"rel","nofollow"),l(se,"href","https://github.com/Visual-Attention-Network/VAN-Classification"),l(se,"rel","nofollow"),l(R,"id","transformers.VanConfig"),l(R,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(R,"href","#transformers.VanConfig"),l(z,"class","relative group"),l(je,"href","/docs/transformers/pr_16027/en/model_doc/van#transformers.VanModel"),l(le,"href","https://huggingface.co/van-base"),l(le,"rel","nofollow"),l(Ae,"href","/docs/transformers/pr_16027/en/main_classes/configuration#transformers.PretrainedConfig"),l(Me,"href","/docs/transformers/pr_16027/en/main_classes/configuration#transformers.PretrainedConfig"),l(v,"class","docstring"),l(Z,"id","transformers.VanModel"),l(Z,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(Z,"href","#transformers.VanModel"),l(S,"class","relative group"),l(pe,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),l(pe,"rel","nofollow"),l(ke,"href","/docs/transformers/pr_16027/en/model_doc/van#transformers.VanModel"),l(C,"class","docstring"),l(k,"class","docstring"),l(B,"id","transformers.VanForImageClassification"),l(B,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),l(B,"href","#transformers.VanForImageClassification"),l(H,"class","relative group"),l(we,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),l(we,"rel","nofollow"),l(Fe,"href","/docs/transformers/pr_16027/en/model_doc/van#transformers.VanForImageClassification"),l(T,"class","docstring"),l(A,"class","docstring")},m(e,c){t(document.head,p),f(e,E,c),f(e,m,c),t(m,u),t(u,j),$(g,j,null),t(m,_),t(m,M),t(M,Tt),f(e,ot,c),f(e,q,c),t(q,U),t(U,Le),$(Y,Le,null),t(q,jt),t(q,Se),t(Se,At),f(e,nt,c),f(e,K,c),t(K,Mt),t(K,ee),t(ee,kt),t(K,Ft),f(e,st,c),f(e,Ve,c),t(Ve,Pt),f(e,rt,c),f(e,xe,c),t(xe,It),f(e,it,c),f(e,Ee,c),t(Ee,te),t(te,Nt),t(te,ae),t(ae,qt),t(te,zt),f(e,lt,c),f(e,Ce,c),t(Ce,Dt),f(e,ct,c),f(e,Te,c),t(Te,oe),t(oe,Lt),t(oe,Oe),t(Oe,St),t(oe,Ot),f(e,dt,c),f(e,F,c),t(F,Ht),t(F,ne),t(ne,Wt),t(F,Ut),t(F,se),t(se,Kt),t(F,Rt),f(e,ht,c),f(e,z,c),t(z,R),t(R,He),$(re,He,null),t(z,Zt),t(z,We),t(We,Gt),f(e,ft,c),f(e,v,c),$(ie,v,null),t(v,Bt),t(v,D),t(D,Xt),t(D,je),t(je,Jt),t(D,Qt),t(D,le),t(le,Yt),t(D,ea),t(v,ta),t(v,L),t(L,aa),t(L,Ae),t(Ae,oa),t(L,na),t(L,Me),t(Me,sa),t(L,ra),t(v,ia),t(v,Ue),t(Ue,la),t(v,ca),$(ce,v,null),f(e,pt,c),f(e,S,c),t(S,Z),t(Z,Ke),$(de,Ke,null),t(S,da),t(S,Re),t(Re,ha),f(e,mt,c),f(e,k,c),$(he,k,null),t(k,fa),t(k,fe),t(fe,pa),t(fe,pe),t(pe,ma),t(fe,ua),t(k,ga),t(k,C),$(me,C,null),t(C,_a),t(C,O),t(O,va),t(O,ke),t(ke,wa),t(O,ba),t(O,Ze),t(Ze,$a),t(O,ya),t(C,Va),$(G,C,null),t(C,xa),t(C,Ge),t(Ge,Ea),t(C,Ca),$(ue,C,null),f(e,ut,c),f(e,H,c),t(H,B),t(B,Be),$(ge,Be,null),t(H,Ta),t(H,Xe),t(Xe,ja),f(e,gt,c),f(e,A,c),$(_e,A,null),t(A,Aa),t(A,Je),t(Je,Ma),t(A,ka),t(A,ve),t(ve,Fa),t(ve,we),t(we,Pa),t(ve,Ia),t(A,Na),t(A,T),$(be,T,null),t(T,qa),t(T,W),t(W,za),t(W,Fe),t(Fe,Da),t(W,La),t(W,Qe),t(Qe,Sa),t(W,Oa),t(T,Ha),$(X,T,null),t(T,Wa),t(T,Ye),t(Ye,Ua),t(T,Ka),$($e,T,null),_t=!0},p(e,[c]){const ye={};c&2&&(ye.$$scope={dirty:c,ctx:e}),G.$set(ye);const et={};c&2&&(et.$$scope={dirty:c,ctx:e}),X.$set(et)},i(e){_t||(y(g.$$.fragment,e),y(Y.$$.fragment,e),y(re.$$.fragment,e),y(ie.$$.fragment,e),y(ce.$$.fragment,e),y(de.$$.fragment,e),y(he.$$.fragment,e),y(me.$$.fragment,e),y(G.$$.fragment,e),y(ue.$$.fragment,e),y(ge.$$.fragment,e),y(_e.$$.fragment,e),y(be.$$.fragment,e),y(X.$$.fragment,e),y($e.$$.fragment,e),_t=!0)},o(e){V(g.$$.fragment,e),V(Y.$$.fragment,e),V(re.$$.fragment,e),V(ie.$$.fragment,e),V(ce.$$.fragment,e),V(de.$$.fragment,e),V(he.$$.fragment,e),V(me.$$.fragment,e),V(G.$$.fragment,e),V(ue.$$.fragment,e),V(ge.$$.fragment,e),V(_e.$$.fragment,e),V(be.$$.fragment,e),V(X.$$.fragment,e),V($e.$$.fragment,e),_t=!1},d(e){a(p),e&&a(E),e&&a(m),x(g),e&&a(ot),e&&a(q),x(Y),e&&a(nt),e&&a(K),e&&a(st),e&&a(Ve),e&&a(rt),e&&a(xe),e&&a(it),e&&a(Ee),e&&a(lt),e&&a(Ce),e&&a(ct),e&&a(Te),e&&a(dt),e&&a(F),e&&a(ht),e&&a(z),x(re),e&&a(ft),e&&a(v),x(ie),x(ce),e&&a(pt),e&&a(S),x(de),e&&a(mt),e&&a(k),x(he),x(me),x(G),x(ue),e&&a(ut),e&&a(H),x(ge),e&&a(gt),e&&a(A),x(_e),x(be),x(X),x($e)}}}const So={local:"van",sections:[{local:"overview",title:"Overview"},{local:"transformers.VanConfig",title:"VanConfig"},{local:"transformers.VanModel",title:"VanModel"},{local:"transformers.VanForImageClassification",title:"VanForImageClassification"}],title:"VAN"};function Oo(Q,p,E){let{fw:m}=p;return Q.$$set=u=>{"fw"in u&&E(0,m=u.fw)},[m]}class Go extends Po{constructor(p){super();Io(this,p,Oo,Lo,No,{fw:0})}}export{Go as default,So as metadata};
