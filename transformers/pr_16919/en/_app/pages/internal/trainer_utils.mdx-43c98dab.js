import{S as xi,i as Ti,s as Oi,e as r,k as i,w as v,t as o,M as Ci,c as s,d as t,m as c,a as n,x as w,h as l,b as m,F as e,g as b,y as $,q as y,o as E,B as D,v as Ai,L as La}from"../../chunks/vendor-6b77c823.js";import{D as O}from"../../chunks/Docstring-1088f2fb.js";import{C as Ia}from"../../chunks/CodeBlock-3a8b25a8.js";import{I as it}from"../../chunks/IconCopyLink-7a11ce68.js";import{E as Ua}from"../../chunks/ExampleCodeBlock-5212b321.js";function Ui(C){let u,j;return u=new Ia({props:{code:"debug_overflow = DebugUnderflowOverflow(model)",highlighted:"debug_overflow = DebugUnderflowOverflow(model)"}}),{c(){v(u.$$.fragment)},l(h){w(u.$$.fragment,h)},m(h,k){$(u,h,k),j=!0},p:La,i(h){j||(y(u.$$.fragment,h),j=!0)},o(h){E(u.$$.fragment,h),j=!1},d(h){D(u,h)}}}function Li(C){let u,j;return u=new Ia({props:{code:`Detected inf/nan during batch_number=0
Last 21 forward frames:
abs min  abs max  metadata
[...]
                  encoder.block.2.layer.1.DenseReluDense.wi_0 Linear
2.17e-07 4.50e+00 weight
1.79e-06 4.65e+00 input[0]
2.68e-06 3.70e+01 output
                  encoder.block.2.layer.1.DenseReluDense.wi_1 Linear
8.08e-07 2.66e+01 weight
1.79e-06 4.65e+00 input[0]
1.27e-04 2.37e+02 output
                  encoder.block.2.layer.1.DenseReluDense.wo Linear
1.01e-06 6.44e+00 weight
0.00e+00 9.74e+03 input[0]
3.18e-04 6.27e+04 output
                  encoder.block.2.layer.1.DenseReluDense T5DenseGatedGeluDense
1.79e-06 4.65e+00 input[0]
3.18e-04 6.27e+04 output
                  encoder.block.2.layer.1.dropout Dropout
3.18e-04 6.27e+04 input[0]
0.00e+00      inf output`,highlighted:`<span class="hljs-attribute">Detected</span> inf/nan during batch_number=<span class="hljs-number">0</span>
<span class="hljs-attribute">Last</span> <span class="hljs-number">21</span> forward frames:
<span class="hljs-attribute">abs</span> min  abs max  metadata<span class="hljs-meta">
[...]</span>
                  <span class="hljs-attribute">encoder</span>.block.<span class="hljs-number">2</span>.layer.<span class="hljs-number">1</span>.DenseReluDense.wi_0 Linear
<span class="hljs-attribute">2</span>.<span class="hljs-number">17</span>e-<span class="hljs-number">07</span> <span class="hljs-number">4</span>.<span class="hljs-number">50</span>e+<span class="hljs-number">00</span> weight
<span class="hljs-attribute">1</span>.<span class="hljs-number">79</span>e-<span class="hljs-number">06</span> <span class="hljs-number">4</span>.<span class="hljs-number">65</span>e+<span class="hljs-number">00</span> input[<span class="hljs-number">0</span>]
<span class="hljs-attribute">2</span>.<span class="hljs-number">68</span>e-<span class="hljs-number">06</span> <span class="hljs-number">3</span>.<span class="hljs-number">70</span>e+<span class="hljs-number">01</span> output
                  <span class="hljs-attribute">encoder</span>.block.<span class="hljs-number">2</span>.layer.<span class="hljs-number">1</span>.DenseReluDense.wi_1 Linear
<span class="hljs-attribute">8</span>.<span class="hljs-number">08</span>e-<span class="hljs-number">07</span> <span class="hljs-number">2</span>.<span class="hljs-number">66</span>e+<span class="hljs-number">01</span> weight
<span class="hljs-attribute">1</span>.<span class="hljs-number">79</span>e-<span class="hljs-number">06</span> <span class="hljs-number">4</span>.<span class="hljs-number">65</span>e+<span class="hljs-number">00</span> input[<span class="hljs-number">0</span>]
<span class="hljs-attribute">1</span>.<span class="hljs-number">27</span>e-<span class="hljs-number">04</span> <span class="hljs-number">2</span>.<span class="hljs-number">37</span>e+<span class="hljs-number">02</span> output
                  <span class="hljs-attribute">encoder</span>.block.<span class="hljs-number">2</span>.layer.<span class="hljs-number">1</span>.DenseReluDense.wo Linear
<span class="hljs-attribute">1</span>.<span class="hljs-number">01</span>e-<span class="hljs-number">06</span> <span class="hljs-number">6</span>.<span class="hljs-number">44</span>e+<span class="hljs-number">00</span> weight
<span class="hljs-attribute">0</span>.<span class="hljs-number">00</span>e+<span class="hljs-number">00</span> <span class="hljs-number">9</span>.<span class="hljs-number">74</span>e+<span class="hljs-number">03</span> input[<span class="hljs-number">0</span>]
<span class="hljs-attribute">3</span>.<span class="hljs-number">18</span>e-<span class="hljs-number">04</span> <span class="hljs-number">6</span>.<span class="hljs-number">27</span>e+<span class="hljs-number">04</span> output
                  <span class="hljs-attribute">encoder</span>.block.<span class="hljs-number">2</span>.layer.<span class="hljs-number">1</span>.DenseReluDense T5DenseGatedGeluDense
<span class="hljs-attribute">1</span>.<span class="hljs-number">79</span>e-<span class="hljs-number">06</span> <span class="hljs-number">4</span>.<span class="hljs-number">65</span>e+<span class="hljs-number">00</span> input[<span class="hljs-number">0</span>]
<span class="hljs-attribute">3</span>.<span class="hljs-number">18</span>e-<span class="hljs-number">04</span> <span class="hljs-number">6</span>.<span class="hljs-number">27</span>e+<span class="hljs-number">04</span> output
                  <span class="hljs-attribute">encoder</span>.block.<span class="hljs-number">2</span>.layer.<span class="hljs-number">1</span>.dropout Dropout
<span class="hljs-attribute">3</span>.<span class="hljs-number">18</span>e-<span class="hljs-number">04</span> <span class="hljs-number">6</span>.<span class="hljs-number">27</span>e+<span class="hljs-number">04</span> input[<span class="hljs-number">0</span>]
<span class="hljs-attribute">0</span>.<span class="hljs-number">00</span>e+<span class="hljs-number">00</span>      inf output`}}),{c(){v(u.$$.fragment)},l(h){w(u.$$.fragment,h)},m(h,k){$(u,h,k),j=!0},p:La,i(h){j||(y(u.$$.fragment,h),j=!0)},o(h){E(u.$$.fragment,h),j=!1},d(h){D(u,h)}}}function Ii(C){let u,j,h,k,L;return k=new Ia({props:{code:"debug_overflow = DebugUnderflowOverflow(model, max_frames_to_save=100)",highlighted:'debug_overflow = DebugUnderflowOverflow(model, max_frames_to_save=<span class="hljs-number">100</span>)'}}),{c(){u=r("p"),j=o("By default the last 21 frames are printed. You can change the default to adjust for your needs. For example :"),h=i(),v(k.$$.fragment)},l(P){u=s(P,"P",{});var I=n(u);j=l(I,"By default the last 21 frames are printed. You can change the default to adjust for your needs. For example :"),I.forEach(t),h=c(P),w(k.$$.fragment,P)},m(P,I){b(P,u,I),e(u,j),b(P,h,I),$(k,P,I),L=!0},p:La,i(P){L||(y(k.$$.fragment,P),L=!0)},o(P){E(k.$$.fragment,P),L=!1},d(P){P&&t(u),P&&t(h),D(k,P)}}}function zi(C){let u,j;return u=new Ia({props:{code:"debug_overflow = DebugUnderflowOverflow(model, trace_batch_nums=[1, 3])",highlighted:'debug_overflow = DebugUnderflowOverflow(model, trace_batch_nums=[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>])'}}),{c(){v(u.$$.fragment)},l(h){w(u.$$.fragment,h)},m(h,k){$(u,h,k),j=!0},p:La,i(h){j||(y(u.$$.fragment,h),j=!0)},o(h){E(u.$$.fragment,h),j=!1},d(h){D(u,h)}}}function Si(C){let u,j;return u=new Ia({props:{code:"debug_overflow = DebugUnderflowOverflow(model, trace_batch_nums=[1, 3], abort_after_batch_num=3)",highlighted:'debug_overflow = DebugUnderflowOverflow(model, trace_batch_nums=[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>], abort_after_batch_num=<span class="hljs-number">3</span>)'}}),{c(){v(u.$$.fragment)},l(h){w(u.$$.fragment,h)},m(h,k){$(u,h,k),j=!0},p:La,i(h){j||(y(u.$$.fragment,h),j=!0)},o(h){E(u.$$.fragment,h),j=!1},d(h){D(u,h)}}}function Hi(C){let u,j,h,k,L,P,I,ct,Dr,za,Z,jr,Ke,kr,Pr,Sa,Ye,xr,Ha,H,ee,pt,me,Tr,dt,Or,Na,N,ge,Cr,ht,Ar,Ga,G,be,Ur,ut,Lr,Va,V,_e,Ir,T,zr,ft,Sr,Hr,mt,Nr,Gr,gt,Vr,Mr,bt,Rr,Fr,Ma,M,ve,qr,_t,Br,Ra,R,te,vt,we,Kr,wt,Yr,Fa,F,$e,Wr,$t,Jr,qa,q,ae,yt,ye,Qr,Et,Xr,Ba,g,Ee,Zr,Dt,es,ts,jt,as,rs,kt,Pt,ss,ns,xt,os,ls,B,We,is,Tt,cs,ps,Je,ds,Ot,hs,us,Qe,fs,Ct,ms,gs,At,bs,_s,K,Xe,vs,Ut,ws,$s,Ze,ys,Lt,Es,Ds,et,js,It,ks,Ps,zt,xs,Ts,St,Ht,Os,Cs,Nt,As,Us,Gt,Vt,Ls,Is,Mt,zs,Ss,re,De,Hs,je,Ns,Rt,Gs,Vs,Ms,se,ke,Rs,Ft,Fs,Ka,Y,ne,qt,Pe,qs,Bt,Bs,Ya,x,xe,Ks,Te,Ys,Kt,Ws,Js,Qs,Oe,Xs,Yt,Zs,en,tn,z,Ce,an,Wt,rn,sn,Ae,nn,Jt,on,ln,cn,oe,Ue,pn,Le,dn,Qt,hn,un,fn,le,Ie,mn,ze,gn,Xt,bn,_n,Wa,W,ie,Zt,Se,vn,ea,wn,Ja,p,He,$n,J,yn,ta,En,Dn,aa,jn,kn,Pn,ra,xn,Tn,Ne,sa,On,Cn,na,An,Un,oa,Ln,In,la,zn,Sn,ce,Hn,U,Nn,ia,Gn,Vn,ca,Mn,Rn,pa,Fn,qn,Bn,Ge,Ve,Kn,da,Yn,Wn,Jn,ha,Qn,Xn,Me,Zn,ua,eo,to,ao,pe,ro,Q,so,fa,no,oo,ma,lo,io,co,ga,po,ho,Re,uo,ba,fo,mo,go,de,bo,_a,_o,vo,va,wo,$o,wa,yo,Eo,Fe,Do,$a,jo,ko,Po,he,xo,ya,To,Oo,Ea,Co,Ao,Da,Uo,Lo,ja,Io,zo,ue,So,ka,Ho,No,tt,Pa,Go,Vo,Mo,X,Ro,xa,Fo,qo,Ta,Bo,Ko,Qa;return P=new it({}),me=new it({}),ge=new O({props:{name:"class transformers.EvalPrediction",anchor:"transformers.EvalPrediction",parameters:[{name:"predictions",val:": typing.Union[numpy.ndarray, typing.Tuple[numpy.ndarray]]"},{name:"label_ids",val:": typing.Union[numpy.ndarray, typing.Tuple[numpy.ndarray]]"}],parametersDescription:[{anchor:"transformers.EvalPrediction.predictions",description:"<strong>predictions</strong> (<code>np.ndarray</code>) &#x2014; Predictions of the model.",name:"predictions"},{anchor:"transformers.EvalPrediction.label_ids",description:"<strong>label_ids</strong> (<code>np.ndarray</code>) &#x2014; Targets to be matched.",name:"label_ids"}],source:"https://github.com/huggingface/transformers/blob/pr_16919/src/transformers/trainer_utils.py#L67"}}),be=new O({props:{name:"class transformers.IntervalStrategy",anchor:"transformers.IntervalStrategy",parameters:[{name:"value",val:""},{name:"names",val:" = None"},{name:"module",val:" = None"},{name:"qualname",val:" = None"},{name:"type",val:" = None"},{name:"start",val:" = 1"}],source:"https://github.com/huggingface/transformers/blob/pr_16919/src/transformers/trainer_utils.py#L115"}}),_e=new O({props:{name:"transformers.set_seed",anchor:"transformers.set_seed",parameters:[{name:"seed",val:": int"}],parametersDescription:[{anchor:"transformers.set_seed.seed",description:"<strong>seed</strong> (<code>int</code>) &#x2014; The seed to set.",name:"seed"}],source:"https://github.com/huggingface/transformers/blob/pr_16919/src/transformers/trainer_utils.py#L50"}}),ve=new O({props:{name:"transformers.torch_distributed_zero_first",anchor:"transformers.torch_distributed_zero_first",parameters:[{name:"local_rank",val:": int"}],parametersDescription:[{anchor:"transformers.torch_distributed_zero_first.local_rank",description:"<strong>local_rank</strong> (<code>int</code>) &#x2014; The rank of the local process.",name:"local_rank"}],source:"https://github.com/huggingface/transformers/blob/pr_16919/src/transformers/trainer_pt_utils.py#L212"}}),we=new it({}),$e=new O({props:{name:"class transformers.trainer_callback.CallbackHandler",anchor:"transformers.trainer_callback.CallbackHandler",parameters:[{name:"callbacks",val:""},{name:"model",val:""},{name:"tokenizer",val:""},{name:"optimizer",val:""},{name:"lr_scheduler",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16919/src/transformers/trainer_callback.py#L284"}}),ye=new it({}),Ee=new O({props:{name:"class transformers.trainer_pt_utils.DistributedTensorGatherer",anchor:"transformers.trainer_pt_utils.DistributedTensorGatherer",parameters:[{name:"world_size",val:""},{name:"num_samples",val:""},{name:"make_multiple_of",val:" = None"},{name:"padding_index",val:" = -100"}],parametersDescription:[{anchor:"transformers.trainer_pt_utils.DistributedTensorGatherer.world_size",description:`<strong>world_size</strong> (<code>int</code>) &#x2014;
The number of processes used in the distributed training.`,name:"world_size"},{anchor:"transformers.trainer_pt_utils.DistributedTensorGatherer.num_samples",description:`<strong>num_samples</strong> (<code>int</code>) &#x2014;
The number of samples in our dataset.`,name:"num_samples"},{anchor:"transformers.trainer_pt_utils.DistributedTensorGatherer.make_multiple_of",description:`<strong>make_multiple_of</strong> (<code>int</code>, <em>optional</em>) &#x2014;
If passed, the class assumes the datasets passed to each process are made to be a multiple of this argument
(by adding samples).`,name:"make_multiple_of"},{anchor:"transformers.trainer_pt_utils.DistributedTensorGatherer.padding_index",description:`<strong>padding_index</strong> (<code>int</code>, <em>optional</em>, defaults to -100) &#x2014;
The padding index to use if the arrays don&#x2019;t all have the same sequence length.`,name:"padding_index"}],source:"https://github.com/huggingface/transformers/blob/pr_16919/src/transformers/trainer_pt_utils.py#L338"}}),De=new O({props:{name:"add_arrays",anchor:"transformers.trainer_pt_utils.DistributedTensorGatherer.add_arrays",parameters:[{name:"arrays",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16919/src/transformers/trainer_pt_utils.py#L399"}}),ke=new O({props:{name:"finalize",anchor:"transformers.trainer_pt_utils.DistributedTensorGatherer.finalize",parameters:[],source:"https://github.com/huggingface/transformers/blob/pr_16919/src/transformers/trainer_pt_utils.py#L435"}}),Pe=new it({}),xe=new O({props:{name:"class transformers.HfArgumentParser",anchor:"transformers.HfArgumentParser",parameters:[{name:"dataclass_types",val:": typing.Union[DataClassType, typing.Iterable[DataClassType]]"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16919/src/transformers/hf_argparser.py#L44"}}),Ce=new O({props:{name:"parse_args_into_dataclasses",anchor:"transformers.HfArgumentParser.parse_args_into_dataclasses",parameters:[{name:"args",val:" = None"},{name:"return_remaining_strings",val:" = False"},{name:"look_for_args_file",val:" = True"},{name:"args_filename",val:" = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16919/src/transformers/hf_argparser.py#L168",returnDescription:`
<ul>
<li>the dataclass instances in the same order as they were passed to the initializer.abspath</li>
<li>if applicable, an additional namespace for more (non-dataclass backed) arguments added to the parser
after initialization.</li>
<li>The potential list of remaining argument strings. (same as argparse.ArgumentParser.parse_known_args)</li>
</ul>
`,returnType:`
<p>Tuple consisting of</p>
`}}),Ue=new O({props:{name:"parse_dict",anchor:"transformers.HfArgumentParser.parse_dict",parameters:[{name:"args",val:": dict"}],source:"https://github.com/huggingface/transformers/blob/pr_16919/src/transformers/hf_argparser.py#L241"}}),Ie=new O({props:{name:"parse_json_file",anchor:"transformers.HfArgumentParser.parse_json_file",parameters:[{name:"json_file",val:": str"}],source:"https://github.com/huggingface/transformers/blob/pr_16919/src/transformers/hf_argparser.py#L227"}}),Se=new it({}),He=new O({props:{name:"class transformers.debug_utils.DebugUnderflowOverflow",anchor:"transformers.debug_utils.DebugUnderflowOverflow",parameters:[{name:"model",val:""},{name:"max_frames_to_save",val:" = 21"},{name:"trace_batch_nums",val:" = []"},{name:"abort_after_batch_num",val:" = None"}],parametersDescription:[{anchor:"transformers.debug_utils.DebugUnderflowOverflow.model",description:`<strong>model</strong> (<code>nn.Module</code>) &#x2014;
The model to debug.`,name:"model"},{anchor:"transformers.debug_utils.DebugUnderflowOverflow.max_frames_to_save",description:`<strong>max_frames_to_save</strong> (<code>int</code>, <em>optional</em>, defaults to 21) &#x2014;
How many frames back to record`,name:"max_frames_to_save"},{anchor:"transformers.debug_utils.DebugUnderflowOverflow.trace_batch_nums(List[int],",description:`<strong>trace_batch_nums(<code>List[int]</code>,</strong> <em>optional</em>, defaults to <code>[]</code>) &#x2014;
Which batch numbers to trace (turns detection off)`,name:"trace_batch_nums(List[int],"},{anchor:"transformers.debug_utils.DebugUnderflowOverflow.abort_after_batch_num",description:"<strong>abort_after_batch_num</strong>  (`int&#x201C;, <em>optional</em>) &#x2014;\nWhether to abort after a certain batch number has finished",name:"abort_after_batch_num"}],source:"https://github.com/huggingface/transformers/blob/pr_16919/src/transformers/debug_utils.py#L27"}}),ce=new Ua({props:{anchor:"transformers.debug_utils.DebugUnderflowOverflow.example",$$slots:{default:[Ui]},$$scope:{ctx:C}}}),pe=new Ua({props:{anchor:"transformers.debug_utils.DebugUnderflowOverflow.example-2",$$slots:{default:[Li]},$$scope:{ctx:C}}}),de=new Ua({props:{anchor:"transformers.debug_utils.DebugUnderflowOverflow.example-3",$$slots:{default:[Ii]},$$scope:{ctx:C}}}),he=new Ua({props:{anchor:"transformers.debug_utils.DebugUnderflowOverflow.example-4",$$slots:{default:[zi]},$$scope:{ctx:C}}}),ue=new Ua({props:{anchor:"transformers.debug_utils.DebugUnderflowOverflow.example-5",$$slots:{default:[Si]},$$scope:{ctx:C}}}),{c(){u=r("meta"),j=i(),h=r("h1"),k=r("a"),L=r("span"),v(P.$$.fragment),I=i(),ct=r("span"),Dr=o("Utilities for Trainer"),za=i(),Z=r("p"),jr=o("This page lists all the utility functions used by "),Ke=r("a"),kr=o("Trainer"),Pr=o("."),Sa=i(),Ye=r("p"),xr=o("Most of those are only useful if you are studying the code of the Trainer in the library."),Ha=i(),H=r("h2"),ee=r("a"),pt=r("span"),v(me.$$.fragment),Tr=i(),dt=r("span"),Or=o("Utilities"),Na=i(),N=r("div"),v(ge.$$.fragment),Cr=i(),ht=r("p"),Ar=o("Evaluation output (always contains labels), to be used to compute metrics."),Ga=i(),G=r("div"),v(be.$$.fragment),Ur=i(),ut=r("p"),Lr=o("An enumeration."),Va=i(),V=r("div"),v(_e.$$.fragment),Ir=i(),T=r("p"),zr=o("Helper function for reproducible behavior to set the seed in "),ft=r("code"),Sr=o("random"),Hr=o(", "),mt=r("code"),Nr=o("numpy"),Gr=o(", "),gt=r("code"),Vr=o("torch"),Mr=o(" and/or "),bt=r("code"),Rr=o("tf"),Fr=o(" (if installed)."),Ma=i(),M=r("div"),v(ve.$$.fragment),qr=i(),_t=r("p"),Br=o("Decorator to make all processes in distributed training wait for each local_master to do something."),Ra=i(),R=r("h2"),te=r("a"),vt=r("span"),v(we.$$.fragment),Kr=i(),wt=r("span"),Yr=o("Callbacks internals"),Fa=i(),F=r("div"),v($e.$$.fragment),Wr=i(),$t=r("p"),Jr=o("Internal class that just calls the list of callbacks in order."),qa=i(),q=r("h2"),ae=r("a"),yt=r("span"),v(ye.$$.fragment),Qr=i(),Et=r("span"),Xr=o("Distributed Evaluation"),Ba=i(),g=r("div"),v(Ee.$$.fragment),Zr=i(),Dt=r("p"),es=o("A class responsible for properly gathering tensors (or nested list/tuple of tensors) on the CPU by chunks."),ts=i(),jt=r("p"),as=o(`If our dataset has 16 samples with a batch size of 2 on 3 processes and we gather then transfer on CPU at every
step, our sampler will generate the following indices:`),rs=i(),kt=r("p"),Pt=r("code"),ss=o("[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1]"),ns=i(),xt=r("p"),os=o(`to get something of size a multiple of 3 (so that each process gets the same dataset length). Then process 0, 1 and
2 will be responsible of making predictions for the following samples:`),ls=i(),B=r("ul"),We=r("li"),is=o("P0: "),Tt=r("code"),cs=o("[0, 1, 2, 3, 4, 5]"),ps=i(),Je=r("li"),ds=o("P1: "),Ot=r("code"),hs=o("[6, 7, 8, 9, 10, 11]"),us=i(),Qe=r("li"),fs=o("P2: "),Ct=r("code"),ms=o("[12, 13, 14, 15, 0, 1]"),gs=i(),At=r("p"),bs=o("The first batch treated on each process will be"),_s=i(),K=r("ul"),Xe=r("li"),vs=o("P0: "),Ut=r("code"),ws=o("[0, 1]"),$s=i(),Ze=r("li"),ys=o("P1: "),Lt=r("code"),Es=o("[6, 7]"),Ds=i(),et=r("li"),js=o("P2: "),It=r("code"),ks=o("[12, 13]"),Ps=i(),zt=r("p"),xs=o(`So if we gather at the end of the first batch, we will get a tensor (nested list/tuple of tensor) corresponding to
the following indices:`),Ts=i(),St=r("p"),Ht=r("code"),Os=o("[0, 1, 6, 7, 12, 13]"),Cs=i(),Nt=r("p"),As=o(`If we directly concatenate our results without taking any precautions, the user will then get the predictions for
the indices in this order at the end of the prediction loop:`),Us=i(),Gt=r("p"),Vt=r("code"),Ls=o("[0, 1, 6, 7, 12, 13, 2, 3, 8, 9, 14, 15, 4, 5, 10, 11, 0, 1]"),Is=i(),Mt=r("p"),zs=o("For some reason, that\u2019s not going to roll their boat. This class is there to solve that problem."),Ss=i(),re=r("div"),v(De.$$.fragment),Hs=i(),je=r("p"),Ns=o("Add "),Rt=r("code"),Gs=o("arrays"),Vs=o(` to the internal storage, Will initialize the storage to the full size at the first arrays passed
so that if we\u2019re bound to get an OOM, it happens at the beginning.`),Ms=i(),se=r("div"),v(ke.$$.fragment),Rs=i(),Ft=r("p"),Fs=o(`Return the properly gathered arrays and truncate to the number of samples (since the sampler added some extras
to get each process a dataset of the same length).`),Ka=i(),Y=r("h2"),ne=r("a"),qt=r("span"),v(Pe.$$.fragment),qs=i(),Bt=r("span"),Bs=o("Distributed Evaluation"),Ya=i(),x=r("div"),v(xe.$$.fragment),Ks=i(),Te=r("p"),Ys=o("This subclass of "),Kt=r("code"),Ws=o("argparse.ArgumentParser"),Js=o(" uses type hints on dataclasses to generate arguments."),Qs=i(),Oe=r("p"),Xs=o(`The class is designed to play well with the native argparse. In particular, you can add more (non-dataclass backed)
arguments to the parser after initialization and you\u2019ll get the output back after parsing as an additional
namespace. Optional: To create sub argument groups use the `),Yt=r("code"),Zs=o("_argument_group_name"),en=o(" attribute in the dataclass."),tn=i(),z=r("div"),v(Ce.$$.fragment),an=i(),Wt=r("p"),rn=o("Parse command-line args into instances of the specified dataclass types."),sn=i(),Ae=r("p"),nn=o("This relies on argparse\u2019s "),Jt=r("code"),on=o("ArgumentParser.parse_known_args"),ln=o(`. See the doc at:
docs.python.org/3.7/library/argparse.html#argparse.ArgumentParser.parse_args`),cn=i(),oe=r("div"),v(Ue.$$.fragment),pn=i(),Le=r("p"),dn=o("Alternative helper method that does not use "),Qt=r("code"),hn=o("argparse"),un=o(` at all, instead uses a dict and populating the dataclass
types.`),fn=i(),le=r("div"),v(Ie.$$.fragment),mn=i(),ze=r("p"),gn=o("Alternative helper method that does not use "),Xt=r("code"),bn=o("argparse"),_n=o(` at all, instead loading a json file and populating the
dataclass types.`),Wa=i(),W=r("h2"),ie=r("a"),Zt=r("span"),v(Se.$$.fragment),vn=i(),ea=r("span"),wn=o("Debug Utilities"),Ja=i(),p=r("div"),v(He.$$.fragment),$n=i(),J=r("p"),yn=o(`This debug class helps detect and understand where the model starts getting very large or very small, and more
importantly `),ta=r("code"),En=o("nan"),Dn=o(" or "),aa=r("code"),jn=o("inf"),kn=o(" weight and activation elements."),Pn=i(),ra=r("p"),xn=o("There are 2 working modes:"),Tn=i(),Ne=r("ol"),sa=r("li"),On=o("Underflow/overflow detection (default)"),Cn=i(),na=r("li"),An=o("Specific batch absolute min/max tracing without detection"),Un=i(),oa=r("p"),Ln=o("Mode 1: Underflow/overflow detection"),In=i(),la=r("p"),zn=o("To activate the underflow/overflow detection, initialize the object with the model :"),Sn=i(),v(ce.$$.fragment),Hn=i(),U=r("p"),Nn=o("then run the training as normal and if "),ia=r("code"),Gn=o("nan"),Vn=o(" or "),ca=r("code"),Mn=o("inf"),Rn=o(` gets detected in at least one of the weight, input or output
elements this module will throw an exception and will print `),pa=r("code"),Fn=o("max_frames_to_save"),qn=o(` frames that lead to this event,
each frame reporting`),Bn=i(),Ge=r("ol"),Ve=r("li"),Kn=o("the fully qualified module name plus the class name whose "),da=r("code"),Yn=o("forward"),Wn=o(" was run"),Jn=i(),ha=r("li"),Qn=o("the absolute min and max value of all elements for each module weights, and the inputs and output"),Xn=i(),Me=r("p"),Zn=o("For example, here is the header and the last few frames in detection report for "),ua=r("code"),eo=o("google/mt5-small"),to=o(` run in fp16
mixed precision :`),ao=i(),v(pe.$$.fragment),ro=i(),Q=r("p"),so=o("You can see here, that "),fa=r("code"),no=o("T5DenseGatedGeluDense.forward"),oo=o(` resulted in output activations, whose absolute max value was
around 62.7K, which is very close to fp16\u2019s top limit of 64K. In the next frame we have `),ma=r("code"),lo=o("Dropout"),io=o(` which
renormalizes the weights, after it zeroed some of the elements, which pushes the absolute max value to more than
64K, and we get an overlow.`),co=i(),ga=r("p"),po=o(`As you can see it\u2019s the previous frames that we need to look into when the numbers start going into very large for
fp16 numbers.`),ho=i(),Re=r("p"),uo=o("The tracking is done in a forward hook, which gets invoked immediately after "),ba=r("code"),fo=o("forward"),mo=o(" has completed."),go=i(),v(de.$$.fragment),bo=i(),_a=r("p"),_o=o(`To validate that you have set up this debugging feature correctly, and you intend to use it in a training that
may take hours to complete, first run it with normal tracing enabled for one of a few batches as explained in
the next section.`),vo=i(),va=r("p"),wo=o("Mode 2. Specific batch absolute min/max tracing without detection"),$o=i(),wa=r("p"),yo=o("The second work mode is per-batch tracing with the underflow/overflow detection feature turned off."),Eo=i(),Fe=r("p"),Do=o("Let\u2019s say you want to watch the absolute min and max values for all the ingredients of each "),$a=r("code"),jo=o("forward"),ko=o(` call of a
given batch, and only do that for batches 1 and 3. Then you instantiate this class as :`),Po=i(),v(he.$$.fragment),xo=i(),ya=r("p"),To=o("And now full batches 1 and 3 will be traced using the same format as explained above. Batches are 0-indexed."),Oo=i(),Ea=r("p"),Co=o(`This is helpful if you know that the program starts misbehaving after a certain batch number, so you can
fast-forward right to that area.`),Ao=i(),Da=r("p"),Uo=o("Early stopping:"),Lo=i(),ja=r("p"),Io=o("You can also specify the batch number after which to stop the training, with :"),zo=i(),v(ue.$$.fragment),So=i(),ka=r("p"),Ho=o("This feature is mainly useful in the tracing mode, but you can use it for any mode."),No=i(),tt=r("p"),Pa=r("strong"),Go=o("Performance"),Vo=o(":"),Mo=i(),X=r("p"),Ro=o("As this module measures absolute "),xa=r("code"),Fo=o("min"),qo=o("/`"),Ta=r("code"),Bo=o("max"),Ko=o(` of each weight of the model on every forward it\u2019ll slow the training
down. Therefore remember to turn it off once the debugging needs have been met.`),this.h()},l(a){const f=Ci('[data-svelte="svelte-1phssyn"]',document.head);u=s(f,"META",{name:!0,content:!0}),f.forEach(t),j=c(a),h=s(a,"H1",{class:!0});var qe=n(h);k=s(qe,"A",{id:!0,class:!0,href:!0});var Oa=n(k);L=s(Oa,"SPAN",{});var Ca=n(L);w(P.$$.fragment,Ca),Ca.forEach(t),Oa.forEach(t),I=c(qe),ct=s(qe,"SPAN",{});var Aa=n(ct);Dr=l(Aa,"Utilities for Trainer"),Aa.forEach(t),qe.forEach(t),za=c(a),Z=s(a,"P",{});var Be=n(Z);jr=l(Be,"This page lists all the utility functions used by "),Ke=s(Be,"A",{href:!0});var tl=n(Ke);kr=l(tl,"Trainer"),tl.forEach(t),Pr=l(Be,"."),Be.forEach(t),Sa=c(a),Ye=s(a,"P",{});var al=n(Ye);xr=l(al,"Most of those are only useful if you are studying the code of the Trainer in the library."),al.forEach(t),Ha=c(a),H=s(a,"H2",{class:!0});var Xa=n(H);ee=s(Xa,"A",{id:!0,class:!0,href:!0});var rl=n(ee);pt=s(rl,"SPAN",{});var sl=n(pt);w(me.$$.fragment,sl),sl.forEach(t),rl.forEach(t),Tr=c(Xa),dt=s(Xa,"SPAN",{});var nl=n(dt);Or=l(nl,"Utilities"),nl.forEach(t),Xa.forEach(t),Na=c(a),N=s(a,"DIV",{class:!0});var Za=n(N);w(ge.$$.fragment,Za),Cr=c(Za),ht=s(Za,"P",{});var ol=n(ht);Ar=l(ol,"Evaluation output (always contains labels), to be used to compute metrics."),ol.forEach(t),Za.forEach(t),Ga=c(a),G=s(a,"DIV",{class:!0});var er=n(G);w(be.$$.fragment,er),Ur=c(er),ut=s(er,"P",{});var ll=n(ut);Lr=l(ll,"An enumeration."),ll.forEach(t),er.forEach(t),Va=c(a),V=s(a,"DIV",{class:!0});var tr=n(V);w(_e.$$.fragment,tr),Ir=c(tr),T=s(tr,"P",{});var S=n(T);zr=l(S,"Helper function for reproducible behavior to set the seed in "),ft=s(S,"CODE",{});var il=n(ft);Sr=l(il,"random"),il.forEach(t),Hr=l(S,", "),mt=s(S,"CODE",{});var cl=n(mt);Nr=l(cl,"numpy"),cl.forEach(t),Gr=l(S,", "),gt=s(S,"CODE",{});var pl=n(gt);Vr=l(pl,"torch"),pl.forEach(t),Mr=l(S," and/or "),bt=s(S,"CODE",{});var dl=n(bt);Rr=l(dl,"tf"),dl.forEach(t),Fr=l(S," (if installed)."),S.forEach(t),tr.forEach(t),Ma=c(a),M=s(a,"DIV",{class:!0});var ar=n(M);w(ve.$$.fragment,ar),qr=c(ar),_t=s(ar,"P",{});var hl=n(_t);Br=l(hl,"Decorator to make all processes in distributed training wait for each local_master to do something."),hl.forEach(t),ar.forEach(t),Ra=c(a),R=s(a,"H2",{class:!0});var rr=n(R);te=s(rr,"A",{id:!0,class:!0,href:!0});var ul=n(te);vt=s(ul,"SPAN",{});var fl=n(vt);w(we.$$.fragment,fl),fl.forEach(t),ul.forEach(t),Kr=c(rr),wt=s(rr,"SPAN",{});var ml=n(wt);Yr=l(ml,"Callbacks internals"),ml.forEach(t),rr.forEach(t),Fa=c(a),F=s(a,"DIV",{class:!0});var sr=n(F);w($e.$$.fragment,sr),Wr=c(sr),$t=s(sr,"P",{});var gl=n($t);Jr=l(gl,"Internal class that just calls the list of callbacks in order."),gl.forEach(t),sr.forEach(t),qa=c(a),q=s(a,"H2",{class:!0});var nr=n(q);ae=s(nr,"A",{id:!0,class:!0,href:!0});var bl=n(ae);yt=s(bl,"SPAN",{});var _l=n(yt);w(ye.$$.fragment,_l),_l.forEach(t),bl.forEach(t),Qr=c(nr),Et=s(nr,"SPAN",{});var vl=n(Et);Xr=l(vl,"Distributed Evaluation"),vl.forEach(t),nr.forEach(t),Ba=c(a),g=s(a,"DIV",{class:!0});var _=n(g);w(Ee.$$.fragment,_),Zr=c(_),Dt=s(_,"P",{});var wl=n(Dt);es=l(wl,"A class responsible for properly gathering tensors (or nested list/tuple of tensors) on the CPU by chunks."),wl.forEach(t),ts=c(_),jt=s(_,"P",{});var $l=n(jt);as=l($l,`If our dataset has 16 samples with a batch size of 2 on 3 processes and we gather then transfer on CPU at every
step, our sampler will generate the following indices:`),$l.forEach(t),rs=c(_),kt=s(_,"P",{});var yl=n(kt);Pt=s(yl,"CODE",{});var El=n(Pt);ss=l(El,"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 1]"),El.forEach(t),yl.forEach(t),ns=c(_),xt=s(_,"P",{});var Dl=n(xt);os=l(Dl,`to get something of size a multiple of 3 (so that each process gets the same dataset length). Then process 0, 1 and
2 will be responsible of making predictions for the following samples:`),Dl.forEach(t),ls=c(_),B=s(_,"UL",{});var at=n(B);We=s(at,"LI",{});var Yo=n(We);is=l(Yo,"P0: "),Tt=s(Yo,"CODE",{});var jl=n(Tt);cs=l(jl,"[0, 1, 2, 3, 4, 5]"),jl.forEach(t),Yo.forEach(t),ps=c(at),Je=s(at,"LI",{});var Wo=n(Je);ds=l(Wo,"P1: "),Ot=s(Wo,"CODE",{});var kl=n(Ot);hs=l(kl,"[6, 7, 8, 9, 10, 11]"),kl.forEach(t),Wo.forEach(t),us=c(at),Qe=s(at,"LI",{});var Jo=n(Qe);fs=l(Jo,"P2: "),Ct=s(Jo,"CODE",{});var Pl=n(Ct);ms=l(Pl,"[12, 13, 14, 15, 0, 1]"),Pl.forEach(t),Jo.forEach(t),at.forEach(t),gs=c(_),At=s(_,"P",{});var xl=n(At);bs=l(xl,"The first batch treated on each process will be"),xl.forEach(t),_s=c(_),K=s(_,"UL",{});var rt=n(K);Xe=s(rt,"LI",{});var Qo=n(Xe);vs=l(Qo,"P0: "),Ut=s(Qo,"CODE",{});var Tl=n(Ut);ws=l(Tl,"[0, 1]"),Tl.forEach(t),Qo.forEach(t),$s=c(rt),Ze=s(rt,"LI",{});var Xo=n(Ze);ys=l(Xo,"P1: "),Lt=s(Xo,"CODE",{});var Ol=n(Lt);Es=l(Ol,"[6, 7]"),Ol.forEach(t),Xo.forEach(t),Ds=c(rt),et=s(rt,"LI",{});var Zo=n(et);js=l(Zo,"P2: "),It=s(Zo,"CODE",{});var Cl=n(It);ks=l(Cl,"[12, 13]"),Cl.forEach(t),Zo.forEach(t),rt.forEach(t),Ps=c(_),zt=s(_,"P",{});var Al=n(zt);xs=l(Al,`So if we gather at the end of the first batch, we will get a tensor (nested list/tuple of tensor) corresponding to
the following indices:`),Al.forEach(t),Ts=c(_),St=s(_,"P",{});var Ul=n(St);Ht=s(Ul,"CODE",{});var Ll=n(Ht);Os=l(Ll,"[0, 1, 6, 7, 12, 13]"),Ll.forEach(t),Ul.forEach(t),Cs=c(_),Nt=s(_,"P",{});var Il=n(Nt);As=l(Il,`If we directly concatenate our results without taking any precautions, the user will then get the predictions for
the indices in this order at the end of the prediction loop:`),Il.forEach(t),Us=c(_),Gt=s(_,"P",{});var zl=n(Gt);Vt=s(zl,"CODE",{});var Sl=n(Vt);Ls=l(Sl,"[0, 1, 6, 7, 12, 13, 2, 3, 8, 9, 14, 15, 4, 5, 10, 11, 0, 1]"),Sl.forEach(t),zl.forEach(t),Is=c(_),Mt=s(_,"P",{});var Hl=n(Mt);zs=l(Hl,"For some reason, that\u2019s not going to roll their boat. This class is there to solve that problem."),Hl.forEach(t),Ss=c(_),re=s(_,"DIV",{class:!0});var or=n(re);w(De.$$.fragment,or),Hs=c(or),je=s(or,"P",{});var lr=n(je);Ns=l(lr,"Add "),Rt=s(lr,"CODE",{});var Nl=n(Rt);Gs=l(Nl,"arrays"),Nl.forEach(t),Vs=l(lr,` to the internal storage, Will initialize the storage to the full size at the first arrays passed
so that if we\u2019re bound to get an OOM, it happens at the beginning.`),lr.forEach(t),or.forEach(t),Ms=c(_),se=s(_,"DIV",{class:!0});var ir=n(se);w(ke.$$.fragment,ir),Rs=c(ir),Ft=s(ir,"P",{});var Gl=n(Ft);Fs=l(Gl,`Return the properly gathered arrays and truncate to the number of samples (since the sampler added some extras
to get each process a dataset of the same length).`),Gl.forEach(t),ir.forEach(t),_.forEach(t),Ka=c(a),Y=s(a,"H2",{class:!0});var cr=n(Y);ne=s(cr,"A",{id:!0,class:!0,href:!0});var Vl=n(ne);qt=s(Vl,"SPAN",{});var Ml=n(qt);w(Pe.$$.fragment,Ml),Ml.forEach(t),Vl.forEach(t),qs=c(cr),Bt=s(cr,"SPAN",{});var Rl=n(Bt);Bs=l(Rl,"Distributed Evaluation"),Rl.forEach(t),cr.forEach(t),Ya=c(a),x=s(a,"DIV",{class:!0});var A=n(x);w(xe.$$.fragment,A),Ks=c(A),Te=s(A,"P",{});var pr=n(Te);Ys=l(pr,"This subclass of "),Kt=s(pr,"CODE",{});var Fl=n(Kt);Ws=l(Fl,"argparse.ArgumentParser"),Fl.forEach(t),Js=l(pr," uses type hints on dataclasses to generate arguments."),pr.forEach(t),Qs=c(A),Oe=s(A,"P",{});var dr=n(Oe);Xs=l(dr,`The class is designed to play well with the native argparse. In particular, you can add more (non-dataclass backed)
arguments to the parser after initialization and you\u2019ll get the output back after parsing as an additional
namespace. Optional: To create sub argument groups use the `),Yt=s(dr,"CODE",{});var ql=n(Yt);Zs=l(ql,"_argument_group_name"),ql.forEach(t),en=l(dr," attribute in the dataclass."),dr.forEach(t),tn=c(A),z=s(A,"DIV",{class:!0});var st=n(z);w(Ce.$$.fragment,st),an=c(st),Wt=s(st,"P",{});var Bl=n(Wt);rn=l(Bl,"Parse command-line args into instances of the specified dataclass types."),Bl.forEach(t),sn=c(st),Ae=s(st,"P",{});var hr=n(Ae);nn=l(hr,"This relies on argparse\u2019s "),Jt=s(hr,"CODE",{});var Kl=n(Jt);on=l(Kl,"ArgumentParser.parse_known_args"),Kl.forEach(t),ln=l(hr,`. See the doc at:
docs.python.org/3.7/library/argparse.html#argparse.ArgumentParser.parse_args`),hr.forEach(t),st.forEach(t),cn=c(A),oe=s(A,"DIV",{class:!0});var ur=n(oe);w(Ue.$$.fragment,ur),pn=c(ur),Le=s(ur,"P",{});var fr=n(Le);dn=l(fr,"Alternative helper method that does not use "),Qt=s(fr,"CODE",{});var Yl=n(Qt);hn=l(Yl,"argparse"),Yl.forEach(t),un=l(fr,` at all, instead uses a dict and populating the dataclass
types.`),fr.forEach(t),ur.forEach(t),fn=c(A),le=s(A,"DIV",{class:!0});var mr=n(le);w(Ie.$$.fragment,mr),mn=c(mr),ze=s(mr,"P",{});var gr=n(ze);gn=l(gr,"Alternative helper method that does not use "),Xt=s(gr,"CODE",{});var Wl=n(Xt);bn=l(Wl,"argparse"),Wl.forEach(t),_n=l(gr,` at all, instead loading a json file and populating the
dataclass types.`),gr.forEach(t),mr.forEach(t),A.forEach(t),Wa=c(a),W=s(a,"H2",{class:!0});var br=n(W);ie=s(br,"A",{id:!0,class:!0,href:!0});var Jl=n(ie);Zt=s(Jl,"SPAN",{});var Ql=n(Zt);w(Se.$$.fragment,Ql),Ql.forEach(t),Jl.forEach(t),vn=c(br),ea=s(br,"SPAN",{});var Xl=n(ea);wn=l(Xl,"Debug Utilities"),Xl.forEach(t),br.forEach(t),Ja=c(a),p=s(a,"DIV",{class:!0});var d=n(p);w(He.$$.fragment,d),$n=c(d),J=s(d,"P",{});var nt=n(J);yn=l(nt,`This debug class helps detect and understand where the model starts getting very large or very small, and more
importantly `),ta=s(nt,"CODE",{});var Zl=n(ta);En=l(Zl,"nan"),Zl.forEach(t),Dn=l(nt," or "),aa=s(nt,"CODE",{});var ei=n(aa);jn=l(ei,"inf"),ei.forEach(t),kn=l(nt," weight and activation elements."),nt.forEach(t),Pn=c(d),ra=s(d,"P",{});var ti=n(ra);xn=l(ti,"There are 2 working modes:"),ti.forEach(t),Tn=c(d),Ne=s(d,"OL",{});var _r=n(Ne);sa=s(_r,"LI",{});var ai=n(sa);On=l(ai,"Underflow/overflow detection (default)"),ai.forEach(t),Cn=c(_r),na=s(_r,"LI",{});var ri=n(na);An=l(ri,"Specific batch absolute min/max tracing without detection"),ri.forEach(t),_r.forEach(t),Un=c(d),oa=s(d,"P",{});var si=n(oa);Ln=l(si,"Mode 1: Underflow/overflow detection"),si.forEach(t),In=c(d),la=s(d,"P",{});var ni=n(la);zn=l(ni,"To activate the underflow/overflow detection, initialize the object with the model :"),ni.forEach(t),Sn=c(d),w(ce.$$.fragment,d),Hn=c(d),U=s(d,"P",{});var fe=n(U);Nn=l(fe,"then run the training as normal and if "),ia=s(fe,"CODE",{});var oi=n(ia);Gn=l(oi,"nan"),oi.forEach(t),Vn=l(fe," or "),ca=s(fe,"CODE",{});var li=n(ca);Mn=l(li,"inf"),li.forEach(t),Rn=l(fe,` gets detected in at least one of the weight, input or output
elements this module will throw an exception and will print `),pa=s(fe,"CODE",{});var ii=n(pa);Fn=l(ii,"max_frames_to_save"),ii.forEach(t),qn=l(fe,` frames that lead to this event,
each frame reporting`),fe.forEach(t),Bn=c(d),Ge=s(d,"OL",{});var vr=n(Ge);Ve=s(vr,"LI",{});var wr=n(Ve);Kn=l(wr,"the fully qualified module name plus the class name whose "),da=s(wr,"CODE",{});var ci=n(da);Yn=l(ci,"forward"),ci.forEach(t),Wn=l(wr," was run"),wr.forEach(t),Jn=c(vr),ha=s(vr,"LI",{});var pi=n(ha);Qn=l(pi,"the absolute min and max value of all elements for each module weights, and the inputs and output"),pi.forEach(t),vr.forEach(t),Xn=c(d),Me=s(d,"P",{});var $r=n(Me);Zn=l($r,"For example, here is the header and the last few frames in detection report for "),ua=s($r,"CODE",{});var di=n(ua);eo=l(di,"google/mt5-small"),di.forEach(t),to=l($r,` run in fp16
mixed precision :`),$r.forEach(t),ao=c(d),w(pe.$$.fragment,d),ro=c(d),Q=s(d,"P",{});var ot=n(Q);so=l(ot,"You can see here, that "),fa=s(ot,"CODE",{});var hi=n(fa);no=l(hi,"T5DenseGatedGeluDense.forward"),hi.forEach(t),oo=l(ot,` resulted in output activations, whose absolute max value was
around 62.7K, which is very close to fp16\u2019s top limit of 64K. In the next frame we have `),ma=s(ot,"CODE",{});var ui=n(ma);lo=l(ui,"Dropout"),ui.forEach(t),io=l(ot,` which
renormalizes the weights, after it zeroed some of the elements, which pushes the absolute max value to more than
64K, and we get an overlow.`),ot.forEach(t),co=c(d),ga=s(d,"P",{});var fi=n(ga);po=l(fi,`As you can see it\u2019s the previous frames that we need to look into when the numbers start going into very large for
fp16 numbers.`),fi.forEach(t),ho=c(d),Re=s(d,"P",{});var yr=n(Re);uo=l(yr,"The tracking is done in a forward hook, which gets invoked immediately after "),ba=s(yr,"CODE",{});var mi=n(ba);fo=l(mi,"forward"),mi.forEach(t),mo=l(yr," has completed."),yr.forEach(t),go=c(d),w(de.$$.fragment,d),bo=c(d),_a=s(d,"P",{});var gi=n(_a);_o=l(gi,`To validate that you have set up this debugging feature correctly, and you intend to use it in a training that
may take hours to complete, first run it with normal tracing enabled for one of a few batches as explained in
the next section.`),gi.forEach(t),vo=c(d),va=s(d,"P",{});var bi=n(va);wo=l(bi,"Mode 2. Specific batch absolute min/max tracing without detection"),bi.forEach(t),$o=c(d),wa=s(d,"P",{});var _i=n(wa);yo=l(_i,"The second work mode is per-batch tracing with the underflow/overflow detection feature turned off."),_i.forEach(t),Eo=c(d),Fe=s(d,"P",{});var Er=n(Fe);Do=l(Er,"Let\u2019s say you want to watch the absolute min and max values for all the ingredients of each "),$a=s(Er,"CODE",{});var vi=n($a);jo=l(vi,"forward"),vi.forEach(t),ko=l(Er,` call of a
given batch, and only do that for batches 1 and 3. Then you instantiate this class as :`),Er.forEach(t),Po=c(d),w(he.$$.fragment,d),xo=c(d),ya=s(d,"P",{});var wi=n(ya);To=l(wi,"And now full batches 1 and 3 will be traced using the same format as explained above. Batches are 0-indexed."),wi.forEach(t),Oo=c(d),Ea=s(d,"P",{});var $i=n(Ea);Co=l($i,`This is helpful if you know that the program starts misbehaving after a certain batch number, so you can
fast-forward right to that area.`),$i.forEach(t),Ao=c(d),Da=s(d,"P",{});var yi=n(Da);Uo=l(yi,"Early stopping:"),yi.forEach(t),Lo=c(d),ja=s(d,"P",{});var Ei=n(ja);Io=l(Ei,"You can also specify the batch number after which to stop the training, with :"),Ei.forEach(t),zo=c(d),w(ue.$$.fragment,d),So=c(d),ka=s(d,"P",{});var Di=n(ka);Ho=l(Di,"This feature is mainly useful in the tracing mode, but you can use it for any mode."),Di.forEach(t),No=c(d),tt=s(d,"P",{});var el=n(tt);Pa=s(el,"STRONG",{});var ji=n(Pa);Go=l(ji,"Performance"),ji.forEach(t),Vo=l(el,":"),el.forEach(t),Mo=c(d),X=s(d,"P",{});var lt=n(X);Ro=l(lt,"As this module measures absolute "),xa=s(lt,"CODE",{});var ki=n(xa);Fo=l(ki,"min"),ki.forEach(t),qo=l(lt,"/`"),Ta=s(lt,"CODE",{});var Pi=n(Ta);Bo=l(Pi,"max"),Pi.forEach(t),Ko=l(lt,` of each weight of the model on every forward it\u2019ll slow the training
down. Therefore remember to turn it off once the debugging needs have been met.`),lt.forEach(t),d.forEach(t),this.h()},h(){m(u,"name","hf:doc:metadata"),m(u,"content",JSON.stringify(Ni)),m(k,"id","utilities-for-trainer"),m(k,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(k,"href","#utilities-for-trainer"),m(h,"class","relative group"),m(Ke,"href","/docs/transformers/pr_16919/en/main_classes/trainer#transformers.Trainer"),m(ee,"id","transformers.EvalPrediction"),m(ee,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(ee,"href","#transformers.EvalPrediction"),m(H,"class","relative group"),m(N,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),m(G,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),m(V,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),m(M,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),m(te,"id","transformers.trainer_callback.CallbackHandler"),m(te,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(te,"href","#transformers.trainer_callback.CallbackHandler"),m(R,"class","relative group"),m(F,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),m(ae,"id","transformers.trainer_pt_utils.DistributedTensorGatherer"),m(ae,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(ae,"href","#transformers.trainer_pt_utils.DistributedTensorGatherer"),m(q,"class","relative group"),m(re,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),m(se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),m(g,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),m(ne,"id","transformers.HfArgumentParser"),m(ne,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(ne,"href","#transformers.HfArgumentParser"),m(Y,"class","relative group"),m(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),m(oe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),m(le,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),m(x,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),m(ie,"id","transformers.debug_utils.DebugUnderflowOverflow"),m(ie,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),m(ie,"href","#transformers.debug_utils.DebugUnderflowOverflow"),m(W,"class","relative group"),m(p,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(a,f){e(document.head,u),b(a,j,f),b(a,h,f),e(h,k),e(k,L),$(P,L,null),e(h,I),e(h,ct),e(ct,Dr),b(a,za,f),b(a,Z,f),e(Z,jr),e(Z,Ke),e(Ke,kr),e(Z,Pr),b(a,Sa,f),b(a,Ye,f),e(Ye,xr),b(a,Ha,f),b(a,H,f),e(H,ee),e(ee,pt),$(me,pt,null),e(H,Tr),e(H,dt),e(dt,Or),b(a,Na,f),b(a,N,f),$(ge,N,null),e(N,Cr),e(N,ht),e(ht,Ar),b(a,Ga,f),b(a,G,f),$(be,G,null),e(G,Ur),e(G,ut),e(ut,Lr),b(a,Va,f),b(a,V,f),$(_e,V,null),e(V,Ir),e(V,T),e(T,zr),e(T,ft),e(ft,Sr),e(T,Hr),e(T,mt),e(mt,Nr),e(T,Gr),e(T,gt),e(gt,Vr),e(T,Mr),e(T,bt),e(bt,Rr),e(T,Fr),b(a,Ma,f),b(a,M,f),$(ve,M,null),e(M,qr),e(M,_t),e(_t,Br),b(a,Ra,f),b(a,R,f),e(R,te),e(te,vt),$(we,vt,null),e(R,Kr),e(R,wt),e(wt,Yr),b(a,Fa,f),b(a,F,f),$($e,F,null),e(F,Wr),e(F,$t),e($t,Jr),b(a,qa,f),b(a,q,f),e(q,ae),e(ae,yt),$(ye,yt,null),e(q,Qr),e(q,Et),e(Et,Xr),b(a,Ba,f),b(a,g,f),$(Ee,g,null),e(g,Zr),e(g,Dt),e(Dt,es),e(g,ts),e(g,jt),e(jt,as),e(g,rs),e(g,kt),e(kt,Pt),e(Pt,ss),e(g,ns),e(g,xt),e(xt,os),e(g,ls),e(g,B),e(B,We),e(We,is),e(We,Tt),e(Tt,cs),e(B,ps),e(B,Je),e(Je,ds),e(Je,Ot),e(Ot,hs),e(B,us),e(B,Qe),e(Qe,fs),e(Qe,Ct),e(Ct,ms),e(g,gs),e(g,At),e(At,bs),e(g,_s),e(g,K),e(K,Xe),e(Xe,vs),e(Xe,Ut),e(Ut,ws),e(K,$s),e(K,Ze),e(Ze,ys),e(Ze,Lt),e(Lt,Es),e(K,Ds),e(K,et),e(et,js),e(et,It),e(It,ks),e(g,Ps),e(g,zt),e(zt,xs),e(g,Ts),e(g,St),e(St,Ht),e(Ht,Os),e(g,Cs),e(g,Nt),e(Nt,As),e(g,Us),e(g,Gt),e(Gt,Vt),e(Vt,Ls),e(g,Is),e(g,Mt),e(Mt,zs),e(g,Ss),e(g,re),$(De,re,null),e(re,Hs),e(re,je),e(je,Ns),e(je,Rt),e(Rt,Gs),e(je,Vs),e(g,Ms),e(g,se),$(ke,se,null),e(se,Rs),e(se,Ft),e(Ft,Fs),b(a,Ka,f),b(a,Y,f),e(Y,ne),e(ne,qt),$(Pe,qt,null),e(Y,qs),e(Y,Bt),e(Bt,Bs),b(a,Ya,f),b(a,x,f),$(xe,x,null),e(x,Ks),e(x,Te),e(Te,Ys),e(Te,Kt),e(Kt,Ws),e(Te,Js),e(x,Qs),e(x,Oe),e(Oe,Xs),e(Oe,Yt),e(Yt,Zs),e(Oe,en),e(x,tn),e(x,z),$(Ce,z,null),e(z,an),e(z,Wt),e(Wt,rn),e(z,sn),e(z,Ae),e(Ae,nn),e(Ae,Jt),e(Jt,on),e(Ae,ln),e(x,cn),e(x,oe),$(Ue,oe,null),e(oe,pn),e(oe,Le),e(Le,dn),e(Le,Qt),e(Qt,hn),e(Le,un),e(x,fn),e(x,le),$(Ie,le,null),e(le,mn),e(le,ze),e(ze,gn),e(ze,Xt),e(Xt,bn),e(ze,_n),b(a,Wa,f),b(a,W,f),e(W,ie),e(ie,Zt),$(Se,Zt,null),e(W,vn),e(W,ea),e(ea,wn),b(a,Ja,f),b(a,p,f),$(He,p,null),e(p,$n),e(p,J),e(J,yn),e(J,ta),e(ta,En),e(J,Dn),e(J,aa),e(aa,jn),e(J,kn),e(p,Pn),e(p,ra),e(ra,xn),e(p,Tn),e(p,Ne),e(Ne,sa),e(sa,On),e(Ne,Cn),e(Ne,na),e(na,An),e(p,Un),e(p,oa),e(oa,Ln),e(p,In),e(p,la),e(la,zn),e(p,Sn),$(ce,p,null),e(p,Hn),e(p,U),e(U,Nn),e(U,ia),e(ia,Gn),e(U,Vn),e(U,ca),e(ca,Mn),e(U,Rn),e(U,pa),e(pa,Fn),e(U,qn),e(p,Bn),e(p,Ge),e(Ge,Ve),e(Ve,Kn),e(Ve,da),e(da,Yn),e(Ve,Wn),e(Ge,Jn),e(Ge,ha),e(ha,Qn),e(p,Xn),e(p,Me),e(Me,Zn),e(Me,ua),e(ua,eo),e(Me,to),e(p,ao),$(pe,p,null),e(p,ro),e(p,Q),e(Q,so),e(Q,fa),e(fa,no),e(Q,oo),e(Q,ma),e(ma,lo),e(Q,io),e(p,co),e(p,ga),e(ga,po),e(p,ho),e(p,Re),e(Re,uo),e(Re,ba),e(ba,fo),e(Re,mo),e(p,go),$(de,p,null),e(p,bo),e(p,_a),e(_a,_o),e(p,vo),e(p,va),e(va,wo),e(p,$o),e(p,wa),e(wa,yo),e(p,Eo),e(p,Fe),e(Fe,Do),e(Fe,$a),e($a,jo),e(Fe,ko),e(p,Po),$(he,p,null),e(p,xo),e(p,ya),e(ya,To),e(p,Oo),e(p,Ea),e(Ea,Co),e(p,Ao),e(p,Da),e(Da,Uo),e(p,Lo),e(p,ja),e(ja,Io),e(p,zo),$(ue,p,null),e(p,So),e(p,ka),e(ka,Ho),e(p,No),e(p,tt),e(tt,Pa),e(Pa,Go),e(tt,Vo),e(p,Mo),e(p,X),e(X,Ro),e(X,xa),e(xa,Fo),e(X,qo),e(X,Ta),e(Ta,Bo),e(X,Ko),Qa=!0},p(a,[f]){const qe={};f&2&&(qe.$$scope={dirty:f,ctx:a}),ce.$set(qe);const Oa={};f&2&&(Oa.$$scope={dirty:f,ctx:a}),pe.$set(Oa);const Ca={};f&2&&(Ca.$$scope={dirty:f,ctx:a}),de.$set(Ca);const Aa={};f&2&&(Aa.$$scope={dirty:f,ctx:a}),he.$set(Aa);const Be={};f&2&&(Be.$$scope={dirty:f,ctx:a}),ue.$set(Be)},i(a){Qa||(y(P.$$.fragment,a),y(me.$$.fragment,a),y(ge.$$.fragment,a),y(be.$$.fragment,a),y(_e.$$.fragment,a),y(ve.$$.fragment,a),y(we.$$.fragment,a),y($e.$$.fragment,a),y(ye.$$.fragment,a),y(Ee.$$.fragment,a),y(De.$$.fragment,a),y(ke.$$.fragment,a),y(Pe.$$.fragment,a),y(xe.$$.fragment,a),y(Ce.$$.fragment,a),y(Ue.$$.fragment,a),y(Ie.$$.fragment,a),y(Se.$$.fragment,a),y(He.$$.fragment,a),y(ce.$$.fragment,a),y(pe.$$.fragment,a),y(de.$$.fragment,a),y(he.$$.fragment,a),y(ue.$$.fragment,a),Qa=!0)},o(a){E(P.$$.fragment,a),E(me.$$.fragment,a),E(ge.$$.fragment,a),E(be.$$.fragment,a),E(_e.$$.fragment,a),E(ve.$$.fragment,a),E(we.$$.fragment,a),E($e.$$.fragment,a),E(ye.$$.fragment,a),E(Ee.$$.fragment,a),E(De.$$.fragment,a),E(ke.$$.fragment,a),E(Pe.$$.fragment,a),E(xe.$$.fragment,a),E(Ce.$$.fragment,a),E(Ue.$$.fragment,a),E(Ie.$$.fragment,a),E(Se.$$.fragment,a),E(He.$$.fragment,a),E(ce.$$.fragment,a),E(pe.$$.fragment,a),E(de.$$.fragment,a),E(he.$$.fragment,a),E(ue.$$.fragment,a),Qa=!1},d(a){t(u),a&&t(j),a&&t(h),D(P),a&&t(za),a&&t(Z),a&&t(Sa),a&&t(Ye),a&&t(Ha),a&&t(H),D(me),a&&t(Na),a&&t(N),D(ge),a&&t(Ga),a&&t(G),D(be),a&&t(Va),a&&t(V),D(_e),a&&t(Ma),a&&t(M),D(ve),a&&t(Ra),a&&t(R),D(we),a&&t(Fa),a&&t(F),D($e),a&&t(qa),a&&t(q),D(ye),a&&t(Ba),a&&t(g),D(Ee),D(De),D(ke),a&&t(Ka),a&&t(Y),D(Pe),a&&t(Ya),a&&t(x),D(xe),D(Ce),D(Ue),D(Ie),a&&t(Wa),a&&t(W),D(Se),a&&t(Ja),a&&t(p),D(He),D(ce),D(pe),D(de),D(he),D(ue)}}}const Ni={local:"utilities-for-trainer",sections:[{local:"transformers.EvalPrediction",title:"Utilities"},{local:"transformers.trainer_callback.CallbackHandler",title:"Callbacks internals"},{local:"transformers.trainer_pt_utils.DistributedTensorGatherer",title:"Distributed Evaluation"},{local:"transformers.HfArgumentParser",title:"Distributed Evaluation"},{local:"transformers.debug_utils.DebugUnderflowOverflow",title:"Debug Utilities"}],title:"Utilities for Trainer"};function Gi(C){return Ai(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Bi extends xi{constructor(u){super();Ti(this,u,Gi,Hi,Oi,{})}}export{Bi as default,Ni as metadata};
