import{S as W2,i as B2,s as Q2,e as r,k as l,w as F,t,M as U2,c as a,d as n,m as d,a as i,x as v,h as o,b as c,F as e,g as h,y as b,q as y,o as w,B as $,v as R2}from"../../chunks/vendor-6b77c823.js";import{T as qe}from"../../chunks/Tip-39098574.js";import{D as X}from"../../chunks/Docstring-17b815d9.js";import{C as be}from"../../chunks/CodeBlock-3a8b25a8.js";import{I as Ce}from"../../chunks/IconCopyLink-7a11ce68.js";function V2(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function H2(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function Y2(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function K2(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function G2(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function Z2(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function X2(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function J2(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function e$(H){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,fe,W,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),x=r("li"),oe=t("a single Tensor with "),B=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),C=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),m=d(Z),M=a(Z,"LI",{});var ye=i(M);ce=o(ye,"having all inputs as a list, tuple or dict in the first positional arguments."),ye.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var we=i(N);ue=o(we,"model(inputs)"),we.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var j=i(P);x=a(j,"LI",{});var R=i(x);oe=o(R,"a single Tensor with "),B=a(R,"CODE",{});var Ee=i(B);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(j),C=a(j,"LI",{});var V=i(C);fe=o(V,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=a(V,"CODE",{});var Me=i(W);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(V," or "),Q=a(V,"CODE",{});var ve=i(Q);me=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),V.forEach(n),I=d(j),O=a(j,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),j.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,x),e(x,oe),e(x,B),e(B,le),e(x,se),e(x,S),e(S,he),e(P,de),e(P,C),e(C,fe),e(C,W),e(W,ee),e(C,ae),e(C,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function n$(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function t$(H){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,fe,W,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),x=r("li"),oe=t("a single Tensor with "),B=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),C=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),m=d(Z),M=a(Z,"LI",{});var ye=i(M);ce=o(ye,"having all inputs as a list, tuple or dict in the first positional arguments."),ye.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var we=i(N);ue=o(we,"model(inputs)"),we.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var j=i(P);x=a(j,"LI",{});var R=i(x);oe=o(R,"a single Tensor with "),B=a(R,"CODE",{});var Ee=i(B);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(j),C=a(j,"LI",{});var V=i(C);fe=o(V,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=a(V,"CODE",{});var Me=i(W);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(V," or "),Q=a(V,"CODE",{});var ve=i(Q);me=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),V.forEach(n),I=d(j),O=a(j,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),j.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,x),e(x,oe),e(x,B),e(B,le),e(x,se),e(x,S),e(S,he),e(P,de),e(P,C),e(C,fe),e(C,W),e(W,ee),e(C,ae),e(C,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function o$(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function s$(H){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,fe,W,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),x=r("li"),oe=t("a single Tensor with "),B=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),C=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),m=d(Z),M=a(Z,"LI",{});var ye=i(M);ce=o(ye,"having all inputs as a list, tuple or dict in the first positional arguments."),ye.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var we=i(N);ue=o(we,"model(inputs)"),we.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var j=i(P);x=a(j,"LI",{});var R=i(x);oe=o(R,"a single Tensor with "),B=a(R,"CODE",{});var Ee=i(B);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(j),C=a(j,"LI",{});var V=i(C);fe=o(V,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=a(V,"CODE",{});var Me=i(W);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(V," or "),Q=a(V,"CODE",{});var ve=i(Q);me=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),V.forEach(n),I=d(j),O=a(j,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),j.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,x),e(x,oe),e(x,B),e(B,le),e(x,se),e(x,S),e(S,he),e(P,de),e(P,C),e(C,fe),e(C,W),e(W,ee),e(C,ae),e(C,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function r$(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function a$(H){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,fe,W,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),x=r("li"),oe=t("a single Tensor with "),B=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),C=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),m=d(Z),M=a(Z,"LI",{});var ye=i(M);ce=o(ye,"having all inputs as a list, tuple or dict in the first positional arguments."),ye.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var we=i(N);ue=o(we,"model(inputs)"),we.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var j=i(P);x=a(j,"LI",{});var R=i(x);oe=o(R,"a single Tensor with "),B=a(R,"CODE",{});var Ee=i(B);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(j),C=a(j,"LI",{});var V=i(C);fe=o(V,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=a(V,"CODE",{});var Me=i(W);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(V," or "),Q=a(V,"CODE",{});var ve=i(Q);me=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),V.forEach(n),I=d(j),O=a(j,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),j.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,x),e(x,oe),e(x,B),e(B,le),e(x,se),e(x,S),e(S,he),e(P,de),e(P,C),e(C,fe),e(C,W),e(W,ee),e(C,ae),e(C,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function i$(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function l$(H){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,fe,W,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),x=r("li"),oe=t("a single Tensor with "),B=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),C=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),m=d(Z),M=a(Z,"LI",{});var ye=i(M);ce=o(ye,"having all inputs as a list, tuple or dict in the first positional arguments."),ye.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var we=i(N);ue=o(we,"model(inputs)"),we.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var j=i(P);x=a(j,"LI",{});var R=i(x);oe=o(R,"a single Tensor with "),B=a(R,"CODE",{});var Ee=i(B);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(j),C=a(j,"LI",{});var V=i(C);fe=o(V,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=a(V,"CODE",{});var Me=i(W);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(V," or "),Q=a(V,"CODE",{});var ve=i(Q);me=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),V.forEach(n),I=d(j),O=a(j,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),j.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,x),e(x,oe),e(x,B),e(B,le),e(x,se),e(x,S),e(S,he),e(P,de),e(P,C),e(C,fe),e(C,W),e(W,ee),e(C,ae),e(C,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function d$(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function c$(H){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,fe,W,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),x=r("li"),oe=t("a single Tensor with "),B=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),C=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),m=d(Z),M=a(Z,"LI",{});var ye=i(M);ce=o(ye,"having all inputs as a list, tuple or dict in the first positional arguments."),ye.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var we=i(N);ue=o(we,"model(inputs)"),we.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var j=i(P);x=a(j,"LI",{});var R=i(x);oe=o(R,"a single Tensor with "),B=a(R,"CODE",{});var Ee=i(B);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(j),C=a(j,"LI",{});var V=i(C);fe=o(V,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=a(V,"CODE",{});var Me=i(W);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(V," or "),Q=a(V,"CODE",{});var ve=i(Q);me=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),V.forEach(n),I=d(j),O=a(j,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),j.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,x),e(x,oe),e(x,B),e(B,le),e(x,se),e(x,S),e(S,he),e(P,de),e(P,C),e(C,fe),e(C,W),e(W,ee),e(C,ae),e(C,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function p$(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function u$(H){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,fe,W,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),x=r("li"),oe=t("a single Tensor with "),B=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),C=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),m=d(Z),M=a(Z,"LI",{});var ye=i(M);ce=o(ye,"having all inputs as a list, tuple or dict in the first positional arguments."),ye.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var we=i(N);ue=o(we,"model(inputs)"),we.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var j=i(P);x=a(j,"LI",{});var R=i(x);oe=o(R,"a single Tensor with "),B=a(R,"CODE",{});var Ee=i(B);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(j),C=a(j,"LI",{});var V=i(C);fe=o(V,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=a(V,"CODE",{});var Me=i(W);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(V," or "),Q=a(V,"CODE",{});var ve=i(Q);me=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),V.forEach(n),I=d(j),O=a(j,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),j.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,x),e(x,oe),e(x,B),e(B,le),e(x,se),e(x,S),e(S,he),e(P,de),e(P,C),e(C,fe),e(C,W),e(W,ee),e(C,ae),e(C,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function h$(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function f$(H){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,fe,W,ee,ae,Q,me,I,O,re,U,ge;return{c(){u=r("p"),z=t("TF 2.0 models accepts two formats as inputs:"),g=l(),_=r("ul"),k=r("li"),T=t("having all inputs as keyword arguments (like PyTorch models), or"),m=l(),M=r("li"),ce=t("having all inputs as a list, tuple or dict in the first positional arguments."),K=l(),q=r("p"),J=t("This second option is useful when using "),A=r("code"),ne=t("tf.keras.Model.fit"),pe=t(` method which currently requires having all the
tensors in the first argument of the model call function: `),N=r("code"),ue=t("model(inputs)"),ie=t("."),Y=l(),L=r("p"),te=t(`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),G=l(),P=r("ul"),x=r("li"),oe=t("a single Tensor with "),B=r("code"),le=t("input_ids"),se=t(" only and nothing else: "),S=r("code"),he=t("model(inputs_ids)"),de=l(),C=r("li"),fe=t(`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=r("code"),ee=t("model([input_ids, attention_mask])"),ae=t(" or "),Q=r("code"),me=t("model([input_ids, attention_mask, token_type_ids])"),I=l(),O=r("li"),re=t(`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=r("code"),ge=t('model({"input_ids": input_ids, "token_type_ids": token_type_ids})')},l(p){u=a(p,"P",{});var E=i(u);z=o(E,"TF 2.0 models accepts two formats as inputs:"),E.forEach(n),g=d(p),_=a(p,"UL",{});var Z=i(_);k=a(Z,"LI",{});var Te=i(k);T=o(Te,"having all inputs as keyword arguments (like PyTorch models), or"),Te.forEach(n),m=d(Z),M=a(Z,"LI",{});var ye=i(M);ce=o(ye,"having all inputs as a list, tuple or dict in the first positional arguments."),ye.forEach(n),Z.forEach(n),K=d(p),q=a(p,"P",{});var D=i(q);J=o(D,"This second option is useful when using "),A=a(D,"CODE",{});var ke=i(A);ne=o(ke,"tf.keras.Model.fit"),ke.forEach(n),pe=o(D,` method which currently requires having all the
tensors in the first argument of the model call function: `),N=a(D,"CODE",{});var we=i(N);ue=o(we,"model(inputs)"),we.forEach(n),ie=o(D,"."),D.forEach(n),Y=d(p),L=a(p,"P",{});var $e=i(L);te=o($e,`If you choose this second option, there are three possibilities you can use to gather all the input Tensors in the
first positional argument :`),$e.forEach(n),G=d(p),P=a(p,"UL",{});var j=i(P);x=a(j,"LI",{});var R=i(x);oe=o(R,"a single Tensor with "),B=a(R,"CODE",{});var Ee=i(B);le=o(Ee,"input_ids"),Ee.forEach(n),se=o(R," only and nothing else: "),S=a(R,"CODE",{});var Fe=i(S);he=o(Fe,"model(inputs_ids)"),Fe.forEach(n),R.forEach(n),de=d(j),C=a(j,"LI",{});var V=i(C);fe=o(V,`a list of varying length with one or several input Tensors IN THE ORDER given in the docstring:
`),W=a(V,"CODE",{});var Me=i(W);ee=o(Me,"model([input_ids, attention_mask])"),Me.forEach(n),ae=o(V," or "),Q=a(V,"CODE",{});var ve=i(Q);me=o(ve,"model([input_ids, attention_mask, token_type_ids])"),ve.forEach(n),V.forEach(n),I=d(j),O=a(j,"LI",{});var _e=i(O);re=o(_e,`a dictionary with one or several input Tensors associated to the input names given in the docstring:
`),U=a(_e,"CODE",{});var ze=i(U);ge=o(ze,'model({"input_ids": input_ids, "token_type_ids": token_type_ids})'),ze.forEach(n),_e.forEach(n),j.forEach(n)},m(p,E){h(p,u,E),e(u,z),h(p,g,E),h(p,_,E),e(_,k),e(k,T),e(_,m),e(_,M),e(M,ce),h(p,K,E),h(p,q,E),e(q,J),e(q,A),e(A,ne),e(q,pe),e(q,N),e(N,ue),e(q,ie),h(p,Y,E),h(p,L,E),e(L,te),h(p,G,E),h(p,P,E),e(P,x),e(x,oe),e(x,B),e(B,le),e(x,se),e(x,S),e(S,he),e(P,de),e(P,C),e(C,fe),e(C,W),e(W,ee),e(C,ae),e(C,Q),e(Q,me),e(P,I),e(P,O),e(O,re),e(O,U),e(U,ge)},d(p){p&&n(u),p&&n(g),p&&n(_),p&&n(K),p&&n(q),p&&n(Y),p&&n(L),p&&n(G),p&&n(P)}}}function m$(H){let u,z,g,_,k;return{c(){u=r("p"),z=t("Although the recipe for forward pass needs to be defined within this function, one should call the "),g=r("code"),_=t("Module"),k=t(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){u=a(T,"P",{});var m=i(u);z=o(m,"Although the recipe for forward pass needs to be defined within this function, one should call the "),g=a(m,"CODE",{});var M=i(g);_=o(M,"Module"),M.forEach(n),k=o(m,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),m.forEach(n)},m(T,m){h(T,u,m),e(u,z),e(u,g),e(g,_),e(u,k)},d(T){T&&n(u)}}}function g$(H){let u,z,g,_,k,T,m,M,ce,K,q,J,A,ne,pe,N,ue,ie,Y,L,te,G,P,x,oe,B,le,se,S,he,de,C,fe,W,ee,ae,Q,me,I,O,re,U,ge,p,E,Z,Te,ye,D,ke,we,$e,j,R,Ee,Fe,V,Me,ve,_e,ze,oi,Yu,Ku,Oc,In,Gu,No,Zu,Xu,So,Ju,eh,Dc,Zn,Wt,Fl,Io,nh,vl,th,Ac,Nn,Wo,oh,Sn,sh,si,rh,ah,ri,ih,lh,Bo,dh,ch,ph,Xn,uh,ai,hh,fh,ii,mh,gh,Nc,Jn,Bt,bl,Qo,_h,yl,Th,Sc,xe,Uo,kh,wl,Fh,vh,Qt,li,bh,yh,di,wh,$h,Eh,Ro,Mh,ci,zh,qh,Ph,Wn,Vo,Ch,$l,xh,jh,Ho,pi,Lh,El,Oh,Dh,ui,Ah,Ml,Nh,Sh,Ut,Yo,Ih,Ko,Wh,zl,Bh,Qh,Uh,bn,Go,Rh,ql,Vh,Hh,Zo,Yh,et,Kh,Pl,Gh,Zh,Cl,Xh,Jh,ef,hi,Xo,Ic,nt,Rt,xl,Jo,nf,jl,tf,Wc,sn,es,of,ns,sf,Ll,rf,af,lf,Vt,fi,df,cf,mi,pf,uf,hf,ts,ff,gi,mf,gf,_f,yn,os,Tf,Ol,kf,Ff,ss,vf,tt,bf,Dl,yf,wf,Al,$f,Ef,Bc,ot,Ht,Nl,rs,Mf,Sl,zf,Qc,st,as,qf,is,Pf,_i,Cf,xf,Uc,rt,ls,jf,ds,Lf,Ti,Of,Df,Rc,at,Yt,Il,cs,Af,Wl,Nf,Vc,Qe,ps,Sf,Bl,If,Wf,us,Bf,hs,Qf,Uf,Rf,fs,Vf,ki,Hf,Yf,Kf,ms,Gf,gs,Zf,Xf,Jf,rn,_s,em,it,nm,Fi,tm,om,Ql,sm,rm,am,Kt,im,Ul,lm,dm,Ts,Hc,lt,Gt,Rl,ks,cm,Vl,pm,Yc,Ue,Fs,um,Hl,hm,fm,vs,mm,bs,gm,_m,Tm,ys,km,vi,Fm,vm,bm,ws,ym,$s,wm,$m,Em,an,Es,Mm,dt,zm,bi,qm,Pm,Yl,Cm,xm,jm,Zt,Lm,Kl,Om,Dm,Ms,Kc,ct,Xt,Gl,zs,Am,Zl,Nm,Gc,pt,qs,Sm,ln,Ps,Im,ut,Wm,yi,Bm,Qm,Xl,Um,Rm,Vm,Jt,Hm,Jl,Ym,Km,Cs,Zc,ht,eo,ed,xs,Gm,nd,Zm,Xc,Re,js,Xm,Ls,Jm,td,eg,ng,tg,Os,og,Ds,sg,rg,ag,As,ig,wi,lg,dg,cg,Ns,pg,Ss,ug,hg,fg,Ge,Is,mg,ft,gg,$i,_g,Tg,od,kg,Fg,vg,no,bg,sd,yg,wg,Ws,$g,Bs,Jc,mt,to,rd,Qs,Eg,ad,Mg,ep,Ve,Us,zg,id,qg,Pg,Rs,Cg,Vs,xg,jg,Lg,Hs,Og,Ei,Dg,Ag,Ng,Ys,Sg,Ks,Ig,Wg,Bg,Pe,Gs,Qg,gt,Ug,Mi,Rg,Vg,ld,Hg,Yg,Kg,oo,Gg,dd,Zg,Xg,Zs,Jg,Xs,e_,cd,n_,t_,Js,o_,er,np,_t,so,pd,nr,s_,ud,r_,tp,He,tr,a_,hd,i_,l_,or,d_,sr,c_,p_,u_,rr,h_,zi,f_,m_,g_,ar,__,ir,T_,k_,F_,dn,lr,v_,Tt,b_,qi,y_,w_,fd,$_,E_,M_,ro,z_,md,q_,P_,dr,op,kt,ao,gd,cr,C_,_d,x_,sp,Ye,pr,j_,Td,L_,O_,ur,D_,hr,A_,N_,S_,fr,I_,Pi,W_,B_,Q_,mr,U_,gr,R_,V_,H_,Ze,_r,Y_,Ft,K_,Ci,G_,Z_,kd,X_,J_,eT,io,nT,Fd,tT,oT,Tr,sT,kr,rp,vt,lo,vd,Fr,rT,bd,aT,ap,Ke,vr,iT,bt,lT,yd,dT,cT,wd,pT,uT,hT,br,fT,yr,mT,gT,_T,wr,TT,xi,kT,FT,vT,$r,bT,Er,yT,wT,$T,Xe,Mr,ET,yt,MT,ji,zT,qT,$d,PT,CT,xT,co,jT,Ed,LT,OT,zr,DT,qr,ip,wt,po,Md,Pr,AT,zd,NT,lp,Le,Cr,ST,qd,IT,WT,xr,BT,jr,QT,UT,RT,Lr,VT,Li,HT,YT,KT,Or,GT,Dr,ZT,XT,JT,uo,e1,cn,Ar,n1,$t,t1,Oi,o1,s1,Pd,r1,a1,i1,ho,l1,Cd,d1,c1,Nr,dp,Et,fo,xd,Sr,p1,jd,u1,cp,Oe,Ir,h1,Ld,f1,m1,Wr,g1,Br,_1,T1,k1,Qr,F1,Di,v1,b1,y1,Ur,w1,Rr,$1,E1,M1,mo,z1,pn,Vr,q1,Mt,P1,Ai,C1,x1,Od,j1,L1,O1,go,D1,Dd,A1,N1,Hr,pp,zt,_o,Ad,Yr,S1,Nd,I1,up,De,Kr,W1,Sd,B1,Q1,Gr,U1,Zr,R1,V1,H1,Xr,Y1,Ni,K1,G1,Z1,Jr,X1,ea,J1,ek,nk,To,tk,un,na,ok,qt,sk,Si,rk,ak,Id,ik,lk,dk,ko,ck,Wd,pk,uk,ta,hp,Pt,Fo,Bd,oa,hk,Qd,fk,fp,Ae,sa,mk,ra,gk,Ud,_k,Tk,kk,aa,Fk,ia,vk,bk,yk,la,wk,Ii,$k,Ek,Mk,da,zk,ca,qk,Pk,Ck,vo,xk,Je,pa,jk,Ct,Lk,Wi,Ok,Dk,Rd,Ak,Nk,Sk,bo,Ik,Vd,Wk,Bk,ua,Qk,ha,mp,xt,yo,Hd,fa,Uk,Yd,Rk,gp,Ne,ma,Vk,Kd,Hk,Yk,ga,Kk,_a,Gk,Zk,Xk,Ta,Jk,Bi,eF,nF,tF,ka,oF,Fa,sF,rF,aF,wo,iF,en,va,lF,jt,dF,Qi,cF,pF,Gd,uF,hF,fF,$o,mF,Zd,gF,_F,ba,TF,ya,_p,Lt,Eo,Xd,wa,kF,Jd,FF,Tp,Se,$a,vF,ec,bF,yF,Ea,wF,Ma,$F,EF,MF,za,zF,Ui,qF,PF,CF,qa,xF,Pa,jF,LF,OF,Mo,DF,hn,Ca,AF,Ot,NF,Ri,SF,IF,nc,WF,BF,QF,zo,UF,tc,RF,VF,xa,kp,Dt,qo,oc,ja,HF,sc,YF,Fp,Ie,La,KF,rc,GF,ZF,Oa,XF,Da,JF,ev,nv,Aa,tv,Vi,ov,sv,rv,Na,av,Sa,iv,lv,dv,Po,cv,nn,Ia,pv,At,uv,Hi,hv,fv,ac,mv,gv,_v,Co,Tv,ic,kv,Fv,Wa,vv,Ba,vp,Nt,xo,lc,Qa,bv,dc,yv,bp,We,Ua,wv,St,$v,cc,Ev,Mv,pc,zv,qv,Pv,Ra,Cv,Va,xv,jv,Lv,Ha,Ov,Yi,Dv,Av,Nv,Ya,Sv,Ka,Iv,Wv,Bv,jo,Qv,tn,Ga,Uv,It,Rv,Ki,Vv,Hv,uc,Yv,Kv,Gv,Lo,Zv,hc,Xv,Jv,Za,eb,Xa,yp;return T=new Ce({}),ne=new Ce({}),Io=new Ce({}),Wo=new X({props:{name:"class transformers.FunnelConfig",anchor:"transformers.FunnelConfig",parameters:[{name:"vocab_size",val:" = 30522"},{name:"block_sizes",val:" = [4, 4, 4]"},{name:"block_repeats",val:" = None"},{name:"num_decoder_layers",val:" = 2"},{name:"d_model",val:" = 768"},{name:"n_head",val:" = 12"},{name:"d_head",val:" = 64"},{name:"d_inner",val:" = 3072"},{name:"hidden_act",val:" = 'gelu_new'"},{name:"hidden_dropout",val:" = 0.1"},{name:"attention_dropout",val:" = 0.1"},{name:"activation_dropout",val:" = 0.0"},{name:"max_position_embeddings",val:" = 512"},{name:"type_vocab_size",val:" = 3"},{name:"initializer_range",val:" = 0.1"},{name:"initializer_std",val:" = None"},{name:"layer_norm_eps",val:" = 1e-09"},{name:"pooling_type",val:" = 'mean'"},{name:"attention_type",val:" = 'relative_shift'"},{name:"separate_cls",val:" = True"},{name:"truncate_seq",val:" = True"},{name:"pool_q_only",val:" = True"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.FunnelConfig.vocab_size",description:`<strong>vocab_size</strong> (<code>int</code>, <em>optional</em>, defaults to 30522) &#x2014;
Vocabulary size of the Funnel transformer. Defines the number of different tokens that can be represented
by the <code>inputs_ids</code> passed when calling <a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelModel">FunnelModel</a> or <a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.TFFunnelModel">TFFunnelModel</a>.`,name:"vocab_size"},{anchor:"transformers.FunnelConfig.block_sizes",description:`<strong>block_sizes</strong> (<code>List[int]</code>, <em>optional</em>, defaults to <code>[4, 4, 4]</code>) &#x2014;
The sizes of the blocks used in the model.`,name:"block_sizes"},{anchor:"transformers.FunnelConfig.block_repeats",description:`<strong>block_repeats</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
If passed along, each layer of each block is repeated the number of times indicated.`,name:"block_repeats"},{anchor:"transformers.FunnelConfig.num_decoder_layers",description:`<strong>num_decoder_layers</strong> (<code>int</code>, <em>optional</em>, defaults to 2) &#x2014;
The number of layers in the decoder (when not using the base model).`,name:"num_decoder_layers"},{anchor:"transformers.FunnelConfig.d_model",description:`<strong>d_model</strong> (<code>int</code>, <em>optional</em>, defaults to 768) &#x2014;
Dimensionality of the model&#x2019;s hidden states.`,name:"d_model"},{anchor:"transformers.FunnelConfig.n_head",description:`<strong>n_head</strong> (<code>int</code>, <em>optional</em>, defaults to 12) &#x2014;
Number of attention heads for each attention layer in the Transformer encoder.`,name:"n_head"},{anchor:"transformers.FunnelConfig.d_head",description:`<strong>d_head</strong> (<code>int</code>, <em>optional</em>, defaults to 64) &#x2014;
Dimensionality of the model&#x2019;s heads.`,name:"d_head"},{anchor:"transformers.FunnelConfig.d_inner",description:`<strong>d_inner</strong> (<code>int</code>, <em>optional</em>, defaults to 3072) &#x2014;
Inner dimension in the feed-forward blocks.`,name:"d_inner"},{anchor:"transformers.FunnelConfig.hidden_act",description:`<strong>hidden_act</strong> (<code>str</code> or <code>callable</code>, <em>optional</em>, defaults to <code>&quot;gelu_new&quot;</code>) &#x2014;
The non-linear activation function (function or string) in the encoder and pooler. If string, <code>&quot;gelu&quot;</code>,
<code>&quot;relu&quot;</code>, <code>&quot;silu&quot;</code> and <code>&quot;gelu_new&quot;</code> are supported.`,name:"hidden_act"},{anchor:"transformers.FunnelConfig.hidden_dropout",description:`<strong>hidden_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.`,name:"hidden_dropout"},{anchor:"transformers.FunnelConfig.attention_dropout",description:`<strong>attention_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The dropout probability for the attention probabilities.`,name:"attention_dropout"},{anchor:"transformers.FunnelConfig.activation_dropout",description:`<strong>activation_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
The dropout probability used between the two layers of the feed-forward blocks.`,name:"activation_dropout"},{anchor:"transformers.FunnelConfig.max_position_embeddings",description:`<strong>max_position_embeddings</strong> (<code>int</code>, <em>optional</em>, defaults to 512) &#x2014;
The maximum sequence length that this model might ever be used with. Typically set this to something large
just in case (e.g., 512 or 1024 or 2048).`,name:"max_position_embeddings"},{anchor:"transformers.FunnelConfig.type_vocab_size",description:`<strong>type_vocab_size</strong> (<code>int</code>, <em>optional</em>, defaults to 3) &#x2014;
The vocabulary size of the <code>token_type_ids</code> passed when calling <a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelModel">FunnelModel</a> or <a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.TFFunnelModel">TFFunnelModel</a>.`,name:"type_vocab_size"},{anchor:"transformers.FunnelConfig.initializer_range",description:`<strong>initializer_range</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The upper bound of the <em>uniform initializer</em> for initializing all weight matrices in attention layers.`,name:"initializer_range"},{anchor:"transformers.FunnelConfig.initializer_std",description:`<strong>initializer_std</strong> (<code>float</code>, <em>optional</em>) &#x2014;
The standard deviation of the <em>normal initializer</em> for initializing the embedding matrix and the weight of
linear layers. Will default to 1 for the embedding matrix and the value given by Xavier initialization for
linear layers.`,name:"initializer_std"},{anchor:"transformers.FunnelConfig.layer_norm_eps",description:`<strong>layer_norm_eps</strong> (<code>float</code>, <em>optional</em>, defaults to 1e-9) &#x2014;
The epsilon used by the layer normalization layers.`,name:"layer_norm_eps"},{anchor:"transformers.FunnelConfig.pooling_type",description:`<strong>pooling_type</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;mean&quot;</code>) &#x2014;
Possible values are <code>&quot;mean&quot;</code> or <code>&quot;max&quot;</code>. The way pooling is performed at the beginning of each block.`,name:"pooling_type"},{anchor:"transformers.FunnelConfig.attention_type",description:`<strong>attention_type</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;relative_shift&quot;</code>) &#x2014;
Possible values are <code>&quot;relative_shift&quot;</code> or <code>&quot;factorized&quot;</code>. The former is faster on CPU/GPU while the latter
is faster on TPU.`,name:"attention_type"},{anchor:"transformers.FunnelConfig.separate_cls",description:`<strong>separate_cls</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to separate the cls token when applying pooling.`,name:"separate_cls"},{anchor:"transformers.FunnelConfig.truncate_seq",description:`<strong>truncate_seq</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
When using <code>separate_cls</code>, whether or not to truncate the last token when pooling, to avoid getting a
sequence length that is not a multiple of 2.`,name:"truncate_seq"},{anchor:"transformers.FunnelConfig.pool_q_only",description:`<strong>pool_q_only</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to apply the pooling only to the query or to query, key and values for the attention layers.`,name:"pool_q_only"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/configuration_funnel.py#L37"}}),Qo=new Ce({}),Uo=new X({props:{name:"class transformers.FunnelTokenizer",anchor:"transformers.FunnelTokenizer",parameters:[{name:"vocab_file",val:""},{name:"do_lower_case",val:" = True"},{name:"do_basic_tokenize",val:" = True"},{name:"never_split",val:" = None"},{name:"unk_token",val:" = '<unk>'"},{name:"sep_token",val:" = '<sep>'"},{name:"pad_token",val:" = '<pad>'"},{name:"cls_token",val:" = '<cls>'"},{name:"mask_token",val:" = '<mask>'"},{name:"bos_token",val:" = '<s>'"},{name:"eos_token",val:" = '</s>'"},{name:"tokenize_chinese_chars",val:" = True"},{name:"strip_accents",val:" = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/tokenization_funnel.py#L58"}}),Vo=new X({props:{name:"build_inputs_with_special_tokens",anchor:"transformers.FunnelTokenizer.build_inputs_with_special_tokens",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"}],parametersDescription:[{anchor:"transformers.FunnelTokenizer.build_inputs_with_special_tokens.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs to which the special tokens will be added.`,name:"token_ids_0"},{anchor:"transformers.FunnelTokenizer.build_inputs_with_special_tokens.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/bert/tokenization_bert.py#L248",returnDescription:`
<p>List of <a href="../glossary#input-ids">input IDs</a> with the appropriate special tokens.</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),Yo=new X({props:{name:"get_special_tokens_mask",anchor:"transformers.FunnelTokenizer.get_special_tokens_mask",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"},{name:"already_has_special_tokens",val:": bool = False"}],parametersDescription:[{anchor:"transformers.FunnelTokenizer.get_special_tokens_mask.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs.`,name:"token_ids_0"},{anchor:"transformers.FunnelTokenizer.get_special_tokens_mask.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"},{anchor:"transformers.FunnelTokenizer.get_special_tokens_mask.already_has_special_tokens",description:`<strong>already_has_special_tokens</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not the token list is already formatted with special tokens for the model.`,name:"already_has_special_tokens"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/bert/tokenization_bert.py#L273",returnDescription:`
<p>A list of integers in the range [0, 1]: 1 for a special token, 0 for a sequence token.</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),Go=new X({props:{name:"create_token_type_ids_from_sequences",anchor:"transformers.FunnelTokenizer.create_token_type_ids_from_sequences",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"}],parametersDescription:[{anchor:"transformers.FunnelTokenizer.create_token_type_ids_from_sequences.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs.`,name:"token_ids_0"},{anchor:"transformers.FunnelTokenizer.create_token_type_ids_from_sequences.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/tokenization_funnel.py#L108",returnDescription:`
<p>List of <a href="../glossary#token-type-ids">token type IDs</a> according to the given sequence(s).</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),Zo=new be({props:{code:`2 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1
| first sequence    | second sequence |`,highlighted:`2<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1 1
| first sequence    | second sequence |`}}),Xo=new X({props:{name:"save_vocabulary",anchor:"transformers.FunnelTokenizer.save_vocabulary",parameters:[{name:"save_directory",val:": str"},{name:"filename_prefix",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/bert/tokenization_bert.py#L330"}}),Jo=new Ce({}),es=new X({props:{name:"class transformers.FunnelTokenizerFast",anchor:"transformers.FunnelTokenizerFast",parameters:[{name:"vocab_file",val:" = None"},{name:"tokenizer_file",val:" = None"},{name:"do_lower_case",val:" = True"},{name:"unk_token",val:" = '<unk>'"},{name:"sep_token",val:" = '<sep>'"},{name:"pad_token",val:" = '<pad>'"},{name:"cls_token",val:" = '<cls>'"},{name:"mask_token",val:" = '<mask>'"},{name:"bos_token",val:" = '<s>'"},{name:"eos_token",val:" = '</s>'"},{name:"clean_text",val:" = True"},{name:"tokenize_chinese_chars",val:" = True"},{name:"strip_accents",val:" = None"},{name:"wordpieces_prefix",val:" = '##'"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/tokenization_funnel_fast.py#L71"}}),os=new X({props:{name:"create_token_type_ids_from_sequences",anchor:"transformers.FunnelTokenizerFast.create_token_type_ids_from_sequences",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"}],parametersDescription:[{anchor:"transformers.FunnelTokenizerFast.create_token_type_ids_from_sequences.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs.`,name:"token_ids_0"},{anchor:"transformers.FunnelTokenizerFast.create_token_type_ids_from_sequences.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/tokenization_funnel_fast.py#L124",returnDescription:`
<p>List of <a href="../glossary#token-type-ids">token type IDs</a> according to the given sequence(s).</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),ss=new be({props:{code:`2 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1
| first sequence    | second sequence |`,highlighted:`2<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1 1
| first sequence    | second sequence |`}}),rs=new Ce({}),as=new X({props:{name:"class transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput",anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput",parameters:[{name:"loss",val:": typing.Optional[torch.FloatTensor] = None"},{name:"logits",val:": FloatTensor = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"}],parametersDescription:[{anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput.loss",description:`<strong>loss</strong> (<em>optional</em>, returned when <code>labels</code> is provided, <code>torch.FloatTensor</code> of shape <code>(1,)</code>) &#x2014;
Total loss of the ELECTRA-style objective.`,name:"loss"},{anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput.logits",description:`<strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Prediction scores of the head (scores for each token before SoftMax).`,name:"logits"},{anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput.hidden_states",description:`<strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.`,name:"hidden_states"},{anchor:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.`,name:"attentions"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_funnel.py#L834"}}),ls=new X({props:{name:"class transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput",anchor:"transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput",parameters:[{name:"logits",val:": Tensor = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[tensorflow.python.framework.ops.Tensor]] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[tensorflow.python.framework.ops.Tensor]] = None"}],parametersDescription:[{anchor:"transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput.logits",description:`<strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Prediction scores of the head (scores for each token before SoftMax).`,name:"logits"},{anchor:"transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput.hidden_states",description:`<strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.`,name:"hidden_states"},{anchor:"transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.`,name:"attentions"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_tf_funnel.py#L978"}}),cs=new Ce({}),ps=new X({props:{name:"class transformers.FunnelBaseModel",anchor:"transformers.FunnelBaseModel",parameters:[{name:"config",val:": FunnelConfig"}],parametersDescription:[{anchor:"transformers.FunnelBaseModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_funnel.py#L927"}}),_s=new X({props:{name:"forward",anchor:"transformers.FunnelBaseModel.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"position_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"head_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.FunnelBaseModel.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16819/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_16819/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16819/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelBaseModel.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelBaseModel.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelBaseModel.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelBaseModel.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelBaseModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelBaseModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16819/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_funnel.py#L943",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Kt=new qe({props:{$$slots:{default:[V2]},$$scope:{ctx:H}}}),Ts=new be({props:{code:`from transformers import FunnelTokenizer, FunnelBaseModel
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = FunnelBaseModel.from_pretrained("funnel-transformer/small-base")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelBaseModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelBaseModel.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),ks=new Ce({}),Fs=new X({props:{name:"class transformers.FunnelModel",anchor:"transformers.FunnelModel",parameters:[{name:"config",val:": FunnelConfig"}],parametersDescription:[{anchor:"transformers.FunnelModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_funnel.py#L1004"}}),Es=new X({props:{name:"forward",anchor:"transformers.FunnelModel.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.FunnelModel.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16819/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_16819/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16819/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelModel.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelModel.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelModel.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelModel.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16819/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_funnel.py#L1021",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_outputs.BaseModelOutput"
>transformers.modeling_outputs.BaseModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Zt=new qe({props:{$$slots:{default:[H2]},$$scope:{ctx:H}}}),Ms=new be({props:{code:`from transformers import FunnelTokenizer, FunnelModel
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelModel.from_pretrained("funnel-transformer/small")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelModel.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),zs=new Ce({}),qs=new X({props:{name:"class transformers.FunnelForPreTraining",anchor:"transformers.FunnelForPreTraining",parameters:[{name:"config",val:": FunnelConfig"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_funnel.py#L1112"}}),Ps=new X({props:{name:"forward",anchor:"transformers.FunnelForPreTraining.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.FunnelForPreTraining.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16819/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_16819/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16819/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForPreTraining.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForPreTraining.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForPreTraining.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForPreTraining.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForPreTraining.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForPreTraining.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16819/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForPreTraining.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the ELECTRA-style loss. Input should be a sequence of tokens (see <code>input_ids</code>
docstring) Indices should be in <code>[0, 1]</code>:</p>
<ul>
<li>0 indicates the token is an original token,</li>
<li>1 indicates the token was replaced.</li>
</ul>`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_funnel.py#L1121",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput"
>transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<em>optional</em>, returned when <code>labels</code> is provided, <code>torch.FloatTensor</code> of shape <code>(1,)</code>) \u2014 Total loss of the ELECTRA-style objective.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Prediction scores of the head (scores for each token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput"
>transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),Jt=new qe({props:{$$slots:{default:[Y2]},$$scope:{ctx:H}}}),Cs=new be({props:{code:`from transformers import FunnelTokenizer, FunnelForPreTraining
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelForPreTraining.from_pretrained("funnel-transformer/small")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
logits = model(**inputs).logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForPreTraining
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForPreTraining.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(**inputs).logits`}}),xs=new Ce({}),js=new X({props:{name:"class transformers.FunnelForMaskedLM",anchor:"transformers.FunnelForMaskedLM",parameters:[{name:"config",val:": FunnelConfig"}],parametersDescription:[{anchor:"transformers.FunnelForMaskedLM.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_funnel.py#L1195"}}),Is=new X({props:{name:"forward",anchor:"transformers.FunnelForMaskedLM.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.FunnelForMaskedLM.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16819/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_16819/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16819/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForMaskedLM.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForMaskedLM.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForMaskedLM.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForMaskedLM.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForMaskedLM.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForMaskedLM.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16819/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForMaskedLM.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the masked language modeling loss. Indices should be in <code>[-100, 0, ..., config.vocab_size]</code> (see <code>input_ids</code> docstring) Tokens with indices set to <code>-100</code> are ignored (masked), the
loss is only computed for the tokens with labels in <code>[0, ..., config.vocab_size]</code>`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_funnel.py#L1211",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_outputs.MaskedLMOutput"
>transformers.modeling_outputs.MaskedLMOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Masked language modeling (MLM) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, config.vocab_size)</code>) \u2014 Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_outputs.MaskedLMOutput"
>transformers.modeling_outputs.MaskedLMOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),no=new qe({props:{$$slots:{default:[K2]},$$scope:{ctx:H}}}),Ws=new be({props:{code:`from transformers import FunnelTokenizer, FunnelForMaskedLM
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelForMaskedLM.from_pretrained("funnel-transformer/small")

inputs = tokenizer("The capital of France is <mask>.", return_tensors="pt")

with torch.no_grad():
    logits = model(**inputs).logits

# retrieve index of <mask>
mask_token_index = (inputs.input_ids == tokenizer.mask_token_id)[0].nonzero(as_tuple=True)[0]

predicted_token_id = logits[0, mask_token_index].argmax(axis=-1)
tokenizer.decode(predicted_token_id)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForMaskedLM
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForMaskedLM.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;The capital of France is &lt;mask&gt;.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># retrieve index of &lt;mask&gt;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>mask_token_index = (inputs.input_ids == tokenizer.mask_token_id)[<span class="hljs-number">0</span>].nonzero(as_tuple=<span class="hljs-literal">True</span>)[<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_token_id = logits[<span class="hljs-number">0</span>, mask_token_index].argmax(axis=-<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.decode(predicted_token_id)
`}}),Bs=new be({props:{code:`labels = tokenizer("The capital of France is Paris.", return_tensors="pt")["input_ids"]
# mask labels of non-<mask> tokens
labels = torch.where(inputs.input_ids == tokenizer.mask_token_id, labels, -100)

outputs = model(**inputs, labels=labels)
round(outputs.loss.item(), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>labels = tokenizer(<span class="hljs-string">&quot;The capital of France is Paris.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)[<span class="hljs-string">&quot;input_ids&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># mask labels of non-&lt;mask&gt; tokens</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.where(inputs.input_ids == tokenizer.mask_token_id, labels, -<span class="hljs-number">100</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, labels=labels)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(outputs.loss.item(), <span class="hljs-number">2</span>)
`}}),Qs=new Ce({}),Us=new X({props:{name:"class transformers.FunnelForSequenceClassification",anchor:"transformers.FunnelForSequenceClassification",parameters:[{name:"config",val:": FunnelConfig"}],parametersDescription:[{anchor:"transformers.FunnelForSequenceClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_funnel.py#L1275"}}),Gs=new X({props:{name:"forward",anchor:"transformers.FunnelForSequenceClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.FunnelForSequenceClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16819/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_16819/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16819/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForSequenceClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForSequenceClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForSequenceClassification.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForSequenceClassification.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForSequenceClassification.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForSequenceClassification.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16819/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForSequenceClassification.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the sequence classification/regression loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>. If <code>config.num_labels == 1</code> a regression loss is computed (Mean-Square loss), If
<code>config.num_labels &gt; 1</code> a classification loss is computed (Cross-Entropy).`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_funnel.py#L1286",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_outputs.SequenceClassifierOutput"
>transformers.modeling_outputs.SequenceClassifierOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification (or regression if config.num_labels==1) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, config.num_labels)</code>) \u2014 Classification (or regression if config.num_labels==1) scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_outputs.SequenceClassifierOutput"
>transformers.modeling_outputs.SequenceClassifierOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),oo=new qe({props:{$$slots:{default:[G2]},$$scope:{ctx:H}}}),Zs=new be({props:{code:`import torch
from transformers import FunnelTokenizer, FunnelForSequenceClassification

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = FunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")

with torch.no_grad():
    logits = model(**inputs).logits

predicted_class_id = logits.argmax().item()
model.config.id2label[predicted_class_id]
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_class_id = logits.argmax().item()
<span class="hljs-meta">&gt;&gt;&gt; </span>model.config.id2label[predicted_class_id]
`}}),Xs=new be({props:{code:`# To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`
num_labels = len(model.config.id2label)
model = FunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base", num_labels=num_labels)

labels = torch.tensor(1)
loss = model(**inputs, labels=labels).loss
round(loss.item(), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>num_labels = <span class="hljs-built_in">len</span>(model.config.id2label)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>, num_labels=num_labels)

<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.tensor(<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs, labels=labels).loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(loss.item(), <span class="hljs-number">2</span>)
`}}),Js=new be({props:{code:`import torch
from transformers import FunnelTokenizer, FunnelForSequenceClassification

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = FunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base", problem_type="multi_label_classification")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")

with torch.no_grad():
    logits = model(**inputs).logits

predicted_class_id = logits.argmax().item()
model.config.id2label[predicted_class_id]
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>, problem_type=<span class="hljs-string">&quot;multi_label_classification&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_class_id = logits.argmax().item()
<span class="hljs-meta">&gt;&gt;&gt; </span>model.config.id2label[predicted_class_id]
`}}),er=new be({props:{code:`# To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`
num_labels = len(model.config.id2label)
model = FunnelForSequenceClassification.from_pretrained(
    "funnel-transformer/small-base", num_labels=num_labels, problem_type="multi_label_classification"
)

labels = torch.nn.functional.one_hot(torch.tensor([predicted_class_id]), num_classes=num_labels).to(
    torch.float
)
loss = model(**inputs, labels=labels).loss
loss.backward()`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>num_labels = <span class="hljs-built_in">len</span>(model.config.id2label)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForSequenceClassification.from_pretrained(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>, num_labels=num_labels, problem_type=<span class="hljs-string">&quot;multi_label_classification&quot;</span>
<span class="hljs-meta">... </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.nn.functional.one_hot(torch.tensor([predicted_class_id]), num_classes=num_labels).to(
<span class="hljs-meta">... </span>    torch.<span class="hljs-built_in">float</span>
<span class="hljs-meta">... </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs, labels=labels).loss
<span class="hljs-meta">&gt;&gt;&gt; </span>loss.backward()`}}),nr=new Ce({}),tr=new X({props:{name:"class transformers.FunnelForMultipleChoice",anchor:"transformers.FunnelForMultipleChoice",parameters:[{name:"config",val:": FunnelConfig"}],parametersDescription:[{anchor:"transformers.FunnelForMultipleChoice.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_funnel.py#L1368"}}),lr=new X({props:{name:"forward",anchor:"transformers.FunnelForMultipleChoice.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.FunnelForMultipleChoice.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16819/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_16819/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16819/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForMultipleChoice.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForMultipleChoice.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForMultipleChoice.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForMultipleChoice.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForMultipleChoice.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForMultipleChoice.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16819/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForMultipleChoice.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the multiple choice classification loss. Indices should be in <code>[0, ..., num_choices-1]</code> where <code>num_choices</code> is the size of the second dimension of the input tensors. (See
<code>input_ids</code> above)`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_funnel.py#L1377",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_outputs.MultipleChoiceModelOutput"
>transformers.modeling_outputs.MultipleChoiceModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <em>(1,)</em>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_choices)</code>) \u2014 <em>num_choices</em> is the second dimension of the input tensors. (see <em>input_ids</em> above).</p>
<p>Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_outputs.MultipleChoiceModelOutput"
>transformers.modeling_outputs.MultipleChoiceModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),ro=new qe({props:{$$slots:{default:[Z2]},$$scope:{ctx:H}}}),dr=new be({props:{code:`from transformers import FunnelTokenizer, FunnelForMultipleChoice
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = FunnelForMultipleChoice.from_pretrained("funnel-transformer/small-base")

prompt = "In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced."
choice0 = "It is eaten with a fork and a knife."
choice1 = "It is eaten while held in the hand."
labels = torch.tensor(0).unsqueeze(0)  # choice0 is correct (according to Wikipedia ;)), batch size 1

encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors="pt", padding=True)
outputs = model(**{k: v.unsqueeze(0) for k, v in encoding.items()}, labels=labels)  # batch size is 1

# the linear classifier still needs to be trained
loss = outputs.loss
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForMultipleChoice
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForMultipleChoice.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>prompt = <span class="hljs-string">&quot;In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice0 = <span class="hljs-string">&quot;It is eaten with a fork and a knife.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice1 = <span class="hljs-string">&quot;It is eaten while held in the hand.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = torch.tensor(<span class="hljs-number">0</span>).unsqueeze(<span class="hljs-number">0</span>)  <span class="hljs-comment"># choice0 is correct (according to Wikipedia ;)), batch size 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors=<span class="hljs-string">&quot;pt&quot;</span>, padding=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**{k: v.unsqueeze(<span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> encoding.items()}, labels=labels)  <span class="hljs-comment"># batch size is 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># the linear classifier still needs to be trained</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = outputs.loss
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),cr=new Ce({}),pr=new X({props:{name:"class transformers.FunnelForTokenClassification",anchor:"transformers.FunnelForTokenClassification",parameters:[{name:"config",val:": FunnelConfig"}],parametersDescription:[{anchor:"transformers.FunnelForTokenClassification.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_funnel.py#L1452"}}),_r=new X({props:{name:"forward",anchor:"transformers.FunnelForTokenClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"labels",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.FunnelForTokenClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16819/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_16819/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16819/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForTokenClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForTokenClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForTokenClassification.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForTokenClassification.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForTokenClassification.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForTokenClassification.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16819/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForTokenClassification.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the token classification loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>.`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_funnel.py#L1464",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_outputs.TokenClassifierOutput"
>transformers.modeling_outputs.TokenClassifierOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided)  \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, config.num_labels)</code>) \u2014 Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_outputs.TokenClassifierOutput"
>transformers.modeling_outputs.TokenClassifierOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),io=new qe({props:{$$slots:{default:[X2]},$$scope:{ctx:H}}}),Tr=new be({props:{code:`from transformers import FunnelTokenizer, FunnelForTokenClassification
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelForTokenClassification.from_pretrained("funnel-transformer/small")

inputs = tokenizer(
    "HuggingFace is a company based in Paris and New York", add_special_tokens=False, return_tensors="pt"
)

with torch.no_grad():
    logits = model(**inputs).logits

predicted_token_class_ids = logits.argmax(-1)

# Note that tokens are classified rather then input words which means that
# there might be more predicted token classes than words.
# Multiple token classes might account for the same word
predicted_tokens_classes = [model.config.id2label[t.item()] for t in predicted_token_class_ids[0]]
predicted_tokens_classes
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForTokenClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;HuggingFace is a company based in Paris and New York&quot;</span>, add_special_tokens=<span class="hljs-literal">False</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>
<span class="hljs-meta">... </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_token_class_ids = logits.argmax(-<span class="hljs-number">1</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Note that tokens are classified rather then input words which means that</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># there might be more predicted token classes than words.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Multiple token classes might account for the same word</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_tokens_classes = [model.config.id2label[t.item()] <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> predicted_token_class_ids[<span class="hljs-number">0</span>]]
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_tokens_classes
`}}),kr=new be({props:{code:`labels = predicted_token_class_ids
loss = model(**inputs, labels=labels).loss
round(loss.item(), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>labels = predicted_token_class_ids
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs, labels=labels).loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(loss.item(), <span class="hljs-number">2</span>)
`}}),Fr=new Ce({}),vr=new X({props:{name:"class transformers.FunnelForQuestionAnswering",anchor:"transformers.FunnelForQuestionAnswering",parameters:[{name:"config",val:": FunnelConfig"}],parametersDescription:[{anchor:"transformers.FunnelForQuestionAnswering.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig">FunnelConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_funnel.py#L1526"}}),Mr=new X({props:{name:"forward",anchor:"transformers.FunnelForQuestionAnswering.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"inputs_embeds",val:": typing.Optional[torch.Tensor] = None"},{name:"start_positions",val:": typing.Optional[torch.Tensor] = None"},{name:"end_positions",val:": typing.Optional[torch.Tensor] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],parametersDescription:[{anchor:"transformers.FunnelForQuestionAnswering.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16819/en/model_doc/bert#transformers.BertTokenizer">BertTokenizer</a>. See <a href="/docs/transformers/pr_16819/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_16819/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FunnelForQuestionAnswering.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FunnelForQuestionAnswering.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.FunnelForQuestionAnswering.forward.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.FunnelForQuestionAnswering.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FunnelForQuestionAnswering.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FunnelForQuestionAnswering.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16819/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FunnelForQuestionAnswering.forward.start_positions",description:`<strong>start_positions</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the start of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"start_positions"},{anchor:"transformers.FunnelForQuestionAnswering.forward.end_positions",description:`<strong>end_positions</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the end of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"end_positions"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_funnel.py#L1537",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_outputs.QuestionAnsweringModelOutput"
>transformers.modeling_outputs.QuestionAnsweringModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.</p>
</li>
<li>
<p><strong>start_logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-start scores (before SoftMax).</p>
</li>
<li>
<p><strong>end_logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-end scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings, if the model has an embedding layer, +
one for the output of each layer) of shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the optional initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_outputs.QuestionAnsweringModelOutput"
>transformers.modeling_outputs.QuestionAnsweringModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),co=new qe({props:{$$slots:{default:[J2]},$$scope:{ctx:H}}}),zr=new be({props:{code:`from transformers import FunnelTokenizer, FunnelForQuestionAnswering
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = FunnelForQuestionAnswering.from_pretrained("funnel-transformer/small")

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"

inputs = tokenizer(question, text, return_tensors="pt")
with torch.no_grad():
    outputs = model(**inputs)

answer_start_index = outputs.start_logits.argmax()
answer_end_index = outputs.end_logits.argmax()

predict_answer_tokens = inputs.input_ids[0, answer_start_index : answer_end_index + 1]
tokenizer.decode(predict_answer_tokens)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, FunnelForQuestionAnswering
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FunnelForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(question, text, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>answer_start_index = outputs.start_logits.argmax()
<span class="hljs-meta">&gt;&gt;&gt; </span>answer_end_index = outputs.end_logits.argmax()

<span class="hljs-meta">&gt;&gt;&gt; </span>predict_answer_tokens = inputs.input_ids[<span class="hljs-number">0</span>, answer_start_index : answer_end_index + <span class="hljs-number">1</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.decode(predict_answer_tokens)
`}}),qr=new be({props:{code:`# target is "nice puppet"
target_start_index = torch.tensor([14])
target_end_index = torch.tensor([15])

outputs = model(**inputs, start_positions=target_start_index, end_positions=target_end_index)
loss = outputs.loss
round(loss.item(), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># target is &quot;nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>target_start_index = torch.tensor([<span class="hljs-number">14</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>target_end_index = torch.tensor([<span class="hljs-number">15</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, start_positions=target_start_index, end_positions=target_end_index)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = outputs.loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(loss.item(), <span class="hljs-number">2</span>)
`}}),Pr=new Ce({}),Cr=new X({props:{name:"class transformers.TFFunnelBaseModel",anchor:"transformers.TFFunnelBaseModel",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelBaseModel.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_tf_funnel.py#L1095"}}),uo=new qe({props:{$$slots:{default:[e$]},$$scope:{ctx:H}}}),Ar=new X({props:{name:"call",anchor:"transformers.TFFunnelBaseModel.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"training",val:": bool = False"}],parametersDescription:[{anchor:"transformers.TFFunnelBaseModel.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/pr_16819/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/pr_16819/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelBaseModel.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelBaseModel.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelBaseModel.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelBaseModel.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelBaseModel.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelBaseModel.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16819/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelBaseModel.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_tf_funnel.py#L1100",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),ho=new qe({props:{$$slots:{default:[n$]},$$scope:{ctx:H}}}),Nr=new be({props:{code:`from transformers import FunnelTokenizer, TFFunnelBaseModel
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = TFFunnelBaseModel.from_pretrained("funnel-transformer/small-base")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")
outputs = model(inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelBaseModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelBaseModel.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),Sr=new Ce({}),Ir=new X({props:{name:"class transformers.TFFunnelModel",anchor:"transformers.TFFunnelModel",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelModel.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_tf_funnel.py#L1142"}}),mo=new qe({props:{$$slots:{default:[t$]},$$scope:{ctx:H}}}),Vr=new X({props:{name:"call",anchor:"transformers.TFFunnelModel.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"training",val:": bool = False"}],parametersDescription:[{anchor:"transformers.TFFunnelModel.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/pr_16819/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/pr_16819/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelModel.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelModel.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelModel.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelModel.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelModel.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelModel.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16819/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelModel.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_tf_funnel.py#L1147",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the model.</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_tf_outputs.TFBaseModelOutput"
>transformers.modeling_tf_outputs.TFBaseModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),go=new qe({props:{$$slots:{default:[o$]},$$scope:{ctx:H}}}),Hr=new be({props:{code:`from transformers import FunnelTokenizer, TFFunnelModel
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelModel.from_pretrained("funnel-transformer/small")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")
outputs = model(inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelModel.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),Yr=new Ce({}),Kr=new X({props:{name:"class transformers.TFFunnelForPreTraining",anchor:"transformers.TFFunnelForPreTraining",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelForPreTraining.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_tf_funnel.py#L1192"}}),To=new qe({props:{$$slots:{default:[s$]},$$scope:{ctx:H}}}),na=new X({props:{name:"call",anchor:"transformers.TFFunnelForPreTraining.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"training",val:": bool = False"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelForPreTraining.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/pr_16819/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/pr_16819/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForPreTraining.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForPreTraining.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForPreTraining.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForPreTraining.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForPreTraining.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForPreTraining.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16819/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForPreTraining.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_tf_funnel.py#L1199",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput"
>transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Prediction scores of the head (scores for each token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput"
>transformers.models.funnel.modeling_tf_funnel.TFFunnelForPreTrainingOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),ko=new qe({props:{$$slots:{default:[r$]},$$scope:{ctx:H}}}),ta=new be({props:{code:`from transformers import FunnelTokenizer, TFFunnelForPreTraining
import torch

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelForPreTraining.from_pretrained("funnel-transformer/small")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")
logits = model(inputs).logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForPreTraining
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForPreTraining.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(inputs).logits`}}),oa=new Ce({}),sa=new X({props:{name:"class transformers.TFFunnelForMaskedLM",anchor:"transformers.TFFunnelForMaskedLM",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelForMaskedLM.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_tf_funnel.py#L1259"}}),vo=new qe({props:{$$slots:{default:[a$]},$$scope:{ctx:H}}}),pa=new X({props:{name:"call",anchor:"transformers.TFFunnelForMaskedLM.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"}],parametersDescription:[{anchor:"transformers.TFFunnelForMaskedLM.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/pr_16819/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/pr_16819/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForMaskedLM.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForMaskedLM.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForMaskedLM.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForMaskedLM.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForMaskedLM.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForMaskedLM.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16819/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForMaskedLM.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForMaskedLM.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the masked language modeling loss. Indices should be in <code>[-100, 0, ..., config.vocab_size]</code> (see <code>input_ids</code> docstring) Tokens with indices set to <code>-100</code> are ignored (masked), the
loss is only computed for the tokens with labels in <code>[0, ..., config.vocab_size]</code>`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_tf_funnel.py#L1273",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_tf_outputs.TFMaskedLMOutput"
>transformers.modeling_tf_outputs.TFMaskedLMOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(n,)</code>, <em>optional</em>, where n is the number of non-masked labels, returned when <code>labels</code> is provided) \u2014 Masked language modeling (MLM) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, config.vocab_size)</code>) \u2014 Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_tf_outputs.TFMaskedLMOutput"
>transformers.modeling_tf_outputs.TFMaskedLMOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),bo=new qe({props:{$$slots:{default:[i$]},$$scope:{ctx:H}}}),ua=new be({props:{code:`from transformers import FunnelTokenizer, TFFunnelForMaskedLM
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelForMaskedLM.from_pretrained("funnel-transformer/small")

inputs = tokenizer("The capital of France is [MASK].", return_tensors="tf")
logits = model(**inputs).logits

# retrieve index of [MASK]
mask_token_index = tf.where((inputs.input_ids == tokenizer.mask_token_id)[0])
selected_logits = tf.gather_nd(logits[0], indices=mask_token_index)

predicted_token_id = tf.math.argmax(selected_logits, axis=-1)
tokenizer.decode(predicted_token_id)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForMaskedLM
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForMaskedLM.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;The capital of France is [MASK].&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># retrieve index of [MASK]</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>mask_token_index = tf.where((inputs.input_ids == tokenizer.mask_token_id)[<span class="hljs-number">0</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>selected_logits = tf.gather_nd(logits[<span class="hljs-number">0</span>], indices=mask_token_index)

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_token_id = tf.math.argmax(selected_logits, axis=-<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.decode(predicted_token_id)
`}}),ha=new be({props:{code:`labels = tokenizer("The capital of France is Paris.", return_tensors="tf")["input_ids"]
# mask labels of non-[MASK] tokens
labels = tf.where(inputs.input_ids == tokenizer.mask_token_id, labels, -100)

outputs = model(**inputs, labels=labels)
round(float(outputs.loss), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>labels = tokenizer(<span class="hljs-string">&quot;The capital of France is Paris.&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)[<span class="hljs-string">&quot;input_ids&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># mask labels of non-[MASK] tokens</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>labels = tf.where(inputs.input_ids == tokenizer.mask_token_id, labels, -<span class="hljs-number">100</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, labels=labels)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(outputs.loss), <span class="hljs-number">2</span>)
`}}),fa=new Ce({}),ma=new X({props:{name:"class transformers.TFFunnelForSequenceClassification",anchor:"transformers.TFFunnelForSequenceClassification",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelForSequenceClassification.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_tf_funnel.py#L1340"}}),wo=new qe({props:{$$slots:{default:[l$]},$$scope:{ctx:H}}}),va=new X({props:{name:"call",anchor:"transformers.TFFunnelForSequenceClassification.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"}],parametersDescription:[{anchor:"transformers.TFFunnelForSequenceClassification.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/pr_16819/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/pr_16819/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForSequenceClassification.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForSequenceClassification.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForSequenceClassification.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForSequenceClassification.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForSequenceClassification.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForSequenceClassification.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16819/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForSequenceClassification.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForSequenceClassification.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the sequence classification/regression loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>. If <code>config.num_labels == 1</code> a regression loss is computed (Mean-Square loss), If
<code>config.num_labels &gt; 1</code> a classification loss is computed (Cross-Entropy).`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_tf_funnel.py#L1348",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_tf_outputs.TFSequenceClassifierOutput"
>transformers.modeling_tf_outputs.TFSequenceClassifierOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, )</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification (or regression if config.num_labels==1) loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, config.num_labels)</code>) \u2014 Classification (or regression if config.num_labels==1) scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_tf_outputs.TFSequenceClassifierOutput"
>transformers.modeling_tf_outputs.TFSequenceClassifierOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),$o=new qe({props:{$$slots:{default:[d$]},$$scope:{ctx:H}}}),ba=new be({props:{code:`from transformers import FunnelTokenizer, TFFunnelForSequenceClassification
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = TFFunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base")

inputs = tokenizer("Hello, my dog is cute", return_tensors="tf")

logits = model(**inputs).logits

predicted_class_id = int(tf.math.argmax(logits, axis=-1)[0])
model.config.id2label[predicted_class_id]
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForSequenceClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(**inputs).logits

<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_class_id = <span class="hljs-built_in">int</span>(tf.math.argmax(logits, axis=-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>model.config.id2label[predicted_class_id]
`}}),ya=new be({props:{code:`# To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`
num_labels = len(model.config.id2label)
model = TFFunnelForSequenceClassification.from_pretrained("funnel-transformer/small-base", num_labels=num_labels)

labels = tf.constant(1)
loss = model(**inputs, labels=labels).loss
round(float(loss), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># To train a model on \`num_labels\` classes, you can pass \`num_labels=num_labels\` to \`.from_pretrained(...)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>num_labels = <span class="hljs-built_in">len</span>(model.config.id2label)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>, num_labels=num_labels)

<span class="hljs-meta">&gt;&gt;&gt; </span>labels = tf.constant(<span class="hljs-number">1</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = model(**inputs, labels=labels).loss
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(loss), <span class="hljs-number">2</span>)
`}}),wa=new Ce({}),$a=new X({props:{name:"class transformers.TFFunnelForMultipleChoice",anchor:"transformers.TFFunnelForMultipleChoice",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelForMultipleChoice.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_tf_funnel.py#L1416"}}),Mo=new qe({props:{$$slots:{default:[c$]},$$scope:{ctx:H}}}),Ca=new X({props:{name:"call",anchor:"transformers.TFFunnelForMultipleChoice.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"}],parametersDescription:[{anchor:"transformers.TFFunnelForMultipleChoice.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/pr_16819/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/pr_16819/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForMultipleChoice.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForMultipleChoice.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForMultipleChoice.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, num_choices, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForMultipleChoice.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForMultipleChoice.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForMultipleChoice.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16819/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForMultipleChoice.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForMultipleChoice.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for computing the multiple choice classification loss. Indices should be in <code>[0, ..., num_choices]</code>
where <code>num_choices</code> is the size of the second dimension of the input tensors. (See <code>input_ids</code> above)`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_tf_funnel.py#L1433",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput"
>transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <em>(batch_size, )</em>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, num_choices)</code>) \u2014 <em>num_choices</em> is the second dimension of the input tensors. (see <em>input_ids</em> above).</p>
<p>Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput"
>transformers.modeling_tf_outputs.TFMultipleChoiceModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),zo=new qe({props:{$$slots:{default:[p$]},$$scope:{ctx:H}}}),xa=new be({props:{code:`from transformers import FunnelTokenizer, TFFunnelForMultipleChoice
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small-base")
model = TFFunnelForMultipleChoice.from_pretrained("funnel-transformer/small-base")

prompt = "In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced."
choice0 = "It is eaten with a fork and a knife."
choice1 = "It is eaten while held in the hand."

encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors="tf", padding=True)
inputs = {k: tf.expand_dims(v, 0) for k, v in encoding.items()}
outputs = model(inputs)  # batch size is 1

# the linear classifier still needs to be trained
logits = outputs.logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForMultipleChoice
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForMultipleChoice.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small-base&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>prompt = <span class="hljs-string">&quot;In Italy, pizza served in formal settings, such as at a restaurant, is presented unsliced.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice0 = <span class="hljs-string">&quot;It is eaten with a fork and a knife.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>choice1 = <span class="hljs-string">&quot;It is eaten while held in the hand.&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>encoding = tokenizer([prompt, prompt], [choice0, choice1], return_tensors=<span class="hljs-string">&quot;tf&quot;</span>, padding=<span class="hljs-literal">True</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = {k: tf.expand_dims(v, <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> encoding.items()}
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(inputs)  <span class="hljs-comment"># batch size is 1</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># the linear classifier still needs to be trained</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits`}}),ja=new Ce({}),La=new X({props:{name:"class transformers.TFFunnelForTokenClassification",anchor:"transformers.TFFunnelForTokenClassification",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelForTokenClassification.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_tf_funnel.py#L1532"}}),Po=new qe({props:{$$slots:{default:[u$]},$$scope:{ctx:H}}}),Ia=new X({props:{name:"call",anchor:"transformers.TFFunnelForTokenClassification.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"labels",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"}],parametersDescription:[{anchor:"transformers.TFFunnelForTokenClassification.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/pr_16819/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/pr_16819/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForTokenClassification.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForTokenClassification.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForTokenClassification.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForTokenClassification.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForTokenClassification.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForTokenClassification.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16819/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForTokenClassification.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForTokenClassification.call.labels",description:`<strong>labels</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the token classification loss. Indices should be in <code>[0, ..., config.num_labels - 1]</code>.`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_tf_funnel.py#L1543",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_tf_outputs.TFTokenClassifierOutput"
>transformers.modeling_tf_outputs.TFTokenClassifierOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(n,)</code>, <em>optional</em>, where n is the number of unmasked labels, returned when <code>labels</code> is provided)  \u2014 Classification loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, config.num_labels)</code>) \u2014 Classification scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_tf_outputs.TFTokenClassifierOutput"
>transformers.modeling_tf_outputs.TFTokenClassifierOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),Co=new qe({props:{$$slots:{default:[h$]},$$scope:{ctx:H}}}),Wa=new be({props:{code:`from transformers import FunnelTokenizer, TFFunnelForTokenClassification
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelForTokenClassification.from_pretrained("funnel-transformer/small")

inputs = tokenizer(
    "HuggingFace is a company based in Paris and New York", add_special_tokens=False, return_tensors="tf"
)

logits = model(**inputs).logits
predicted_token_class_ids = tf.math.argmax(logits, axis=-1)

# Note that tokens are classified rather then input words which means that
# there might be more predicted token classes than words.
# Multiple token classes might account for the same word
predicted_tokens_classes = [model.config.id2label[t] for t in predicted_token_class_ids[0].numpy().tolist()]
predicted_tokens_classes
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForTokenClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(
<span class="hljs-meta">... </span>    <span class="hljs-string">&quot;HuggingFace is a company based in Paris and New York&quot;</span>, add_special_tokens=<span class="hljs-literal">False</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>
<span class="hljs-meta">... </span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>logits = model(**inputs).logits
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_token_class_ids = tf.math.argmax(logits, axis=-<span class="hljs-number">1</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Note that tokens are classified rather then input words which means that</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># there might be more predicted token classes than words.</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Multiple token classes might account for the same word</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_tokens_classes = [model.config.id2label[t] <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> predicted_token_class_ids[<span class="hljs-number">0</span>].numpy().tolist()]
<span class="hljs-meta">&gt;&gt;&gt; </span>predicted_tokens_classes
`}}),Ba=new be({props:{code:`labels = predicted_token_class_ids
loss = tf.math.reduce_mean(model(**inputs, labels=labels).loss)
round(float(loss), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>labels = predicted_token_class_ids
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = tf.math.reduce_mean(model(**inputs, labels=labels).loss)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(loss), <span class="hljs-number">2</span>)
`}}),Qa=new Ce({}),Ua=new X({props:{name:"class transformers.TFFunnelForQuestionAnswering",anchor:"transformers.TFFunnelForQuestionAnswering",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.TFFunnelForQuestionAnswering.config",description:`<strong>config</strong> (<code>XxxConfig</code>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_tf_funnel.py#L1610"}}),jo=new qe({props:{$$slots:{default:[f$]},$$scope:{ctx:H}}}),Ga=new X({props:{name:"call",anchor:"transformers.TFFunnelForQuestionAnswering.call",parameters:[{name:"input_ids",val:": typing.Union[typing.List[tensorflow.python.framework.ops.Tensor], typing.List[numpy.ndarray], typing.List[tensorflow.python.keras.engine.keras_tensor.KerasTensor], typing.Dict[str, tensorflow.python.framework.ops.Tensor], typing.Dict[str, numpy.ndarray], typing.Dict[str, tensorflow.python.keras.engine.keras_tensor.KerasTensor], tensorflow.python.framework.ops.Tensor, numpy.ndarray, tensorflow.python.keras.engine.keras_tensor.KerasTensor, NoneType] = None"},{name:"attention_mask",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"token_type_ids",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"inputs_embeds",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"},{name:"start_positions",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"end_positions",val:": typing.Union[numpy.ndarray, tensorflow.python.framework.ops.Tensor, NoneType] = None"},{name:"training",val:": bool = False"}],parametersDescription:[{anchor:"transformers.TFFunnelForQuestionAnswering.call.input_ids",description:`<strong>input_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelTokenizer">FunnelTokenizer</a>. See <a href="/docs/transformers/pr_16819/en/model_doc/wav2vec2_phoneme#transformers.Wav2Vec2PhonemeCTCTokenizer.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> and
<a href="/docs/transformers/pr_16819/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.attention_mask",description:`<strong>attention_mask</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.token_type_ids",description:`<strong>token_type_ids</strong> (<code>Numpy array</code> or <code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:</p>
<ul>
<li>0 corresponds to a <em>sentence A</em> token,</li>
<li>1 corresponds to a <em>sentence B</em> token.</li>
</ul>
<p><a href="../glossary#token-type-ids">What are token type IDs?</a>`,name:"token_type_ids"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.inputs_embeds",description:`<strong>inputs_embeds</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) &#x2014;
Optionally, instead of passing <code>input_ids</code> you can choose to directly pass an embedded representation. This
is useful if you want more control over how to convert <code>input_ids</code> indices into associated vectors than the
model&#x2019;s internal embedding lookup matrix.`,name:"inputs_embeds"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail. This argument can be used only in eager mode, in graph mode the value in the
config will be used instead.`,name:"output_attentions"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail. This argument can be used only in eager mode, in graph mode the value in the config will be
used instead.`,name:"output_hidden_states"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_16819/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple. This argument can be used in
eager mode, in graph mode the value will always be set to True.`,name:"return_dict"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.training",description:`<strong>training</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to use the model in training mode (some modules like dropout modules have different
behaviors between training and evaluation).`,name:"training"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.start_positions",description:`<strong>start_positions</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the start of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"start_positions"},{anchor:"transformers.TFFunnelForQuestionAnswering.call.end_positions",description:`<strong>end_positions</strong> (<code>tf.Tensor</code> of shape <code>(batch_size,)</code>, <em>optional</em>) &#x2014;
Labels for position (index) of the end of the labelled span for computing the token classification loss.
Positions are clamped to the length of the sequence (<code>sequence_length</code>). Position outside of the sequence
are not taken into account for computing the loss.`,name:"end_positions"}],source:"https://github.com/huggingface/transformers/blob/pr_16819/src/transformers/models/funnel/modeling_tf_funnel.py#L1620",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput"
>transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput</a> or a tuple of <code>tf.Tensor</code> (if
<code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various elements depending on the
configuration (<a
  href="/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelConfig"
>FunnelConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, )</code>, <em>optional</em>, returned when <code>start_positions</code> and <code>end_positions</code> are provided) \u2014 Total span extraction loss is the sum of a Cross-Entropy for the start and end positions.</p>
</li>
<li>
<p><strong>start_logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-start scores (before SoftMax).</p>
</li>
<li>
<p><strong>end_logits</strong> (<code>tf.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) \u2014 Span-end scores (before SoftMax).</p>
</li>
<li>
<p><strong>hidden_states</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for the output of the embeddings + one for the output of each layer) of shape
<code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the model at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>attentions</strong> (<code>tuple(tf.Tensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>tf.Tensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights after the attention softmax, used to compute the weighted average in the self-attention
heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_16819/en/main_classes/output#transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput"
>transformers.modeling_tf_outputs.TFQuestionAnsweringModelOutput</a> or <code>tuple(tf.Tensor)</code></p>
`}}),Lo=new qe({props:{$$slots:{default:[m$]},$$scope:{ctx:H}}}),Za=new be({props:{code:`from transformers import FunnelTokenizer, TFFunnelForQuestionAnswering
import tensorflow as tf

tokenizer = FunnelTokenizer.from_pretrained("funnel-transformer/small")
model = TFFunnelForQuestionAnswering.from_pretrained("funnel-transformer/small")

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"

inputs = tokenizer(question, text, return_tensors="tf")
outputs = model(**inputs)

answer_start_index = int(tf.math.argmax(outputs.start_logits, axis=-1)[0])
answer_end_index = int(tf.math.argmax(outputs.end_logits, axis=-1)[0])

predict_answer_tokens = inputs.input_ids[0, answer_start_index : answer_end_index + 1]
tokenizer.decode(predict_answer_tokens)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FunnelTokenizer, TFFunnelForQuestionAnswering
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FunnelTokenizer.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = TFFunnelForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;funnel-transformer/small&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(question, text, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>answer_start_index = <span class="hljs-built_in">int</span>(tf.math.argmax(outputs.start_logits, axis=-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>answer_end_index = <span class="hljs-built_in">int</span>(tf.math.argmax(outputs.end_logits, axis=-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>predict_answer_tokens = inputs.input_ids[<span class="hljs-number">0</span>, answer_start_index : answer_end_index + <span class="hljs-number">1</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.decode(predict_answer_tokens)
`}}),Xa=new be({props:{code:`# target is "nice puppet"
target_start_index = tf.constant([14])
target_end_index = tf.constant([15])

outputs = model(**inputs, start_positions=target_start_index, end_positions=target_end_index)
loss = tf.math.reduce_mean(outputs.loss)
round(float(loss), 2)
`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># target is &quot;nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>target_start_index = tf.constant([<span class="hljs-number">14</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>target_end_index = tf.constant([<span class="hljs-number">15</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, start_positions=target_start_index, end_positions=target_end_index)
<span class="hljs-meta">&gt;&gt;&gt; </span>loss = tf.math.reduce_mean(outputs.loss)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">round</span>(<span class="hljs-built_in">float</span>(loss), <span class="hljs-number">2</span>)
`}}),{c(){u=r("meta"),z=l(),g=r("h1"),_=r("a"),k=r("span"),F(T.$$.fragment),m=l(),M=r("span"),ce=t("Funnel Transformer"),K=l(),q=r("h2"),J=r("a"),A=r("span"),F(ne.$$.fragment),pe=l(),N=r("span"),ue=t("Overview"),ie=l(),Y=r("p"),L=t("The Funnel Transformer model was proposed in the paper "),te=r("a"),G=t(`Funnel-Transformer: Filtering out Sequential Redundancy for
Efficient Language Processing`),P=t(`. It is a bidirectional transformer model, like
BERT, but with a pooling operation after each block of layers, a bit like in traditional convolutional neural networks
(CNN) in computer vision.`),x=l(),oe=r("p"),B=t("The abstract from the paper is the following:"),le=l(),se=r("p"),S=r("em"),he=t(`With the success of language pretraining, it is highly desirable to develop more efficient architectures of good
scalability that can exploit the abundant unlabeled data at a lower cost. To improve the efficiency, we examine the
much-overlooked redundancy in maintaining a full-length token-level presentation, especially for tasks that only
require a single-vector presentation of the sequence. With this intuition, we propose Funnel-Transformer which
gradually compresses the sequence of hidden states to a shorter one and hence reduces the computation cost. More
importantly, by re-investing the saved FLOPs from length reduction in constructing a deeper or wider model, we further
improve the model capacity. In addition, to perform token-level predictions as required by common pretraining
objectives, Funnel-Transformer is able to recover a deep representation for each token from the reduced hidden sequence
via a decoder. Empirically, with comparable or fewer FLOPs, Funnel-Transformer outperforms the standard Transformer on
a wide variety of sequence-level prediction tasks, including text classification, language understanding, and reading
comprehension.`),de=l(),C=r("p"),fe=t("Tips:"),W=l(),ee=r("ul"),ae=r("li"),Q=t(`Since Funnel Transformer uses pooling, the sequence length of the hidden states changes after each block of layers.
The base model therefore has a final sequence length that is a quarter of the original one. This model can be used
directly for tasks that just require a sentence summary (like sequence classification or multiple choice). For other
tasks, the full model is used; this full model has a decoder that upsamples the final hidden states to the same
sequence length as the input.`),me=l(),I=r("li"),O=t(`The Funnel Transformer checkpoints are all available with a full version and a base version. The first ones should be
used for `),re=r("a"),U=t("FunnelModel"),ge=t(", "),p=r("a"),E=t("FunnelForPreTraining"),Z=t(`,
`),Te=r("a"),ye=t("FunnelForMaskedLM"),D=t(", "),ke=r("a"),we=t("FunnelForTokenClassification"),$e=t(` and
class:`),j=r("em"),R=t("~transformers.FunnelForQuestionAnswering"),Ee=t(`. The second ones should be used for
`),Fe=r("a"),V=t("FunnelBaseModel"),Me=t(", "),ve=r("a"),_e=t("FunnelForSequenceClassification"),ze=t(` and
`),oi=r("a"),Yu=t("FunnelForMultipleChoice"),Ku=t("."),Oc=l(),In=r("p"),Gu=t("This model was contributed by "),No=r("a"),Zu=t("sgugger"),Xu=t(". The original code can be found "),So=r("a"),Ju=t("here"),eh=t("."),Dc=l(),Zn=r("h2"),Wt=r("a"),Fl=r("span"),F(Io.$$.fragment),nh=l(),vl=r("span"),th=t("FunnelConfig"),Ac=l(),Nn=r("div"),F(Wo.$$.fragment),oh=l(),Sn=r("p"),sh=t("This is the configuration class to store the configuration of a "),si=r("a"),rh=t("FunnelModel"),ah=t(" or a "),ri=r("a"),ih=t("TFBertModel"),lh=t(`. It is used to
instantiate a Funnel Transformer model according to the specified arguments, defining the model architecture.
Instantiating a configuration with the defaults will yield a similar configuration to that of the Funnel
Transformer `),Bo=r("a"),dh=t("funnel-transformer/small"),ch=t(" architecture."),ph=l(),Xn=r("p"),uh=t("Configuration objects inherit from "),ai=r("a"),hh=t("PretrainedConfig"),fh=t(` and can be used to control the model outputs. Read the
documentation from `),ii=r("a"),mh=t("PretrainedConfig"),gh=t(" for more information."),Nc=l(),Jn=r("h2"),Bt=r("a"),bl=r("span"),F(Qo.$$.fragment),_h=l(),yl=r("span"),Th=t("FunnelTokenizer"),Sc=l(),xe=r("div"),F(Uo.$$.fragment),kh=l(),wl=r("p"),Fh=t("Construct a Funnel Transformer tokenizer."),vh=l(),Qt=r("p"),li=r("a"),bh=t("FunnelTokenizer"),yh=t(" is identical to "),di=r("a"),wh=t("BertTokenizer"),$h=t(` and runs end-to-end tokenization: punctuation splitting and
wordpiece.`),Eh=l(),Ro=r("p"),Mh=t("Refer to superclass "),ci=r("a"),zh=t("BertTokenizer"),qh=t(" for usage examples and documentation concerning parameters."),Ph=l(),Wn=r("div"),F(Vo.$$.fragment),Ch=l(),$l=r("p"),xh=t(`Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and
adding special tokens. A BERT sequence has the following format:`),jh=l(),Ho=r("ul"),pi=r("li"),Lh=t("single sequence: "),El=r("code"),Oh=t("[CLS] X [SEP]"),Dh=l(),ui=r("li"),Ah=t("pair of sequences: "),Ml=r("code"),Nh=t("[CLS] A [SEP] B [SEP]"),Sh=l(),Ut=r("div"),F(Yo.$$.fragment),Ih=l(),Ko=r("p"),Wh=t(`Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding
special tokens using the tokenizer `),zl=r("code"),Bh=t("prepare_for_model"),Qh=t(" method."),Uh=l(),bn=r("div"),F(Go.$$.fragment),Rh=l(),ql=r("p"),Vh=t(`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A Funnel
Transformer sequence pair mask has the following format:`),Hh=l(),F(Zo.$$.fragment),Yh=l(),et=r("p"),Kh=t("If "),Pl=r("code"),Gh=t("token_ids_1"),Zh=t(" is "),Cl=r("code"),Xh=t("None"),Jh=t(", this method only returns the first portion of the mask (0s)."),ef=l(),hi=r("div"),F(Xo.$$.fragment),Ic=l(),nt=r("h2"),Rt=r("a"),xl=r("span"),F(Jo.$$.fragment),nf=l(),jl=r("span"),tf=t("FunnelTokenizerFast"),Wc=l(),sn=r("div"),F(es.$$.fragment),of=l(),ns=r("p"),sf=t("Construct a \u201Cfast\u201D Funnel Transformer tokenizer (backed by HuggingFace\u2019s "),Ll=r("em"),rf=t("tokenizers"),af=t(" library)."),lf=l(),Vt=r("p"),fi=r("a"),df=t("FunnelTokenizerFast"),cf=t(" is identical to "),mi=r("a"),pf=t("BertTokenizerFast"),uf=t(` and runs end-to-end tokenization: punctuation
splitting and wordpiece.`),hf=l(),ts=r("p"),ff=t("Refer to superclass "),gi=r("a"),mf=t("BertTokenizerFast"),gf=t(" for usage examples and documentation concerning parameters."),_f=l(),yn=r("div"),F(os.$$.fragment),Tf=l(),Ol=r("p"),kf=t(`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A Funnel
Transformer sequence pair mask has the following format:`),Ff=l(),F(ss.$$.fragment),vf=l(),tt=r("p"),bf=t("If "),Dl=r("code"),yf=t("token_ids_1"),wf=t(" is "),Al=r("code"),$f=t("None"),Ef=t(", this method only returns the first portion of the mask (0s)."),Bc=l(),ot=r("h2"),Ht=r("a"),Nl=r("span"),F(rs.$$.fragment),Mf=l(),Sl=r("span"),zf=t("Funnel specific outputs"),Qc=l(),st=r("div"),F(as.$$.fragment),qf=l(),is=r("p"),Pf=t("Output type of "),_i=r("a"),Cf=t("FunnelForPreTraining"),xf=t("."),Uc=l(),rt=r("div"),F(ls.$$.fragment),jf=l(),ds=r("p"),Lf=t("Output type of "),Ti=r("a"),Of=t("FunnelForPreTraining"),Df=t("."),Rc=l(),at=r("h2"),Yt=r("a"),Il=r("span"),F(cs.$$.fragment),Af=l(),Wl=r("span"),Nf=t("FunnelBaseModel"),Vc=l(),Qe=r("div"),F(ps.$$.fragment),Sf=l(),Bl=r("p"),If=t(`The base Funnel Transformer Model transformer outputting raw hidden-states without upsampling head (also called
decoder) or any task-specific head on top.`),Wf=l(),us=r("p"),Bf=t("The Funnel Transformer model was proposed in "),hs=r("a"),Qf=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Uf=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Rf=l(),fs=r("p"),Vf=t("This model inherits from "),ki=r("a"),Hf=t("PreTrainedModel"),Yf=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Kf=l(),ms=r("p"),Gf=t("This model is also a PyTorch "),gs=r("a"),Zf=t("torch.nn.Module"),Xf=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Jf=l(),rn=r("div"),F(_s.$$.fragment),em=l(),it=r("p"),nm=t("The "),Fi=r("a"),tm=t("FunnelBaseModel"),om=t(" forward method, overrides the "),Ql=r("code"),sm=t("__call__"),rm=t(" special method."),am=l(),F(Kt.$$.fragment),im=l(),Ul=r("p"),lm=t("Example:"),dm=l(),F(Ts.$$.fragment),Hc=l(),lt=r("h2"),Gt=r("a"),Rl=r("span"),F(ks.$$.fragment),cm=l(),Vl=r("span"),pm=t("FunnelModel"),Yc=l(),Ue=r("div"),F(Fs.$$.fragment),um=l(),Hl=r("p"),hm=t("The bare Funnel Transformer Model transformer outputting raw hidden-states without any specific head on top."),fm=l(),vs=r("p"),mm=t("The Funnel Transformer model was proposed in "),bs=r("a"),gm=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),_m=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Tm=l(),ys=r("p"),km=t("This model inherits from "),vi=r("a"),Fm=t("PreTrainedModel"),vm=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),bm=l(),ws=r("p"),ym=t("This model is also a PyTorch "),$s=r("a"),wm=t("torch.nn.Module"),$m=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Em=l(),an=r("div"),F(Es.$$.fragment),Mm=l(),dt=r("p"),zm=t("The "),bi=r("a"),qm=t("FunnelModel"),Pm=t(" forward method, overrides the "),Yl=r("code"),Cm=t("__call__"),xm=t(" special method."),jm=l(),F(Zt.$$.fragment),Lm=l(),Kl=r("p"),Om=t("Example:"),Dm=l(),F(Ms.$$.fragment),Kc=l(),ct=r("h2"),Xt=r("a"),Gl=r("span"),F(zs.$$.fragment),Am=l(),Zl=r("span"),Nm=t("FunnelModelForPreTraining"),Gc=l(),pt=r("div"),F(qs.$$.fragment),Sm=l(),ln=r("div"),F(Ps.$$.fragment),Im=l(),ut=r("p"),Wm=t("The "),yi=r("a"),Bm=t("FunnelForPreTraining"),Qm=t(" forward method, overrides the "),Xl=r("code"),Um=t("__call__"),Rm=t(" special method."),Vm=l(),F(Jt.$$.fragment),Hm=l(),Jl=r("p"),Ym=t("Examples:"),Km=l(),F(Cs.$$.fragment),Zc=l(),ht=r("h2"),eo=r("a"),ed=r("span"),F(xs.$$.fragment),Gm=l(),nd=r("span"),Zm=t("FunnelForMaskedLM"),Xc=l(),Re=r("div"),F(js.$$.fragment),Xm=l(),Ls=r("p"),Jm=t("Funnel Transformer Model with a "),td=r("code"),eg=t("language modeling"),ng=t(" head on top."),tg=l(),Os=r("p"),og=t("The Funnel Transformer model was proposed in "),Ds=r("a"),sg=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),rg=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),ag=l(),As=r("p"),ig=t("This model inherits from "),wi=r("a"),lg=t("PreTrainedModel"),dg=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),cg=l(),Ns=r("p"),pg=t("This model is also a PyTorch "),Ss=r("a"),ug=t("torch.nn.Module"),hg=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),fg=l(),Ge=r("div"),F(Is.$$.fragment),mg=l(),ft=r("p"),gg=t("The "),$i=r("a"),_g=t("FunnelForMaskedLM"),Tg=t(" forward method, overrides the "),od=r("code"),kg=t("__call__"),Fg=t(" special method."),vg=l(),F(no.$$.fragment),bg=l(),sd=r("p"),yg=t("Example:"),wg=l(),F(Ws.$$.fragment),$g=l(),F(Bs.$$.fragment),Jc=l(),mt=r("h2"),to=r("a"),rd=r("span"),F(Qs.$$.fragment),Eg=l(),ad=r("span"),Mg=t("FunnelForSequenceClassification"),ep=l(),Ve=r("div"),F(Us.$$.fragment),zg=l(),id=r("p"),qg=t(`Funnel Transformer Model with a sequence classification/regression head on top (two linear layer on top of the
first timestep of the last hidden state) e.g. for GLUE tasks.`),Pg=l(),Rs=r("p"),Cg=t("The Funnel Transformer model was proposed in "),Vs=r("a"),xg=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),jg=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Lg=l(),Hs=r("p"),Og=t("This model inherits from "),Ei=r("a"),Dg=t("PreTrainedModel"),Ag=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Ng=l(),Ys=r("p"),Sg=t("This model is also a PyTorch "),Ks=r("a"),Ig=t("torch.nn.Module"),Wg=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Bg=l(),Pe=r("div"),F(Gs.$$.fragment),Qg=l(),gt=r("p"),Ug=t("The "),Mi=r("a"),Rg=t("FunnelForSequenceClassification"),Vg=t(" forward method, overrides the "),ld=r("code"),Hg=t("__call__"),Yg=t(" special method."),Kg=l(),F(oo.$$.fragment),Gg=l(),dd=r("p"),Zg=t("Example of single-label classification:"),Xg=l(),F(Zs.$$.fragment),Jg=l(),F(Xs.$$.fragment),e_=l(),cd=r("p"),n_=t("Example of multi-label classification:"),t_=l(),F(Js.$$.fragment),o_=l(),F(er.$$.fragment),np=l(),_t=r("h2"),so=r("a"),pd=r("span"),F(nr.$$.fragment),s_=l(),ud=r("span"),r_=t("FunnelForMultipleChoice"),tp=l(),He=r("div"),F(tr.$$.fragment),a_=l(),hd=r("p"),i_=t(`Funnel Transformer Model with a multiple choice classification head on top (two linear layer on top of the first
timestep of the last hidden state, and a softmax) e.g. for RocStories/SWAG tasks.`),l_=l(),or=r("p"),d_=t("The Funnel Transformer model was proposed in "),sr=r("a"),c_=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),p_=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),u_=l(),rr=r("p"),h_=t("This model inherits from "),zi=r("a"),f_=t("PreTrainedModel"),m_=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),g_=l(),ar=r("p"),__=t("This model is also a PyTorch "),ir=r("a"),T_=t("torch.nn.Module"),k_=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),F_=l(),dn=r("div"),F(lr.$$.fragment),v_=l(),Tt=r("p"),b_=t("The "),qi=r("a"),y_=t("FunnelForMultipleChoice"),w_=t(" forward method, overrides the "),fd=r("code"),$_=t("__call__"),E_=t(" special method."),M_=l(),F(ro.$$.fragment),z_=l(),md=r("p"),q_=t("Example:"),P_=l(),F(dr.$$.fragment),op=l(),kt=r("h2"),ao=r("a"),gd=r("span"),F(cr.$$.fragment),C_=l(),_d=r("span"),x_=t("FunnelForTokenClassification"),sp=l(),Ye=r("div"),F(pr.$$.fragment),j_=l(),Td=r("p"),L_=t(`Funnel Transformer Model with a token classification head on top (a linear layer on top of the hidden-states
output) e.g. for Named-Entity-Recognition (NER) tasks.`),O_=l(),ur=r("p"),D_=t("The Funnel Transformer model was proposed in "),hr=r("a"),A_=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),N_=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),S_=l(),fr=r("p"),I_=t("This model inherits from "),Pi=r("a"),W_=t("PreTrainedModel"),B_=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Q_=l(),mr=r("p"),U_=t("This model is also a PyTorch "),gr=r("a"),R_=t("torch.nn.Module"),V_=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),H_=l(),Ze=r("div"),F(_r.$$.fragment),Y_=l(),Ft=r("p"),K_=t("The "),Ci=r("a"),G_=t("FunnelForTokenClassification"),Z_=t(" forward method, overrides the "),kd=r("code"),X_=t("__call__"),J_=t(" special method."),eT=l(),F(io.$$.fragment),nT=l(),Fd=r("p"),tT=t("Example:"),oT=l(),F(Tr.$$.fragment),sT=l(),F(kr.$$.fragment),rp=l(),vt=r("h2"),lo=r("a"),vd=r("span"),F(Fr.$$.fragment),rT=l(),bd=r("span"),aT=t("FunnelForQuestionAnswering"),ap=l(),Ke=r("div"),F(vr.$$.fragment),iT=l(),bt=r("p"),lT=t(`Funnel Transformer Model with a span classification head on top for extractive question-answering tasks like SQuAD
(a linear layer on top of the hidden-states output to compute `),yd=r("code"),dT=t("span start logits"),cT=t(" and "),wd=r("code"),pT=t("span end logits"),uT=t(")."),hT=l(),br=r("p"),fT=t("The Funnel Transformer model was proposed in "),yr=r("a"),mT=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),gT=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),_T=l(),wr=r("p"),TT=t("This model inherits from "),xi=r("a"),kT=t("PreTrainedModel"),FT=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),vT=l(),$r=r("p"),bT=t("This model is also a PyTorch "),Er=r("a"),yT=t("torch.nn.Module"),wT=t(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),$T=l(),Xe=r("div"),F(Mr.$$.fragment),ET=l(),yt=r("p"),MT=t("The "),ji=r("a"),zT=t("FunnelForQuestionAnswering"),qT=t(" forward method, overrides the "),$d=r("code"),PT=t("__call__"),CT=t(" special method."),xT=l(),F(co.$$.fragment),jT=l(),Ed=r("p"),LT=t("Example:"),OT=l(),F(zr.$$.fragment),DT=l(),F(qr.$$.fragment),ip=l(),wt=r("h2"),po=r("a"),Md=r("span"),F(Pr.$$.fragment),AT=l(),zd=r("span"),NT=t("TFFunnelBaseModel"),lp=l(),Le=r("div"),F(Cr.$$.fragment),ST=l(),qd=r("p"),IT=t(`The base Funnel Transformer Model transformer outputting raw hidden-states without upsampling head (also called
decoder) or any task-specific head on top.`),WT=l(),xr=r("p"),BT=t("The Funnel Transformer model was proposed in "),jr=r("a"),QT=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),UT=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),RT=l(),Lr=r("p"),VT=t("This model inherits from "),Li=r("a"),HT=t("TFPreTrainedModel"),YT=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),KT=l(),Or=r("p"),GT=t("This model is also a "),Dr=r("a"),ZT=t("tf.keras.Model"),XT=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),JT=l(),F(uo.$$.fragment),e1=l(),cn=r("div"),F(Ar.$$.fragment),n1=l(),$t=r("p"),t1=t("The "),Oi=r("a"),o1=t("TFFunnelBaseModel"),s1=t(" forward method, overrides the "),Pd=r("code"),r1=t("__call__"),a1=t(" special method."),i1=l(),F(ho.$$.fragment),l1=l(),Cd=r("p"),d1=t("Example:"),c1=l(),F(Nr.$$.fragment),dp=l(),Et=r("h2"),fo=r("a"),xd=r("span"),F(Sr.$$.fragment),p1=l(),jd=r("span"),u1=t("TFFunnelModel"),cp=l(),Oe=r("div"),F(Ir.$$.fragment),h1=l(),Ld=r("p"),f1=t("The bare Funnel Transformer Model transformer outputting raw hidden-states without any specific head on top."),m1=l(),Wr=r("p"),g1=t("The Funnel Transformer model was proposed in "),Br=r("a"),_1=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),T1=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),k1=l(),Qr=r("p"),F1=t("This model inherits from "),Di=r("a"),v1=t("TFPreTrainedModel"),b1=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),y1=l(),Ur=r("p"),w1=t("This model is also a "),Rr=r("a"),$1=t("tf.keras.Model"),E1=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),M1=l(),F(mo.$$.fragment),z1=l(),pn=r("div"),F(Vr.$$.fragment),q1=l(),Mt=r("p"),P1=t("The "),Ai=r("a"),C1=t("TFFunnelModel"),x1=t(" forward method, overrides the "),Od=r("code"),j1=t("__call__"),L1=t(" special method."),O1=l(),F(go.$$.fragment),D1=l(),Dd=r("p"),A1=t("Example:"),N1=l(),F(Hr.$$.fragment),pp=l(),zt=r("h2"),_o=r("a"),Ad=r("span"),F(Yr.$$.fragment),S1=l(),Nd=r("span"),I1=t("TFFunnelModelForPreTraining"),up=l(),De=r("div"),F(Kr.$$.fragment),W1=l(),Sd=r("p"),B1=t("Funnel model with a binary classification head on top as used during pretraining for identifying generated tokens."),Q1=l(),Gr=r("p"),U1=t("The Funnel Transformer model was proposed in "),Zr=r("a"),R1=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),V1=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),H1=l(),Xr=r("p"),Y1=t("This model inherits from "),Ni=r("a"),K1=t("TFPreTrainedModel"),G1=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Z1=l(),Jr=r("p"),X1=t("This model is also a "),ea=r("a"),J1=t("tf.keras.Model"),ek=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),nk=l(),F(To.$$.fragment),tk=l(),un=r("div"),F(na.$$.fragment),ok=l(),qt=r("p"),sk=t("The "),Si=r("a"),rk=t("TFFunnelForPreTraining"),ak=t(" forward method, overrides the "),Id=r("code"),ik=t("__call__"),lk=t(" special method."),dk=l(),F(ko.$$.fragment),ck=l(),Wd=r("p"),pk=t("Examples:"),uk=l(),F(ta.$$.fragment),hp=l(),Pt=r("h2"),Fo=r("a"),Bd=r("span"),F(oa.$$.fragment),hk=l(),Qd=r("span"),fk=t("TFFunnelForMaskedLM"),fp=l(),Ae=r("div"),F(sa.$$.fragment),mk=l(),ra=r("p"),gk=t("Funnel Model with a "),Ud=r("code"),_k=t("language modeling"),Tk=t(" head on top."),kk=l(),aa=r("p"),Fk=t("The Funnel Transformer model was proposed in "),ia=r("a"),vk=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),bk=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),yk=l(),la=r("p"),wk=t("This model inherits from "),Ii=r("a"),$k=t("TFPreTrainedModel"),Ek=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Mk=l(),da=r("p"),zk=t("This model is also a "),ca=r("a"),qk=t("tf.keras.Model"),Pk=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Ck=l(),F(vo.$$.fragment),xk=l(),Je=r("div"),F(pa.$$.fragment),jk=l(),Ct=r("p"),Lk=t("The "),Wi=r("a"),Ok=t("TFFunnelForMaskedLM"),Dk=t(" forward method, overrides the "),Rd=r("code"),Ak=t("__call__"),Nk=t(" special method."),Sk=l(),F(bo.$$.fragment),Ik=l(),Vd=r("p"),Wk=t("Example:"),Bk=l(),F(ua.$$.fragment),Qk=l(),F(ha.$$.fragment),mp=l(),xt=r("h2"),yo=r("a"),Hd=r("span"),F(fa.$$.fragment),Uk=l(),Yd=r("span"),Rk=t("TFFunnelForSequenceClassification"),gp=l(),Ne=r("div"),F(ma.$$.fragment),Vk=l(),Kd=r("p"),Hk=t(`Funnel Model transformer with a sequence classification/regression head on top (a linear layer on top of the pooled
output) e.g. for GLUE tasks.`),Yk=l(),ga=r("p"),Kk=t("The Funnel Transformer model was proposed in "),_a=r("a"),Gk=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Zk=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Xk=l(),Ta=r("p"),Jk=t("This model inherits from "),Bi=r("a"),eF=t("TFPreTrainedModel"),nF=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),tF=l(),ka=r("p"),oF=t("This model is also a "),Fa=r("a"),sF=t("tf.keras.Model"),rF=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),aF=l(),F(wo.$$.fragment),iF=l(),en=r("div"),F(va.$$.fragment),lF=l(),jt=r("p"),dF=t("The "),Qi=r("a"),cF=t("TFFunnelForSequenceClassification"),pF=t(" forward method, overrides the "),Gd=r("code"),uF=t("__call__"),hF=t(" special method."),fF=l(),F($o.$$.fragment),mF=l(),Zd=r("p"),gF=t("Example:"),_F=l(),F(ba.$$.fragment),TF=l(),F(ya.$$.fragment),_p=l(),Lt=r("h2"),Eo=r("a"),Xd=r("span"),F(wa.$$.fragment),kF=l(),Jd=r("span"),FF=t("TFFunnelForMultipleChoice"),Tp=l(),Se=r("div"),F($a.$$.fragment),vF=l(),ec=r("p"),bF=t(`Funnel Model with a multiple choice classification head on top (a linear layer on top of the pooled output and a
softmax) e.g. for RocStories/SWAG tasks.`),yF=l(),Ea=r("p"),wF=t("The Funnel Transformer model was proposed in "),Ma=r("a"),$F=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),EF=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),MF=l(),za=r("p"),zF=t("This model inherits from "),Ui=r("a"),qF=t("TFPreTrainedModel"),PF=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),CF=l(),qa=r("p"),xF=t("This model is also a "),Pa=r("a"),jF=t("tf.keras.Model"),LF=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),OF=l(),F(Mo.$$.fragment),DF=l(),hn=r("div"),F(Ca.$$.fragment),AF=l(),Ot=r("p"),NF=t("The "),Ri=r("a"),SF=t("TFFunnelForMultipleChoice"),IF=t(" forward method, overrides the "),nc=r("code"),WF=t("__call__"),BF=t(" special method."),QF=l(),F(zo.$$.fragment),UF=l(),tc=r("p"),RF=t("Example:"),VF=l(),F(xa.$$.fragment),kp=l(),Dt=r("h2"),qo=r("a"),oc=r("span"),F(ja.$$.fragment),HF=l(),sc=r("span"),YF=t("TFFunnelForTokenClassification"),Fp=l(),Ie=r("div"),F(La.$$.fragment),KF=l(),rc=r("p"),GF=t(`Funnel Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g. for
Named-Entity-Recognition (NER) tasks.`),ZF=l(),Oa=r("p"),XF=t("The Funnel Transformer model was proposed in "),Da=r("a"),JF=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),ev=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),nv=l(),Aa=r("p"),tv=t("This model inherits from "),Vi=r("a"),ov=t("TFPreTrainedModel"),sv=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),rv=l(),Na=r("p"),av=t("This model is also a "),Sa=r("a"),iv=t("tf.keras.Model"),lv=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),dv=l(),F(Po.$$.fragment),cv=l(),nn=r("div"),F(Ia.$$.fragment),pv=l(),At=r("p"),uv=t("The "),Hi=r("a"),hv=t("TFFunnelForTokenClassification"),fv=t(" forward method, overrides the "),ac=r("code"),mv=t("__call__"),gv=t(" special method."),_v=l(),F(Co.$$.fragment),Tv=l(),ic=r("p"),kv=t("Example:"),Fv=l(),F(Wa.$$.fragment),vv=l(),F(Ba.$$.fragment),vp=l(),Nt=r("h2"),xo=r("a"),lc=r("span"),F(Qa.$$.fragment),bv=l(),dc=r("span"),yv=t("TFFunnelForQuestionAnswering"),bp=l(),We=r("div"),F(Ua.$$.fragment),wv=l(),St=r("p"),$v=t(`Funnel Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear
layers on top of the hidden-states output to compute `),cc=r("code"),Ev=t("span start logits"),Mv=t(" and "),pc=r("code"),zv=t("span end logits"),qv=t(")."),Pv=l(),Ra=r("p"),Cv=t("The Funnel Transformer model was proposed in "),Va=r("a"),xv=t(`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),jv=t(" by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Lv=l(),Ha=r("p"),Ov=t("This model inherits from "),Yi=r("a"),Dv=t("TFPreTrainedModel"),Av=t(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Nv=l(),Ya=r("p"),Sv=t("This model is also a "),Ka=r("a"),Iv=t("tf.keras.Model"),Wv=t(` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Bv=l(),F(jo.$$.fragment),Qv=l(),tn=r("div"),F(Ga.$$.fragment),Uv=l(),It=r("p"),Rv=t("The "),Ki=r("a"),Vv=t("TFFunnelForQuestionAnswering"),Hv=t(" forward method, overrides the "),uc=r("code"),Yv=t("__call__"),Kv=t(" special method."),Gv=l(),F(Lo.$$.fragment),Zv=l(),hc=r("p"),Xv=t("Example:"),Jv=l(),F(Za.$$.fragment),eb=l(),F(Xa.$$.fragment),this.h()},l(s){const f=U2('[data-svelte="svelte-1phssyn"]',document.head);u=a(f,"META",{name:!0,content:!0}),f.forEach(n),z=d(s),g=a(s,"H1",{class:!0});var Ja=i(g);_=a(Ja,"A",{id:!0,class:!0,href:!0});var fc=i(_);k=a(fc,"SPAN",{});var mc=i(k);v(T.$$.fragment,mc),mc.forEach(n),fc.forEach(n),m=d(Ja),M=a(Ja,"SPAN",{});var gc=i(M);ce=o(gc,"Funnel Transformer"),gc.forEach(n),Ja.forEach(n),K=d(s),q=a(s,"H2",{class:!0});var ei=i(q);J=a(ei,"A",{id:!0,class:!0,href:!0});var _c=i(J);A=a(_c,"SPAN",{});var Tc=i(A);v(ne.$$.fragment,Tc),Tc.forEach(n),_c.forEach(n),pe=d(ei),N=a(ei,"SPAN",{});var kc=i(N);ue=o(kc,"Overview"),kc.forEach(n),ei.forEach(n),ie=d(s),Y=a(s,"P",{});var ni=i(Y);L=o(ni,"The Funnel Transformer model was proposed in the paper "),te=a(ni,"A",{href:!0,rel:!0});var Fc=i(te);G=o(Fc,`Funnel-Transformer: Filtering out Sequential Redundancy for
Efficient Language Processing`),Fc.forEach(n),P=o(ni,`. It is a bidirectional transformer model, like
BERT, but with a pooling operation after each block of layers, a bit like in traditional convolutional neural networks
(CNN) in computer vision.`),ni.forEach(n),x=d(s),oe=a(s,"P",{});var vc=i(oe);B=o(vc,"The abstract from the paper is the following:"),vc.forEach(n),le=d(s),se=a(s,"P",{});var bc=i(se);S=a(bc,"EM",{});var yc=i(S);he=o(yc,`With the success of language pretraining, it is highly desirable to develop more efficient architectures of good
scalability that can exploit the abundant unlabeled data at a lower cost. To improve the efficiency, we examine the
much-overlooked redundancy in maintaining a full-length token-level presentation, especially for tasks that only
require a single-vector presentation of the sequence. With this intuition, we propose Funnel-Transformer which
gradually compresses the sequence of hidden states to a shorter one and hence reduces the computation cost. More
importantly, by re-investing the saved FLOPs from length reduction in constructing a deeper or wider model, we further
improve the model capacity. In addition, to perform token-level predictions as required by common pretraining
objectives, Funnel-Transformer is able to recover a deep representation for each token from the reduced hidden sequence
via a decoder. Empirically, with comparable or fewer FLOPs, Funnel-Transformer outperforms the standard Transformer on
a wide variety of sequence-level prediction tasks, including text classification, language understanding, and reading
comprehension.`),yc.forEach(n),bc.forEach(n),de=d(s),C=a(s,"P",{});var wc=i(C);fe=o(wc,"Tips:"),wc.forEach(n),W=d(s),ee=a(s,"UL",{});var ti=i(ee);ae=a(ti,"LI",{});var $c=i(ae);Q=o($c,`Since Funnel Transformer uses pooling, the sequence length of the hidden states changes after each block of layers.
The base model therefore has a final sequence length that is a quarter of the original one. This model can be used
directly for tasks that just require a sentence summary (like sequence classification or multiple choice). For other
tasks, the full model is used; this full model has a decoder that upsamples the final hidden states to the same
sequence length as the input.`),$c.forEach(n),me=d(ti),I=a(ti,"LI",{});var je=i(I);O=o(je,`The Funnel Transformer checkpoints are all available with a full version and a base version. The first ones should be
used for `),re=a(je,"A",{href:!0});var Ec=i(re);U=o(Ec,"FunnelModel"),Ec.forEach(n),ge=o(je,", "),p=a(je,"A",{href:!0});var Mc=i(p);E=o(Mc,"FunnelForPreTraining"),Mc.forEach(n),Z=o(je,`,
`),Te=a(je,"A",{href:!0});var zc=i(Te);ye=o(zc,"FunnelForMaskedLM"),zc.forEach(n),D=o(je,", "),ke=a(je,"A",{href:!0});var qc=i(ke);we=o(qc,"FunnelForTokenClassification"),qc.forEach(n),$e=o(je,` and
class:`),j=a(je,"EM",{});var Pc=i(j);R=o(Pc,"~transformers.FunnelForQuestionAnswering"),Pc.forEach(n),Ee=o(je,`. The second ones should be used for
`),Fe=a(je,"A",{href:!0});var Cc=i(Fe);V=o(Cc,"FunnelBaseModel"),Cc.forEach(n),Me=o(je,", "),ve=a(je,"A",{href:!0});var xc=i(ve);_e=o(xc,"FunnelForSequenceClassification"),xc.forEach(n),ze=o(je,` and
`),oi=a(je,"A",{href:!0});var ob=i(oi);Yu=o(ob,"FunnelForMultipleChoice"),ob.forEach(n),Ku=o(je,"."),je.forEach(n),ti.forEach(n),Oc=d(s),In=a(s,"P",{});var Gi=i(In);Gu=o(Gi,"This model was contributed by "),No=a(Gi,"A",{href:!0,rel:!0});var sb=i(No);Zu=o(sb,"sgugger"),sb.forEach(n),Xu=o(Gi,". The original code can be found "),So=a(Gi,"A",{href:!0,rel:!0});var rb=i(So);Ju=o(rb,"here"),rb.forEach(n),eh=o(Gi,"."),Gi.forEach(n),Dc=d(s),Zn=a(s,"H2",{class:!0});var wp=i(Zn);Wt=a(wp,"A",{id:!0,class:!0,href:!0});var ab=i(Wt);Fl=a(ab,"SPAN",{});var ib=i(Fl);v(Io.$$.fragment,ib),ib.forEach(n),ab.forEach(n),nh=d(wp),vl=a(wp,"SPAN",{});var lb=i(vl);th=o(lb,"FunnelConfig"),lb.forEach(n),wp.forEach(n),Ac=d(s),Nn=a(s,"DIV",{class:!0});var Zi=i(Nn);v(Wo.$$.fragment,Zi),oh=d(Zi),Sn=a(Zi,"P",{});var Oo=i(Sn);sh=o(Oo,"This is the configuration class to store the configuration of a "),si=a(Oo,"A",{href:!0});var db=i(si);rh=o(db,"FunnelModel"),db.forEach(n),ah=o(Oo," or a "),ri=a(Oo,"A",{href:!0});var cb=i(ri);ih=o(cb,"TFBertModel"),cb.forEach(n),lh=o(Oo,`. It is used to
instantiate a Funnel Transformer model according to the specified arguments, defining the model architecture.
Instantiating a configuration with the defaults will yield a similar configuration to that of the Funnel
Transformer `),Bo=a(Oo,"A",{href:!0,rel:!0});var pb=i(Bo);dh=o(pb,"funnel-transformer/small"),pb.forEach(n),ch=o(Oo," architecture."),Oo.forEach(n),ph=d(Zi),Xn=a(Zi,"P",{});var Xi=i(Xn);uh=o(Xi,"Configuration objects inherit from "),ai=a(Xi,"A",{href:!0});var ub=i(ai);hh=o(ub,"PretrainedConfig"),ub.forEach(n),fh=o(Xi,` and can be used to control the model outputs. Read the
documentation from `),ii=a(Xi,"A",{href:!0});var hb=i(ii);mh=o(hb,"PretrainedConfig"),hb.forEach(n),gh=o(Xi," for more information."),Xi.forEach(n),Zi.forEach(n),Nc=d(s),Jn=a(s,"H2",{class:!0});var $p=i(Jn);Bt=a($p,"A",{id:!0,class:!0,href:!0});var fb=i(Bt);bl=a(fb,"SPAN",{});var mb=i(bl);v(Qo.$$.fragment,mb),mb.forEach(n),fb.forEach(n),_h=d($p),yl=a($p,"SPAN",{});var gb=i(yl);Th=o(gb,"FunnelTokenizer"),gb.forEach(n),$p.forEach(n),Sc=d(s),xe=a(s,"DIV",{class:!0});var on=i(xe);v(Uo.$$.fragment,on),kh=d(on),wl=a(on,"P",{});var _b=i(wl);Fh=o(_b,"Construct a Funnel Transformer tokenizer."),_b.forEach(n),vh=d(on),Qt=a(on,"P",{});var jc=i(Qt);li=a(jc,"A",{href:!0});var Tb=i(li);bh=o(Tb,"FunnelTokenizer"),Tb.forEach(n),yh=o(jc," is identical to "),di=a(jc,"A",{href:!0});var kb=i(di);wh=o(kb,"BertTokenizer"),kb.forEach(n),$h=o(jc,` and runs end-to-end tokenization: punctuation splitting and
wordpiece.`),jc.forEach(n),Eh=d(on),Ro=a(on,"P",{});var Ep=i(Ro);Mh=o(Ep,"Refer to superclass "),ci=a(Ep,"A",{href:!0});var Fb=i(ci);zh=o(Fb,"BertTokenizer"),Fb.forEach(n),qh=o(Ep," for usage examples and documentation concerning parameters."),Ep.forEach(n),Ph=d(on),Wn=a(on,"DIV",{class:!0});var Ji=i(Wn);v(Vo.$$.fragment,Ji),Ch=d(Ji),$l=a(Ji,"P",{});var vb=i($l);xh=o(vb,`Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and
adding special tokens. A BERT sequence has the following format:`),vb.forEach(n),jh=d(Ji),Ho=a(Ji,"UL",{});var Mp=i(Ho);pi=a(Mp,"LI",{});var nb=i(pi);Lh=o(nb,"single sequence: "),El=a(nb,"CODE",{});var bb=i(El);Oh=o(bb,"[CLS] X [SEP]"),bb.forEach(n),nb.forEach(n),Dh=d(Mp),ui=a(Mp,"LI",{});var tb=i(ui);Ah=o(tb,"pair of sequences: "),Ml=a(tb,"CODE",{});var yb=i(Ml);Nh=o(yb,"[CLS] A [SEP] B [SEP]"),yb.forEach(n),tb.forEach(n),Mp.forEach(n),Ji.forEach(n),Sh=d(on),Ut=a(on,"DIV",{class:!0});var zp=i(Ut);v(Yo.$$.fragment,zp),Ih=d(zp),Ko=a(zp,"P",{});var qp=i(Ko);Wh=o(qp,`Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding
special tokens using the tokenizer `),zl=a(qp,"CODE",{});var wb=i(zl);Bh=o(wb,"prepare_for_model"),wb.forEach(n),Qh=o(qp," method."),qp.forEach(n),zp.forEach(n),Uh=d(on),bn=a(on,"DIV",{class:!0});var Do=i(bn);v(Go.$$.fragment,Do),Rh=d(Do),ql=a(Do,"P",{});var $b=i(ql);Vh=o($b,`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A Funnel
Transformer sequence pair mask has the following format:`),$b.forEach(n),Hh=d(Do),v(Zo.$$.fragment,Do),Yh=d(Do),et=a(Do,"P",{});var el=i(et);Kh=o(el,"If "),Pl=a(el,"CODE",{});var Eb=i(Pl);Gh=o(Eb,"token_ids_1"),Eb.forEach(n),Zh=o(el," is "),Cl=a(el,"CODE",{});var Mb=i(Cl);Xh=o(Mb,"None"),Mb.forEach(n),Jh=o(el,", this method only returns the first portion of the mask (0s)."),el.forEach(n),Do.forEach(n),ef=d(on),hi=a(on,"DIV",{class:!0});var zb=i(hi);v(Xo.$$.fragment,zb),zb.forEach(n),on.forEach(n),Ic=d(s),nt=a(s,"H2",{class:!0});var Pp=i(nt);Rt=a(Pp,"A",{id:!0,class:!0,href:!0});var qb=i(Rt);xl=a(qb,"SPAN",{});var Pb=i(xl);v(Jo.$$.fragment,Pb),Pb.forEach(n),qb.forEach(n),nf=d(Pp),jl=a(Pp,"SPAN",{});var Cb=i(jl);tf=o(Cb,"FunnelTokenizerFast"),Cb.forEach(n),Pp.forEach(n),Wc=d(s),sn=a(s,"DIV",{class:!0});var Bn=i(sn);v(es.$$.fragment,Bn),of=d(Bn),ns=a(Bn,"P",{});var Cp=i(ns);sf=o(Cp,"Construct a \u201Cfast\u201D Funnel Transformer tokenizer (backed by HuggingFace\u2019s "),Ll=a(Cp,"EM",{});var xb=i(Ll);rf=o(xb,"tokenizers"),xb.forEach(n),af=o(Cp," library)."),Cp.forEach(n),lf=d(Bn),Vt=a(Bn,"P",{});var Lc=i(Vt);fi=a(Lc,"A",{href:!0});var jb=i(fi);df=o(jb,"FunnelTokenizerFast"),jb.forEach(n),cf=o(Lc," is identical to "),mi=a(Lc,"A",{href:!0});var Lb=i(mi);pf=o(Lb,"BertTokenizerFast"),Lb.forEach(n),uf=o(Lc,` and runs end-to-end tokenization: punctuation
splitting and wordpiece.`),Lc.forEach(n),hf=d(Bn),ts=a(Bn,"P",{});var xp=i(ts);ff=o(xp,"Refer to superclass "),gi=a(xp,"A",{href:!0});var Ob=i(gi);mf=o(Ob,"BertTokenizerFast"),Ob.forEach(n),gf=o(xp," for usage examples and documentation concerning parameters."),xp.forEach(n),_f=d(Bn),yn=a(Bn,"DIV",{class:!0});var Ao=i(yn);v(os.$$.fragment,Ao),Tf=d(Ao),Ol=a(Ao,"P",{});var Db=i(Ol);kf=o(Db,`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A Funnel
Transformer sequence pair mask has the following format:`),Db.forEach(n),Ff=d(Ao),v(ss.$$.fragment,Ao),vf=d(Ao),tt=a(Ao,"P",{});var nl=i(tt);bf=o(nl,"If "),Dl=a(nl,"CODE",{});var Ab=i(Dl);yf=o(Ab,"token_ids_1"),Ab.forEach(n),wf=o(nl," is "),Al=a(nl,"CODE",{});var Nb=i(Al);$f=o(Nb,"None"),Nb.forEach(n),Ef=o(nl,", this method only returns the first portion of the mask (0s)."),nl.forEach(n),Ao.forEach(n),Bn.forEach(n),Bc=d(s),ot=a(s,"H2",{class:!0});var jp=i(ot);Ht=a(jp,"A",{id:!0,class:!0,href:!0});var Sb=i(Ht);Nl=a(Sb,"SPAN",{});var Ib=i(Nl);v(rs.$$.fragment,Ib),Ib.forEach(n),Sb.forEach(n),Mf=d(jp),Sl=a(jp,"SPAN",{});var Wb=i(Sl);zf=o(Wb,"Funnel specific outputs"),Wb.forEach(n),jp.forEach(n),Qc=d(s),st=a(s,"DIV",{class:!0});var Lp=i(st);v(as.$$.fragment,Lp),qf=d(Lp),is=a(Lp,"P",{});var Op=i(is);Pf=o(Op,"Output type of "),_i=a(Op,"A",{href:!0});var Bb=i(_i);Cf=o(Bb,"FunnelForPreTraining"),Bb.forEach(n),xf=o(Op,"."),Op.forEach(n),Lp.forEach(n),Uc=d(s),rt=a(s,"DIV",{class:!0});var Dp=i(rt);v(ls.$$.fragment,Dp),jf=d(Dp),ds=a(Dp,"P",{});var Ap=i(ds);Lf=o(Ap,"Output type of "),Ti=a(Ap,"A",{href:!0});var Qb=i(Ti);Of=o(Qb,"FunnelForPreTraining"),Qb.forEach(n),Df=o(Ap,"."),Ap.forEach(n),Dp.forEach(n),Rc=d(s),at=a(s,"H2",{class:!0});var Np=i(at);Yt=a(Np,"A",{id:!0,class:!0,href:!0});var Ub=i(Yt);Il=a(Ub,"SPAN",{});var Rb=i(Il);v(cs.$$.fragment,Rb),Rb.forEach(n),Ub.forEach(n),Af=d(Np),Wl=a(Np,"SPAN",{});var Vb=i(Wl);Nf=o(Vb,"FunnelBaseModel"),Vb.forEach(n),Np.forEach(n),Vc=d(s),Qe=a(s,"DIV",{class:!0});var wn=i(Qe);v(ps.$$.fragment,wn),Sf=d(wn),Bl=a(wn,"P",{});var Hb=i(Bl);If=o(Hb,`The base Funnel Transformer Model transformer outputting raw hidden-states without upsampling head (also called
decoder) or any task-specific head on top.`),Hb.forEach(n),Wf=d(wn),us=a(wn,"P",{});var Sp=i(us);Bf=o(Sp,"The Funnel Transformer model was proposed in "),hs=a(Sp,"A",{href:!0,rel:!0});var Yb=i(hs);Qf=o(Yb,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Yb.forEach(n),Uf=o(Sp," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Sp.forEach(n),Rf=d(wn),fs=a(wn,"P",{});var Ip=i(fs);Vf=o(Ip,"This model inherits from "),ki=a(Ip,"A",{href:!0});var Kb=i(ki);Hf=o(Kb,"PreTrainedModel"),Kb.forEach(n),Yf=o(Ip,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Ip.forEach(n),Kf=d(wn),ms=a(wn,"P",{});var Wp=i(ms);Gf=o(Wp,"This model is also a PyTorch "),gs=a(Wp,"A",{href:!0,rel:!0});var Gb=i(gs);Zf=o(Gb,"torch.nn.Module"),Gb.forEach(n),Xf=o(Wp,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Wp.forEach(n),Jf=d(wn),rn=a(wn,"DIV",{class:!0});var Qn=i(rn);v(_s.$$.fragment,Qn),em=d(Qn),it=a(Qn,"P",{});var tl=i(it);nm=o(tl,"The "),Fi=a(tl,"A",{href:!0});var Zb=i(Fi);tm=o(Zb,"FunnelBaseModel"),Zb.forEach(n),om=o(tl," forward method, overrides the "),Ql=a(tl,"CODE",{});var Xb=i(Ql);sm=o(Xb,"__call__"),Xb.forEach(n),rm=o(tl," special method."),tl.forEach(n),am=d(Qn),v(Kt.$$.fragment,Qn),im=d(Qn),Ul=a(Qn,"P",{});var Jb=i(Ul);lm=o(Jb,"Example:"),Jb.forEach(n),dm=d(Qn),v(Ts.$$.fragment,Qn),Qn.forEach(n),wn.forEach(n),Hc=d(s),lt=a(s,"H2",{class:!0});var Bp=i(lt);Gt=a(Bp,"A",{id:!0,class:!0,href:!0});var ey=i(Gt);Rl=a(ey,"SPAN",{});var ny=i(Rl);v(ks.$$.fragment,ny),ny.forEach(n),ey.forEach(n),cm=d(Bp),Vl=a(Bp,"SPAN",{});var ty=i(Vl);pm=o(ty,"FunnelModel"),ty.forEach(n),Bp.forEach(n),Yc=d(s),Ue=a(s,"DIV",{class:!0});var $n=i(Ue);v(Fs.$$.fragment,$n),um=d($n),Hl=a($n,"P",{});var oy=i(Hl);hm=o(oy,"The bare Funnel Transformer Model transformer outputting raw hidden-states without any specific head on top."),oy.forEach(n),fm=d($n),vs=a($n,"P",{});var Qp=i(vs);mm=o(Qp,"The Funnel Transformer model was proposed in "),bs=a(Qp,"A",{href:!0,rel:!0});var sy=i(bs);gm=o(sy,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),sy.forEach(n),_m=o(Qp," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Qp.forEach(n),Tm=d($n),ys=a($n,"P",{});var Up=i(ys);km=o(Up,"This model inherits from "),vi=a(Up,"A",{href:!0});var ry=i(vi);Fm=o(ry,"PreTrainedModel"),ry.forEach(n),vm=o(Up,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Up.forEach(n),bm=d($n),ws=a($n,"P",{});var Rp=i(ws);ym=o(Rp,"This model is also a PyTorch "),$s=a(Rp,"A",{href:!0,rel:!0});var ay=i($s);wm=o(ay,"torch.nn.Module"),ay.forEach(n),$m=o(Rp,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Rp.forEach(n),Em=d($n),an=a($n,"DIV",{class:!0});var Un=i(an);v(Es.$$.fragment,Un),Mm=d(Un),dt=a(Un,"P",{});var ol=i(dt);zm=o(ol,"The "),bi=a(ol,"A",{href:!0});var iy=i(bi);qm=o(iy,"FunnelModel"),iy.forEach(n),Pm=o(ol," forward method, overrides the "),Yl=a(ol,"CODE",{});var ly=i(Yl);Cm=o(ly,"__call__"),ly.forEach(n),xm=o(ol," special method."),ol.forEach(n),jm=d(Un),v(Zt.$$.fragment,Un),Lm=d(Un),Kl=a(Un,"P",{});var dy=i(Kl);Om=o(dy,"Example:"),dy.forEach(n),Dm=d(Un),v(Ms.$$.fragment,Un),Un.forEach(n),$n.forEach(n),Kc=d(s),ct=a(s,"H2",{class:!0});var Vp=i(ct);Xt=a(Vp,"A",{id:!0,class:!0,href:!0});var cy=i(Xt);Gl=a(cy,"SPAN",{});var py=i(Gl);v(zs.$$.fragment,py),py.forEach(n),cy.forEach(n),Am=d(Vp),Zl=a(Vp,"SPAN",{});var uy=i(Zl);Nm=o(uy,"FunnelModelForPreTraining"),uy.forEach(n),Vp.forEach(n),Gc=d(s),pt=a(s,"DIV",{class:!0});var Hp=i(pt);v(qs.$$.fragment,Hp),Sm=d(Hp),ln=a(Hp,"DIV",{class:!0});var Rn=i(ln);v(Ps.$$.fragment,Rn),Im=d(Rn),ut=a(Rn,"P",{});var sl=i(ut);Wm=o(sl,"The "),yi=a(sl,"A",{href:!0});var hy=i(yi);Bm=o(hy,"FunnelForPreTraining"),hy.forEach(n),Qm=o(sl," forward method, overrides the "),Xl=a(sl,"CODE",{});var fy=i(Xl);Um=o(fy,"__call__"),fy.forEach(n),Rm=o(sl," special method."),sl.forEach(n),Vm=d(Rn),v(Jt.$$.fragment,Rn),Hm=d(Rn),Jl=a(Rn,"P",{});var my=i(Jl);Ym=o(my,"Examples:"),my.forEach(n),Km=d(Rn),v(Cs.$$.fragment,Rn),Rn.forEach(n),Hp.forEach(n),Zc=d(s),ht=a(s,"H2",{class:!0});var Yp=i(ht);eo=a(Yp,"A",{id:!0,class:!0,href:!0});var gy=i(eo);ed=a(gy,"SPAN",{});var _y=i(ed);v(xs.$$.fragment,_y),_y.forEach(n),gy.forEach(n),Gm=d(Yp),nd=a(Yp,"SPAN",{});var Ty=i(nd);Zm=o(Ty,"FunnelForMaskedLM"),Ty.forEach(n),Yp.forEach(n),Xc=d(s),Re=a(s,"DIV",{class:!0});var En=i(Re);v(js.$$.fragment,En),Xm=d(En),Ls=a(En,"P",{});var Kp=i(Ls);Jm=o(Kp,"Funnel Transformer Model with a "),td=a(Kp,"CODE",{});var ky=i(td);eg=o(ky,"language modeling"),ky.forEach(n),ng=o(Kp," head on top."),Kp.forEach(n),tg=d(En),Os=a(En,"P",{});var Gp=i(Os);og=o(Gp,"The Funnel Transformer model was proposed in "),Ds=a(Gp,"A",{href:!0,rel:!0});var Fy=i(Ds);sg=o(Fy,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Fy.forEach(n),rg=o(Gp," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Gp.forEach(n),ag=d(En),As=a(En,"P",{});var Zp=i(As);ig=o(Zp,"This model inherits from "),wi=a(Zp,"A",{href:!0});var vy=i(wi);lg=o(vy,"PreTrainedModel"),vy.forEach(n),dg=o(Zp,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Zp.forEach(n),cg=d(En),Ns=a(En,"P",{});var Xp=i(Ns);pg=o(Xp,"This model is also a PyTorch "),Ss=a(Xp,"A",{href:!0,rel:!0});var by=i(Ss);ug=o(by,"torch.nn.Module"),by.forEach(n),hg=o(Xp,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Xp.forEach(n),fg=d(En),Ge=a(En,"DIV",{class:!0});var Mn=i(Ge);v(Is.$$.fragment,Mn),mg=d(Mn),ft=a(Mn,"P",{});var rl=i(ft);gg=o(rl,"The "),$i=a(rl,"A",{href:!0});var yy=i($i);_g=o(yy,"FunnelForMaskedLM"),yy.forEach(n),Tg=o(rl," forward method, overrides the "),od=a(rl,"CODE",{});var wy=i(od);kg=o(wy,"__call__"),wy.forEach(n),Fg=o(rl," special method."),rl.forEach(n),vg=d(Mn),v(no.$$.fragment,Mn),bg=d(Mn),sd=a(Mn,"P",{});var $y=i(sd);yg=o($y,"Example:"),$y.forEach(n),wg=d(Mn),v(Ws.$$.fragment,Mn),$g=d(Mn),v(Bs.$$.fragment,Mn),Mn.forEach(n),En.forEach(n),Jc=d(s),mt=a(s,"H2",{class:!0});var Jp=i(mt);to=a(Jp,"A",{id:!0,class:!0,href:!0});var Ey=i(to);rd=a(Ey,"SPAN",{});var My=i(rd);v(Qs.$$.fragment,My),My.forEach(n),Ey.forEach(n),Eg=d(Jp),ad=a(Jp,"SPAN",{});var zy=i(ad);Mg=o(zy,"FunnelForSequenceClassification"),zy.forEach(n),Jp.forEach(n),ep=d(s),Ve=a(s,"DIV",{class:!0});var zn=i(Ve);v(Us.$$.fragment,zn),zg=d(zn),id=a(zn,"P",{});var qy=i(id);qg=o(qy,`Funnel Transformer Model with a sequence classification/regression head on top (two linear layer on top of the
first timestep of the last hidden state) e.g. for GLUE tasks.`),qy.forEach(n),Pg=d(zn),Rs=a(zn,"P",{});var eu=i(Rs);Cg=o(eu,"The Funnel Transformer model was proposed in "),Vs=a(eu,"A",{href:!0,rel:!0});var Py=i(Vs);xg=o(Py,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Py.forEach(n),jg=o(eu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),eu.forEach(n),Lg=d(zn),Hs=a(zn,"P",{});var nu=i(Hs);Og=o(nu,"This model inherits from "),Ei=a(nu,"A",{href:!0});var Cy=i(Ei);Dg=o(Cy,"PreTrainedModel"),Cy.forEach(n),Ag=o(nu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),nu.forEach(n),Ng=d(zn),Ys=a(zn,"P",{});var tu=i(Ys);Sg=o(tu,"This model is also a PyTorch "),Ks=a(tu,"A",{href:!0,rel:!0});var xy=i(Ks);Ig=o(xy,"torch.nn.Module"),xy.forEach(n),Wg=o(tu,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),tu.forEach(n),Bg=d(zn),Pe=a(zn,"DIV",{class:!0});var Be=i(Pe);v(Gs.$$.fragment,Be),Qg=d(Be),gt=a(Be,"P",{});var al=i(gt);Ug=o(al,"The "),Mi=a(al,"A",{href:!0});var jy=i(Mi);Rg=o(jy,"FunnelForSequenceClassification"),jy.forEach(n),Vg=o(al," forward method, overrides the "),ld=a(al,"CODE",{});var Ly=i(ld);Hg=o(Ly,"__call__"),Ly.forEach(n),Yg=o(al," special method."),al.forEach(n),Kg=d(Be),v(oo.$$.fragment,Be),Gg=d(Be),dd=a(Be,"P",{});var Oy=i(dd);Zg=o(Oy,"Example of single-label classification:"),Oy.forEach(n),Xg=d(Be),v(Zs.$$.fragment,Be),Jg=d(Be),v(Xs.$$.fragment,Be),e_=d(Be),cd=a(Be,"P",{});var Dy=i(cd);n_=o(Dy,"Example of multi-label classification:"),Dy.forEach(n),t_=d(Be),v(Js.$$.fragment,Be),o_=d(Be),v(er.$$.fragment,Be),Be.forEach(n),zn.forEach(n),np=d(s),_t=a(s,"H2",{class:!0});var ou=i(_t);so=a(ou,"A",{id:!0,class:!0,href:!0});var Ay=i(so);pd=a(Ay,"SPAN",{});var Ny=i(pd);v(nr.$$.fragment,Ny),Ny.forEach(n),Ay.forEach(n),s_=d(ou),ud=a(ou,"SPAN",{});var Sy=i(ud);r_=o(Sy,"FunnelForMultipleChoice"),Sy.forEach(n),ou.forEach(n),tp=d(s),He=a(s,"DIV",{class:!0});var qn=i(He);v(tr.$$.fragment,qn),a_=d(qn),hd=a(qn,"P",{});var Iy=i(hd);i_=o(Iy,`Funnel Transformer Model with a multiple choice classification head on top (two linear layer on top of the first
timestep of the last hidden state, and a softmax) e.g. for RocStories/SWAG tasks.`),Iy.forEach(n),l_=d(qn),or=a(qn,"P",{});var su=i(or);d_=o(su,"The Funnel Transformer model was proposed in "),sr=a(su,"A",{href:!0,rel:!0});var Wy=i(sr);c_=o(Wy,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Wy.forEach(n),p_=o(su," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),su.forEach(n),u_=d(qn),rr=a(qn,"P",{});var ru=i(rr);h_=o(ru,"This model inherits from "),zi=a(ru,"A",{href:!0});var By=i(zi);f_=o(By,"PreTrainedModel"),By.forEach(n),m_=o(ru,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),ru.forEach(n),g_=d(qn),ar=a(qn,"P",{});var au=i(ar);__=o(au,"This model is also a PyTorch "),ir=a(au,"A",{href:!0,rel:!0});var Qy=i(ir);T_=o(Qy,"torch.nn.Module"),Qy.forEach(n),k_=o(au,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),au.forEach(n),F_=d(qn),dn=a(qn,"DIV",{class:!0});var Vn=i(dn);v(lr.$$.fragment,Vn),v_=d(Vn),Tt=a(Vn,"P",{});var il=i(Tt);b_=o(il,"The "),qi=a(il,"A",{href:!0});var Uy=i(qi);y_=o(Uy,"FunnelForMultipleChoice"),Uy.forEach(n),w_=o(il," forward method, overrides the "),fd=a(il,"CODE",{});var Ry=i(fd);$_=o(Ry,"__call__"),Ry.forEach(n),E_=o(il," special method."),il.forEach(n),M_=d(Vn),v(ro.$$.fragment,Vn),z_=d(Vn),md=a(Vn,"P",{});var Vy=i(md);q_=o(Vy,"Example:"),Vy.forEach(n),P_=d(Vn),v(dr.$$.fragment,Vn),Vn.forEach(n),qn.forEach(n),op=d(s),kt=a(s,"H2",{class:!0});var iu=i(kt);ao=a(iu,"A",{id:!0,class:!0,href:!0});var Hy=i(ao);gd=a(Hy,"SPAN",{});var Yy=i(gd);v(cr.$$.fragment,Yy),Yy.forEach(n),Hy.forEach(n),C_=d(iu),_d=a(iu,"SPAN",{});var Ky=i(_d);x_=o(Ky,"FunnelForTokenClassification"),Ky.forEach(n),iu.forEach(n),sp=d(s),Ye=a(s,"DIV",{class:!0});var Pn=i(Ye);v(pr.$$.fragment,Pn),j_=d(Pn),Td=a(Pn,"P",{});var Gy=i(Td);L_=o(Gy,`Funnel Transformer Model with a token classification head on top (a linear layer on top of the hidden-states
output) e.g. for Named-Entity-Recognition (NER) tasks.`),Gy.forEach(n),O_=d(Pn),ur=a(Pn,"P",{});var lu=i(ur);D_=o(lu,"The Funnel Transformer model was proposed in "),hr=a(lu,"A",{href:!0,rel:!0});var Zy=i(hr);A_=o(Zy,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Zy.forEach(n),N_=o(lu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),lu.forEach(n),S_=d(Pn),fr=a(Pn,"P",{});var du=i(fr);I_=o(du,"This model inherits from "),Pi=a(du,"A",{href:!0});var Xy=i(Pi);W_=o(Xy,"PreTrainedModel"),Xy.forEach(n),B_=o(du,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),du.forEach(n),Q_=d(Pn),mr=a(Pn,"P",{});var cu=i(mr);U_=o(cu,"This model is also a PyTorch "),gr=a(cu,"A",{href:!0,rel:!0});var Jy=i(gr);R_=o(Jy,"torch.nn.Module"),Jy.forEach(n),V_=o(cu,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),cu.forEach(n),H_=d(Pn),Ze=a(Pn,"DIV",{class:!0});var Cn=i(Ze);v(_r.$$.fragment,Cn),Y_=d(Cn),Ft=a(Cn,"P",{});var ll=i(Ft);K_=o(ll,"The "),Ci=a(ll,"A",{href:!0});var ew=i(Ci);G_=o(ew,"FunnelForTokenClassification"),ew.forEach(n),Z_=o(ll," forward method, overrides the "),kd=a(ll,"CODE",{});var nw=i(kd);X_=o(nw,"__call__"),nw.forEach(n),J_=o(ll," special method."),ll.forEach(n),eT=d(Cn),v(io.$$.fragment,Cn),nT=d(Cn),Fd=a(Cn,"P",{});var tw=i(Fd);tT=o(tw,"Example:"),tw.forEach(n),oT=d(Cn),v(Tr.$$.fragment,Cn),sT=d(Cn),v(kr.$$.fragment,Cn),Cn.forEach(n),Pn.forEach(n),rp=d(s),vt=a(s,"H2",{class:!0});var pu=i(vt);lo=a(pu,"A",{id:!0,class:!0,href:!0});var ow=i(lo);vd=a(ow,"SPAN",{});var sw=i(vd);v(Fr.$$.fragment,sw),sw.forEach(n),ow.forEach(n),rT=d(pu),bd=a(pu,"SPAN",{});var rw=i(bd);aT=o(rw,"FunnelForQuestionAnswering"),rw.forEach(n),pu.forEach(n),ap=d(s),Ke=a(s,"DIV",{class:!0});var xn=i(Ke);v(vr.$$.fragment,xn),iT=d(xn),bt=a(xn,"P",{});var dl=i(bt);lT=o(dl,`Funnel Transformer Model with a span classification head on top for extractive question-answering tasks like SQuAD
(a linear layer on top of the hidden-states output to compute `),yd=a(dl,"CODE",{});var aw=i(yd);dT=o(aw,"span start logits"),aw.forEach(n),cT=o(dl," and "),wd=a(dl,"CODE",{});var iw=i(wd);pT=o(iw,"span end logits"),iw.forEach(n),uT=o(dl,")."),dl.forEach(n),hT=d(xn),br=a(xn,"P",{});var uu=i(br);fT=o(uu,"The Funnel Transformer model was proposed in "),yr=a(uu,"A",{href:!0,rel:!0});var lw=i(yr);mT=o(lw,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),lw.forEach(n),gT=o(uu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),uu.forEach(n),_T=d(xn),wr=a(xn,"P",{});var hu=i(wr);TT=o(hu,"This model inherits from "),xi=a(hu,"A",{href:!0});var dw=i(xi);kT=o(dw,"PreTrainedModel"),dw.forEach(n),FT=o(hu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),hu.forEach(n),vT=d(xn),$r=a(xn,"P",{});var fu=i($r);bT=o(fu,"This model is also a PyTorch "),Er=a(fu,"A",{href:!0,rel:!0});var cw=i(Er);yT=o(cw,"torch.nn.Module"),cw.forEach(n),wT=o(fu,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),fu.forEach(n),$T=d(xn),Xe=a(xn,"DIV",{class:!0});var jn=i(Xe);v(Mr.$$.fragment,jn),ET=d(jn),yt=a(jn,"P",{});var cl=i(yt);MT=o(cl,"The "),ji=a(cl,"A",{href:!0});var pw=i(ji);zT=o(pw,"FunnelForQuestionAnswering"),pw.forEach(n),qT=o(cl," forward method, overrides the "),$d=a(cl,"CODE",{});var uw=i($d);PT=o(uw,"__call__"),uw.forEach(n),CT=o(cl," special method."),cl.forEach(n),xT=d(jn),v(co.$$.fragment,jn),jT=d(jn),Ed=a(jn,"P",{});var hw=i(Ed);LT=o(hw,"Example:"),hw.forEach(n),OT=d(jn),v(zr.$$.fragment,jn),DT=d(jn),v(qr.$$.fragment,jn),jn.forEach(n),xn.forEach(n),ip=d(s),wt=a(s,"H2",{class:!0});var mu=i(wt);po=a(mu,"A",{id:!0,class:!0,href:!0});var fw=i(po);Md=a(fw,"SPAN",{});var mw=i(Md);v(Pr.$$.fragment,mw),mw.forEach(n),fw.forEach(n),AT=d(mu),zd=a(mu,"SPAN",{});var gw=i(zd);NT=o(gw,"TFFunnelBaseModel"),gw.forEach(n),mu.forEach(n),lp=d(s),Le=a(s,"DIV",{class:!0});var fn=i(Le);v(Cr.$$.fragment,fn),ST=d(fn),qd=a(fn,"P",{});var _w=i(qd);IT=o(_w,`The base Funnel Transformer Model transformer outputting raw hidden-states without upsampling head (also called
decoder) or any task-specific head on top.`),_w.forEach(n),WT=d(fn),xr=a(fn,"P",{});var gu=i(xr);BT=o(gu,"The Funnel Transformer model was proposed in "),jr=a(gu,"A",{href:!0,rel:!0});var Tw=i(jr);QT=o(Tw,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Tw.forEach(n),UT=o(gu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),gu.forEach(n),RT=d(fn),Lr=a(fn,"P",{});var _u=i(Lr);VT=o(_u,"This model inherits from "),Li=a(_u,"A",{href:!0});var kw=i(Li);HT=o(kw,"TFPreTrainedModel"),kw.forEach(n),YT=o(_u,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),_u.forEach(n),KT=d(fn),Or=a(fn,"P",{});var Tu=i(Or);GT=o(Tu,"This model is also a "),Dr=a(Tu,"A",{href:!0,rel:!0});var Fw=i(Dr);ZT=o(Fw,"tf.keras.Model"),Fw.forEach(n),XT=o(Tu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Tu.forEach(n),JT=d(fn),v(uo.$$.fragment,fn),e1=d(fn),cn=a(fn,"DIV",{class:!0});var Hn=i(cn);v(Ar.$$.fragment,Hn),n1=d(Hn),$t=a(Hn,"P",{});var pl=i($t);t1=o(pl,"The "),Oi=a(pl,"A",{href:!0});var vw=i(Oi);o1=o(vw,"TFFunnelBaseModel"),vw.forEach(n),s1=o(pl," forward method, overrides the "),Pd=a(pl,"CODE",{});var bw=i(Pd);r1=o(bw,"__call__"),bw.forEach(n),a1=o(pl," special method."),pl.forEach(n),i1=d(Hn),v(ho.$$.fragment,Hn),l1=d(Hn),Cd=a(Hn,"P",{});var yw=i(Cd);d1=o(yw,"Example:"),yw.forEach(n),c1=d(Hn),v(Nr.$$.fragment,Hn),Hn.forEach(n),fn.forEach(n),dp=d(s),Et=a(s,"H2",{class:!0});var ku=i(Et);fo=a(ku,"A",{id:!0,class:!0,href:!0});var ww=i(fo);xd=a(ww,"SPAN",{});var $w=i(xd);v(Sr.$$.fragment,$w),$w.forEach(n),ww.forEach(n),p1=d(ku),jd=a(ku,"SPAN",{});var Ew=i(jd);u1=o(Ew,"TFFunnelModel"),Ew.forEach(n),ku.forEach(n),cp=d(s),Oe=a(s,"DIV",{class:!0});var mn=i(Oe);v(Ir.$$.fragment,mn),h1=d(mn),Ld=a(mn,"P",{});var Mw=i(Ld);f1=o(Mw,"The bare Funnel Transformer Model transformer outputting raw hidden-states without any specific head on top."),Mw.forEach(n),m1=d(mn),Wr=a(mn,"P",{});var Fu=i(Wr);g1=o(Fu,"The Funnel Transformer model was proposed in "),Br=a(Fu,"A",{href:!0,rel:!0});var zw=i(Br);_1=o(zw,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),zw.forEach(n),T1=o(Fu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Fu.forEach(n),k1=d(mn),Qr=a(mn,"P",{});var vu=i(Qr);F1=o(vu,"This model inherits from "),Di=a(vu,"A",{href:!0});var qw=i(Di);v1=o(qw,"TFPreTrainedModel"),qw.forEach(n),b1=o(vu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),vu.forEach(n),y1=d(mn),Ur=a(mn,"P",{});var bu=i(Ur);w1=o(bu,"This model is also a "),Rr=a(bu,"A",{href:!0,rel:!0});var Pw=i(Rr);$1=o(Pw,"tf.keras.Model"),Pw.forEach(n),E1=o(bu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),bu.forEach(n),M1=d(mn),v(mo.$$.fragment,mn),z1=d(mn),pn=a(mn,"DIV",{class:!0});var Yn=i(pn);v(Vr.$$.fragment,Yn),q1=d(Yn),Mt=a(Yn,"P",{});var ul=i(Mt);P1=o(ul,"The "),Ai=a(ul,"A",{href:!0});var Cw=i(Ai);C1=o(Cw,"TFFunnelModel"),Cw.forEach(n),x1=o(ul," forward method, overrides the "),Od=a(ul,"CODE",{});var xw=i(Od);j1=o(xw,"__call__"),xw.forEach(n),L1=o(ul," special method."),ul.forEach(n),O1=d(Yn),v(go.$$.fragment,Yn),D1=d(Yn),Dd=a(Yn,"P",{});var jw=i(Dd);A1=o(jw,"Example:"),jw.forEach(n),N1=d(Yn),v(Hr.$$.fragment,Yn),Yn.forEach(n),mn.forEach(n),pp=d(s),zt=a(s,"H2",{class:!0});var yu=i(zt);_o=a(yu,"A",{id:!0,class:!0,href:!0});var Lw=i(_o);Ad=a(Lw,"SPAN",{});var Ow=i(Ad);v(Yr.$$.fragment,Ow),Ow.forEach(n),Lw.forEach(n),S1=d(yu),Nd=a(yu,"SPAN",{});var Dw=i(Nd);I1=o(Dw,"TFFunnelModelForPreTraining"),Dw.forEach(n),yu.forEach(n),up=d(s),De=a(s,"DIV",{class:!0});var gn=i(De);v(Kr.$$.fragment,gn),W1=d(gn),Sd=a(gn,"P",{});var Aw=i(Sd);B1=o(Aw,"Funnel model with a binary classification head on top as used during pretraining for identifying generated tokens."),Aw.forEach(n),Q1=d(gn),Gr=a(gn,"P",{});var wu=i(Gr);U1=o(wu,"The Funnel Transformer model was proposed in "),Zr=a(wu,"A",{href:!0,rel:!0});var Nw=i(Zr);R1=o(Nw,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Nw.forEach(n),V1=o(wu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),wu.forEach(n),H1=d(gn),Xr=a(gn,"P",{});var $u=i(Xr);Y1=o($u,"This model inherits from "),Ni=a($u,"A",{href:!0});var Sw=i(Ni);K1=o(Sw,"TFPreTrainedModel"),Sw.forEach(n),G1=o($u,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),$u.forEach(n),Z1=d(gn),Jr=a(gn,"P",{});var Eu=i(Jr);X1=o(Eu,"This model is also a "),ea=a(Eu,"A",{href:!0,rel:!0});var Iw=i(ea);J1=o(Iw,"tf.keras.Model"),Iw.forEach(n),ek=o(Eu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Eu.forEach(n),nk=d(gn),v(To.$$.fragment,gn),tk=d(gn),un=a(gn,"DIV",{class:!0});var Kn=i(un);v(na.$$.fragment,Kn),ok=d(Kn),qt=a(Kn,"P",{});var hl=i(qt);sk=o(hl,"The "),Si=a(hl,"A",{href:!0});var Ww=i(Si);rk=o(Ww,"TFFunnelForPreTraining"),Ww.forEach(n),ak=o(hl," forward method, overrides the "),Id=a(hl,"CODE",{});var Bw=i(Id);ik=o(Bw,"__call__"),Bw.forEach(n),lk=o(hl," special method."),hl.forEach(n),dk=d(Kn),v(ko.$$.fragment,Kn),ck=d(Kn),Wd=a(Kn,"P",{});var Qw=i(Wd);pk=o(Qw,"Examples:"),Qw.forEach(n),uk=d(Kn),v(ta.$$.fragment,Kn),Kn.forEach(n),gn.forEach(n),hp=d(s),Pt=a(s,"H2",{class:!0});var Mu=i(Pt);Fo=a(Mu,"A",{id:!0,class:!0,href:!0});var Uw=i(Fo);Bd=a(Uw,"SPAN",{});var Rw=i(Bd);v(oa.$$.fragment,Rw),Rw.forEach(n),Uw.forEach(n),hk=d(Mu),Qd=a(Mu,"SPAN",{});var Vw=i(Qd);fk=o(Vw,"TFFunnelForMaskedLM"),Vw.forEach(n),Mu.forEach(n),fp=d(s),Ae=a(s,"DIV",{class:!0});var _n=i(Ae);v(sa.$$.fragment,_n),mk=d(_n),ra=a(_n,"P",{});var zu=i(ra);gk=o(zu,"Funnel Model with a "),Ud=a(zu,"CODE",{});var Hw=i(Ud);_k=o(Hw,"language modeling"),Hw.forEach(n),Tk=o(zu," head on top."),zu.forEach(n),kk=d(_n),aa=a(_n,"P",{});var qu=i(aa);Fk=o(qu,"The Funnel Transformer model was proposed in "),ia=a(qu,"A",{href:!0,rel:!0});var Yw=i(ia);vk=o(Yw,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),Yw.forEach(n),bk=o(qu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),qu.forEach(n),yk=d(_n),la=a(_n,"P",{});var Pu=i(la);wk=o(Pu,"This model inherits from "),Ii=a(Pu,"A",{href:!0});var Kw=i(Ii);$k=o(Kw,"TFPreTrainedModel"),Kw.forEach(n),Ek=o(Pu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Pu.forEach(n),Mk=d(_n),da=a(_n,"P",{});var Cu=i(da);zk=o(Cu,"This model is also a "),ca=a(Cu,"A",{href:!0,rel:!0});var Gw=i(ca);qk=o(Gw,"tf.keras.Model"),Gw.forEach(n),Pk=o(Cu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Cu.forEach(n),Ck=d(_n),v(vo.$$.fragment,_n),xk=d(_n),Je=a(_n,"DIV",{class:!0});var Ln=i(Je);v(pa.$$.fragment,Ln),jk=d(Ln),Ct=a(Ln,"P",{});var fl=i(Ct);Lk=o(fl,"The "),Wi=a(fl,"A",{href:!0});var Zw=i(Wi);Ok=o(Zw,"TFFunnelForMaskedLM"),Zw.forEach(n),Dk=o(fl," forward method, overrides the "),Rd=a(fl,"CODE",{});var Xw=i(Rd);Ak=o(Xw,"__call__"),Xw.forEach(n),Nk=o(fl," special method."),fl.forEach(n),Sk=d(Ln),v(bo.$$.fragment,Ln),Ik=d(Ln),Vd=a(Ln,"P",{});var Jw=i(Vd);Wk=o(Jw,"Example:"),Jw.forEach(n),Bk=d(Ln),v(ua.$$.fragment,Ln),Qk=d(Ln),v(ha.$$.fragment,Ln),Ln.forEach(n),_n.forEach(n),mp=d(s),xt=a(s,"H2",{class:!0});var xu=i(xt);yo=a(xu,"A",{id:!0,class:!0,href:!0});var e2=i(yo);Hd=a(e2,"SPAN",{});var n2=i(Hd);v(fa.$$.fragment,n2),n2.forEach(n),e2.forEach(n),Uk=d(xu),Yd=a(xu,"SPAN",{});var t2=i(Yd);Rk=o(t2,"TFFunnelForSequenceClassification"),t2.forEach(n),xu.forEach(n),gp=d(s),Ne=a(s,"DIV",{class:!0});var Tn=i(Ne);v(ma.$$.fragment,Tn),Vk=d(Tn),Kd=a(Tn,"P",{});var o2=i(Kd);Hk=o(o2,`Funnel Model transformer with a sequence classification/regression head on top (a linear layer on top of the pooled
output) e.g. for GLUE tasks.`),o2.forEach(n),Yk=d(Tn),ga=a(Tn,"P",{});var ju=i(ga);Kk=o(ju,"The Funnel Transformer model was proposed in "),_a=a(ju,"A",{href:!0,rel:!0});var s2=i(_a);Gk=o(s2,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),s2.forEach(n),Zk=o(ju," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),ju.forEach(n),Xk=d(Tn),Ta=a(Tn,"P",{});var Lu=i(Ta);Jk=o(Lu,"This model inherits from "),Bi=a(Lu,"A",{href:!0});var r2=i(Bi);eF=o(r2,"TFPreTrainedModel"),r2.forEach(n),nF=o(Lu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Lu.forEach(n),tF=d(Tn),ka=a(Tn,"P",{});var Ou=i(ka);oF=o(Ou,"This model is also a "),Fa=a(Ou,"A",{href:!0,rel:!0});var a2=i(Fa);sF=o(a2,"tf.keras.Model"),a2.forEach(n),rF=o(Ou,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Ou.forEach(n),aF=d(Tn),v(wo.$$.fragment,Tn),iF=d(Tn),en=a(Tn,"DIV",{class:!0});var On=i(en);v(va.$$.fragment,On),lF=d(On),jt=a(On,"P",{});var ml=i(jt);dF=o(ml,"The "),Qi=a(ml,"A",{href:!0});var i2=i(Qi);cF=o(i2,"TFFunnelForSequenceClassification"),i2.forEach(n),pF=o(ml," forward method, overrides the "),Gd=a(ml,"CODE",{});var l2=i(Gd);uF=o(l2,"__call__"),l2.forEach(n),hF=o(ml," special method."),ml.forEach(n),fF=d(On),v($o.$$.fragment,On),mF=d(On),Zd=a(On,"P",{});var d2=i(Zd);gF=o(d2,"Example:"),d2.forEach(n),_F=d(On),v(ba.$$.fragment,On),TF=d(On),v(ya.$$.fragment,On),On.forEach(n),Tn.forEach(n),_p=d(s),Lt=a(s,"H2",{class:!0});var Du=i(Lt);Eo=a(Du,"A",{id:!0,class:!0,href:!0});var c2=i(Eo);Xd=a(c2,"SPAN",{});var p2=i(Xd);v(wa.$$.fragment,p2),p2.forEach(n),c2.forEach(n),kF=d(Du),Jd=a(Du,"SPAN",{});var u2=i(Jd);FF=o(u2,"TFFunnelForMultipleChoice"),u2.forEach(n),Du.forEach(n),Tp=d(s),Se=a(s,"DIV",{class:!0});var kn=i(Se);v($a.$$.fragment,kn),vF=d(kn),ec=a(kn,"P",{});var h2=i(ec);bF=o(h2,`Funnel Model with a multiple choice classification head on top (a linear layer on top of the pooled output and a
softmax) e.g. for RocStories/SWAG tasks.`),h2.forEach(n),yF=d(kn),Ea=a(kn,"P",{});var Au=i(Ea);wF=o(Au,"The Funnel Transformer model was proposed in "),Ma=a(Au,"A",{href:!0,rel:!0});var f2=i(Ma);$F=o(f2,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),f2.forEach(n),EF=o(Au," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Au.forEach(n),MF=d(kn),za=a(kn,"P",{});var Nu=i(za);zF=o(Nu,"This model inherits from "),Ui=a(Nu,"A",{href:!0});var m2=i(Ui);qF=o(m2,"TFPreTrainedModel"),m2.forEach(n),PF=o(Nu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Nu.forEach(n),CF=d(kn),qa=a(kn,"P",{});var Su=i(qa);xF=o(Su,"This model is also a "),Pa=a(Su,"A",{href:!0,rel:!0});var g2=i(Pa);jF=o(g2,"tf.keras.Model"),g2.forEach(n),LF=o(Su,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Su.forEach(n),OF=d(kn),v(Mo.$$.fragment,kn),DF=d(kn),hn=a(kn,"DIV",{class:!0});var Gn=i(hn);v(Ca.$$.fragment,Gn),AF=d(Gn),Ot=a(Gn,"P",{});var gl=i(Ot);NF=o(gl,"The "),Ri=a(gl,"A",{href:!0});var _2=i(Ri);SF=o(_2,"TFFunnelForMultipleChoice"),_2.forEach(n),IF=o(gl," forward method, overrides the "),nc=a(gl,"CODE",{});var T2=i(nc);WF=o(T2,"__call__"),T2.forEach(n),BF=o(gl," special method."),gl.forEach(n),QF=d(Gn),v(zo.$$.fragment,Gn),UF=d(Gn),tc=a(Gn,"P",{});var k2=i(tc);RF=o(k2,"Example:"),k2.forEach(n),VF=d(Gn),v(xa.$$.fragment,Gn),Gn.forEach(n),kn.forEach(n),kp=d(s),Dt=a(s,"H2",{class:!0});var Iu=i(Dt);qo=a(Iu,"A",{id:!0,class:!0,href:!0});var F2=i(qo);oc=a(F2,"SPAN",{});var v2=i(oc);v(ja.$$.fragment,v2),v2.forEach(n),F2.forEach(n),HF=d(Iu),sc=a(Iu,"SPAN",{});var b2=i(sc);YF=o(b2,"TFFunnelForTokenClassification"),b2.forEach(n),Iu.forEach(n),Fp=d(s),Ie=a(s,"DIV",{class:!0});var Fn=i(Ie);v(La.$$.fragment,Fn),KF=d(Fn),rc=a(Fn,"P",{});var y2=i(rc);GF=o(y2,`Funnel Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g. for
Named-Entity-Recognition (NER) tasks.`),y2.forEach(n),ZF=d(Fn),Oa=a(Fn,"P",{});var Wu=i(Oa);XF=o(Wu,"The Funnel Transformer model was proposed in "),Da=a(Wu,"A",{href:!0,rel:!0});var w2=i(Da);JF=o(w2,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),w2.forEach(n),ev=o(Wu," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Wu.forEach(n),nv=d(Fn),Aa=a(Fn,"P",{});var Bu=i(Aa);tv=o(Bu,"This model inherits from "),Vi=a(Bu,"A",{href:!0});var $2=i(Vi);ov=o($2,"TFPreTrainedModel"),$2.forEach(n),sv=o(Bu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Bu.forEach(n),rv=d(Fn),Na=a(Fn,"P",{});var Qu=i(Na);av=o(Qu,"This model is also a "),Sa=a(Qu,"A",{href:!0,rel:!0});var E2=i(Sa);iv=o(E2,"tf.keras.Model"),E2.forEach(n),lv=o(Qu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Qu.forEach(n),dv=d(Fn),v(Po.$$.fragment,Fn),cv=d(Fn),nn=a(Fn,"DIV",{class:!0});var Dn=i(nn);v(Ia.$$.fragment,Dn),pv=d(Dn),At=a(Dn,"P",{});var _l=i(At);uv=o(_l,"The "),Hi=a(_l,"A",{href:!0});var M2=i(Hi);hv=o(M2,"TFFunnelForTokenClassification"),M2.forEach(n),fv=o(_l," forward method, overrides the "),ac=a(_l,"CODE",{});var z2=i(ac);mv=o(z2,"__call__"),z2.forEach(n),gv=o(_l," special method."),_l.forEach(n),_v=d(Dn),v(Co.$$.fragment,Dn),Tv=d(Dn),ic=a(Dn,"P",{});var q2=i(ic);kv=o(q2,"Example:"),q2.forEach(n),Fv=d(Dn),v(Wa.$$.fragment,Dn),vv=d(Dn),v(Ba.$$.fragment,Dn),Dn.forEach(n),Fn.forEach(n),vp=d(s),Nt=a(s,"H2",{class:!0});var Uu=i(Nt);xo=a(Uu,"A",{id:!0,class:!0,href:!0});var P2=i(xo);lc=a(P2,"SPAN",{});var C2=i(lc);v(Qa.$$.fragment,C2),C2.forEach(n),P2.forEach(n),bv=d(Uu),dc=a(Uu,"SPAN",{});var x2=i(dc);yv=o(x2,"TFFunnelForQuestionAnswering"),x2.forEach(n),Uu.forEach(n),bp=d(s),We=a(s,"DIV",{class:!0});var vn=i(We);v(Ua.$$.fragment,vn),wv=d(vn),St=a(vn,"P",{});var Tl=i(St);$v=o(Tl,`Funnel Model with a span classification head on top for extractive question-answering tasks like SQuAD (a linear
layers on top of the hidden-states output to compute `),cc=a(Tl,"CODE",{});var j2=i(cc);Ev=o(j2,"span start logits"),j2.forEach(n),Mv=o(Tl," and "),pc=a(Tl,"CODE",{});var L2=i(pc);zv=o(L2,"span end logits"),L2.forEach(n),qv=o(Tl,")."),Tl.forEach(n),Pv=d(vn),Ra=a(vn,"P",{});var Ru=i(Ra);Cv=o(Ru,"The Funnel Transformer model was proposed in "),Va=a(Ru,"A",{href:!0,rel:!0});var O2=i(Va);xv=o(O2,`Funnel-Transformer: Filtering out Sequential Redundancy for Efficient
Language Processing`),O2.forEach(n),jv=o(Ru," by Zihang Dai, Guokun Lai, Yiming Yang, Quoc V. Le."),Ru.forEach(n),Lv=d(vn),Ha=a(vn,"P",{});var Vu=i(Ha);Ov=o(Vu,"This model inherits from "),Yi=a(Vu,"A",{href:!0});var D2=i(Yi);Dv=o(D2,"TFPreTrainedModel"),D2.forEach(n),Av=o(Vu,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Vu.forEach(n),Nv=d(vn),Ya=a(vn,"P",{});var Hu=i(Ya);Sv=o(Hu,"This model is also a "),Ka=a(Hu,"A",{href:!0,rel:!0});var A2=i(Ka);Iv=o(A2,"tf.keras.Model"),A2.forEach(n),Wv=o(Hu,` subclass. Use it
as a regular TF 2.0 Keras Model and refer to the TF 2.0 documentation for all matter related to general usage and
behavior.`),Hu.forEach(n),Bv=d(vn),v(jo.$$.fragment,vn),Qv=d(vn),tn=a(vn,"DIV",{class:!0});var An=i(tn);v(Ga.$$.fragment,An),Uv=d(An),It=a(An,"P",{});var kl=i(It);Rv=o(kl,"The "),Ki=a(kl,"A",{href:!0});var N2=i(Ki);Vv=o(N2,"TFFunnelForQuestionAnswering"),N2.forEach(n),Hv=o(kl," forward method, overrides the "),uc=a(kl,"CODE",{});var S2=i(uc);Yv=o(S2,"__call__"),S2.forEach(n),Kv=o(kl," special method."),kl.forEach(n),Gv=d(An),v(Lo.$$.fragment,An),Zv=d(An),hc=a(An,"P",{});var I2=i(hc);Xv=o(I2,"Example:"),I2.forEach(n),Jv=d(An),v(Za.$$.fragment,An),eb=d(An),v(Xa.$$.fragment,An),An.forEach(n),vn.forEach(n),this.h()},h(){c(u,"name","hf:doc:metadata"),c(u,"content",JSON.stringify(_$)),c(_,"id","funnel-transformer"),c(_,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(_,"href","#funnel-transformer"),c(g,"class","relative group"),c(J,"id","overview"),c(J,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(J,"href","#overview"),c(q,"class","relative group"),c(te,"href","https://arxiv.org/abs/2006.03236"),c(te,"rel","nofollow"),c(re,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelModel"),c(p,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelForPreTraining"),c(Te,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelForMaskedLM"),c(ke,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelForTokenClassification"),c(Fe,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelBaseModel"),c(ve,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelForSequenceClassification"),c(oi,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelForMultipleChoice"),c(No,"href","https://huggingface.co/sgugger"),c(No,"rel","nofollow"),c(So,"href","https://github.com/laiguokun/Funnel-Transformer"),c(So,"rel","nofollow"),c(Wt,"id","transformers.FunnelConfig"),c(Wt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Wt,"href","#transformers.FunnelConfig"),c(Zn,"class","relative group"),c(si,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelModel"),c(ri,"href","/docs/transformers/pr_16819/en/model_doc/bert#transformers.TFBertModel"),c(Bo,"href","https://huggingface.co/funnel-transformer/small"),c(Bo,"rel","nofollow"),c(ai,"href","/docs/transformers/pr_16819/en/main_classes/configuration#transformers.PretrainedConfig"),c(ii,"href","/docs/transformers/pr_16819/en/main_classes/configuration#transformers.PretrainedConfig"),c(Nn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Bt,"id","transformers.FunnelTokenizer"),c(Bt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Bt,"href","#transformers.FunnelTokenizer"),c(Jn,"class","relative group"),c(li,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelTokenizer"),c(di,"href","/docs/transformers/pr_16819/en/model_doc/bert#transformers.BertTokenizer"),c(ci,"href","/docs/transformers/pr_16819/en/model_doc/bert#transformers.BertTokenizer"),c(Wn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ut,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(bn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(hi,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(xe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Rt,"id","transformers.FunnelTokenizerFast"),c(Rt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Rt,"href","#transformers.FunnelTokenizerFast"),c(nt,"class","relative group"),c(fi,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelTokenizerFast"),c(mi,"href","/docs/transformers/pr_16819/en/model_doc/bert#transformers.BertTokenizerFast"),c(gi,"href","/docs/transformers/pr_16819/en/model_doc/bert#transformers.BertTokenizerFast"),c(yn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(sn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ht,"id","transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput"),c(Ht,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Ht,"href","#transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput"),c(ot,"class","relative group"),c(_i,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelForPreTraining"),c(st,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ti,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelForPreTraining"),c(rt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Yt,"id","transformers.FunnelBaseModel"),c(Yt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Yt,"href","#transformers.FunnelBaseModel"),c(at,"class","relative group"),c(hs,"href","https://arxiv.org/abs/2006.03236"),c(hs,"rel","nofollow"),c(ki,"href","/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel"),c(gs,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(gs,"rel","nofollow"),c(Fi,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelBaseModel"),c(rn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Qe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Gt,"id","transformers.FunnelModel"),c(Gt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Gt,"href","#transformers.FunnelModel"),c(lt,"class","relative group"),c(bs,"href","https://arxiv.org/abs/2006.03236"),c(bs,"rel","nofollow"),c(vi,"href","/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel"),c($s,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c($s,"rel","nofollow"),c(bi,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelModel"),c(an,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ue,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Xt,"id","transformers.FunnelForPreTraining"),c(Xt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Xt,"href","#transformers.FunnelForPreTraining"),c(ct,"class","relative group"),c(yi,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelForPreTraining"),c(ln,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(pt,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(eo,"id","transformers.FunnelForMaskedLM"),c(eo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(eo,"href","#transformers.FunnelForMaskedLM"),c(ht,"class","relative group"),c(Ds,"href","https://arxiv.org/abs/2006.03236"),c(Ds,"rel","nofollow"),c(wi,"href","/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel"),c(Ss,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Ss,"rel","nofollow"),c($i,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelForMaskedLM"),c(Ge,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Re,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(to,"id","transformers.FunnelForSequenceClassification"),c(to,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(to,"href","#transformers.FunnelForSequenceClassification"),c(mt,"class","relative group"),c(Vs,"href","https://arxiv.org/abs/2006.03236"),c(Vs,"rel","nofollow"),c(Ei,"href","/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel"),c(Ks,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Ks,"rel","nofollow"),c(Mi,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelForSequenceClassification"),c(Pe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ve,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(so,"id","transformers.FunnelForMultipleChoice"),c(so,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(so,"href","#transformers.FunnelForMultipleChoice"),c(_t,"class","relative group"),c(sr,"href","https://arxiv.org/abs/2006.03236"),c(sr,"rel","nofollow"),c(zi,"href","/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel"),c(ir,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(ir,"rel","nofollow"),c(qi,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelForMultipleChoice"),c(dn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(He,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(ao,"id","transformers.FunnelForTokenClassification"),c(ao,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ao,"href","#transformers.FunnelForTokenClassification"),c(kt,"class","relative group"),c(hr,"href","https://arxiv.org/abs/2006.03236"),c(hr,"rel","nofollow"),c(Pi,"href","/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel"),c(gr,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(gr,"rel","nofollow"),c(Ci,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelForTokenClassification"),c(Ze,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ye,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(lo,"id","transformers.FunnelForQuestionAnswering"),c(lo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(lo,"href","#transformers.FunnelForQuestionAnswering"),c(vt,"class","relative group"),c(yr,"href","https://arxiv.org/abs/2006.03236"),c(yr,"rel","nofollow"),c(xi,"href","/docs/transformers/pr_16819/en/main_classes/model#transformers.PreTrainedModel"),c(Er,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),c(Er,"rel","nofollow"),c(ji,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.FunnelForQuestionAnswering"),c(Xe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ke,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(po,"id","transformers.TFFunnelBaseModel"),c(po,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(po,"href","#transformers.TFFunnelBaseModel"),c(wt,"class","relative group"),c(jr,"href","https://arxiv.org/abs/2006.03236"),c(jr,"rel","nofollow"),c(Li,"href","/docs/transformers/pr_16819/en/main_classes/model#transformers.TFPreTrainedModel"),c(Dr,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Dr,"rel","nofollow"),c(Oi,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.TFFunnelBaseModel"),c(cn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Le,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(fo,"id","transformers.TFFunnelModel"),c(fo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(fo,"href","#transformers.TFFunnelModel"),c(Et,"class","relative group"),c(Br,"href","https://arxiv.org/abs/2006.03236"),c(Br,"rel","nofollow"),c(Di,"href","/docs/transformers/pr_16819/en/main_classes/model#transformers.TFPreTrainedModel"),c(Rr,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Rr,"rel","nofollow"),c(Ai,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.TFFunnelModel"),c(pn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Oe,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(_o,"id","transformers.TFFunnelForPreTraining"),c(_o,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(_o,"href","#transformers.TFFunnelForPreTraining"),c(zt,"class","relative group"),c(Zr,"href","https://arxiv.org/abs/2006.03236"),c(Zr,"rel","nofollow"),c(Ni,"href","/docs/transformers/pr_16819/en/main_classes/model#transformers.TFPreTrainedModel"),c(ea,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(ea,"rel","nofollow"),c(Si,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.TFFunnelForPreTraining"),c(un,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(De,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Fo,"id","transformers.TFFunnelForMaskedLM"),c(Fo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Fo,"href","#transformers.TFFunnelForMaskedLM"),c(Pt,"class","relative group"),c(ia,"href","https://arxiv.org/abs/2006.03236"),c(ia,"rel","nofollow"),c(Ii,"href","/docs/transformers/pr_16819/en/main_classes/model#transformers.TFPreTrainedModel"),c(ca,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(ca,"rel","nofollow"),c(Wi,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.TFFunnelForMaskedLM"),c(Je,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ae,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(yo,"id","transformers.TFFunnelForSequenceClassification"),c(yo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(yo,"href","#transformers.TFFunnelForSequenceClassification"),c(xt,"class","relative group"),c(_a,"href","https://arxiv.org/abs/2006.03236"),c(_a,"rel","nofollow"),c(Bi,"href","/docs/transformers/pr_16819/en/main_classes/model#transformers.TFPreTrainedModel"),c(Fa,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Fa,"rel","nofollow"),c(Qi,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.TFFunnelForSequenceClassification"),c(en,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ne,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Eo,"id","transformers.TFFunnelForMultipleChoice"),c(Eo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Eo,"href","#transformers.TFFunnelForMultipleChoice"),c(Lt,"class","relative group"),c(Ma,"href","https://arxiv.org/abs/2006.03236"),c(Ma,"rel","nofollow"),c(Ui,"href","/docs/transformers/pr_16819/en/main_classes/model#transformers.TFPreTrainedModel"),c(Pa,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Pa,"rel","nofollow"),c(Ri,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.TFFunnelForMultipleChoice"),c(hn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Se,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(qo,"id","transformers.TFFunnelForTokenClassification"),c(qo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(qo,"href","#transformers.TFFunnelForTokenClassification"),c(Dt,"class","relative group"),c(Da,"href","https://arxiv.org/abs/2006.03236"),c(Da,"rel","nofollow"),c(Vi,"href","/docs/transformers/pr_16819/en/main_classes/model#transformers.TFPreTrainedModel"),c(Sa,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Sa,"rel","nofollow"),c(Hi,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.TFFunnelForTokenClassification"),c(nn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(Ie,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(xo,"id","transformers.TFFunnelForQuestionAnswering"),c(xo,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(xo,"href","#transformers.TFFunnelForQuestionAnswering"),c(Nt,"class","relative group"),c(Va,"href","https://arxiv.org/abs/2006.03236"),c(Va,"rel","nofollow"),c(Yi,"href","/docs/transformers/pr_16819/en/main_classes/model#transformers.TFPreTrainedModel"),c(Ka,"href","https://www.tensorflow.org/api_docs/python/tf/keras/Model"),c(Ka,"rel","nofollow"),c(Ki,"href","/docs/transformers/pr_16819/en/model_doc/funnel#transformers.TFFunnelForQuestionAnswering"),c(tn,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),c(We,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(s,f){e(document.head,u),h(s,z,f),h(s,g,f),e(g,_),e(_,k),b(T,k,null),e(g,m),e(g,M),e(M,ce),h(s,K,f),h(s,q,f),e(q,J),e(J,A),b(ne,A,null),e(q,pe),e(q,N),e(N,ue),h(s,ie,f),h(s,Y,f),e(Y,L),e(Y,te),e(te,G),e(Y,P),h(s,x,f),h(s,oe,f),e(oe,B),h(s,le,f),h(s,se,f),e(se,S),e(S,he),h(s,de,f),h(s,C,f),e(C,fe),h(s,W,f),h(s,ee,f),e(ee,ae),e(ae,Q),e(ee,me),e(ee,I),e(I,O),e(I,re),e(re,U),e(I,ge),e(I,p),e(p,E),e(I,Z),e(I,Te),e(Te,ye),e(I,D),e(I,ke),e(ke,we),e(I,$e),e(I,j),e(j,R),e(I,Ee),e(I,Fe),e(Fe,V),e(I,Me),e(I,ve),e(ve,_e),e(I,ze),e(I,oi),e(oi,Yu),e(I,Ku),h(s,Oc,f),h(s,In,f),e(In,Gu),e(In,No),e(No,Zu),e(In,Xu),e(In,So),e(So,Ju),e(In,eh),h(s,Dc,f),h(s,Zn,f),e(Zn,Wt),e(Wt,Fl),b(Io,Fl,null),e(Zn,nh),e(Zn,vl),e(vl,th),h(s,Ac,f),h(s,Nn,f),b(Wo,Nn,null),e(Nn,oh),e(Nn,Sn),e(Sn,sh),e(Sn,si),e(si,rh),e(Sn,ah),e(Sn,ri),e(ri,ih),e(Sn,lh),e(Sn,Bo),e(Bo,dh),e(Sn,ch),e(Nn,ph),e(Nn,Xn),e(Xn,uh),e(Xn,ai),e(ai,hh),e(Xn,fh),e(Xn,ii),e(ii,mh),e(Xn,gh),h(s,Nc,f),h(s,Jn,f),e(Jn,Bt),e(Bt,bl),b(Qo,bl,null),e(Jn,_h),e(Jn,yl),e(yl,Th),h(s,Sc,f),h(s,xe,f),b(Uo,xe,null),e(xe,kh),e(xe,wl),e(wl,Fh),e(xe,vh),e(xe,Qt),e(Qt,li),e(li,bh),e(Qt,yh),e(Qt,di),e(di,wh),e(Qt,$h),e(xe,Eh),e(xe,Ro),e(Ro,Mh),e(Ro,ci),e(ci,zh),e(Ro,qh),e(xe,Ph),e(xe,Wn),b(Vo,Wn,null),e(Wn,Ch),e(Wn,$l),e($l,xh),e(Wn,jh),e(Wn,Ho),e(Ho,pi),e(pi,Lh),e(pi,El),e(El,Oh),e(Ho,Dh),e(Ho,ui),e(ui,Ah),e(ui,Ml),e(Ml,Nh),e(xe,Sh),e(xe,Ut),b(Yo,Ut,null),e(Ut,Ih),e(Ut,Ko),e(Ko,Wh),e(Ko,zl),e(zl,Bh),e(Ko,Qh),e(xe,Uh),e(xe,bn),b(Go,bn,null),e(bn,Rh),e(bn,ql),e(ql,Vh),e(bn,Hh),b(Zo,bn,null),e(bn,Yh),e(bn,et),e(et,Kh),e(et,Pl),e(Pl,Gh),e(et,Zh),e(et,Cl),e(Cl,Xh),e(et,Jh),e(xe,ef),e(xe,hi),b(Xo,hi,null),h(s,Ic,f),h(s,nt,f),e(nt,Rt),e(Rt,xl),b(Jo,xl,null),e(nt,nf),e(nt,jl),e(jl,tf),h(s,Wc,f),h(s,sn,f),b(es,sn,null),e(sn,of),e(sn,ns),e(ns,sf),e(ns,Ll),e(Ll,rf),e(ns,af),e(sn,lf),e(sn,Vt),e(Vt,fi),e(fi,df),e(Vt,cf),e(Vt,mi),e(mi,pf),e(Vt,uf),e(sn,hf),e(sn,ts),e(ts,ff),e(ts,gi),e(gi,mf),e(ts,gf),e(sn,_f),e(sn,yn),b(os,yn,null),e(yn,Tf),e(yn,Ol),e(Ol,kf),e(yn,Ff),b(ss,yn,null),e(yn,vf),e(yn,tt),e(tt,bf),e(tt,Dl),e(Dl,yf),e(tt,wf),e(tt,Al),e(Al,$f),e(tt,Ef),h(s,Bc,f),h(s,ot,f),e(ot,Ht),e(Ht,Nl),b(rs,Nl,null),e(ot,Mf),e(ot,Sl),e(Sl,zf),h(s,Qc,f),h(s,st,f),b(as,st,null),e(st,qf),e(st,is),e(is,Pf),e(is,_i),e(_i,Cf),e(is,xf),h(s,Uc,f),h(s,rt,f),b(ls,rt,null),e(rt,jf),e(rt,ds),e(ds,Lf),e(ds,Ti),e(Ti,Of),e(ds,Df),h(s,Rc,f),h(s,at,f),e(at,Yt),e(Yt,Il),b(cs,Il,null),e(at,Af),e(at,Wl),e(Wl,Nf),h(s,Vc,f),h(s,Qe,f),b(ps,Qe,null),e(Qe,Sf),e(Qe,Bl),e(Bl,If),e(Qe,Wf),e(Qe,us),e(us,Bf),e(us,hs),e(hs,Qf),e(us,Uf),e(Qe,Rf),e(Qe,fs),e(fs,Vf),e(fs,ki),e(ki,Hf),e(fs,Yf),e(Qe,Kf),e(Qe,ms),e(ms,Gf),e(ms,gs),e(gs,Zf),e(ms,Xf),e(Qe,Jf),e(Qe,rn),b(_s,rn,null),e(rn,em),e(rn,it),e(it,nm),e(it,Fi),e(Fi,tm),e(it,om),e(it,Ql),e(Ql,sm),e(it,rm),e(rn,am),b(Kt,rn,null),e(rn,im),e(rn,Ul),e(Ul,lm),e(rn,dm),b(Ts,rn,null),h(s,Hc,f),h(s,lt,f),e(lt,Gt),e(Gt,Rl),b(ks,Rl,null),e(lt,cm),e(lt,Vl),e(Vl,pm),h(s,Yc,f),h(s,Ue,f),b(Fs,Ue,null),e(Ue,um),e(Ue,Hl),e(Hl,hm),e(Ue,fm),e(Ue,vs),e(vs,mm),e(vs,bs),e(bs,gm),e(vs,_m),e(Ue,Tm),e(Ue,ys),e(ys,km),e(ys,vi),e(vi,Fm),e(ys,vm),e(Ue,bm),e(Ue,ws),e(ws,ym),e(ws,$s),e($s,wm),e(ws,$m),e(Ue,Em),e(Ue,an),b(Es,an,null),e(an,Mm),e(an,dt),e(dt,zm),e(dt,bi),e(bi,qm),e(dt,Pm),e(dt,Yl),e(Yl,Cm),e(dt,xm),e(an,jm),b(Zt,an,null),e(an,Lm),e(an,Kl),e(Kl,Om),e(an,Dm),b(Ms,an,null),h(s,Kc,f),h(s,ct,f),e(ct,Xt),e(Xt,Gl),b(zs,Gl,null),e(ct,Am),e(ct,Zl),e(Zl,Nm),h(s,Gc,f),h(s,pt,f),b(qs,pt,null),e(pt,Sm),e(pt,ln),b(Ps,ln,null),e(ln,Im),e(ln,ut),e(ut,Wm),e(ut,yi),e(yi,Bm),e(ut,Qm),e(ut,Xl),e(Xl,Um),e(ut,Rm),e(ln,Vm),b(Jt,ln,null),e(ln,Hm),e(ln,Jl),e(Jl,Ym),e(ln,Km),b(Cs,ln,null),h(s,Zc,f),h(s,ht,f),e(ht,eo),e(eo,ed),b(xs,ed,null),e(ht,Gm),e(ht,nd),e(nd,Zm),h(s,Xc,f),h(s,Re,f),b(js,Re,null),e(Re,Xm),e(Re,Ls),e(Ls,Jm),e(Ls,td),e(td,eg),e(Ls,ng),e(Re,tg),e(Re,Os),e(Os,og),e(Os,Ds),e(Ds,sg),e(Os,rg),e(Re,ag),e(Re,As),e(As,ig),e(As,wi),e(wi,lg),e(As,dg),e(Re,cg),e(Re,Ns),e(Ns,pg),e(Ns,Ss),e(Ss,ug),e(Ns,hg),e(Re,fg),e(Re,Ge),b(Is,Ge,null),e(Ge,mg),e(Ge,ft),e(ft,gg),e(ft,$i),e($i,_g),e(ft,Tg),e(ft,od),e(od,kg),e(ft,Fg),e(Ge,vg),b(no,Ge,null),e(Ge,bg),e(Ge,sd),e(sd,yg),e(Ge,wg),b(Ws,Ge,null),e(Ge,$g),b(Bs,Ge,null),h(s,Jc,f),h(s,mt,f),e(mt,to),e(to,rd),b(Qs,rd,null),e(mt,Eg),e(mt,ad),e(ad,Mg),h(s,ep,f),h(s,Ve,f),b(Us,Ve,null),e(Ve,zg),e(Ve,id),e(id,qg),e(Ve,Pg),e(Ve,Rs),e(Rs,Cg),e(Rs,Vs),e(Vs,xg),e(Rs,jg),e(Ve,Lg),e(Ve,Hs),e(Hs,Og),e(Hs,Ei),e(Ei,Dg),e(Hs,Ag),e(Ve,Ng),e(Ve,Ys),e(Ys,Sg),e(Ys,Ks),e(Ks,Ig),e(Ys,Wg),e(Ve,Bg),e(Ve,Pe),b(Gs,Pe,null),e(Pe,Qg),e(Pe,gt),e(gt,Ug),e(gt,Mi),e(Mi,Rg),e(gt,Vg),e(gt,ld),e(ld,Hg),e(gt,Yg),e(Pe,Kg),b(oo,Pe,null),e(Pe,Gg),e(Pe,dd),e(dd,Zg),e(Pe,Xg),b(Zs,Pe,null),e(Pe,Jg),b(Xs,Pe,null),e(Pe,e_),e(Pe,cd),e(cd,n_),e(Pe,t_),b(Js,Pe,null),e(Pe,o_),b(er,Pe,null),h(s,np,f),h(s,_t,f),e(_t,so),e(so,pd),b(nr,pd,null),e(_t,s_),e(_t,ud),e(ud,r_),h(s,tp,f),h(s,He,f),b(tr,He,null),e(He,a_),e(He,hd),e(hd,i_),e(He,l_),e(He,or),e(or,d_),e(or,sr),e(sr,c_),e(or,p_),e(He,u_),e(He,rr),e(rr,h_),e(rr,zi),e(zi,f_),e(rr,m_),e(He,g_),e(He,ar),e(ar,__),e(ar,ir),e(ir,T_),e(ar,k_),e(He,F_),e(He,dn),b(lr,dn,null),e(dn,v_),e(dn,Tt),e(Tt,b_),e(Tt,qi),e(qi,y_),e(Tt,w_),e(Tt,fd),e(fd,$_),e(Tt,E_),e(dn,M_),b(ro,dn,null),e(dn,z_),e(dn,md),e(md,q_),e(dn,P_),b(dr,dn,null),h(s,op,f),h(s,kt,f),e(kt,ao),e(ao,gd),b(cr,gd,null),e(kt,C_),e(kt,_d),e(_d,x_),h(s,sp,f),h(s,Ye,f),b(pr,Ye,null),e(Ye,j_),e(Ye,Td),e(Td,L_),e(Ye,O_),e(Ye,ur),e(ur,D_),e(ur,hr),e(hr,A_),e(ur,N_),e(Ye,S_),e(Ye,fr),e(fr,I_),e(fr,Pi),e(Pi,W_),e(fr,B_),e(Ye,Q_),e(Ye,mr),e(mr,U_),e(mr,gr),e(gr,R_),e(mr,V_),e(Ye,H_),e(Ye,Ze),b(_r,Ze,null),e(Ze,Y_),e(Ze,Ft),e(Ft,K_),e(Ft,Ci),e(Ci,G_),e(Ft,Z_),e(Ft,kd),e(kd,X_),e(Ft,J_),e(Ze,eT),b(io,Ze,null),e(Ze,nT),e(Ze,Fd),e(Fd,tT),e(Ze,oT),b(Tr,Ze,null),e(Ze,sT),b(kr,Ze,null),h(s,rp,f),h(s,vt,f),e(vt,lo),e(lo,vd),b(Fr,vd,null),e(vt,rT),e(vt,bd),e(bd,aT),h(s,ap,f),h(s,Ke,f),b(vr,Ke,null),e(Ke,iT),e(Ke,bt),e(bt,lT),e(bt,yd),e(yd,dT),e(bt,cT),e(bt,wd),e(wd,pT),e(bt,uT),e(Ke,hT),e(Ke,br),e(br,fT),e(br,yr),e(yr,mT),e(br,gT),e(Ke,_T),e(Ke,wr),e(wr,TT),e(wr,xi),e(xi,kT),e(wr,FT),e(Ke,vT),e(Ke,$r),e($r,bT),e($r,Er),e(Er,yT),e($r,wT),e(Ke,$T),e(Ke,Xe),b(Mr,Xe,null),e(Xe,ET),e(Xe,yt),e(yt,MT),e(yt,ji),e(ji,zT),e(yt,qT),e(yt,$d),e($d,PT),e(yt,CT),e(Xe,xT),b(co,Xe,null),e(Xe,jT),e(Xe,Ed),e(Ed,LT),e(Xe,OT),b(zr,Xe,null),e(Xe,DT),b(qr,Xe,null),h(s,ip,f),h(s,wt,f),e(wt,po),e(po,Md),b(Pr,Md,null),e(wt,AT),e(wt,zd),e(zd,NT),h(s,lp,f),h(s,Le,f),b(Cr,Le,null),e(Le,ST),e(Le,qd),e(qd,IT),e(Le,WT),e(Le,xr),e(xr,BT),e(xr,jr),e(jr,QT),e(xr,UT),e(Le,RT),e(Le,Lr),e(Lr,VT),e(Lr,Li),e(Li,HT),e(Lr,YT),e(Le,KT),e(Le,Or),e(Or,GT),e(Or,Dr),e(Dr,ZT),e(Or,XT),e(Le,JT),b(uo,Le,null),e(Le,e1),e(Le,cn),b(Ar,cn,null),e(cn,n1),e(cn,$t),e($t,t1),e($t,Oi),e(Oi,o1),e($t,s1),e($t,Pd),e(Pd,r1),e($t,a1),e(cn,i1),b(ho,cn,null),e(cn,l1),e(cn,Cd),e(Cd,d1),e(cn,c1),b(Nr,cn,null),h(s,dp,f),h(s,Et,f),e(Et,fo),e(fo,xd),b(Sr,xd,null),e(Et,p1),e(Et,jd),e(jd,u1),h(s,cp,f),h(s,Oe,f),b(Ir,Oe,null),e(Oe,h1),e(Oe,Ld),e(Ld,f1),e(Oe,m1),e(Oe,Wr),e(Wr,g1),e(Wr,Br),e(Br,_1),e(Wr,T1),e(Oe,k1),e(Oe,Qr),e(Qr,F1),e(Qr,Di),e(Di,v1),e(Qr,b1),e(Oe,y1),e(Oe,Ur),e(Ur,w1),e(Ur,Rr),e(Rr,$1),e(Ur,E1),e(Oe,M1),b(mo,Oe,null),e(Oe,z1),e(Oe,pn),b(Vr,pn,null),e(pn,q1),e(pn,Mt),e(Mt,P1),e(Mt,Ai),e(Ai,C1),e(Mt,x1),e(Mt,Od),e(Od,j1),e(Mt,L1),e(pn,O1),b(go,pn,null),e(pn,D1),e(pn,Dd),e(Dd,A1),e(pn,N1),b(Hr,pn,null),h(s,pp,f),h(s,zt,f),e(zt,_o),e(_o,Ad),b(Yr,Ad,null),e(zt,S1),e(zt,Nd),e(Nd,I1),h(s,up,f),h(s,De,f),b(Kr,De,null),e(De,W1),e(De,Sd),e(Sd,B1),e(De,Q1),e(De,Gr),e(Gr,U1),e(Gr,Zr),e(Zr,R1),e(Gr,V1),e(De,H1),e(De,Xr),e(Xr,Y1),e(Xr,Ni),e(Ni,K1),e(Xr,G1),e(De,Z1),e(De,Jr),e(Jr,X1),e(Jr,ea),e(ea,J1),e(Jr,ek),e(De,nk),b(To,De,null),e(De,tk),e(De,un),b(na,un,null),e(un,ok),e(un,qt),e(qt,sk),e(qt,Si),e(Si,rk),e(qt,ak),e(qt,Id),e(Id,ik),e(qt,lk),e(un,dk),b(ko,un,null),e(un,ck),e(un,Wd),e(Wd,pk),e(un,uk),b(ta,un,null),h(s,hp,f),h(s,Pt,f),e(Pt,Fo),e(Fo,Bd),b(oa,Bd,null),e(Pt,hk),e(Pt,Qd),e(Qd,fk),h(s,fp,f),h(s,Ae,f),b(sa,Ae,null),e(Ae,mk),e(Ae,ra),e(ra,gk),e(ra,Ud),e(Ud,_k),e(ra,Tk),e(Ae,kk),e(Ae,aa),e(aa,Fk),e(aa,ia),e(ia,vk),e(aa,bk),e(Ae,yk),e(Ae,la),e(la,wk),e(la,Ii),e(Ii,$k),e(la,Ek),e(Ae,Mk),e(Ae,da),e(da,zk),e(da,ca),e(ca,qk),e(da,Pk),e(Ae,Ck),b(vo,Ae,null),e(Ae,xk),e(Ae,Je),b(pa,Je,null),e(Je,jk),e(Je,Ct),e(Ct,Lk),e(Ct,Wi),e(Wi,Ok),e(Ct,Dk),e(Ct,Rd),e(Rd,Ak),e(Ct,Nk),e(Je,Sk),b(bo,Je,null),e(Je,Ik),e(Je,Vd),e(Vd,Wk),e(Je,Bk),b(ua,Je,null),e(Je,Qk),b(ha,Je,null),h(s,mp,f),h(s,xt,f),e(xt,yo),e(yo,Hd),b(fa,Hd,null),e(xt,Uk),e(xt,Yd),e(Yd,Rk),h(s,gp,f),h(s,Ne,f),b(ma,Ne,null),e(Ne,Vk),e(Ne,Kd),e(Kd,Hk),e(Ne,Yk),e(Ne,ga),e(ga,Kk),e(ga,_a),e(_a,Gk),e(ga,Zk),e(Ne,Xk),e(Ne,Ta),e(Ta,Jk),e(Ta,Bi),e(Bi,eF),e(Ta,nF),e(Ne,tF),e(Ne,ka),e(ka,oF),e(ka,Fa),e(Fa,sF),e(ka,rF),e(Ne,aF),b(wo,Ne,null),e(Ne,iF),e(Ne,en),b(va,en,null),e(en,lF),e(en,jt),e(jt,dF),e(jt,Qi),e(Qi,cF),e(jt,pF),e(jt,Gd),e(Gd,uF),e(jt,hF),e(en,fF),b($o,en,null),e(en,mF),e(en,Zd),e(Zd,gF),e(en,_F),b(ba,en,null),e(en,TF),b(ya,en,null),h(s,_p,f),h(s,Lt,f),e(Lt,Eo),e(Eo,Xd),b(wa,Xd,null),e(Lt,kF),e(Lt,Jd),e(Jd,FF),h(s,Tp,f),h(s,Se,f),b($a,Se,null),e(Se,vF),e(Se,ec),e(ec,bF),e(Se,yF),e(Se,Ea),e(Ea,wF),e(Ea,Ma),e(Ma,$F),e(Ea,EF),e(Se,MF),e(Se,za),e(za,zF),e(za,Ui),e(Ui,qF),e(za,PF),e(Se,CF),e(Se,qa),e(qa,xF),e(qa,Pa),e(Pa,jF),e(qa,LF),e(Se,OF),b(Mo,Se,null),e(Se,DF),e(Se,hn),b(Ca,hn,null),e(hn,AF),e(hn,Ot),e(Ot,NF),e(Ot,Ri),e(Ri,SF),e(Ot,IF),e(Ot,nc),e(nc,WF),e(Ot,BF),e(hn,QF),b(zo,hn,null),e(hn,UF),e(hn,tc),e(tc,RF),e(hn,VF),b(xa,hn,null),h(s,kp,f),h(s,Dt,f),e(Dt,qo),e(qo,oc),b(ja,oc,null),e(Dt,HF),e(Dt,sc),e(sc,YF),h(s,Fp,f),h(s,Ie,f),b(La,Ie,null),e(Ie,KF),e(Ie,rc),e(rc,GF),e(Ie,ZF),e(Ie,Oa),e(Oa,XF),e(Oa,Da),e(Da,JF),e(Oa,ev),e(Ie,nv),e(Ie,Aa),e(Aa,tv),e(Aa,Vi),e(Vi,ov),e(Aa,sv),e(Ie,rv),e(Ie,Na),e(Na,av),e(Na,Sa),e(Sa,iv),e(Na,lv),e(Ie,dv),b(Po,Ie,null),e(Ie,cv),e(Ie,nn),b(Ia,nn,null),e(nn,pv),e(nn,At),e(At,uv),e(At,Hi),e(Hi,hv),e(At,fv),e(At,ac),e(ac,mv),e(At,gv),e(nn,_v),b(Co,nn,null),e(nn,Tv),e(nn,ic),e(ic,kv),e(nn,Fv),b(Wa,nn,null),e(nn,vv),b(Ba,nn,null),h(s,vp,f),h(s,Nt,f),e(Nt,xo),e(xo,lc),b(Qa,lc,null),e(Nt,bv),e(Nt,dc),e(dc,yv),h(s,bp,f),h(s,We,f),b(Ua,We,null),e(We,wv),e(We,St),e(St,$v),e(St,cc),e(cc,Ev),e(St,Mv),e(St,pc),e(pc,zv),e(St,qv),e(We,Pv),e(We,Ra),e(Ra,Cv),e(Ra,Va),e(Va,xv),e(Ra,jv),e(We,Lv),e(We,Ha),e(Ha,Ov),e(Ha,Yi),e(Yi,Dv),e(Ha,Av),e(We,Nv),e(We,Ya),e(Ya,Sv),e(Ya,Ka),e(Ka,Iv),e(Ya,Wv),e(We,Bv),b(jo,We,null),e(We,Qv),e(We,tn),b(Ga,tn,null),e(tn,Uv),e(tn,It),e(It,Rv),e(It,Ki),e(Ki,Vv),e(It,Hv),e(It,uc),e(uc,Yv),e(It,Kv),e(tn,Gv),b(Lo,tn,null),e(tn,Zv),e(tn,hc),e(hc,Xv),e(tn,Jv),b(Za,tn,null),e(tn,eb),b(Xa,tn,null),yp=!0},p(s,[f]){const Ja={};f&2&&(Ja.$$scope={dirty:f,ctx:s}),Kt.$set(Ja);const fc={};f&2&&(fc.$$scope={dirty:f,ctx:s}),Zt.$set(fc);const mc={};f&2&&(mc.$$scope={dirty:f,ctx:s}),Jt.$set(mc);const gc={};f&2&&(gc.$$scope={dirty:f,ctx:s}),no.$set(gc);const ei={};f&2&&(ei.$$scope={dirty:f,ctx:s}),oo.$set(ei);const _c={};f&2&&(_c.$$scope={dirty:f,ctx:s}),ro.$set(_c);const Tc={};f&2&&(Tc.$$scope={dirty:f,ctx:s}),io.$set(Tc);const kc={};f&2&&(kc.$$scope={dirty:f,ctx:s}),co.$set(kc);const ni={};f&2&&(ni.$$scope={dirty:f,ctx:s}),uo.$set(ni);const Fc={};f&2&&(Fc.$$scope={dirty:f,ctx:s}),ho.$set(Fc);const vc={};f&2&&(vc.$$scope={dirty:f,ctx:s}),mo.$set(vc);const bc={};f&2&&(bc.$$scope={dirty:f,ctx:s}),go.$set(bc);const yc={};f&2&&(yc.$$scope={dirty:f,ctx:s}),To.$set(yc);const wc={};f&2&&(wc.$$scope={dirty:f,ctx:s}),ko.$set(wc);const ti={};f&2&&(ti.$$scope={dirty:f,ctx:s}),vo.$set(ti);const $c={};f&2&&($c.$$scope={dirty:f,ctx:s}),bo.$set($c);const je={};f&2&&(je.$$scope={dirty:f,ctx:s}),wo.$set(je);const Ec={};f&2&&(Ec.$$scope={dirty:f,ctx:s}),$o.$set(Ec);const Mc={};f&2&&(Mc.$$scope={dirty:f,ctx:s}),Mo.$set(Mc);const zc={};f&2&&(zc.$$scope={dirty:f,ctx:s}),zo.$set(zc);const qc={};f&2&&(qc.$$scope={dirty:f,ctx:s}),Po.$set(qc);const Pc={};f&2&&(Pc.$$scope={dirty:f,ctx:s}),Co.$set(Pc);const Cc={};f&2&&(Cc.$$scope={dirty:f,ctx:s}),jo.$set(Cc);const xc={};f&2&&(xc.$$scope={dirty:f,ctx:s}),Lo.$set(xc)},i(s){yp||(y(T.$$.fragment,s),y(ne.$$.fragment,s),y(Io.$$.fragment,s),y(Wo.$$.fragment,s),y(Qo.$$.fragment,s),y(Uo.$$.fragment,s),y(Vo.$$.fragment,s),y(Yo.$$.fragment,s),y(Go.$$.fragment,s),y(Zo.$$.fragment,s),y(Xo.$$.fragment,s),y(Jo.$$.fragment,s),y(es.$$.fragment,s),y(os.$$.fragment,s),y(ss.$$.fragment,s),y(rs.$$.fragment,s),y(as.$$.fragment,s),y(ls.$$.fragment,s),y(cs.$$.fragment,s),y(ps.$$.fragment,s),y(_s.$$.fragment,s),y(Kt.$$.fragment,s),y(Ts.$$.fragment,s),y(ks.$$.fragment,s),y(Fs.$$.fragment,s),y(Es.$$.fragment,s),y(Zt.$$.fragment,s),y(Ms.$$.fragment,s),y(zs.$$.fragment,s),y(qs.$$.fragment,s),y(Ps.$$.fragment,s),y(Jt.$$.fragment,s),y(Cs.$$.fragment,s),y(xs.$$.fragment,s),y(js.$$.fragment,s),y(Is.$$.fragment,s),y(no.$$.fragment,s),y(Ws.$$.fragment,s),y(Bs.$$.fragment,s),y(Qs.$$.fragment,s),y(Us.$$.fragment,s),y(Gs.$$.fragment,s),y(oo.$$.fragment,s),y(Zs.$$.fragment,s),y(Xs.$$.fragment,s),y(Js.$$.fragment,s),y(er.$$.fragment,s),y(nr.$$.fragment,s),y(tr.$$.fragment,s),y(lr.$$.fragment,s),y(ro.$$.fragment,s),y(dr.$$.fragment,s),y(cr.$$.fragment,s),y(pr.$$.fragment,s),y(_r.$$.fragment,s),y(io.$$.fragment,s),y(Tr.$$.fragment,s),y(kr.$$.fragment,s),y(Fr.$$.fragment,s),y(vr.$$.fragment,s),y(Mr.$$.fragment,s),y(co.$$.fragment,s),y(zr.$$.fragment,s),y(qr.$$.fragment,s),y(Pr.$$.fragment,s),y(Cr.$$.fragment,s),y(uo.$$.fragment,s),y(Ar.$$.fragment,s),y(ho.$$.fragment,s),y(Nr.$$.fragment,s),y(Sr.$$.fragment,s),y(Ir.$$.fragment,s),y(mo.$$.fragment,s),y(Vr.$$.fragment,s),y(go.$$.fragment,s),y(Hr.$$.fragment,s),y(Yr.$$.fragment,s),y(Kr.$$.fragment,s),y(To.$$.fragment,s),y(na.$$.fragment,s),y(ko.$$.fragment,s),y(ta.$$.fragment,s),y(oa.$$.fragment,s),y(sa.$$.fragment,s),y(vo.$$.fragment,s),y(pa.$$.fragment,s),y(bo.$$.fragment,s),y(ua.$$.fragment,s),y(ha.$$.fragment,s),y(fa.$$.fragment,s),y(ma.$$.fragment,s),y(wo.$$.fragment,s),y(va.$$.fragment,s),y($o.$$.fragment,s),y(ba.$$.fragment,s),y(ya.$$.fragment,s),y(wa.$$.fragment,s),y($a.$$.fragment,s),y(Mo.$$.fragment,s),y(Ca.$$.fragment,s),y(zo.$$.fragment,s),y(xa.$$.fragment,s),y(ja.$$.fragment,s),y(La.$$.fragment,s),y(Po.$$.fragment,s),y(Ia.$$.fragment,s),y(Co.$$.fragment,s),y(Wa.$$.fragment,s),y(Ba.$$.fragment,s),y(Qa.$$.fragment,s),y(Ua.$$.fragment,s),y(jo.$$.fragment,s),y(Ga.$$.fragment,s),y(Lo.$$.fragment,s),y(Za.$$.fragment,s),y(Xa.$$.fragment,s),yp=!0)},o(s){w(T.$$.fragment,s),w(ne.$$.fragment,s),w(Io.$$.fragment,s),w(Wo.$$.fragment,s),w(Qo.$$.fragment,s),w(Uo.$$.fragment,s),w(Vo.$$.fragment,s),w(Yo.$$.fragment,s),w(Go.$$.fragment,s),w(Zo.$$.fragment,s),w(Xo.$$.fragment,s),w(Jo.$$.fragment,s),w(es.$$.fragment,s),w(os.$$.fragment,s),w(ss.$$.fragment,s),w(rs.$$.fragment,s),w(as.$$.fragment,s),w(ls.$$.fragment,s),w(cs.$$.fragment,s),w(ps.$$.fragment,s),w(_s.$$.fragment,s),w(Kt.$$.fragment,s),w(Ts.$$.fragment,s),w(ks.$$.fragment,s),w(Fs.$$.fragment,s),w(Es.$$.fragment,s),w(Zt.$$.fragment,s),w(Ms.$$.fragment,s),w(zs.$$.fragment,s),w(qs.$$.fragment,s),w(Ps.$$.fragment,s),w(Jt.$$.fragment,s),w(Cs.$$.fragment,s),w(xs.$$.fragment,s),w(js.$$.fragment,s),w(Is.$$.fragment,s),w(no.$$.fragment,s),w(Ws.$$.fragment,s),w(Bs.$$.fragment,s),w(Qs.$$.fragment,s),w(Us.$$.fragment,s),w(Gs.$$.fragment,s),w(oo.$$.fragment,s),w(Zs.$$.fragment,s),w(Xs.$$.fragment,s),w(Js.$$.fragment,s),w(er.$$.fragment,s),w(nr.$$.fragment,s),w(tr.$$.fragment,s),w(lr.$$.fragment,s),w(ro.$$.fragment,s),w(dr.$$.fragment,s),w(cr.$$.fragment,s),w(pr.$$.fragment,s),w(_r.$$.fragment,s),w(io.$$.fragment,s),w(Tr.$$.fragment,s),w(kr.$$.fragment,s),w(Fr.$$.fragment,s),w(vr.$$.fragment,s),w(Mr.$$.fragment,s),w(co.$$.fragment,s),w(zr.$$.fragment,s),w(qr.$$.fragment,s),w(Pr.$$.fragment,s),w(Cr.$$.fragment,s),w(uo.$$.fragment,s),w(Ar.$$.fragment,s),w(ho.$$.fragment,s),w(Nr.$$.fragment,s),w(Sr.$$.fragment,s),w(Ir.$$.fragment,s),w(mo.$$.fragment,s),w(Vr.$$.fragment,s),w(go.$$.fragment,s),w(Hr.$$.fragment,s),w(Yr.$$.fragment,s),w(Kr.$$.fragment,s),w(To.$$.fragment,s),w(na.$$.fragment,s),w(ko.$$.fragment,s),w(ta.$$.fragment,s),w(oa.$$.fragment,s),w(sa.$$.fragment,s),w(vo.$$.fragment,s),w(pa.$$.fragment,s),w(bo.$$.fragment,s),w(ua.$$.fragment,s),w(ha.$$.fragment,s),w(fa.$$.fragment,s),w(ma.$$.fragment,s),w(wo.$$.fragment,s),w(va.$$.fragment,s),w($o.$$.fragment,s),w(ba.$$.fragment,s),w(ya.$$.fragment,s),w(wa.$$.fragment,s),w($a.$$.fragment,s),w(Mo.$$.fragment,s),w(Ca.$$.fragment,s),w(zo.$$.fragment,s),w(xa.$$.fragment,s),w(ja.$$.fragment,s),w(La.$$.fragment,s),w(Po.$$.fragment,s),w(Ia.$$.fragment,s),w(Co.$$.fragment,s),w(Wa.$$.fragment,s),w(Ba.$$.fragment,s),w(Qa.$$.fragment,s),w(Ua.$$.fragment,s),w(jo.$$.fragment,s),w(Ga.$$.fragment,s),w(Lo.$$.fragment,s),w(Za.$$.fragment,s),w(Xa.$$.fragment,s),yp=!1},d(s){n(u),s&&n(z),s&&n(g),$(T),s&&n(K),s&&n(q),$(ne),s&&n(ie),s&&n(Y),s&&n(x),s&&n(oe),s&&n(le),s&&n(se),s&&n(de),s&&n(C),s&&n(W),s&&n(ee),s&&n(Oc),s&&n(In),s&&n(Dc),s&&n(Zn),$(Io),s&&n(Ac),s&&n(Nn),$(Wo),s&&n(Nc),s&&n(Jn),$(Qo),s&&n(Sc),s&&n(xe),$(Uo),$(Vo),$(Yo),$(Go),$(Zo),$(Xo),s&&n(Ic),s&&n(nt),$(Jo),s&&n(Wc),s&&n(sn),$(es),$(os),$(ss),s&&n(Bc),s&&n(ot),$(rs),s&&n(Qc),s&&n(st),$(as),s&&n(Uc),s&&n(rt),$(ls),s&&n(Rc),s&&n(at),$(cs),s&&n(Vc),s&&n(Qe),$(ps),$(_s),$(Kt),$(Ts),s&&n(Hc),s&&n(lt),$(ks),s&&n(Yc),s&&n(Ue),$(Fs),$(Es),$(Zt),$(Ms),s&&n(Kc),s&&n(ct),$(zs),s&&n(Gc),s&&n(pt),$(qs),$(Ps),$(Jt),$(Cs),s&&n(Zc),s&&n(ht),$(xs),s&&n(Xc),s&&n(Re),$(js),$(Is),$(no),$(Ws),$(Bs),s&&n(Jc),s&&n(mt),$(Qs),s&&n(ep),s&&n(Ve),$(Us),$(Gs),$(oo),$(Zs),$(Xs),$(Js),$(er),s&&n(np),s&&n(_t),$(nr),s&&n(tp),s&&n(He),$(tr),$(lr),$(ro),$(dr),s&&n(op),s&&n(kt),$(cr),s&&n(sp),s&&n(Ye),$(pr),$(_r),$(io),$(Tr),$(kr),s&&n(rp),s&&n(vt),$(Fr),s&&n(ap),s&&n(Ke),$(vr),$(Mr),$(co),$(zr),$(qr),s&&n(ip),s&&n(wt),$(Pr),s&&n(lp),s&&n(Le),$(Cr),$(uo),$(Ar),$(ho),$(Nr),s&&n(dp),s&&n(Et),$(Sr),s&&n(cp),s&&n(Oe),$(Ir),$(mo),$(Vr),$(go),$(Hr),s&&n(pp),s&&n(zt),$(Yr),s&&n(up),s&&n(De),$(Kr),$(To),$(na),$(ko),$(ta),s&&n(hp),s&&n(Pt),$(oa),s&&n(fp),s&&n(Ae),$(sa),$(vo),$(pa),$(bo),$(ua),$(ha),s&&n(mp),s&&n(xt),$(fa),s&&n(gp),s&&n(Ne),$(ma),$(wo),$(va),$($o),$(ba),$(ya),s&&n(_p),s&&n(Lt),$(wa),s&&n(Tp),s&&n(Se),$($a),$(Mo),$(Ca),$(zo),$(xa),s&&n(kp),s&&n(Dt),$(ja),s&&n(Fp),s&&n(Ie),$(La),$(Po),$(Ia),$(Co),$(Wa),$(Ba),s&&n(vp),s&&n(Nt),$(Qa),s&&n(bp),s&&n(We),$(Ua),$(jo),$(Ga),$(Lo),$(Za),$(Xa)}}}const _$={local:"funnel-transformer",sections:[{local:"overview",title:"Overview"},{local:"transformers.FunnelConfig",title:"FunnelConfig"},{local:"transformers.FunnelTokenizer",title:"FunnelTokenizer"},{local:"transformers.FunnelTokenizerFast",title:"FunnelTokenizerFast"},{local:"transformers.models.funnel.modeling_funnel.FunnelForPreTrainingOutput",title:"Funnel specific outputs"},{local:"transformers.FunnelBaseModel",title:"FunnelBaseModel"},{local:"transformers.FunnelModel",title:"FunnelModel"},{local:"transformers.FunnelForPreTraining",title:"FunnelModelForPreTraining"},{local:"transformers.FunnelForMaskedLM",title:"FunnelForMaskedLM"},{local:"transformers.FunnelForSequenceClassification",title:"FunnelForSequenceClassification"},{local:"transformers.FunnelForMultipleChoice",title:"FunnelForMultipleChoice"},{local:"transformers.FunnelForTokenClassification",title:"FunnelForTokenClassification"},{local:"transformers.FunnelForQuestionAnswering",title:"FunnelForQuestionAnswering"},{local:"transformers.TFFunnelBaseModel",title:"TFFunnelBaseModel"},{local:"transformers.TFFunnelModel",title:"TFFunnelModel"},{local:"transformers.TFFunnelForPreTraining",title:"TFFunnelModelForPreTraining"},{local:"transformers.TFFunnelForMaskedLM",title:"TFFunnelForMaskedLM"},{local:"transformers.TFFunnelForSequenceClassification",title:"TFFunnelForSequenceClassification"},{local:"transformers.TFFunnelForMultipleChoice",title:"TFFunnelForMultipleChoice"},{local:"transformers.TFFunnelForTokenClassification",title:"TFFunnelForTokenClassification"},{local:"transformers.TFFunnelForQuestionAnswering",title:"TFFunnelForQuestionAnswering"}],title:"Funnel Transformer"};function T$(H){return R2(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class w$ extends W2{constructor(u){super();B2(this,u,T$,g$,Q2,{})}}export{w$ as default,_$ as metadata};
