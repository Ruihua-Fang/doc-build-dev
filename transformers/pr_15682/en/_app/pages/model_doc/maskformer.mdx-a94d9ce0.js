import{S as si,i as ai,s as ni,e as r,k as c,w as u,t as n,M as ii,c as s,d as o,m as l,a,x as g,h as i,b as d,F as e,g as h,y as _,q as k,o as F,B as v}from"../../chunks/vendor-4833417e.js";import{T as Ga}from"../../chunks/Tip-fffd6df1.js";import{D as I}from"../../chunks/Docstring-44c5af16.js";import{C as Qa}from"../../chunks/CodeBlock-90ffda97.js";import{I as lt}from"../../chunks/IconCopyLink-4b81c553.js";import"../../chunks/CopyButton-04a16537.js";function di(U){let p,T;return{c(){p=r("p"),T=n(`NumPy arrays and PyTorch tensors are converted to PIL images when resizing, so the most efficient is to pass
PIL images.`)},l(f){p=s(f,"P",{});var b=a(p);T=i(b,`NumPy arrays and PyTorch tensors are converted to PIL images when resizing, so the most efficient is to pass
PIL images.`),b.forEach(o)},m(f,b){h(f,p,b),e(p,T)},d(f){f&&o(p)}}}function ci(U){let p,T,f,b,z;return{c(){p=r("p"),T=n("Although the recipe for forward pass needs to be defined within this function, one should call the "),f=r("code"),b=n("Module"),z=n(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(M){p=s(M,"P",{});var y=a(p);T=i(y,"Although the recipe for forward pass needs to be defined within this function, one should call the "),f=s(y,"CODE",{});var D=a(f);b=i(D,"Module"),D.forEach(o),z=i(y,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),y.forEach(o)},m(M,y){h(M,p,y),e(p,T),e(p,f),e(f,b),e(p,z)},d(M){M&&o(p)}}}function li(U){let p,T,f,b,z;return{c(){p=r("p"),T=n("Although the recipe for forward pass needs to be defined within this function, one should call the "),f=r("code"),b=n("Module"),z=n(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(M){p=s(M,"P",{});var y=a(p);T=i(y,"Although the recipe for forward pass needs to be defined within this function, one should call the "),f=s(y,"CODE",{});var D=a(f);b=i(D,"Module"),D.forEach(o),z=i(y,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),y.forEach(o)},m(M,y){h(M,p,y),e(p,T),e(p,f),e(f,b),e(p,z)},d(M){M&&o(p)}}}function mi(U){let p,T,f,b,z,M,y,D,lr,ko,R,se,qt,we,mr,Nt,hr,Fo,ae,pr,xe,fr,ur,vo,mt,gr,bo,ht,Lt,_r,wo,pt,kr,xo,S,j,Fr,Ht,vr,br,ft,wr,xr,Wt,Mr,Tr,yr,C,$r,Vt,Er,Ir,Ut,Or,Pr,Rt,zr,Cr,Me,Sr,Dr,jr,Te,Ar,ut,qr,Nr,Lr,B,Hr,gt,Wr,Vr,_t,Ur,Rr,Mo,N,Br,ye,Kr,Gr,$e,Qr,Yr,To,K,ne,Bt,Ee,Jr,Kt,Xr,yo,G,Ie,Zr,Oe,es,kt,ts,os,$o,A,Pe,rs,ze,ss,Ft,as,ns,is,Q,ds,vt,cs,ls,bt,ms,hs,Eo,Y,ie,Gt,Ce,ps,Qt,fs,Io,w,Se,us,De,gs,Yt,_s,ks,Fs,J,vs,wt,bs,ws,xt,xs,Ms,Ts,Jt,ys,$s,Xt,Es,Is,je,Os,de,Ae,Ps,qe,zs,Mt,Cs,Ss,Ds,ce,Ne,js,Le,As,Tt,qs,Ns,Oo,X,le,Zt,He,Ls,eo,Hs,Po,x,We,Ws,to,Vs,Us,Ve,Rs,yt,Bs,Ks,Gs,L,Ue,Qs,oo,Ys,Js,me,Xs,he,Re,Zs,Be,ea,ro,ta,oa,ra,pe,Ke,sa,Ge,aa,so,na,ia,da,fe,Qe,ca,Ye,la,ao,ma,ha,pa,ue,Je,fa,Xe,ua,no,ga,_a,zo,Z,ge,io,Ze,ka,co,Fa,Co,q,et,va,tt,ba,ot,wa,xa,Ma,O,rt,Ta,ee,ya,$t,$a,Ea,lo,Ia,Oa,Pa,_e,za,mo,Ca,Sa,st,So,te,ke,ho,at,Da,po,ja,Do,oe,nt,Aa,P,it,qa,re,Na,Et,La,Ha,fo,Wa,Va,Ua,Fe,Ra,uo,Ba,Ka,dt,jo;return M=new lt({}),we=new lt({}),Ee=new lt({}),Ie=new I({props:{name:"class transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput",anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput",parameters:[{name:"encoder_last_hidden_state",val:": typing.Optional[torch.FloatTensor] = None"},{name:"pixel_decoder_last_hidden_state",val:": typing.Optional[torch.FloatTensor] = None"},{name:"transformer_decoder_last_hidden_state",val:": typing.Optional[torch.FloatTensor] = None"},{name:"encoder_hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"pixel_decoder_hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"transformer_decoder_hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_15682/src/transformers/models/maskformer/modeling_maskformer.py#L220",parametersDescription:[{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput.encoder_last_hidden_state",description:`<strong>encoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Last hidden states (final feature map) of the last stage of the encoder model (backbone).`,name:"encoder_last_hidden_state"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput.pixel_decoder_last_hidden_state",description:`<strong>pixel_decoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Last hidden states (final feature map) of the last stage of the pixel decoder model (FPN).`,name:"pixel_decoder_last_hidden_state"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput.transformer_decoder_last_hidden_state",description:`<strong>transformer_decoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) &#x2014;
Last hidden states (final feature map) of the last stage of the transformer decoder model.`,name:"transformer_decoder_last_hidden_state"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput.encoder_hidden_states",description:`<strong>encoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the encoder
model at the output of each stage.`,name:"encoder_hidden_states"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput.pixel_decoder_hidden_states",description:`<strong>pixel_decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the pixel
decoder model at the output of each stage.`,name:"pixel_decoder_hidden_states"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput.decoder_hidden_states",description:`<strong>decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, sequence_length, hidden_size)</code>. Hidden-states (also called feature maps) of the
transformer decoder at the output of each stage.`,name:"decoder_hidden_states"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput.hidden_states",description:`<strong>hidden_states</strong> <code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> containing <code>encoder_hidden_states</code>, <code>pixel_decoder_hidden_states</code> and
<code>decoder_hidden_states</code>`,name:"hidden_states"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>. Attentions weights from Detr&#x2019;s decoder after the attention softmax, used to compute the
weighted average in the self-attention heads.`,name:"attentions"}]}}),Pe=new I({props:{name:"class transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput",anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput",parameters:[{name:"loss",val:": typing.Optional[torch.FloatTensor] = None"},{name:"class_queries_logits",val:": FloatTensor = None"},{name:"masks_queries_logits",val:": FloatTensor = None"},{name:"auxilary_logits",val:": FloatTensor = None"},{name:"encoder_last_hidden_state",val:": typing.Optional[torch.FloatTensor] = None"},{name:"pixel_decoder_last_hidden_state",val:": typing.Optional[torch.FloatTensor] = None"},{name:"transformer_decoder_last_hidden_state",val:": typing.Optional[torch.FloatTensor] = None"},{name:"encoder_hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"pixel_decoder_hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"transformer_decoder_hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"hidden_states",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"},{name:"attentions",val:": typing.Optional[typing.Tuple[torch.FloatTensor]] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_15682/src/transformers/models/maskformer/modeling_maskformer.py#L263",parametersDescription:[{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.loss",description:`<strong>loss</strong> (<code>torch.Tensor</code>, <em>optional</em>) &#x2014;
The computed loss, returned when labels are present.`,name:"loss"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.class_queries_logits",description:`<strong>class_queries_logits</strong> (<code>torch.FloatTensor</code>) &#x2014;
A tensor of shape <code>(batch_size, num_queries, height, width)</code> representing the proposed masks for each
query.`,name:"class_queries_logits"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.masks_queries_logits",description:`<strong>masks_queries_logits</strong> (<code>torch.FloatTensor</code>) &#x2014;
A tensor of shape <code>(batch_size, num_queries, num_classes + 1)</code> representing the proposed classes for each
query. Note the <code>+ 1</code> is needed because we incorporate the null class.`,name:"masks_queries_logits"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.encoder_last_hidden_state",description:`<strong>encoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Last hidden states (final feature map) of the last stage of the encoder model (backbone).`,name:"encoder_last_hidden_state"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.pixel_decoder_last_hidden_state",description:`<strong>pixel_decoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Last hidden states (final feature map) of the last stage of the pixel decoder model (FPN).`,name:"pixel_decoder_last_hidden_state"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.transformer_decoder_last_hidden_state",description:`<strong>transformer_decoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) &#x2014;
Last hidden states (final feature map) of the last stage of the transformer decoder model.`,name:"transformer_decoder_last_hidden_state"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.encoder_hidden_states",description:`<strong>encoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the encoder
model at the output of each stage.`,name:"encoder_hidden_states"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.pixel_decoder_hidden_states",description:`<strong>pixel_decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the pixel
decoder model at the output of each stage.`,name:"pixel_decoder_hidden_states"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.decoder_hidden_states",description:`<strong>decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, sequence_length, hidden_size)</code>. Hidden-states (also called feature maps) of the
transformer decoder at the output of each stage.`,name:"decoder_hidden_states"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.hidden_states",description:`<strong>hidden_states</strong> <code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> containing <code>encoder_hidden_states</code>, <code>pixel_decoder_hidden_states</code> and
<code>decoder_hidden_states</code>.`,name:"hidden_states"},{anchor:"transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput.attentions",description:`<strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) &#x2014;
Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>. Attentions weights from Detr&#x2019;s decoder after the attention softmax, used to compute the
weighted average in the self-attention heads.`,name:"attentions"}]}}),Ce=new lt({}),Se=new I({props:{name:"class transformers.MaskFormerConfig",anchor:"transformers.MaskFormerConfig",parameters:[{name:"fpn_feature_size",val:": int = 256"},{name:"mask_feature_size",val:": int = 256"},{name:"no_object_weight",val:": float = 0.1"},{name:"use_auxilary_loss",val:": bool = False"},{name:"backbone_config",val:": typing.Optional[typing.Dict] = None"},{name:"detr_config",val:": typing.Optional[typing.Dict] = None"},{name:"init_std",val:": float = 0.02"},{name:"init_xavier_std",val:": float = 1.0"},{name:"dice_weight",val:": float = 1.0"},{name:"cross_entropy_weight",val:": float = 1.0"},{name:"mask_weight",val:": float = 20.0"},{name:"num_labels",val:": int = 150"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_15682/src/transformers/models/maskformer/configuration_maskformer.py#L34",parametersDescription:[{anchor:"transformers.MaskFormerConfig.mask_feature_size",description:`<strong>mask_feature_size</strong> (<code>int</code>, <em>optional</em>, defaults to 256) &#x2014;
The masks&#x2019; features size, this value will also be used to specify the Feature Pyramid Network featuresc
size.`,name:"mask_feature_size"},{anchor:"transformers.MaskFormerConfig.no_object_weight",description:`<strong>no_object_weight</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
Weight to apply to the null class .`,name:"no_object_weight"},{anchor:"transformers.MaskFormerConfig.use_auxilary_loss",description:`<strong>use_auxilary_loss</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
If <code>true</code> <code>MaskFormerOutput</code> will contain.`,name:"use_auxilary_loss"},{anchor:"transformers.MaskFormerConfig.backbone_config",description:`<strong>backbone_config</strong> (<code>Dict</code>, <em>optional</em>) &#x2014;
The configuration passed to the backbone, if unset, the configuration corresponding to <code>swin-base</code> will be
used.`,name:"backbone_config"},{anchor:"transformers.MaskFormerConfig.detr_config",description:`<strong>detr_config</strong> (<code>Dict</code>, <em>optional</em>) &#x2014;
The configuration passed to the Detr model, if unset the base config for <code>detr</code> will be used.`,name:"detr_config"},{anchor:"transformers.MaskFormerConfig.init_std",description:`<strong>init_std</strong> (<code>float</code>, <em>optional</em>, defaults to 0.02) &#x2014;
The standard deviation of the truncated_normal_initializer for initializing all weight matrices.`,name:"init_std"},{anchor:"transformers.MaskFormerConfig.init_xavier_std",description:`<strong>init_xavier_std</strong> (<code>float</code>, <em>optional</em>, defaults to 1) &#x2014;
The scaling factor used for the Xavier initialization gain in the HM Attention map module.`,name:"init_xavier_std"},{anchor:"transformers.MaskFormerConfig.dice_weight",description:`<strong>dice_weight</strong> (<code>float</code>, <em>optional</em>, defaults to 1.0) &#x2014;
The weight for the dice loss.`,name:"dice_weight"},{anchor:"transformers.MaskFormerConfig.cross_entropy_weight",description:`<strong>cross_entropy_weight</strong> (<code>float</code>, <em>optional</em>, defaults to 1.0) &#x2014;
The weight for the cross entropy loss.`,name:"cross_entropy_weight"},{anchor:"transformers.MaskFormerConfig.mask_weight",description:`<strong>mask_weight</strong> (<code>float</code>, <em>optional</em>, defaults to 20.0) &#x2014;
The weight for the mask loss.`,name:"mask_weight"},{anchor:"transformers.MaskFormerConfig.num_labels",description:`<strong>num_labels</strong> (<code>int</code>, <em>optional</em>, defaults to 150) &#x2014;
The number of labels.`,name:"num_labels"}]}}),je=new Qa({props:{code:`from transformers import MaskFormerConfig, MaskFormerModel

# Initializing a MaskFormer facebook/maskformer-swin-base-ade configuration
configuration = MaskFormerConfig()

# Initializing a model from the facebook/maskformer-swin-base-ade style configuration
model = MaskFormerModel(configuration)

# Accessing the model configuration
configuration = model.config,`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> MaskFormerConfig, MaskFormerModel

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a MaskFormer facebook/maskformer-swin-base-ade configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = MaskFormerConfig()

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Initializing a model from the facebook/maskformer-swin-base-ade style configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = MaskFormerModel(configuration)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Accessing the model configuration</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>configuration = model.config`}}),Ae=new I({props:{name:"from_backbone_and_detr_configs",anchor:"transformers.MaskFormerConfig.from_backbone_and_detr_configs",parameters:[{name:"backbone_config",val:": PretrainedConfig"},{name:"detr_config",val:": DetrConfig"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_15682/src/transformers/models/maskformer/configuration_maskformer.py#L152",parametersDescription:[{anchor:"transformers.MaskFormerConfig.from_backbone_and_detr_configs.backbone_config",description:`<strong>backbone_config</strong> (<a href="/docs/transformers/pr_15682/en/main_classes/configuration#transformers.PretrainedConfig">PretrainedConfig</a>) &#x2014;
The backbone configuration.`,name:"backbone_config"},{anchor:"transformers.MaskFormerConfig.from_backbone_and_detr_configs.detr_config",description:`<strong>detr_config</strong> (<a href="/docs/transformers/pr_15682/en/model_doc/detr#transformers.DetrConfig">DetrConfig</a>) &#x2014;
The transformer decoder configuration to use`,name:"detr_config"}],returnDescription:`
<p>An instance of a configuration object</p>
`,returnType:`
<p><a
  href="/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerConfig"
>MaskFormerConfig</a></p>
`}}),Ne=new I({props:{name:"to_dict",anchor:"transformers.MaskFormerConfig.to_dict",parameters:[],source:"https://github.com/huggingface/transformers/blob/pr_15682/src/transformers/models/maskformer/configuration_maskformer.py#L168",returnDescription:`
<p>Dictionary of all the attributes that make up this configuration instance,</p>
`,returnType:`
<p><code>Dict[str, any]</code></p>
`}}),He=new lt({}),We=new I({props:{name:"class transformers.MaskFormerFeatureExtractor",anchor:"transformers.MaskFormerFeatureExtractor",parameters:[{name:"do_resize",val:" = True"},{name:"size",val:" = 800"},{name:"max_size",val:" = 1333"},{name:"size_divisibility",val:" = 32"},{name:"do_normalize",val:" = True"},{name:"image_mean",val:" = None"},{name:"image_std",val:" = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_15682/src/transformers/models/maskformer/feature_extraction_maskformer.py#L39",parametersDescription:[{anchor:"transformers.MaskFormerFeatureExtractor.do_resize",description:`<strong>do_resize</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether to resize the input to a certain <code>size</code>.`,name:"do_resize"},{anchor:"transformers.MaskFormerFeatureExtractor.size",description:`<strong>size</strong> (<code>int</code>, <em>optional</em>, defaults to 800) &#x2014;
Resize the input to the given size. Only has an effect if <code>do_resize</code> is set to <code>True</code>. If size is a
sequence like <code>(width, height)</code>, output size will be matched to this. If size is an int, smaller edge of
the image will be matched to this number. i.e, if <code>height &gt; width</code>, then image will be rescaled to <code>(size * height / width, size)</code>.`,name:"size"},{anchor:"transformers.MaskFormerFeatureExtractor.max_size",description:`<strong>max_size</strong> (<code>int</code>, <em>optional</em>, defaults to 1333) &#x2014;
The largest size an image dimension can have (otherwise it&#x2019;s capped). Only has an effect if <code>do_resize</code> is
set to <code>True</code>.`,name:"max_size"},{anchor:"transformers.MaskFormerFeatureExtractor.size_divisibility",description:`<strong>size_divisibility</strong> (<code>int</code>, <em>optional</em>, defaults to 32) &#x2014;
Some backbones need images divisible by a certain number, if not passes it detauls to the value used in
swin.`,name:"size_divisibility"},{anchor:"transformers.MaskFormerFeatureExtractor.do_normalize",description:`<strong>do_normalize</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to normalize the input with mean and standard deviation.`,name:"do_normalize"},{anchor:"transformers.MaskFormerFeatureExtractor.image_mean",description:`<strong>image_mean</strong> (<code>int</code>, <em>optional</em>, defaults to <code>[0.485, 0.456, 0.406]</code>) &#x2014;
The sequence of means for each channel, to be used when normalizing images. Defaults to the ImageNet mean.`,name:"image_mean"},{anchor:"transformers.MaskFormerFeatureExtractor.image_std",description:`<strong>image_std</strong> (<code>int</code>, <em>optional</em>, defaults to <code>[0.229, 0.224, 0.225]</code>) &#x2014;
The sequence of standard deviations for each channel, to be used when normalizing images. Defaults to the
ImageNet std.`,name:"image_std"}]}}),Ue=new I({props:{name:"__call__",anchor:"transformers.MaskFormerFeatureExtractor.__call__",parameters:[{name:"images",val:": typing.Union[PIL.Image.Image, numpy.ndarray, ForwardRef('torch.Tensor'), typing.List[PIL.Image.Image], typing.List[numpy.ndarray], typing.List[ForwardRef('torch.Tensor')]]"},{name:"annotations",val:": typing.Union[typing.List[typing.Dict], typing.List[typing.List[typing.Dict]]] = None"},{name:"pad_and_return_pixel_mask",val:": typing.Optional[bool] = True"},{name:"return_tensors",val:": typing.Union[str, transformers.file_utils.TensorType, NoneType] = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/transformers/blob/pr_15682/src/transformers/models/maskformer/feature_extraction_maskformer.py#L167",parametersDescription:[{anchor:"transformers.MaskFormerFeatureExtractor.__call__.images",description:`<strong>images</strong> (<code>PIL.Image.Image</code>, <code>np.ndarray</code>, <code>torch.Tensor</code>, <code>List[PIL.Image.Image]</code>, <code>List[np.ndarray]</code>, <code>List[torch.Tensor]</code>) &#x2014;
The image or batch of images to be prepared. Each image can be a PIL image, NumPy array or PyTorch
tensor. In case of a NumPy array/PyTorch tensor, each image should be of shape (C, H, W), where C is a
number of channels, H and W are image height and width.`,name:"images"},{anchor:"transformers.MaskFormerFeatureExtractor.__call__.annotations",description:`<strong>annotations</strong> (<code>Dict</code>, <code>List[Dict]</code>, <em>optional</em>) &#x2014;
The corresponding annotations as dictionary of numpy arrays with the following keys:</p>
<ul>
<li><strong>masks</strong> (<code>np.ndarray</code>) The target mask of shape <code>(num_classes, height, width)</code>.</li>
<li><strong>labels</strong> (<code>np.ndarray</code>) The target labels of shape <code>(num_classes)</code>.</li>
</ul>`,name:"annotations"},{anchor:"transformers.MaskFormerFeatureExtractor.__call__.pad_and_return_pixel_mask",description:`<strong>pad_and_return_pixel_mask</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not to pad images up to the largest image in a batch and create a pixel mask.</p>
<p>If left to the default, will return a pixel mask that is:</p>
<ul>
<li>1 for pixels that are real (i.e. <strong>not masked</strong>),</li>
<li>0 for pixels that are padding (i.e. <strong>masked</strong>).</li>
</ul>`,name:"pad_and_return_pixel_mask"},{anchor:"transformers.MaskFormerFeatureExtractor.__call__.return_tensors",description:`<strong>return_tensors</strong> (<code>str</code> or <a href="/docs/transformers/pr_15682/en/internal/file_utils#transformers.TensorType">TensorType</a>, <em>optional</em>) &#x2014;
If set, will return tensors instead of NumPy arrays. If set to <code>&apos;pt&apos;</code>, return PyTorch <code>torch.Tensor</code>
objects.`,name:"return_tensors"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_15682/en/main_classes/feature_extractor#transformers.BatchFeature"
>BatchFeature</a> with the following fields:</p>
<ul>
<li><strong>pixel_values</strong> \u2014 Pixel values to be fed to a model.</li>
<li><strong>pixel_mask</strong> \u2014 Pixel mask to be fed to a model (when <code>pad_and_return_pixel_mask=True</code> or if
<code>"pixel_mask"</code> is in <code>self.model_input_names</code>).</li>
<li><strong>labels</strong> \u2014 Optional labels to be fed to a model (when <code>annotations</code> are provided)</li>
</ul>
`}}),me=new Ga({props:{warning:"&lcub;true}",$$slots:{default:[di]},$$scope:{ctx:U}}}),Re=new I({props:{name:"encode_inputs",anchor:"transformers.MaskFormerFeatureExtractor.encode_inputs",parameters:[{name:"pixel_values_list",val:": typing.List[ForwardRef('torch.Tensor')]"},{name:"annotations",val:": typing.Optional[typing.List[typing.Dict]] = None"},{name:"pad_and_return_pixel_mask",val:": typing.Optional[bool] = True"},{name:"return_tensors",val:": typing.Union[str, transformers.file_utils.TensorType, NoneType] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_15682/src/transformers/models/maskformer/feature_extraction_maskformer.py#L304",parametersDescription:[{anchor:"transformers.MaskFormerFeatureExtractor.encode_inputs.pixel_values_list",description:`<strong>pixel_values_list</strong> (<code>List[torch.Tensor]</code>) &#x2014;
List of images (pixel values) to be padded. Each image should be a tensor of shape <code>(channels, height, width)</code>.`,name:"pixel_values_list"},{anchor:"transformers.MaskFormerFeatureExtractor.encode_inputs.return_tensors",description:`<strong>return_tensors</strong> (<code>str</code> or <a href="/docs/transformers/pr_15682/en/internal/file_utils#transformers.TensorType">TensorType</a>, <em>optional</em>) &#x2014;
If set, will return tensors instead of NumPy arrays. If set to <code>&apos;pt&apos;</code>, return PyTorch <code>torch.Tensor</code>
objects.`,name:"return_tensors"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_15682/en/main_classes/feature_extractor#transformers.BatchFeature"
>BatchFeature</a> with the following fields:</p>
<ul>
<li><strong>pixel_values</strong> \u2014 Pixel values to be fed to a model.</li>
<li><strong>pixel_mask</strong> \u2014 Pixel mask to be fed to a model (when <code>pad_and_return_pixel_mask=True</code> or if
<em>\u201Cpixel_mask\u201D</em> is in <code>self.model_input_names</code>).</li>
<li><strong>mask_labels</strong> \u2014 Optional mask labels of shape <code>(batch_size, num_classes, height, width) to be fed to a model (when </code>annotations\` are provided).</li>
<li><strong>class_labels</strong> \u2014 Optional class labels of shape <code>(batch_size, num_classes) to be fed to a model (when </code>annotations\` are provided).</li>
</ul>
`}}),Ke=new I({props:{name:"post_process_segmentation",anchor:"transformers.MaskFormerFeatureExtractor.post_process_segmentation",parameters:[{name:"outputs",val:": MaskFormerForInstanceSegmentationOutput"},{name:"target_size",val:": typing.Tuple[int, int] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_15682/src/transformers/models/maskformer/feature_extraction_maskformer.py#L375",parametersDescription:[{anchor:"transformers.MaskFormerFeatureExtractor.post_process_segmentation.outputs",description:`<strong>outputs</strong> (<code>MaskFormerForInstanceSegmentationOutput</code>) &#x2014;
The outputs from <a href="/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerForInstanceSegmentation">MaskFormerForInstanceSegmentation</a>.`,name:"outputs"}],returnDescription:`
<p>A tensor of shape (<code>batch_size, num_labels, height, width</code>).</p>
`,returnType:`
<p><code>torch.Tensor</code></p>
`}}),Qe=new I({props:{name:"post_process_semantic_segmentation",anchor:"transformers.MaskFormerFeatureExtractor.post_process_semantic_segmentation",parameters:[{name:"outputs",val:": MaskFormerForInstanceSegmentationOutput"},{name:"target_size",val:": typing.Tuple[int, int] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_15682/src/transformers/models/maskformer/feature_extraction_maskformer.py#L443",parametersDescription:[{anchor:"transformers.MaskFormerFeatureExtractor.post_process_semantic_segmentation.outputs",description:`<strong>outputs</strong> (<code>MaskFormerForInstanceSegmentationOutput</code>) &#x2014;
The outputs from <a href="/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerForInstanceSegmentation">MaskFormerForInstanceSegmentation</a>.`,name:"outputs"}],returnDescription:`
<p>A tensor of shape <code>batch_size, height, width</code>.</p>
`,returnType:`
<p><code>torch.Tensor</code></p>
`}}),Je=new I({props:{name:"post_process_panoptic_segmentation",anchor:"transformers.MaskFormerFeatureExtractor.post_process_panoptic_segmentation",parameters:[{name:"outputs",val:": MaskFormerForInstanceSegmentationOutput"},{name:"object_mask_threshold",val:": float = 0.8"},{name:"overlap_mask_area_threshold",val:": float = 0.8"},{name:"is_thing_map",val:": typing.Union[typing.Dict[int, bool], NoneType] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_15682/src/transformers/models/maskformer/feature_extraction_maskformer.py#L461",parametersDescription:[{anchor:"transformers.MaskFormerFeatureExtractor.post_process_panoptic_segmentation.outputs",description:`<strong>outputs</strong> (<code>MaskFormerForInstanceSegmentationOutput</code>) &#x2014;
The outputs from <a href="/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerForInstanceSegmentation">MaskFormerForInstanceSegmentation</a>.`,name:"outputs"},{anchor:"transformers.MaskFormerFeatureExtractor.post_process_panoptic_segmentation.object_mask_threshold",description:`<strong>object_mask_threshold</strong> (<code>float</code>, <em>optional</em>, defaults to 0.8) &#x2014;
The object mask threshold.`,name:"object_mask_threshold"},{anchor:"transformers.MaskFormerFeatureExtractor.post_process_panoptic_segmentation.overlap_mask_area_threshold",description:`<strong>overlap_mask_area_threshold</strong> (<code>float</code>, <em>optional</em>, defaults to 0.8) &#x2014;
The overlap mask area threshold.`,name:"overlap_mask_area_threshold"},{anchor:"transformers.MaskFormerFeatureExtractor.post_process_panoptic_segmentation.is_thing_map",description:`<strong>is_thing_map</strong> (<code>Dict[int, bool]</code>, <em>optional</em>) &#x2014;
Dictionary mapping class indices to either <code>True</code> or <code>False</code>, depending on whether or not they are a
thing. If not set, defaults to the <code>is_thing_map</code> of ADE20K-150 panoptic.`,name:"is_thing_map"}],returnDescription:`
<p>A list of dictionaries, one per image, each dictionary containing two keys:</p>
<ul>
<li><strong>segmentation</strong> \u2014 a tensor of shape <code>(height, width)</code> where each pixel represent a <code>segment_id</code>.</li>
<li><strong>segments</strong> \u2014 a dictionary with the following keys<ul>
<li><strong>id</strong> \u2014 an integer representing the <code>segment_id</code>.</li>
<li><strong>category_id</strong> \u2014 an integer representing the segment\u2019s label.</li>
<li><strong>is_thing</strong> \u2014 a boolean, <code>True</code> if <code>category_id</code> was in <code>is_thing_map</code>, <code>False</code> otherwise.</li>
</ul></li>
</ul>
`}}),Ze=new lt({}),et=new I({props:{name:"class transformers.MaskFormerModel",anchor:"transformers.MaskFormerModel",parameters:[{name:"config",val:": MaskFormerConfig"}],source:"https://github.com/huggingface/transformers/blob/pr_15682/src/transformers/models/maskformer/modeling_maskformer.py#L2264",parametersDescription:[{anchor:"transformers.MaskFormerModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerConfig">MaskFormerConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_15682/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}]}}),rt=new I({props:{name:"forward",anchor:"transformers.MaskFormerModel.forward",parameters:[{name:"pixel_values",val:": Tensor"},{name:"pixel_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_15682/src/transformers/models/maskformer/modeling_maskformer.py#L2274",parametersDescription:[{anchor:"transformers.MaskFormerModel.forward.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Pixel values can be obtained using <a href="/docs/transformers/pr_15682/en/model_doc/auto#transformers.AutoFeatureExtractor">AutoFeatureExtractor</a>. See
<code>AutoFeatureExtractor.__call__()</code>for details.`,name:"pixel_values"},{anchor:"transformers.MaskFormerModel.forward.pixel_mask",description:`<strong>pixel_mask</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, height, width)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding pixel values. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for pixels that are real (i.e. <strong>not masked</strong>),</li>
<li>0 for pixels that are padding (i.e. <strong>masked</strong>).</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"pixel_mask"},{anchor:"transformers.MaskFormerModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.MaskFormerModel.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of Detr&#x2019;s decoder attention layers.`,name:"output_attentions"},{anchor:"transformers.MaskFormerModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <code>~MaskFormerModelOutput</code> instead of a plain tuple.`,name:"return_dict"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput"
>transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerConfig"
>MaskFormerConfig</a>) and inputs.</p>
<ul>
<li><strong>encoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) \u2014 Last hidden states (final feature map) of the last stage of the encoder model (backbone).</li>
<li><strong>pixel_decoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) \u2014 Last hidden states (final feature map) of the last stage of the pixel decoder model (FPN).</li>
<li><strong>transformer_decoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Last hidden states (final feature map) of the last stage of the transformer decoder model.</li>
<li><strong>encoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the encoder
model at the output of each stage.</li>
<li><strong>pixel_decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the pixel
decoder model at the output of each stage.</li>
<li><strong>decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, sequence_length, hidden_size)</code>. Hidden-states (also called feature maps) of the
transformer decoder at the output of each stage.</li>
<li><strong>hidden_states</strong> <code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> containing <code>encoder_hidden_states</code>, <code>pixel_decoder_hidden_states</code> and
<code>decoder_hidden_states</code></li>
<li><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>. Attentions weights from Detr\u2019s decoder after the attention softmax, used to compute the
weighted average in the self-attention heads.</li>
</ul>
`}}),_e=new Ga({props:{$$slots:{default:[ci]},$$scope:{ctx:U}}}),st=new Qa({props:{code:`from transformers import MaskFormerFeatureExtractor, MaskFormerModel
import torch
from datasets import load_dataset

dataset = load_dataset("huggingface/cats-image")
image = dataset["test"]["image"][0]

feature_extractor = MaskFormerFeatureExtractor.from_pretrained("facebook/maskformer-swin-base-ade")
model = MaskFormerModel.from_pretrained("facebook/maskformer-swin-base-ade")

inputs = feature_extractor(image, return_tensors="pt")

with torch.no_grad():
    outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state
list(last_hidden_states.shape)
,`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> MaskFormerFeatureExtractor, MaskFormerModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

<span class="hljs-meta">&gt;&gt;&gt; </span>dataset = load_dataset(<span class="hljs-string">&quot;huggingface/cats-image&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>image = dataset[<span class="hljs-string">&quot;test&quot;</span>][<span class="hljs-string">&quot;image&quot;</span>][<span class="hljs-number">0</span>]

<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = MaskFormerFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;facebook/maskformer-swin-base-ade&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = MaskFormerModel.from_pretrained(<span class="hljs-string">&quot;facebook/maskformer-swin-base-ade&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = feature_extractor(image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> torch.no_grad():
<span class="hljs-meta">... </span>    outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(last_hidden_states.shape)
`}}),at=new lt({}),nt=new I({props:{name:"class transformers.MaskFormerForInstanceSegmentation",anchor:"transformers.MaskFormerForInstanceSegmentation",parameters:[{name:"config",val:": MaskFormerConfig"}],source:"https://github.com/huggingface/transformers/blob/pr_15682/src/transformers/models/maskformer/modeling_maskformer.py#L2336"}}),it=new I({props:{name:"forward",anchor:"transformers.MaskFormerForInstanceSegmentation.forward",parameters:[{name:"pixel_values",val:": Tensor"},{name:"mask_labels",val:": typing.Optional[torch.Tensor] = None"},{name:"class_labels",val:": typing.Optional[torch.Tensor] = None"},{name:"pixel_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"output_hidden_states",val:": typing.Optional[bool] = None"},{name:"output_attentions",val:": typing.Optional[bool] = None"},{name:"return_dict",val:": typing.Optional[bool] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_15682/src/transformers/models/maskformer/modeling_maskformer.py#L2413",parametersDescription:[{anchor:"transformers.MaskFormerForInstanceSegmentation.forward.pixel_values",description:`<strong>pixel_values</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) &#x2014;
Pixel values. Pixel values can be obtained using <a href="/docs/transformers/pr_15682/en/model_doc/auto#transformers.AutoFeatureExtractor">AutoFeatureExtractor</a>. See
<code>AutoFeatureExtractor.__call__()</code>for details.`,name:"pixel_values"},{anchor:"transformers.MaskFormerForInstanceSegmentation.forward.pixel_mask",description:`<strong>pixel_mask</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, height, width)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding pixel values. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for pixels that are real (i.e. <strong>not masked</strong>),</li>
<li>0 for pixels that are padding (i.e. <strong>masked</strong>).</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"pixel_mask"},{anchor:"transformers.MaskFormerForInstanceSegmentation.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.MaskFormerForInstanceSegmentation.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of Detr&#x2019;s decoder attention layers.`,name:"output_attentions"},{anchor:"transformers.MaskFormerForInstanceSegmentation.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <code>~MaskFormerModelOutput</code> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.MaskFormerForInstanceSegmentation.forward.mask_labels",description:`<strong>mask_labels</strong> (<code>torch.FloatTensor</code>, <em>optional</em>) &#x2014;
The target mask of shape <code>(num_classes, height, width)</code>.`,name:"mask_labels"},{anchor:"transformers.MaskFormerForInstanceSegmentation.forward.class_labels",description:`<strong>class_labels</strong> (<code>torch.LongTensor</code>, <em>optional</em>) &#x2014;
The target labels of shape <code>(num_classes)</code>.`,name:"class_labels"}],returnDescription:`
<p>A <a
  href="/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput"
>transformers.models.maskformer.modeling_maskformer.MaskFormerForInstanceSegmentationOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerConfig"
>MaskFormerConfig</a>) and inputs.</p>
<ul>
<li><strong>loss</strong> (<code>torch.Tensor</code>, <em>optional</em>) \u2014 The computed loss, returned when labels are present.</li>
<li><strong>class_queries_logits</strong> (<code>torch.FloatTensor</code>) \u2014 A tensor of shape <code>(batch_size, num_queries, height, width)</code> representing the proposed masks for each
query.</li>
<li><strong>masks_queries_logits</strong> (<code>torch.FloatTensor</code>) \u2014 A tensor of shape <code>(batch_size, num_queries, num_classes + 1)</code> representing the proposed classes for each
query. Note the <code>+ 1</code> is needed because we incorporate the null class.</li>
<li><strong>encoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) \u2014 Last hidden states (final feature map) of the last stage of the encoder model (backbone).</li>
<li><strong>pixel_decoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, num_channels, height, width)</code>) \u2014 Last hidden states (final feature map) of the last stage of the pixel decoder model (FPN).</li>
<li><strong>transformer_decoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Last hidden states (final feature map) of the last stage of the transformer decoder model.</li>
<li><strong>encoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the encoder
model at the output of each stage.</li>
<li><strong>pixel_decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, num_channels, height, width)</code>. Hidden-states (also called feature maps) of the pixel
decoder model at the output of each stage.</li>
<li><strong>decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each stage) of
shape <code>(batch_size, sequence_length, hidden_size)</code>. Hidden-states (also called feature maps) of the
transformer decoder at the output of each stage.</li>
<li><strong>hidden_states</strong> <code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> containing <code>encoder_hidden_states</code>, <code>pixel_decoder_hidden_states</code> and
<code>decoder_hidden_states</code>.</li>
<li><strong>attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>. Attentions weights from Detr\u2019s decoder after the attention softmax, used to compute the
weighted average in the self-attention heads.</li>
</ul>
`}}),Fe=new Ga({props:{$$slots:{default:[li]},$$scope:{ctx:U}}}),dt=new Qa({props:{code:`from transformers import MaskFormerFeatureExtractor, MaskFormerForInstanceSegmentation
from PIL import Image
import requests

url = "http://images.cocodataset.org/val2017/000000039769.jpg"
image = Image.open(requests.get(url, stream=True).raw)
feature_extractor = MaskFormerFeatureExtractor.from_pretrained("facebook/maskformer-swin-base-ade")
inputs = feature_extractor(images=image, return_tensors="pt")

model = MaskFormerForInstanceSegmentation.from_pretrained("facebook/maskformer-swin-base-ade")
outputs = model(**inputs)
# model predicts class_queries_logits of shape \`(batch_size, num_queries)\`
# and masks_queries_logits of shape \`(batch_size, num_queries, height, width)\`
class_queries_logits = outputs.class_queries_logits
masks_queries_logits = outputs.masks_queries_logits

# you can pass them to feature_extractor for postprocessing
output = feature_extractor.post_process_segmentation(outputs)
output = feature_extractor.post_process_semantic_segmentation(outputs)

output = feature_extractor.post_process_panoptic_segmentation(outputs),`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> MaskFormerFeatureExtractor, MaskFormerForInstanceSegmentation
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> requests

<span class="hljs-meta">&gt;&gt;&gt; </span>url = <span class="hljs-string">&quot;http://images.cocodataset.org/val2017/000000039769.jpg&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>image = Image.<span class="hljs-built_in">open</span>(requests.get(url, stream=<span class="hljs-literal">True</span>).raw)
<span class="hljs-meta">&gt;&gt;&gt; </span>feature_extractor = MaskFormerFeatureExtractor.from_pretrained(<span class="hljs-string">&quot;facebook/maskformer-swin-base-ade&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = feature_extractor(images=image, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>model = MaskFormerForInstanceSegmentation.from_pretrained(<span class="hljs-string">&quot;facebook/maskformer-swin-base-ade&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># model predicts class_queries_logits of shape \`(batch_size, num_queries)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># and masks_queries_logits of shape \`(batch_size, num_queries, height, width)\`</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>class_queries_logits = outputs.class_queries_logits
<span class="hljs-meta">&gt;&gt;&gt; </span>masks_queries_logits = outputs.masks_queries_logits

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># you can pass them to feature_extractor for postprocessing</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>output = feature_extractor.post_process_segmentation(outputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>output = feature_extractor.post_process_semantic_segmentation(outputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>output = feature_extractor.post_process_panoptic_segmentation(outputs)`}}),{c(){p=r("meta"),T=c(),f=r("h1"),b=r("a"),z=r("span"),u(M.$$.fragment),y=c(),D=r("span"),lr=n("MaskFormer"),ko=c(),R=r("h2"),se=r("a"),qt=r("span"),u(we.$$.fragment),mr=c(),Nt=r("span"),hr=n("Overview"),Fo=c(),ae=r("p"),pr=n("The MaskFormer model was proposed in "),xe=r("a"),fr=n("Per-Pixel Classification is Not All You Need for Semantic Segmentation"),ur=n(" by Bowen Cheng, Alexander G. Schwing, Alexander Kirillov. MaskFormer addresses semantic segmentation with a mask classification paradigm instead of performing classic pixel-level classification."),vo=c(),mt=r("p"),gr=n("The abstract from the paper is the following:"),bo=c(),ht=r("p"),Lt=r("em"),_r=n("Modern approaches typically formulate semantic segmentation as a per-pixel classification task, while instance-level segmentation is handled with an alternative mask classification. Our key insight: mask classification is sufficiently general to solve both semantic- and instance-level segmentation tasks in a unified manner using the exact same model, loss, and training procedure. Following this observation, we propose MaskFormer, a simple mask classification model which predicts a set of binary masks, each associated with a single global class label prediction. Overall, the proposed mask classification-based method simplifies the landscape of effective approaches to semantic and panoptic segmentation tasks and shows excellent empirical results. In particular, we observe that MaskFormer outperforms per-pixel classification baselines when the number of classes is large. Our mask classification-based method outperforms both current state-of-the-art semantic (55.6 mIoU on ADE20K) and panoptic segmentation (52.7 PQ on COCO) models."),wo=c(),pt=r("p"),kr=n("Tips:"),xo=c(),S=r("ul"),j=r("li"),Fr=n(`During training, the authors of DETR did find it helpful to use auxiliary losses in the decoder, especially to help
the model output the correct number of objects of each class. If you set the parameter `),Ht=r("code"),vr=n("use_auxilary_loss"),br=n(` of
`),ft=r("a"),wr=n("MaskFormerConfig"),xr=n(" to "),Wt=r("code"),Mr=n("True"),Tr=n(`, then prediction feedforward neural networks and Hungarian losses
are added after each decoder layer (with the FFNs sharing parameters).`),yr=c(),C=r("li"),$r=n(`If you want to train the model in a distributed environment across multiple nodes, then one should update the
`),Vt=r("code"),Er=n("get_num_masks"),Ir=n(" function inside in the "),Ut=r("code"),Or=n("MaskFormerLoss"),Pr=n(" class of "),Rt=r("code"),zr=n("modeling_maskformer.py"),Cr=n(`. When training on multiple nodes, this should be
set to the average number of target masks across all nodes, as can be seen in the original implementation `),Me=r("a"),Sr=n("here"),Dr=n("."),jr=c(),Te=r("li"),Ar=n("One can use "),ut=r("a"),qr=n("MaskFormerFeatureExtractor"),Nr=n(" to prepare images for the model."),Lr=c(),B=r("li"),Hr=n("To get the final segmentation, depending on the task, you can call "),gt=r("a"),Wr=n("post_process_semantic_segmentation()"),Vr=n(" or "),_t=r("a"),Ur=n("post_process_panoptic_segmentation()"),Rr=n("."),Mo=c(),N=r("p"),Br=n("This model was contributed by "),ye=r("a"),Kr=n("francesco"),Gr=n(". The original code can be found "),$e=r("a"),Qr=n("here"),Yr=n("."),To=c(),K=r("h2"),ne=r("a"),Bt=r("span"),u(Ee.$$.fragment),Jr=c(),Kt=r("span"),Xr=n("MaskFormer specific outputs"),yo=c(),G=r("div"),u(Ie.$$.fragment),Zr=c(),Oe=r("p"),es=n("Class for outputs of "),kt=r("a"),ts=n("MaskFormerModel"),os=n(". This class returns all the needed hidden states to compute the logits."),$o=c(),A=r("div"),u(Pe.$$.fragment),rs=c(),ze=r("p"),ss=n("Class for outputs of "),Ft=r("a"),as=n("MaskFormerForInstanceSegmentation"),ns=n("."),is=c(),Q=r("p"),ds=n("This output can be directly passed to "),vt=r("a"),cs=n("post_process_segmentation()"),ls=n(` or
`),bt=r("a"),ms=n("post_process_panoptic_segmentation()"),hs=n(" depending on the task. Please, see\n[`~MaskFormerFeatureExtractor] for details regarding usage."),Eo=c(),Y=r("h2"),ie=r("a"),Gt=r("span"),u(Ce.$$.fragment),ps=c(),Qt=r("span"),fs=n("MaskFormerConfig"),Io=c(),w=r("div"),u(Se.$$.fragment),us=c(),De=r("p"),gs=n("This is the configuration class to store the configuration of a "),Yt=r("code"),_s=n("MaskFormer"),ks=n(`. It is used to instantiate a
MaskFormer model according to the specified arguments, defining the model architecture. Instantiating a
configuration with the defaults will yield a similar configuration to that of the
\u201CFrancesco/maskformer-swin-base-ade\u201D architecture trained on ADE20k-150`),Fs=c(),J=r("p"),vs=n("Configuration objects inherit from "),wt=r("a"),bs=n("PretrainedConfig"),ws=n(` and can be used to control the model outputs. Read the
documentation from `),xt=r("a"),xs=n("PretrainedConfig"),Ms=n(" for more information."),Ts=c(),Jt=r("p"),ys=n("Currently, maskformer supports only Swin backbone."),$s=c(),Xt=r("p"),Es=n("Examples:"),Is=c(),u(je.$$.fragment),Os=c(),de=r("div"),u(Ae.$$.fragment),Ps=c(),qe=r("p"),zs=n("Instantiate a "),Mt=r("a"),Cs=n("MaskFormerConfig"),Ss=n(` (or a derived class) from a pre-trained backbone model configuration and DETR model
configuration.`),Ds=c(),ce=r("div"),u(Ne.$$.fragment),js=c(),Le=r("p"),As=n("Serializes this instance to a Python dictionary. Override the default "),Tt=r("a"),qs=n("to_dict()"),Ns=n("."),Oo=c(),X=r("h2"),le=r("a"),Zt=r("span"),u(He.$$.fragment),Ls=c(),eo=r("span"),Hs=n("MaskFormerFeatureExtractor"),Po=c(),x=r("div"),u(We.$$.fragment),Ws=c(),to=r("p"),Vs=n("Constructs a MaskFormer feature extractor."),Us=c(),Ve=r("p"),Rs=n("This feature extractor inherits from "),yt=r("a"),Bs=n("FeatureExtractionMixin"),Ks=n(` which contains most of the main methods. Users
should refer to this superclass for more information regarding those methods.`),Gs=c(),L=r("div"),u(Ue.$$.fragment),Qs=c(),oo=r("p"),Ys=n(`Main method to prepare for the model one or several image(s) and optional annotations. Images are by default
padded up to the largest image in a batch, and a pixel mask is created that indicates which pixels are
real/which are padding.`),Js=c(),u(me.$$.fragment),Xs=c(),he=r("div"),u(Re.$$.fragment),Zs=c(),Be=r("p"),ea=n("Pad images up to the largest image in a batch and create a corresponding "),ro=r("code"),ta=n("pixel_mask"),oa=n("."),ra=c(),pe=r("div"),u(Ke.$$.fragment),sa=c(),Ge=r("p"),aa=n("Converts the output of "),so=r("code"),na=n("MaskFormerForInstanceSegmentationOutput"),ia=n(` into image segmentation predictions. Only
supports PyTorch.`),da=c(),fe=r("div"),u(Qe.$$.fragment),ca=c(),Ye=r("p"),la=n("Converts the output of "),ao=r("code"),ma=n("MaskFormerForInstanceSegmentationOutput"),ha=n(` into semantic segmentation predictions. Only
supports PyTorch.`),pa=c(),ue=r("div"),u(Je.$$.fragment),fa=c(),Xe=r("p"),ua=n("Converts the output of "),no=r("code"),ga=n("MaskFormerForInstanceSegmentationOutput"),_a=n(` into image panoptic segmentation
predictions. Only supports PyTorch.`),zo=c(),Z=r("h2"),ge=r("a"),io=r("span"),u(Ze.$$.fragment),ka=c(),co=r("span"),Fa=n("MaskFormerModel"),Co=c(),q=r("div"),u(et.$$.fragment),va=c(),tt=r("p"),ba=n(`The bare MaskFormer Model outputting raw hidden-states without any specific head on top.
This model is a PyTorch `),ot=r("a"),wa=n("torch.nn.Module"),xa=n(` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),Ma=c(),O=r("div"),u(rt.$$.fragment),Ta=c(),ee=r("p"),ya=n("The "),$t=r("a"),$a=n("MaskFormerModel"),Ea=n(" forward method, overrides the "),lo=r("code"),Ia=n("__call__"),Oa=n(" special method."),Pa=c(),u(_e.$$.fragment),za=c(),mo=r("p"),Ca=n("Example:"),Sa=c(),u(st.$$.fragment),So=c(),te=r("h2"),ke=r("a"),ho=r("span"),u(at.$$.fragment),Da=c(),po=r("span"),ja=n("MaskFormerForInstanceSegmentation"),Do=c(),oe=r("div"),u(nt.$$.fragment),Aa=c(),P=r("div"),u(it.$$.fragment),qa=c(),re=r("p"),Na=n("The "),Et=r("a"),La=n("MaskFormerForInstanceSegmentation"),Ha=n(" forward method, overrides the "),fo=r("code"),Wa=n("__call__"),Va=n(" special method."),Ua=c(),u(Fe.$$.fragment),Ra=c(),uo=r("p"),Ba=n("Examples:"),Ka=c(),u(dt.$$.fragment),this.h()},l(t){const m=ii('[data-svelte="svelte-1phssyn"]',document.head);p=s(m,"META",{name:!0,content:!0}),m.forEach(o),T=l(t),f=s(t,"H1",{class:!0});var ct=a(f);b=s(ct,"A",{id:!0,class:!0,href:!0});var go=a(b);z=s(go,"SPAN",{});var _o=a(z);g(M.$$.fragment,_o),_o.forEach(o),go.forEach(o),y=l(ct),D=s(ct,"SPAN",{});var Ya=a(D);lr=i(Ya,"MaskFormer"),Ya.forEach(o),ct.forEach(o),ko=l(t),R=s(t,"H2",{class:!0});var Ao=a(R);se=s(Ao,"A",{id:!0,class:!0,href:!0});var Ja=a(se);qt=s(Ja,"SPAN",{});var Xa=a(qt);g(we.$$.fragment,Xa),Xa.forEach(o),Ja.forEach(o),mr=l(Ao),Nt=s(Ao,"SPAN",{});var Za=a(Nt);hr=i(Za,"Overview"),Za.forEach(o),Ao.forEach(o),Fo=l(t),ae=s(t,"P",{});var qo=a(ae);pr=i(qo,"The MaskFormer model was proposed in "),xe=s(qo,"A",{href:!0,rel:!0});var en=a(xe);fr=i(en,"Per-Pixel Classification is Not All You Need for Semantic Segmentation"),en.forEach(o),ur=i(qo," by Bowen Cheng, Alexander G. Schwing, Alexander Kirillov. MaskFormer addresses semantic segmentation with a mask classification paradigm instead of performing classic pixel-level classification."),qo.forEach(o),vo=l(t),mt=s(t,"P",{});var tn=a(mt);gr=i(tn,"The abstract from the paper is the following:"),tn.forEach(o),bo=l(t),ht=s(t,"P",{});var on=a(ht);Lt=s(on,"EM",{});var rn=a(Lt);_r=i(rn,"Modern approaches typically formulate semantic segmentation as a per-pixel classification task, while instance-level segmentation is handled with an alternative mask classification. Our key insight: mask classification is sufficiently general to solve both semantic- and instance-level segmentation tasks in a unified manner using the exact same model, loss, and training procedure. Following this observation, we propose MaskFormer, a simple mask classification model which predicts a set of binary masks, each associated with a single global class label prediction. Overall, the proposed mask classification-based method simplifies the landscape of effective approaches to semantic and panoptic segmentation tasks and shows excellent empirical results. In particular, we observe that MaskFormer outperforms per-pixel classification baselines when the number of classes is large. Our mask classification-based method outperforms both current state-of-the-art semantic (55.6 mIoU on ADE20K) and panoptic segmentation (52.7 PQ on COCO) models."),rn.forEach(o),on.forEach(o),wo=l(t),pt=s(t,"P",{});var sn=a(pt);kr=i(sn,"Tips:"),sn.forEach(o),xo=l(t),S=s(t,"UL",{});var ve=a(S);j=s(ve,"LI",{});var be=a(j);Fr=i(be,`During training, the authors of DETR did find it helpful to use auxiliary losses in the decoder, especially to help
the model output the correct number of objects of each class. If you set the parameter `),Ht=s(be,"CODE",{});var an=a(Ht);vr=i(an,"use_auxilary_loss"),an.forEach(o),br=i(be,` of
`),ft=s(be,"A",{href:!0});var nn=a(ft);wr=i(nn,"MaskFormerConfig"),nn.forEach(o),xr=i(be," to "),Wt=s(be,"CODE",{});var dn=a(Wt);Mr=i(dn,"True"),dn.forEach(o),Tr=i(be,`, then prediction feedforward neural networks and Hungarian losses
are added after each decoder layer (with the FFNs sharing parameters).`),be.forEach(o),yr=l(ve),C=s(ve,"LI",{});var H=a(C);$r=i(H,`If you want to train the model in a distributed environment across multiple nodes, then one should update the
`),Vt=s(H,"CODE",{});var cn=a(Vt);Er=i(cn,"get_num_masks"),cn.forEach(o),Ir=i(H," function inside in the "),Ut=s(H,"CODE",{});var ln=a(Ut);Or=i(ln,"MaskFormerLoss"),ln.forEach(o),Pr=i(H," class of "),Rt=s(H,"CODE",{});var mn=a(Rt);zr=i(mn,"modeling_maskformer.py"),mn.forEach(o),Cr=i(H,`. When training on multiple nodes, this should be
set to the average number of target masks across all nodes, as can be seen in the original implementation `),Me=s(H,"A",{href:!0,rel:!0});var hn=a(Me);Sr=i(hn,"here"),hn.forEach(o),Dr=i(H,"."),H.forEach(o),jr=l(ve),Te=s(ve,"LI",{});var No=a(Te);Ar=i(No,"One can use "),ut=s(No,"A",{href:!0});var pn=a(ut);qr=i(pn,"MaskFormerFeatureExtractor"),pn.forEach(o),Nr=i(No," to prepare images for the model."),No.forEach(o),Lr=l(ve),B=s(ve,"LI",{});var It=a(B);Hr=i(It,"To get the final segmentation, depending on the task, you can call "),gt=s(It,"A",{href:!0});var fn=a(gt);Wr=i(fn,"post_process_semantic_segmentation()"),fn.forEach(o),Vr=i(It," or "),_t=s(It,"A",{href:!0});var un=a(_t);Ur=i(un,"post_process_panoptic_segmentation()"),un.forEach(o),Rr=i(It,"."),It.forEach(o),ve.forEach(o),Mo=l(t),N=s(t,"P",{});var Ot=a(N);Br=i(Ot,"This model was contributed by "),ye=s(Ot,"A",{href:!0,rel:!0});var gn=a(ye);Kr=i(gn,"francesco"),gn.forEach(o),Gr=i(Ot,". The original code can be found "),$e=s(Ot,"A",{href:!0,rel:!0});var _n=a($e);Qr=i(_n,"here"),_n.forEach(o),Yr=i(Ot,"."),Ot.forEach(o),To=l(t),K=s(t,"H2",{class:!0});var Lo=a(K);ne=s(Lo,"A",{id:!0,class:!0,href:!0});var kn=a(ne);Bt=s(kn,"SPAN",{});var Fn=a(Bt);g(Ee.$$.fragment,Fn),Fn.forEach(o),kn.forEach(o),Jr=l(Lo),Kt=s(Lo,"SPAN",{});var vn=a(Kt);Xr=i(vn,"MaskFormer specific outputs"),vn.forEach(o),Lo.forEach(o),yo=l(t),G=s(t,"DIV",{class:!0});var Ho=a(G);g(Ie.$$.fragment,Ho),Zr=l(Ho),Oe=s(Ho,"P",{});var Wo=a(Oe);es=i(Wo,"Class for outputs of "),kt=s(Wo,"A",{href:!0});var bn=a(kt);ts=i(bn,"MaskFormerModel"),bn.forEach(o),os=i(Wo,". This class returns all the needed hidden states to compute the logits."),Wo.forEach(o),Ho.forEach(o),$o=l(t),A=s(t,"DIV",{class:!0});var Pt=a(A);g(Pe.$$.fragment,Pt),rs=l(Pt),ze=s(Pt,"P",{});var Vo=a(ze);ss=i(Vo,"Class for outputs of "),Ft=s(Vo,"A",{href:!0});var wn=a(Ft);as=i(wn,"MaskFormerForInstanceSegmentation"),wn.forEach(o),ns=i(Vo,"."),Vo.forEach(o),is=l(Pt),Q=s(Pt,"P",{});var zt=a(Q);ds=i(zt,"This output can be directly passed to "),vt=s(zt,"A",{href:!0});var xn=a(vt);cs=i(xn,"post_process_segmentation()"),xn.forEach(o),ls=i(zt,` or
`),bt=s(zt,"A",{href:!0});var Mn=a(bt);ms=i(Mn,"post_process_panoptic_segmentation()"),Mn.forEach(o),hs=i(zt," depending on the task. Please, see\n[`~MaskFormerFeatureExtractor] for details regarding usage."),zt.forEach(o),Pt.forEach(o),Eo=l(t),Y=s(t,"H2",{class:!0});var Uo=a(Y);ie=s(Uo,"A",{id:!0,class:!0,href:!0});var Tn=a(ie);Gt=s(Tn,"SPAN",{});var yn=a(Gt);g(Ce.$$.fragment,yn),yn.forEach(o),Tn.forEach(o),ps=l(Uo),Qt=s(Uo,"SPAN",{});var $n=a(Qt);fs=i($n,"MaskFormerConfig"),$n.forEach(o),Uo.forEach(o),Io=l(t),w=s(t,"DIV",{class:!0});var $=a(w);g(Se.$$.fragment,$),us=l($),De=s($,"P",{});var Ro=a(De);gs=i(Ro,"This is the configuration class to store the configuration of a "),Yt=s(Ro,"CODE",{});var En=a(Yt);_s=i(En,"MaskFormer"),En.forEach(o),ks=i(Ro,`. It is used to instantiate a
MaskFormer model according to the specified arguments, defining the model architecture. Instantiating a
configuration with the defaults will yield a similar configuration to that of the
\u201CFrancesco/maskformer-swin-base-ade\u201D architecture trained on ADE20k-150`),Ro.forEach(o),Fs=l($),J=s($,"P",{});var Ct=a(J);vs=i(Ct,"Configuration objects inherit from "),wt=s(Ct,"A",{href:!0});var In=a(wt);bs=i(In,"PretrainedConfig"),In.forEach(o),ws=i(Ct,` and can be used to control the model outputs. Read the
documentation from `),xt=s(Ct,"A",{href:!0});var On=a(xt);xs=i(On,"PretrainedConfig"),On.forEach(o),Ms=i(Ct," for more information."),Ct.forEach(o),Ts=l($),Jt=s($,"P",{});var Pn=a(Jt);ys=i(Pn,"Currently, maskformer supports only Swin backbone."),Pn.forEach(o),$s=l($),Xt=s($,"P",{});var zn=a(Xt);Es=i(zn,"Examples:"),zn.forEach(o),Is=l($),g(je.$$.fragment,$),Os=l($),de=s($,"DIV",{class:!0});var Bo=a(de);g(Ae.$$.fragment,Bo),Ps=l(Bo),qe=s(Bo,"P",{});var Ko=a(qe);zs=i(Ko,"Instantiate a "),Mt=s(Ko,"A",{href:!0});var Cn=a(Mt);Cs=i(Cn,"MaskFormerConfig"),Cn.forEach(o),Ss=i(Ko,` (or a derived class) from a pre-trained backbone model configuration and DETR model
configuration.`),Ko.forEach(o),Bo.forEach(o),Ds=l($),ce=s($,"DIV",{class:!0});var Go=a(ce);g(Ne.$$.fragment,Go),js=l(Go),Le=s(Go,"P",{});var Qo=a(Le);As=i(Qo,"Serializes this instance to a Python dictionary. Override the default "),Tt=s(Qo,"A",{href:!0});var Sn=a(Tt);qs=i(Sn,"to_dict()"),Sn.forEach(o),Ns=i(Qo,"."),Qo.forEach(o),Go.forEach(o),$.forEach(o),Oo=l(t),X=s(t,"H2",{class:!0});var Yo=a(X);le=s(Yo,"A",{id:!0,class:!0,href:!0});var Dn=a(le);Zt=s(Dn,"SPAN",{});var jn=a(Zt);g(He.$$.fragment,jn),jn.forEach(o),Dn.forEach(o),Ls=l(Yo),eo=s(Yo,"SPAN",{});var An=a(eo);Hs=i(An,"MaskFormerFeatureExtractor"),An.forEach(o),Yo.forEach(o),Po=l(t),x=s(t,"DIV",{class:!0});var E=a(x);g(We.$$.fragment,E),Ws=l(E),to=s(E,"P",{});var qn=a(to);Vs=i(qn,"Constructs a MaskFormer feature extractor."),qn.forEach(o),Us=l(E),Ve=s(E,"P",{});var Jo=a(Ve);Rs=i(Jo,"This feature extractor inherits from "),yt=s(Jo,"A",{href:!0});var Nn=a(yt);Bs=i(Nn,"FeatureExtractionMixin"),Nn.forEach(o),Ks=i(Jo,` which contains most of the main methods. Users
should refer to this superclass for more information regarding those methods.`),Jo.forEach(o),Gs=l(E),L=s(E,"DIV",{class:!0});var St=a(L);g(Ue.$$.fragment,St),Qs=l(St),oo=s(St,"P",{});var Ln=a(oo);Ys=i(Ln,`Main method to prepare for the model one or several image(s) and optional annotations. Images are by default
padded up to the largest image in a batch, and a pixel mask is created that indicates which pixels are
real/which are padding.`),Ln.forEach(o),Js=l(St),g(me.$$.fragment,St),St.forEach(o),Xs=l(E),he=s(E,"DIV",{class:!0});var Xo=a(he);g(Re.$$.fragment,Xo),Zs=l(Xo),Be=s(Xo,"P",{});var Zo=a(Be);ea=i(Zo,"Pad images up to the largest image in a batch and create a corresponding "),ro=s(Zo,"CODE",{});var Hn=a(ro);ta=i(Hn,"pixel_mask"),Hn.forEach(o),oa=i(Zo,"."),Zo.forEach(o),Xo.forEach(o),ra=l(E),pe=s(E,"DIV",{class:!0});var er=a(pe);g(Ke.$$.fragment,er),sa=l(er),Ge=s(er,"P",{});var tr=a(Ge);aa=i(tr,"Converts the output of "),so=s(tr,"CODE",{});var Wn=a(so);na=i(Wn,"MaskFormerForInstanceSegmentationOutput"),Wn.forEach(o),ia=i(tr,` into image segmentation predictions. Only
supports PyTorch.`),tr.forEach(o),er.forEach(o),da=l(E),fe=s(E,"DIV",{class:!0});var or=a(fe);g(Qe.$$.fragment,or),ca=l(or),Ye=s(or,"P",{});var rr=a(Ye);la=i(rr,"Converts the output of "),ao=s(rr,"CODE",{});var Vn=a(ao);ma=i(Vn,"MaskFormerForInstanceSegmentationOutput"),Vn.forEach(o),ha=i(rr,` into semantic segmentation predictions. Only
supports PyTorch.`),rr.forEach(o),or.forEach(o),pa=l(E),ue=s(E,"DIV",{class:!0});var sr=a(ue);g(Je.$$.fragment,sr),fa=l(sr),Xe=s(sr,"P",{});var ar=a(Xe);ua=i(ar,"Converts the output of "),no=s(ar,"CODE",{});var Un=a(no);ga=i(Un,"MaskFormerForInstanceSegmentationOutput"),Un.forEach(o),_a=i(ar,` into image panoptic segmentation
predictions. Only supports PyTorch.`),ar.forEach(o),sr.forEach(o),E.forEach(o),zo=l(t),Z=s(t,"H2",{class:!0});var nr=a(Z);ge=s(nr,"A",{id:!0,class:!0,href:!0});var Rn=a(ge);io=s(Rn,"SPAN",{});var Bn=a(io);g(Ze.$$.fragment,Bn),Bn.forEach(o),Rn.forEach(o),ka=l(nr),co=s(nr,"SPAN",{});var Kn=a(co);Fa=i(Kn,"MaskFormerModel"),Kn.forEach(o),nr.forEach(o),Co=l(t),q=s(t,"DIV",{class:!0});var Dt=a(q);g(et.$$.fragment,Dt),va=l(Dt),tt=s(Dt,"P",{});var ir=a(tt);ba=i(ir,`The bare MaskFormer Model outputting raw hidden-states without any specific head on top.
This model is a PyTorch `),ot=s(ir,"A",{href:!0,rel:!0});var Gn=a(ot);wa=i(Gn,"torch.nn.Module"),Gn.forEach(o),xa=i(ir,` sub-class. Use
it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage and
behavior.`),ir.forEach(o),Ma=l(Dt),O=s(Dt,"DIV",{class:!0});var W=a(O);g(rt.$$.fragment,W),Ta=l(W),ee=s(W,"P",{});var jt=a(ee);ya=i(jt,"The "),$t=s(jt,"A",{href:!0});var Qn=a($t);$a=i(Qn,"MaskFormerModel"),Qn.forEach(o),Ea=i(jt," forward method, overrides the "),lo=s(jt,"CODE",{});var Yn=a(lo);Ia=i(Yn,"__call__"),Yn.forEach(o),Oa=i(jt," special method."),jt.forEach(o),Pa=l(W),g(_e.$$.fragment,W),za=l(W),mo=s(W,"P",{});var Jn=a(mo);Ca=i(Jn,"Example:"),Jn.forEach(o),Sa=l(W),g(st.$$.fragment,W),W.forEach(o),Dt.forEach(o),So=l(t),te=s(t,"H2",{class:!0});var dr=a(te);ke=s(dr,"A",{id:!0,class:!0,href:!0});var Xn=a(ke);ho=s(Xn,"SPAN",{});var Zn=a(ho);g(at.$$.fragment,Zn),Zn.forEach(o),Xn.forEach(o),Da=l(dr),po=s(dr,"SPAN",{});var ei=a(po);ja=i(ei,"MaskFormerForInstanceSegmentation"),ei.forEach(o),dr.forEach(o),Do=l(t),oe=s(t,"DIV",{class:!0});var cr=a(oe);g(nt.$$.fragment,cr),Aa=l(cr),P=s(cr,"DIV",{class:!0});var V=a(P);g(it.$$.fragment,V),qa=l(V),re=s(V,"P",{});var At=a(re);Na=i(At,"The "),Et=s(At,"A",{href:!0});var ti=a(Et);La=i(ti,"MaskFormerForInstanceSegmentation"),ti.forEach(o),Ha=i(At," forward method, overrides the "),fo=s(At,"CODE",{});var oi=a(fo);Wa=i(oi,"__call__"),oi.forEach(o),Va=i(At," special method."),At.forEach(o),Ua=l(V),g(Fe.$$.fragment,V),Ra=l(V),uo=s(V,"P",{});var ri=a(uo);Ba=i(ri,"Examples:"),ri.forEach(o),Ka=l(V),g(dt.$$.fragment,V),V.forEach(o),cr.forEach(o),this.h()},h(){d(p,"name","hf:doc:metadata"),d(p,"content",JSON.stringify(hi)),d(b,"id","maskformer"),d(b,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(b,"href","#maskformer"),d(f,"class","relative group"),d(se,"id","overview"),d(se,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(se,"href","#overview"),d(R,"class","relative group"),d(xe,"href","https://arxiv.org/abs/2107.06278"),d(xe,"rel","nofollow"),d(ft,"href","/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerConfig"),d(Me,"href","https://github.com/facebookresearch/MaskFormer/blob/da3e60d85fdeedcb31476b5edd7d328826ce56cc/mask_former/modeling/criterion.py#L169"),d(Me,"rel","nofollow"),d(ut,"href","/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerFeatureExtractor"),d(gt,"href","/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerFeatureExtractor.post_process_semantic_segmentation"),d(_t,"href","/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerFeatureExtractor.post_process_panoptic_segmentation"),d(ye,"href","https://huggingface.co/francesco"),d(ye,"rel","nofollow"),d($e,"href","https://github.com/facebookresearch/MaskFormer"),d($e,"rel","nofollow"),d(ne,"id","transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput"),d(ne,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(ne,"href","#transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput"),d(K,"class","relative group"),d(kt,"href","/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerModel"),d(G,"class","docstring"),d(Ft,"href","/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerForInstanceSegmentation"),d(vt,"href","/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerFeatureExtractor.post_process_segmentation"),d(bt,"href","/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerFeatureExtractor.post_process_panoptic_segmentation"),d(A,"class","docstring"),d(ie,"id","transformers.MaskFormerConfig"),d(ie,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(ie,"href","#transformers.MaskFormerConfig"),d(Y,"class","relative group"),d(wt,"href","/docs/transformers/pr_15682/en/main_classes/configuration#transformers.PretrainedConfig"),d(xt,"href","/docs/transformers/pr_15682/en/main_classes/configuration#transformers.PretrainedConfig"),d(Mt,"href","/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerConfig"),d(de,"class","docstring"),d(Tt,"href","/docs/transformers/pr_15682/en/main_classes/configuration#transformers.PretrainedConfig.to_dict"),d(ce,"class","docstring"),d(w,"class","docstring"),d(le,"id","transformers.MaskFormerFeatureExtractor"),d(le,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(le,"href","#transformers.MaskFormerFeatureExtractor"),d(X,"class","relative group"),d(yt,"href","/docs/transformers/pr_15682/en/main_classes/feature_extractor#transformers.FeatureExtractionMixin"),d(L,"class","docstring"),d(he,"class","docstring"),d(pe,"class","docstring"),d(fe,"class","docstring"),d(ue,"class","docstring"),d(x,"class","docstring"),d(ge,"id","transformers.MaskFormerModel"),d(ge,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(ge,"href","#transformers.MaskFormerModel"),d(Z,"class","relative group"),d(ot,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),d(ot,"rel","nofollow"),d($t,"href","/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerModel"),d(O,"class","docstring"),d(q,"class","docstring"),d(ke,"id","transformers.MaskFormerForInstanceSegmentation"),d(ke,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),d(ke,"href","#transformers.MaskFormerForInstanceSegmentation"),d(te,"class","relative group"),d(Et,"href","/docs/transformers/pr_15682/en/model_doc/maskformer#transformers.MaskFormerForInstanceSegmentation"),d(P,"class","docstring"),d(oe,"class","docstring")},m(t,m){e(document.head,p),h(t,T,m),h(t,f,m),e(f,b),e(b,z),_(M,z,null),e(f,y),e(f,D),e(D,lr),h(t,ko,m),h(t,R,m),e(R,se),e(se,qt),_(we,qt,null),e(R,mr),e(R,Nt),e(Nt,hr),h(t,Fo,m),h(t,ae,m),e(ae,pr),e(ae,xe),e(xe,fr),e(ae,ur),h(t,vo,m),h(t,mt,m),e(mt,gr),h(t,bo,m),h(t,ht,m),e(ht,Lt),e(Lt,_r),h(t,wo,m),h(t,pt,m),e(pt,kr),h(t,xo,m),h(t,S,m),e(S,j),e(j,Fr),e(j,Ht),e(Ht,vr),e(j,br),e(j,ft),e(ft,wr),e(j,xr),e(j,Wt),e(Wt,Mr),e(j,Tr),e(S,yr),e(S,C),e(C,$r),e(C,Vt),e(Vt,Er),e(C,Ir),e(C,Ut),e(Ut,Or),e(C,Pr),e(C,Rt),e(Rt,zr),e(C,Cr),e(C,Me),e(Me,Sr),e(C,Dr),e(S,jr),e(S,Te),e(Te,Ar),e(Te,ut),e(ut,qr),e(Te,Nr),e(S,Lr),e(S,B),e(B,Hr),e(B,gt),e(gt,Wr),e(B,Vr),e(B,_t),e(_t,Ur),e(B,Rr),h(t,Mo,m),h(t,N,m),e(N,Br),e(N,ye),e(ye,Kr),e(N,Gr),e(N,$e),e($e,Qr),e(N,Yr),h(t,To,m),h(t,K,m),e(K,ne),e(ne,Bt),_(Ee,Bt,null),e(K,Jr),e(K,Kt),e(Kt,Xr),h(t,yo,m),h(t,G,m),_(Ie,G,null),e(G,Zr),e(G,Oe),e(Oe,es),e(Oe,kt),e(kt,ts),e(Oe,os),h(t,$o,m),h(t,A,m),_(Pe,A,null),e(A,rs),e(A,ze),e(ze,ss),e(ze,Ft),e(Ft,as),e(ze,ns),e(A,is),e(A,Q),e(Q,ds),e(Q,vt),e(vt,cs),e(Q,ls),e(Q,bt),e(bt,ms),e(Q,hs),h(t,Eo,m),h(t,Y,m),e(Y,ie),e(ie,Gt),_(Ce,Gt,null),e(Y,ps),e(Y,Qt),e(Qt,fs),h(t,Io,m),h(t,w,m),_(Se,w,null),e(w,us),e(w,De),e(De,gs),e(De,Yt),e(Yt,_s),e(De,ks),e(w,Fs),e(w,J),e(J,vs),e(J,wt),e(wt,bs),e(J,ws),e(J,xt),e(xt,xs),e(J,Ms),e(w,Ts),e(w,Jt),e(Jt,ys),e(w,$s),e(w,Xt),e(Xt,Es),e(w,Is),_(je,w,null),e(w,Os),e(w,de),_(Ae,de,null),e(de,Ps),e(de,qe),e(qe,zs),e(qe,Mt),e(Mt,Cs),e(qe,Ss),e(w,Ds),e(w,ce),_(Ne,ce,null),e(ce,js),e(ce,Le),e(Le,As),e(Le,Tt),e(Tt,qs),e(Le,Ns),h(t,Oo,m),h(t,X,m),e(X,le),e(le,Zt),_(He,Zt,null),e(X,Ls),e(X,eo),e(eo,Hs),h(t,Po,m),h(t,x,m),_(We,x,null),e(x,Ws),e(x,to),e(to,Vs),e(x,Us),e(x,Ve),e(Ve,Rs),e(Ve,yt),e(yt,Bs),e(Ve,Ks),e(x,Gs),e(x,L),_(Ue,L,null),e(L,Qs),e(L,oo),e(oo,Ys),e(L,Js),_(me,L,null),e(x,Xs),e(x,he),_(Re,he,null),e(he,Zs),e(he,Be),e(Be,ea),e(Be,ro),e(ro,ta),e(Be,oa),e(x,ra),e(x,pe),_(Ke,pe,null),e(pe,sa),e(pe,Ge),e(Ge,aa),e(Ge,so),e(so,na),e(Ge,ia),e(x,da),e(x,fe),_(Qe,fe,null),e(fe,ca),e(fe,Ye),e(Ye,la),e(Ye,ao),e(ao,ma),e(Ye,ha),e(x,pa),e(x,ue),_(Je,ue,null),e(ue,fa),e(ue,Xe),e(Xe,ua),e(Xe,no),e(no,ga),e(Xe,_a),h(t,zo,m),h(t,Z,m),e(Z,ge),e(ge,io),_(Ze,io,null),e(Z,ka),e(Z,co),e(co,Fa),h(t,Co,m),h(t,q,m),_(et,q,null),e(q,va),e(q,tt),e(tt,ba),e(tt,ot),e(ot,wa),e(tt,xa),e(q,Ma),e(q,O),_(rt,O,null),e(O,Ta),e(O,ee),e(ee,ya),e(ee,$t),e($t,$a),e(ee,Ea),e(ee,lo),e(lo,Ia),e(ee,Oa),e(O,Pa),_(_e,O,null),e(O,za),e(O,mo),e(mo,Ca),e(O,Sa),_(st,O,null),h(t,So,m),h(t,te,m),e(te,ke),e(ke,ho),_(at,ho,null),e(te,Da),e(te,po),e(po,ja),h(t,Do,m),h(t,oe,m),_(nt,oe,null),e(oe,Aa),e(oe,P),_(it,P,null),e(P,qa),e(P,re),e(re,Na),e(re,Et),e(Et,La),e(re,Ha),e(re,fo),e(fo,Wa),e(re,Va),e(P,Ua),_(Fe,P,null),e(P,Ra),e(P,uo),e(uo,Ba),e(P,Ka),_(dt,P,null),jo=!0},p(t,[m]){const ct={};m&2&&(ct.$$scope={dirty:m,ctx:t}),me.$set(ct);const go={};m&2&&(go.$$scope={dirty:m,ctx:t}),_e.$set(go);const _o={};m&2&&(_o.$$scope={dirty:m,ctx:t}),Fe.$set(_o)},i(t){jo||(k(M.$$.fragment,t),k(we.$$.fragment,t),k(Ee.$$.fragment,t),k(Ie.$$.fragment,t),k(Pe.$$.fragment,t),k(Ce.$$.fragment,t),k(Se.$$.fragment,t),k(je.$$.fragment,t),k(Ae.$$.fragment,t),k(Ne.$$.fragment,t),k(He.$$.fragment,t),k(We.$$.fragment,t),k(Ue.$$.fragment,t),k(me.$$.fragment,t),k(Re.$$.fragment,t),k(Ke.$$.fragment,t),k(Qe.$$.fragment,t),k(Je.$$.fragment,t),k(Ze.$$.fragment,t),k(et.$$.fragment,t),k(rt.$$.fragment,t),k(_e.$$.fragment,t),k(st.$$.fragment,t),k(at.$$.fragment,t),k(nt.$$.fragment,t),k(it.$$.fragment,t),k(Fe.$$.fragment,t),k(dt.$$.fragment,t),jo=!0)},o(t){F(M.$$.fragment,t),F(we.$$.fragment,t),F(Ee.$$.fragment,t),F(Ie.$$.fragment,t),F(Pe.$$.fragment,t),F(Ce.$$.fragment,t),F(Se.$$.fragment,t),F(je.$$.fragment,t),F(Ae.$$.fragment,t),F(Ne.$$.fragment,t),F(He.$$.fragment,t),F(We.$$.fragment,t),F(Ue.$$.fragment,t),F(me.$$.fragment,t),F(Re.$$.fragment,t),F(Ke.$$.fragment,t),F(Qe.$$.fragment,t),F(Je.$$.fragment,t),F(Ze.$$.fragment,t),F(et.$$.fragment,t),F(rt.$$.fragment,t),F(_e.$$.fragment,t),F(st.$$.fragment,t),F(at.$$.fragment,t),F(nt.$$.fragment,t),F(it.$$.fragment,t),F(Fe.$$.fragment,t),F(dt.$$.fragment,t),jo=!1},d(t){o(p),t&&o(T),t&&o(f),v(M),t&&o(ko),t&&o(R),v(we),t&&o(Fo),t&&o(ae),t&&o(vo),t&&o(mt),t&&o(bo),t&&o(ht),t&&o(wo),t&&o(pt),t&&o(xo),t&&o(S),t&&o(Mo),t&&o(N),t&&o(To),t&&o(K),v(Ee),t&&o(yo),t&&o(G),v(Ie),t&&o($o),t&&o(A),v(Pe),t&&o(Eo),t&&o(Y),v(Ce),t&&o(Io),t&&o(w),v(Se),v(je),v(Ae),v(Ne),t&&o(Oo),t&&o(X),v(He),t&&o(Po),t&&o(x),v(We),v(Ue),v(me),v(Re),v(Ke),v(Qe),v(Je),t&&o(zo),t&&o(Z),v(Ze),t&&o(Co),t&&o(q),v(et),v(rt),v(_e),v(st),t&&o(So),t&&o(te),v(at),t&&o(Do),t&&o(oe),v(nt),v(it),v(Fe),v(dt)}}}const hi={local:"maskformer",sections:[{local:"overview",title:"Overview"},{local:"transformers.models.maskformer.modeling_maskformer.MaskFormerModelOutput",title:"MaskFormer specific outputs"},{local:"transformers.MaskFormerConfig",title:"MaskFormerConfig"},{local:"transformers.MaskFormerFeatureExtractor",title:"MaskFormerFeatureExtractor"},{local:"transformers.MaskFormerModel",title:"MaskFormerModel"},{local:"transformers.MaskFormerForInstanceSegmentation",title:"MaskFormerForInstanceSegmentation"}],title:"MaskFormer"};function pi(U,p,T){let{fw:f}=p;return U.$$set=b=>{"fw"in b&&T(0,f=b.fw)},[f]}class vi extends si{constructor(p){super();ai(this,p,pi,mi,ni,{fw:0})}}export{vi as default,hi as metadata};
