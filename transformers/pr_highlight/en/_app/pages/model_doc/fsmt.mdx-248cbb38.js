import{S as Na,i as La,s as ja,e as n,k as l,w as v,t as a,M as Oa,c as s,d as o,m as c,a as r,x as b,h as i,b as h,F as e,g as _,y,q as M,o as w,B as F,v as Ga,L as Ko}from"../../chunks/vendor-6b77c823.js";import{T as Da}from"../../chunks/Tip-39098574.js";import{D as L}from"../../chunks/Docstring-1088f2fb.js";import{C as Yo}from"../../chunks/CodeBlock-3a8b25a8.js";import{I as nt}from"../../chunks/IconCopyLink-7a11ce68.js";import{E as Xo}from"../../chunks/ExampleCodeBlock-5212b321.js";function Ra(E){let m,k,f,u,T;return u=new Yo({props:{code:`from transformers import FSMTConfig, FSMTModel

config = FSMTConfig.from_pretrained("facebook/wmt19-en-ru")
model = FSMTModel(config)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FSMTConfig, FSMTModel

<span class="hljs-meta">&gt;&gt;&gt; </span>config = FSMTConfig.from_pretrained(<span class="hljs-string">&quot;facebook/wmt19-en-ru&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FSMTModel(config)`}}),{c(){m=n("p"),k=a("Examples:"),f=l(),v(u.$$.fragment)},l(d){m=s(d,"P",{});var g=r(m);k=i(g,"Examples:"),g.forEach(o),f=c(d),b(u.$$.fragment,d)},m(d,g){_(d,m,g),e(m,k),_(d,f,g),y(u,d,g),T=!0},p:Ko,i(d){T||(M(u.$$.fragment,d),T=!0)},o(d){w(u.$$.fragment,d),T=!1},d(d){d&&o(m),d&&o(f),F(u,d)}}}function Wa(E){let m,k;return m=new Yo({props:{code:`0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1
| first sequence    | second sequence |`,highlighted:`0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 0 </span>0<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1<span class="hljs-number"> 1 </span>1 1
| first sequence    | second sequence |`}}),{c(){v(m.$$.fragment)},l(f){b(m.$$.fragment,f)},m(f,u){y(m,f,u),k=!0},p:Ko,i(f){k||(M(m.$$.fragment,f),k=!0)},o(f){w(m.$$.fragment,f),k=!1},d(f){F(m,f)}}}function Ba(E){let m,k,f,u,T;return{c(){m=n("p"),k=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),f=n("code"),u=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(d){m=s(d,"P",{});var g=r(m);k=i(g,"Although the recipe for forward pass needs to be defined within this function, one should call the "),f=s(g,"CODE",{});var A=r(f);u=i(A,"Module"),A.forEach(o),T=i(g,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),g.forEach(o)},m(d,g){_(d,m,g),e(m,k),e(m,f),e(f,u),e(m,T)},d(d){d&&o(m)}}}function Ua(E){let m,k,f,u,T;return u=new Yo({props:{code:`from transformers import FSMTTokenizer, FSMTModel
import torch

tokenizer = FSMTTokenizer.from_pretrained("facebook/wmt19-ru-en")
model = FSMTModel.from_pretrained("facebook/wmt19-ru-en")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")
outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FSMTTokenizer, FSMTModel
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FSMTTokenizer.from_pretrained(<span class="hljs-string">&quot;facebook/wmt19-ru-en&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FSMTModel.from_pretrained(<span class="hljs-string">&quot;facebook/wmt19-ru-en&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)

<span class="hljs-meta">&gt;&gt;&gt; </span>last_hidden_states = outputs.last_hidden_state`}}),{c(){m=n("p"),k=a("Example:"),f=l(),v(u.$$.fragment)},l(d){m=s(d,"P",{});var g=r(m);k=i(g,"Example:"),g.forEach(o),f=c(d),b(u.$$.fragment,d)},m(d,g){_(d,m,g),e(m,k),_(d,f,g),y(u,d,g),T=!0},p:Ko,i(d){T||(M(u.$$.fragment,d),T=!0)},o(d){w(u.$$.fragment,d),T=!1},d(d){d&&o(m),d&&o(f),F(u,d)}}}function Ha(E){let m,k,f,u,T;return{c(){m=n("p"),k=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),f=n("code"),u=a("Module"),T=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(d){m=s(d,"P",{});var g=r(m);k=i(g,"Although the recipe for forward pass needs to be defined within this function, one should call the "),f=s(g,"CODE",{});var A=r(f);u=i(A,"Module"),A.forEach(o),T=i(g,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),g.forEach(o)},m(d,g){_(d,m,g),e(m,k),e(m,f),e(f,u),e(m,T)},d(d){d&&o(m)}}}function Va(E){let m,k,f,u,T;return u=new Yo({props:{code:`from transformers import FSMTTokenizer, FSMTForConditionalGeneration

mname = "facebook/wmt19-ru-en"
model = FSMTForConditionalGeneration.from_pretrained(mname)
tokenizer = FSMTTokenizer.from_pretrained(mname)

src_text = "\u041C\u0430\u0448\u0438\u043D\u043D\u043E\u0435 \u043E\u0431\u0443\u0447\u0435\u043D\u0438\u0435 - \u044D\u0442\u043E \u0437\u0434\u043E\u0440\u043E\u0432\u043E, \u043D\u0435 \u0442\u0430\u043A \u043B\u0438?"
input_ids = tokenizer(src_text, return_tensors="pt").input_ids
outputs = model.generate(input_ids, num_beams=5, num_return_sequences=3)
tokenizer.decode(outputs[0], skip_special_tokens=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> FSMTTokenizer, FSMTForConditionalGeneration

<span class="hljs-meta">&gt;&gt;&gt; </span>mname = <span class="hljs-string">&quot;facebook/wmt19-ru-en&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model = FSMTForConditionalGeneration.from_pretrained(mname)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = FSMTTokenizer.from_pretrained(mname)

<span class="hljs-meta">&gt;&gt;&gt; </span>src_text = <span class="hljs-string">&quot;\u041C\u0430\u0448\u0438\u043D\u043D\u043E\u0435 \u043E\u0431\u0443\u0447\u0435\u043D\u0438\u0435 - \u044D\u0442\u043E \u0437\u0434\u043E\u0440\u043E\u0432\u043E, \u043D\u0435 \u0442\u0430\u043A \u043B\u0438?&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>input_ids = tokenizer(src_text, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>).input_ids
<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model.generate(input_ids, num_beams=<span class="hljs-number">5</span>, num_return_sequences=<span class="hljs-number">3</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer.decode(outputs[<span class="hljs-number">0</span>], skip_special_tokens=<span class="hljs-literal">True</span>)
<span class="hljs-string">&quot;Machine learning is great, isn&#x27;t it?&quot;</span>`}}),{c(){m=n("p"),k=a("Translation example::"),f=l(),v(u.$$.fragment)},l(d){m=s(d,"P",{});var g=r(m);k=i(g,"Translation example::"),g.forEach(o),f=c(d),b(u.$$.fragment,d)},m(d,g){_(d,m,g),e(m,k),_(d,f,g),y(u,d,g),T=!0},p:Ko,i(d){T||(M(u.$$.fragment,d),T=!0)},o(d){w(u.$$.fragment,d),T=!1},d(d){d&&o(m),d&&o(f),F(u,d)}}}function Qa(E){let m,k,f,u,T,d,g,A,Jo,fo,U,zt,Zo,en,we,tn,on,uo,H,se,qt,Fe,nn,xt,sn,_o,re,rn,$e,an,dn,go,st,ln,ko,rt,Et,cn,To,j,hn,Se,mn,pn,ze,fn,un,vo,V,ae,Ct,qe,_n,Pt,gn,bo,at,Q,kn,it,Tn,vn,dt,bn,yn,yo,X,ie,It,xe,Mn,At,wn,Mo,z,Ee,Fn,Ce,$n,lt,Sn,zn,qn,K,xn,ct,En,Cn,ht,Pn,In,An,de,Dn,le,Pe,Nn,Y,Ln,Dt,jn,On,Nt,Gn,Rn,wo,J,ce,Lt,Ie,Wn,jt,Bn,Fo,$,Ae,Un,Ot,Hn,Vn,D,Gt,Qn,Xn,Rt,Kn,Yn,N,Jn,Wt,Zn,es,Bt,ts,os,Ut,ns,ss,rs,De,as,Ht,is,ds,ls,Ne,cs,mt,hs,ms,ps,O,Le,fs,Vt,us,_s,je,pt,gs,Qt,ks,Ts,ft,vs,Xt,bs,ys,he,Oe,Ms,Ge,ws,Kt,Fs,$s,Ss,C,Re,zs,Yt,qs,xs,me,Es,Z,Cs,Jt,Ps,Is,Zt,As,Ds,Ns,eo,Ls,js,ut,We,$o,ee,pe,to,Be,Os,oo,Gs,So,q,Ue,Rs,no,Ws,Bs,He,Us,_t,Hs,Vs,Qs,Ve,Xs,Qe,Ks,Ys,Js,P,Xe,Zs,te,er,gt,tr,or,so,nr,sr,rr,fe,ar,ue,zo,oe,_e,ro,Ke,ir,ao,dr,qo,x,Ye,lr,io,cr,hr,Je,mr,kt,pr,fr,ur,Ze,_r,et,gr,kr,Tr,I,tt,vr,ne,br,Tt,yr,Mr,lo,wr,Fr,$r,ge,Sr,ke,xo;return d=new nt({}),Fe=new nt({}),qe=new nt({}),xe=new nt({}),Ee=new L({props:{name:"class transformers.FSMTConfig",anchor:"transformers.FSMTConfig",parameters:[{name:"langs",val:" = ['en', 'de']"},{name:"src_vocab_size",val:" = 42024"},{name:"tgt_vocab_size",val:" = 42024"},{name:"activation_function",val:" = 'relu'"},{name:"d_model",val:" = 1024"},{name:"max_length",val:" = 200"},{name:"max_position_embeddings",val:" = 1024"},{name:"encoder_ffn_dim",val:" = 4096"},{name:"encoder_layers",val:" = 12"},{name:"encoder_attention_heads",val:" = 16"},{name:"encoder_layerdrop",val:" = 0.0"},{name:"decoder_ffn_dim",val:" = 4096"},{name:"decoder_layers",val:" = 12"},{name:"decoder_attention_heads",val:" = 16"},{name:"decoder_layerdrop",val:" = 0.0"},{name:"attention_dropout",val:" = 0.0"},{name:"dropout",val:" = 0.1"},{name:"activation_dropout",val:" = 0.0"},{name:"init_std",val:" = 0.02"},{name:"decoder_start_token_id",val:" = 2"},{name:"is_encoder_decoder",val:" = True"},{name:"scale_embedding",val:" = True"},{name:"tie_word_embeddings",val:" = False"},{name:"num_beams",val:" = 5"},{name:"length_penalty",val:" = 1.0"},{name:"early_stopping",val:" = False"},{name:"use_cache",val:" = True"},{name:"pad_token_id",val:" = 1"},{name:"bos_token_id",val:" = 0"},{name:"eos_token_id",val:" = 2"},{name:"forced_eos_token_id",val:" = 2"},{name:"**common_kwargs",val:""}],parametersDescription:[{anchor:"transformers.FSMTConfig.langs",description:`<strong>langs</strong> (<code>List[str]</code>) &#x2014;
A list with source language and target_language (e.g., [&#x2018;en&#x2019;, &#x2018;ru&#x2019;]).`,name:"langs"},{anchor:"transformers.FSMTConfig.src_vocab_size",description:`<strong>src_vocab_size</strong> (<code>int</code>) &#x2014;
Vocabulary size of the encoder. Defines the number of different tokens that can be represented by the
<code>inputs_ids</code> passed to the forward method in the encoder.`,name:"src_vocab_size"},{anchor:"transformers.FSMTConfig.tgt_vocab_size",description:`<strong>tgt_vocab_size</strong> (<code>int</code>) &#x2014;
Vocabulary size of the decoder. Defines the number of different tokens that can be represented by the
<code>inputs_ids</code> passed to the forward method in the decoder.`,name:"tgt_vocab_size"},{anchor:"transformers.FSMTConfig.d_model",description:`<strong>d_model</strong> (<code>int</code>, <em>optional</em>, defaults to 1024) &#x2014;
Dimensionality of the layers and the pooler layer.`,name:"d_model"},{anchor:"transformers.FSMTConfig.encoder_layers",description:`<strong>encoder_layers</strong> (<code>int</code>, <em>optional</em>, defaults to 12) &#x2014;
Number of encoder layers.`,name:"encoder_layers"},{anchor:"transformers.FSMTConfig.decoder_layers",description:`<strong>decoder_layers</strong> (<code>int</code>, <em>optional</em>, defaults to 12) &#x2014;
Number of decoder layers.`,name:"decoder_layers"},{anchor:"transformers.FSMTConfig.encoder_attention_heads",description:`<strong>encoder_attention_heads</strong> (<code>int</code>, <em>optional</em>, defaults to 16) &#x2014;
Number of attention heads for each attention layer in the Transformer encoder.`,name:"encoder_attention_heads"},{anchor:"transformers.FSMTConfig.decoder_attention_heads",description:`<strong>decoder_attention_heads</strong> (<code>int</code>, <em>optional</em>, defaults to 16) &#x2014;
Number of attention heads for each attention layer in the Transformer decoder.`,name:"decoder_attention_heads"},{anchor:"transformers.FSMTConfig.decoder_ffn_dim",description:`<strong>decoder_ffn_dim</strong> (<code>int</code>, <em>optional</em>, defaults to 4096) &#x2014;
Dimensionality of the &#x201C;intermediate&#x201D; (often named feed-forward) layer in decoder.`,name:"decoder_ffn_dim"},{anchor:"transformers.FSMTConfig.encoder_ffn_dim",description:`<strong>encoder_ffn_dim</strong> (<code>int</code>, <em>optional</em>, defaults to 4096) &#x2014;
Dimensionality of the &#x201C;intermediate&#x201D; (often named feed-forward) layer in decoder.`,name:"encoder_ffn_dim"},{anchor:"transformers.FSMTConfig.activation_function",description:`<strong>activation_function</strong> (<code>str</code> or <code>Callable</code>, <em>optional</em>, defaults to <code>&quot;relu&quot;</code>) &#x2014;
The non-linear activation function (function or string) in the encoder and pooler. If string, <code>&quot;gelu&quot;</code>,
<code>&quot;relu&quot;</code>, <code>&quot;silu&quot;</code> and <code>&quot;gelu_new&quot;</code> are supported.`,name:"activation_function"},{anchor:"transformers.FSMTConfig.dropout",description:`<strong>dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.1) &#x2014;
The dropout probability for all fully connected layers in the embeddings, encoder, and pooler.`,name:"dropout"},{anchor:"transformers.FSMTConfig.attention_dropout",description:`<strong>attention_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
The dropout ratio for the attention probabilities.`,name:"attention_dropout"},{anchor:"transformers.FSMTConfig.activation_dropout",description:`<strong>activation_dropout</strong> (<code>float</code>, <em>optional</em>, defaults to 0.0) &#x2014;
The dropout ratio for activations inside the fully connected layer.`,name:"activation_dropout"},{anchor:"transformers.FSMTConfig.max_position_embeddings",description:`<strong>max_position_embeddings</strong> (<code>int</code>, <em>optional</em>, defaults to 1024) &#x2014;
The maximum sequence length that this model might ever be used with. Typically set this to something large
just in case (e.g., 512 or 1024 or 2048).`,name:"max_position_embeddings"},{anchor:"transformers.FSMTConfig.init_std",description:`<strong>init_std</strong> (<code>float</code>, <em>optional</em>, defaults to 0.02) &#x2014;
The standard deviation of the truncated_normal_initializer for initializing all weight matrices.`,name:"init_std"},{anchor:"transformers.FSMTConfig.scale_embedding",description:`<strong>scale_embedding</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Scale embeddings by diving by sqrt(d_model).`,name:"scale_embedding"},{anchor:"transformers.FSMTConfig.bos_token_id",description:`<strong>bos_token_id</strong> (<code>int</code>, <em>optional</em>, defaults to 0) &#x2014;
Beginning of stream token id.`,name:"bos_token_id"},{anchor:"transformers.FSMTConfig.pad_token_id",description:`<strong>pad_token_id</strong> (<code>int</code>, <em>optional</em>, defaults to 1) &#x2014;
Padding token id.`,name:"pad_token_id"},{anchor:"transformers.FSMTConfig.eos_token_id",description:`<strong>eos_token_id</strong> (<code>int</code>, <em>optional</em>, defaults to 2) &#x2014;
End of stream token id.`,name:"eos_token_id"},{anchor:"transformers.FSMTConfig.decoder_start_token_id",description:`<strong>decoder_start_token_id</strong> (<code>int</code>, <em>optional</em>) &#x2014;
This model starts decoding with <code>eos_token_id</code>
encoder_layerdrop &#x2014; (<code>float</code>, <em>optional</em>, defaults to 0.0):
Google &#x201C;layerdrop arxiv&#x201D;, as its not explainable in one line.
decoder_layerdrop &#x2014; (<code>float</code>, <em>optional</em>, defaults to 0.0):
Google &#x201C;layerdrop arxiv&#x201D;, as its not explainable in one line.`,name:"decoder_start_token_id"},{anchor:"transformers.FSMTConfig.is_encoder_decoder",description:`<strong>is_encoder_decoder</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether this is an encoder/decoder model.`,name:"is_encoder_decoder"},{anchor:"transformers.FSMTConfig.tie_word_embeddings",description:`<strong>tie_word_embeddings</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to tie input and output embeddings.`,name:"tie_word_embeddings"},{anchor:"transformers.FSMTConfig.num_beams",description:`<strong>num_beams</strong> (<code>int</code>, <em>optional</em>, defaults to 5) &#x2014;
Number of beams for beam search that will be used by default in the <code>generate</code> method of the model. 1 means
no beam search.`,name:"num_beams"},{anchor:"transformers.FSMTConfig.length_penalty",description:`<strong>length_penalty</strong> (<code>float</code>, <em>optional</em>, defaults to 1) &#x2014;
Exponential penalty to the length that will be used by default in the <code>generate</code> method of the model.`,name:"length_penalty"},{anchor:"transformers.FSMTConfig.early_stopping",description:`<strong>early_stopping</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Flag that will be used by default in the <code>generate</code> method of the model. Whether to stop the beam search
when at least <code>num_beams</code> sentences are finished per batch or not.`,name:"early_stopping"},{anchor:"transformers.FSMTConfig.use_cache",description:`<strong>use_cache</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not the model should return the last key/values attentions (not used by all models).`,name:"use_cache"},{anchor:"transformers.FSMTConfig.forced_eos_token_id",description:`<strong>forced_eos_token_id</strong> (<code>int</code>, <em>optional</em>, defaults to 2) &#x2014;
The id of the token to force as the last generated token when <code>max_length</code> is reached. Usually set to
<code>eos_token_id</code>.`,name:"forced_eos_token_id"}],source:"https://github.com/huggingface/transformers/blob/pr_highlight/src/transformers/models/fsmt/configuration_fsmt.py#L41"}}),de=new Xo({props:{anchor:"transformers.FSMTConfig.example",$$slots:{default:[Ra]},$$scope:{ctx:E}}}),Pe=new L({props:{name:"to_dict",anchor:"transformers.FSMTConfig.to_dict",parameters:[],source:"https://github.com/huggingface/transformers/blob/pr_highlight/src/transformers/models/fsmt/configuration_fsmt.py#L209",returnDescription:`
<p>Dictionary of all the attributes that make up this configuration instance,</p>
`,returnType:`
<p><code>Dict[str, any]</code></p>
`}}),Ie=new nt({}),Ae=new L({props:{name:"class transformers.FSMTTokenizer",anchor:"transformers.FSMTTokenizer",parameters:[{name:"langs",val:" = None"},{name:"src_vocab_file",val:" = None"},{name:"tgt_vocab_file",val:" = None"},{name:"merges_file",val:" = None"},{name:"do_lower_case",val:" = False"},{name:"unk_token",val:" = '<unk>'"},{name:"bos_token",val:" = '<s>'"},{name:"sep_token",val:" = '</s>'"},{name:"pad_token",val:" = '<pad>'"},{name:"**kwargs",val:""}],parametersDescription:[{anchor:"transformers.FSMTTokenizer.langs",description:`<strong>langs</strong> (<code>List[str]</code>) &#x2014;
A list of two languages to translate from and to, for instance <code>[&quot;en&quot;, &quot;ru&quot;]</code>.`,name:"langs"},{anchor:"transformers.FSMTTokenizer.src_vocab_file",description:`<strong>src_vocab_file</strong> (<code>str</code>) &#x2014;
File containing the vocabulary for the source language.`,name:"src_vocab_file"},{anchor:"transformers.FSMTTokenizer.tgt_vocab_file",description:`<strong>tgt_vocab_file</strong> (<code>st</code>) &#x2014;
File containing the vocabulary for the target language.`,name:"tgt_vocab_file"},{anchor:"transformers.FSMTTokenizer.merges_file",description:`<strong>merges_file</strong> (<code>str</code>) &#x2014;
File containing the merges.`,name:"merges_file"},{anchor:"transformers.FSMTTokenizer.do_lower_case",description:`<strong>do_lower_case</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to lowercase the input when tokenizing.`,name:"do_lower_case"},{anchor:"transformers.FSMTTokenizer.unk_token",description:`<strong>unk_token</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;&lt;unk&gt;&quot;</code>) &#x2014;
The unknown token. A token that is not in the vocabulary cannot be converted to an ID and is set to be this
token instead.`,name:"unk_token"},{anchor:"transformers.FSMTTokenizer.bos_token",description:`<strong>bos_token</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;&lt;s&gt;&quot;</code>) &#x2014;
The beginning of sequence token that was used during pretraining. Can be used a sequence classifier token.</p>
<div class="course-tip  bg-gradient-to-br dark:bg-gradient-to-r before:border-green-500 dark:before:border-green-800 from-green-50 dark:from-gray-900 to-white dark:to-gray-950 border border-green-50 text-green-700 dark:text-gray-400">
						
<p>When building a sequence using special tokens, this is not the token that is used for the beginning of
sequence. The token used is the <code>cls_token</code>.</p>

					</div>`,name:"bos_token"},{anchor:"transformers.FSMTTokenizer.sep_token",description:`<strong>sep_token</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;&lt;/s&gt;&quot;</code>) &#x2014;
The separator token, which is used when building a sequence from multiple sequences, e.g. two sequences for
sequence classification or for a text and a question for question answering. It is also used as the last
token of a sequence built with special tokens.`,name:"sep_token"},{anchor:"transformers.FSMTTokenizer.pad_token",description:`<strong>pad_token</strong> (<code>str</code>, <em>optional</em>, defaults to <code>&quot;&lt;pad&gt;&quot;</code>) &#x2014;
The token used for padding, for example when batching sequences of different lengths.`,name:"pad_token"}],source:"https://github.com/huggingface/transformers/blob/pr_highlight/src/transformers/models/fsmt/tokenization_fsmt.py#L137"}}),Le=new L({props:{name:"build_inputs_with_special_tokens",anchor:"transformers.FSMTTokenizer.build_inputs_with_special_tokens",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"}],parametersDescription:[{anchor:"transformers.FSMTTokenizer.build_inputs_with_special_tokens.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs to which the special tokens will be added.`,name:"token_ids_0"},{anchor:"transformers.FSMTTokenizer.build_inputs_with_special_tokens.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"}],source:"https://github.com/huggingface/transformers/blob/pr_highlight/src/transformers/models/fsmt/tokenization_fsmt.py#L397",returnDescription:`
<p>List of <a href="../glossary#input-ids">input IDs</a> with the appropriate special tokens.</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),Oe=new L({props:{name:"get_special_tokens_mask",anchor:"transformers.FSMTTokenizer.get_special_tokens_mask",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"},{name:"already_has_special_tokens",val:": bool = False"}],parametersDescription:[{anchor:"transformers.FSMTTokenizer.get_special_tokens_mask.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs.`,name:"token_ids_0"},{anchor:"transformers.FSMTTokenizer.get_special_tokens_mask.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"},{anchor:"transformers.FSMTTokenizer.get_special_tokens_mask.already_has_special_tokens",description:`<strong>already_has_special_tokens</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not the token list is already formatted with special tokens for the model.`,name:"already_has_special_tokens"}],source:"https://github.com/huggingface/transformers/blob/pr_highlight/src/transformers/models/fsmt/tokenization_fsmt.py#L423",returnDescription:`
<p>A list of integers in the range [0, 1]: 1 for a special token, 0 for a sequence token.</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),Re=new L({props:{name:"create_token_type_ids_from_sequences",anchor:"transformers.FSMTTokenizer.create_token_type_ids_from_sequences",parameters:[{name:"token_ids_0",val:": typing.List[int]"},{name:"token_ids_1",val:": typing.Optional[typing.List[int]] = None"}],parametersDescription:[{anchor:"transformers.FSMTTokenizer.create_token_type_ids_from_sequences.token_ids_0",description:`<strong>token_ids_0</strong> (<code>List[int]</code>) &#x2014;
List of IDs.`,name:"token_ids_0"},{anchor:"transformers.FSMTTokenizer.create_token_type_ids_from_sequences.token_ids_1",description:`<strong>token_ids_1</strong> (<code>List[int]</code>, <em>optional</em>) &#x2014;
Optional second list of IDs for sequence pairs.`,name:"token_ids_1"}],source:"https://github.com/huggingface/transformers/blob/pr_highlight/src/transformers/models/fsmt/tokenization_fsmt.py#L451",returnDescription:`
<p>List of <a href="../glossary#token-type-ids">token type IDs</a> according to the given sequence(s).</p>
`,returnType:`
<p><code>List[int]</code></p>
`}}),me=new Xo({props:{anchor:"transformers.FSMTTokenizer.create_token_type_ids_from_sequences.example",$$slots:{default:[Wa]},$$scope:{ctx:E}}}),We=new L({props:{name:"save_vocabulary",anchor:"transformers.FSMTTokenizer.save_vocabulary",parameters:[{name:"save_directory",val:": str"},{name:"filename_prefix",val:": typing.Optional[str] = None"}],source:"https://github.com/huggingface/transformers/blob/pr_highlight/src/transformers/models/fsmt/tokenization_fsmt.py#L484"}}),Be=new nt({}),Ue=new L({props:{name:"class transformers.FSMTModel",anchor:"transformers.FSMTModel",parameters:[{name:"config",val:": FSMTConfig"}],parametersDescription:[{anchor:"transformers.FSMTModel.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_highlight/en/model_doc/fsmt#transformers.FSMTConfig">FSMTConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_highlight/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_highlight/src/transformers/models/fsmt/modeling_fsmt.py#L989"}}),Xe=new L({props:{name:"forward",anchor:"transformers.FSMTModel.forward",parameters:[{name:"input_ids",val:""},{name:"attention_mask",val:" = None"},{name:"decoder_input_ids",val:" = None"},{name:"decoder_attention_mask",val:" = None"},{name:"head_mask",val:" = None"},{name:"decoder_head_mask",val:" = None"},{name:"cross_attn_head_mask",val:" = None"},{name:"encoder_outputs",val:": typing.Optional[typing.Tuple] = None"},{name:"past_key_values",val:" = None"},{name:"use_cache",val:" = None"},{name:"output_attentions",val:" = None"},{name:"output_hidden_states",val:" = None"},{name:"return_dict",val:" = None"}],parametersDescription:[{anchor:"transformers.FSMTModel.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>IIndices can be obtained using <code>FSTMTokenizer</code>. See <a href="/docs/transformers/pr_highlight/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_highlight/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FSMTModel.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FSMTModel.forward.decoder_input_ids",description:`<strong>decoder_input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, target_sequence_length)</code>, <em>optional</em>) &#x2014;
Indices of decoder input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_highlight/en/model_doc/fsmt#transformers.FSMTTokenizer">FSMTTokenizer</a>. See <a href="/docs/transformers/pr_highlight/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_highlight/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#decoder-input-ids">What are decoder input IDs?</a></p>
<p>FSMT uses the <code>eos_token_id</code> as the starting token for <code>decoder_input_ids</code> generation. If <code>past_key_values</code>
is used, optionally only the last <code>decoder_input_ids</code> have to be input (see <code>past_key_values</code>).`,name:"decoder_input_ids"},{anchor:"transformers.FSMTModel.forward.decoder_attention_mask",description:`<strong>decoder_attention_mask</strong> (<code>torch.BoolTensor</code> of shape <code>(batch_size, target_sequence_length)</code>, <em>optional</em>) &#x2014;
Default behavior: generate a tensor that ignores pad tokens in <code>decoder_input_ids</code>. Causal mask will also
be used by default.`,name:"decoder_attention_mask"},{anchor:"transformers.FSMTModel.forward.head_mask",description:`<strong>head_mask</strong> (<code>torch.Tensor</code> of shape <code>(encoder_layers, encoder_attention_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the attention modules in the encoder. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"head_mask"},{anchor:"transformers.FSMTModel.forward.decoder_head_mask",description:`<strong>decoder_head_mask</strong> (<code>torch.Tensor</code> of shape <code>(decoder_layers, decoder_attention_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the attention modules in the decoder. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"decoder_head_mask"},{anchor:"transformers.FSMTModel.forward.cross_attn_head_mask",description:`<strong>cross_attn_head_mask</strong> (<code>torch.Tensor</code> of shape <code>(decoder_layers, decoder_attention_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the cross-attention modules in the decoder. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"cross_attn_head_mask"},{anchor:"transformers.FSMTModel.forward.encoder_outputs",description:`<strong>encoder_outputs</strong> (<code>Tuple(torch.FloatTensor)</code>, <em>optional</em>) &#x2014;
Tuple consists of (<code>last_hidden_state</code>, <em>optional</em>: <code>hidden_states</code>, <em>optional</em>: <code>attentions</code>)
<code>last_hidden_state</code> of shape <code>(batch_size, sequence_length, hidden_size)</code> is a sequence of hidden-states at
the output of the last layer of the encoder. Used in the cross-attention of the decoder.`,name:"encoder_outputs"},{anchor:"transformers.FSMTModel.forward.past_key_values",description:`<strong>past_key_values</strong> (<code>Tuple(torch.FloatTensor)</code> of length <code>config.n_layers</code> with each tuple having 4 tensors of shape <code>(batch_size, num_heads, sequence_length - 1, embed_size_per_head)</code>) &#x2014;
Contains precomputed key and value hidden-states of the attention blocks. Can be used to speed up decoding.
If <code>past_key_values</code> are used, the user can optionally input only the last <code>decoder_input_ids</code> (those that
don&#x2019;t have their past key value states given to this model) of shape <code>(batch_size, 1)</code> instead of all
<code>decoder_input_ids</code> of shape <code>(batch_size, sequence_length)</code>.`,name:"past_key_values"},{anchor:"transformers.FSMTModel.forward.use_cache",description:`<strong>use_cache</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
If set to <code>True</code>, <code>past_key_values</code> key value states are returned and can be used to speed up decoding (see
<code>past_key_values</code>).`,name:"use_cache"},{anchor:"transformers.FSMTModel.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FSMTModel.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FSMTModel.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_highlight/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"}],source:"https://github.com/huggingface/transformers/blob/pr_highlight/src/transformers/models/fsmt/modeling_fsmt.py#L1003",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_highlight/en/main_classes/output#transformers.modeling_outputs.Seq2SeqModelOutput"
>transformers.modeling_outputs.Seq2SeqModelOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_highlight/en/model_doc/fsmt#transformers.FSMTConfig"
>FSMTConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>) \u2014 Sequence of hidden-states at the output of the last layer of the decoder of the model.</p>
<p>If <code>past_key_values</code> is used only the last hidden-state of the sequences of shape <code>(batch_size, 1, hidden_size)</code> is output.</p>
</li>
<li>
<p><strong>past_key_values</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>use_cache=True</code> is passed or when <code>config.use_cache=True</code>) \u2014 Tuple of <code>tuple(torch.FloatTensor)</code> of length <code>config.n_layers</code>, with each tuple having 2 tensors of shape
<code>(batch_size, num_heads, sequence_length, embed_size_per_head)</code>) and 2 additional tensors of shape
<code>(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)</code>.</p>
<p>Contains pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention
blocks) that can be used (see <code>past_key_values</code> input) to speed up sequential decoding.</p>
</li>
<li>
<p><strong>decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the decoder at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>decoder_attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights of the decoder, after the attention softmax, used to compute the weighted average in the
self-attention heads.</p>
</li>
<li>
<p><strong>cross_attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights of the decoder\u2019s cross-attention layer, after the attention softmax, used to compute the
weighted average in the cross-attention heads.</p>
</li>
<li>
<p><strong>encoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) \u2014 Sequence of hidden-states at the output of the last layer of the encoder of the model.</p>
</li>
<li>
<p><strong>encoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the encoder at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>encoder_attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights of the encoder, after the attention softmax, used to compute the weighted average in the
self-attention heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_highlight/en/main_classes/output#transformers.modeling_outputs.Seq2SeqModelOutput"
>transformers.modeling_outputs.Seq2SeqModelOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),fe=new Da({props:{$$slots:{default:[Ba]},$$scope:{ctx:E}}}),ue=new Xo({props:{anchor:"transformers.FSMTModel.forward.example",$$slots:{default:[Ua]},$$scope:{ctx:E}}}),Ke=new nt({}),Ye=new L({props:{name:"class transformers.FSMTForConditionalGeneration",anchor:"transformers.FSMTForConditionalGeneration",parameters:[{name:"config",val:": FSMTConfig"}],parametersDescription:[{anchor:"transformers.FSMTForConditionalGeneration.config",description:`<strong>config</strong> (<a href="/docs/transformers/pr_highlight/en/model_doc/fsmt#transformers.FSMTConfig">FSMTConfig</a>) &#x2014; Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <a href="/docs/transformers/pr_highlight/en/main_classes/model#transformers.PreTrainedModel.from_pretrained">from_pretrained()</a> method to load the model weights.`,name:"config"}],source:"https://github.com/huggingface/transformers/blob/pr_highlight/src/transformers/models/fsmt/modeling_fsmt.py#L1113"}}),tt=new L({props:{name:"forward",anchor:"transformers.FSMTForConditionalGeneration.forward",parameters:[{name:"input_ids",val:""},{name:"attention_mask",val:" = None"},{name:"decoder_input_ids",val:" = None"},{name:"decoder_attention_mask",val:" = None"},{name:"head_mask",val:" = None"},{name:"decoder_head_mask",val:" = None"},{name:"cross_attn_head_mask",val:" = None"},{name:"encoder_outputs",val:" = None"},{name:"past_key_values",val:" = None"},{name:"labels",val:" = None"},{name:"use_cache",val:" = None"},{name:"output_attentions",val:" = None"},{name:"output_hidden_states",val:" = None"},{name:"return_dict",val:" = None"}],parametersDescription:[{anchor:"transformers.FSMTForConditionalGeneration.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.</p>
<p>IIndices can be obtained using <code>FSTMTokenizer</code>. See <a href="/docs/transformers/pr_highlight/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_highlight/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#input-ids">What are input IDs?</a>`,name:"input_ids"},{anchor:"transformers.FSMTForConditionalGeneration.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.</li>
</ul>
<p><a href="../glossary#attention-mask">What are attention masks?</a>`,name:"attention_mask"},{anchor:"transformers.FSMTForConditionalGeneration.forward.decoder_input_ids",description:`<strong>decoder_input_ids</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, target_sequence_length)</code>, <em>optional</em>) &#x2014;
Indices of decoder input sequence tokens in the vocabulary.</p>
<p>Indices can be obtained using <a href="/docs/transformers/pr_highlight/en/model_doc/fsmt#transformers.FSMTTokenizer">FSMTTokenizer</a>. See <a href="/docs/transformers/pr_highlight/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.encode">PreTrainedTokenizer.encode()</a> and
<a href="/docs/transformers/pr_highlight/en/main_classes/tokenizer#transformers.PreTrainedTokenizerFast.__call__">PreTrainedTokenizer.<strong>call</strong>()</a> for details.</p>
<p><a href="../glossary#decoder-input-ids">What are decoder input IDs?</a></p>
<p>FSMT uses the <code>eos_token_id</code> as the starting token for <code>decoder_input_ids</code> generation. If <code>past_key_values</code>
is used, optionally only the last <code>decoder_input_ids</code> have to be input (see <code>past_key_values</code>).`,name:"decoder_input_ids"},{anchor:"transformers.FSMTForConditionalGeneration.forward.decoder_attention_mask",description:`<strong>decoder_attention_mask</strong> (<code>torch.BoolTensor</code> of shape <code>(batch_size, target_sequence_length)</code>, <em>optional</em>) &#x2014;
Default behavior: generate a tensor that ignores pad tokens in <code>decoder_input_ids</code>. Causal mask will also
be used by default.`,name:"decoder_attention_mask"},{anchor:"transformers.FSMTForConditionalGeneration.forward.head_mask",description:`<strong>head_mask</strong> (<code>torch.Tensor</code> of shape <code>(encoder_layers, encoder_attention_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the attention modules in the encoder. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"head_mask"},{anchor:"transformers.FSMTForConditionalGeneration.forward.decoder_head_mask",description:`<strong>decoder_head_mask</strong> (<code>torch.Tensor</code> of shape <code>(decoder_layers, decoder_attention_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the attention modules in the decoder. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"decoder_head_mask"},{anchor:"transformers.FSMTForConditionalGeneration.forward.cross_attn_head_mask",description:`<strong>cross_attn_head_mask</strong> (<code>torch.Tensor</code> of shape <code>(decoder_layers, decoder_attention_heads)</code>, <em>optional</em>) &#x2014;
Mask to nullify selected heads of the cross-attention modules in the decoder. Mask values selected in <code>[0, 1]</code>:</p>
<ul>
<li>1 indicates the head is <strong>not masked</strong>,</li>
<li>0 indicates the head is <strong>masked</strong>.</li>
</ul>`,name:"cross_attn_head_mask"},{anchor:"transformers.FSMTForConditionalGeneration.forward.encoder_outputs",description:`<strong>encoder_outputs</strong> (<code>Tuple(torch.FloatTensor)</code>, <em>optional</em>) &#x2014;
Tuple consists of (<code>last_hidden_state</code>, <em>optional</em>: <code>hidden_states</code>, <em>optional</em>: <code>attentions</code>)
<code>last_hidden_state</code> of shape <code>(batch_size, sequence_length, hidden_size)</code> is a sequence of hidden-states at
the output of the last layer of the encoder. Used in the cross-attention of the decoder.`,name:"encoder_outputs"},{anchor:"transformers.FSMTForConditionalGeneration.forward.past_key_values",description:`<strong>past_key_values</strong> (<code>Tuple(torch.FloatTensor)</code> of length <code>config.n_layers</code> with each tuple having 4 tensors of shape <code>(batch_size, num_heads, sequence_length - 1, embed_size_per_head)</code>) &#x2014;
Contains precomputed key and value hidden-states of the attention blocks. Can be used to speed up decoding.
If <code>past_key_values</code> are used, the user can optionally input only the last <code>decoder_input_ids</code> (those that
don&#x2019;t have their past key value states given to this model) of shape <code>(batch_size, 1)</code> instead of all
<code>decoder_input_ids</code> of shape <code>(batch_size, sequence_length)</code>.`,name:"past_key_values"},{anchor:"transformers.FSMTForConditionalGeneration.forward.use_cache",description:`<strong>use_cache</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
If set to <code>True</code>, <code>past_key_values</code> key value states are returned and can be used to speed up decoding (see
<code>past_key_values</code>).`,name:"use_cache"},{anchor:"transformers.FSMTForConditionalGeneration.forward.output_attentions",description:`<strong>output_attentions</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the attentions tensors of all attention layers. See <code>attentions</code> under returned
tensors for more detail.`,name:"output_attentions"},{anchor:"transformers.FSMTForConditionalGeneration.forward.output_hidden_states",description:`<strong>output_hidden_states</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return the hidden states of all layers. See <code>hidden_states</code> under returned tensors for
more detail.`,name:"output_hidden_states"},{anchor:"transformers.FSMTForConditionalGeneration.forward.return_dict",description:`<strong>return_dict</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to return a <a href="/docs/transformers/pr_highlight/en/main_classes/output#transformers.utils.ModelOutput">ModelOutput</a> instead of a plain tuple.`,name:"return_dict"},{anchor:"transformers.FSMTForConditionalGeneration.forward.labels",description:`<strong>labels</strong> (<code>torch.LongTensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Labels for computing the masked language modeling loss. Indices should either be in <code>[0, ..., config.vocab_size]</code> or -100 (see <code>input_ids</code> docstring). Tokens with indices set to <code>-100</code> are ignored
(masked), the loss is only computed for the tokens with labels in <code>[0, ..., config.vocab_size]</code>.`,name:"labels"}],source:"https://github.com/huggingface/transformers/blob/pr_highlight/src/transformers/models/fsmt/modeling_fsmt.py#L1129",returnDescription:`
<p>A <a
  href="/docs/transformers/pr_highlight/en/main_classes/output#transformers.modeling_outputs.Seq2SeqLMOutput"
>transformers.modeling_outputs.Seq2SeqLMOutput</a> or a tuple of
<code>torch.FloatTensor</code> (if <code>return_dict=False</code> is passed or when <code>config.return_dict=False</code>) comprising various
elements depending on the configuration (<a
  href="/docs/transformers/pr_highlight/en/model_doc/fsmt#transformers.FSMTConfig"
>FSMTConfig</a>) and inputs.</p>
<ul>
<li>
<p><strong>loss</strong> (<code>torch.FloatTensor</code> of shape <code>(1,)</code>, <em>optional</em>, returned when <code>labels</code> is provided) \u2014 Language modeling loss.</p>
</li>
<li>
<p><strong>logits</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, config.vocab_size)</code>) \u2014 Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).</p>
</li>
<li>
<p><strong>past_key_values</strong> (<code>tuple(tuple(torch.FloatTensor))</code>, <em>optional</em>, returned when <code>use_cache=True</code> is passed or when <code>config.use_cache=True</code>) \u2014 Tuple of <code>tuple(torch.FloatTensor)</code> of length <code>config.n_layers</code>, with each tuple having 2 tensors of shape
<code>(batch_size, num_heads, sequence_length, embed_size_per_head)</code>) and 2 additional tensors of shape
<code>(batch_size, num_heads, encoder_sequence_length, embed_size_per_head)</code>.</p>
<p>Contains pre-computed hidden-states (key and values in the self-attention blocks and in the cross-attention
blocks) that can be used (see <code>past_key_values</code> input) to speed up sequential decoding.</p>
</li>
<li>
<p><strong>decoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the decoder at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>decoder_attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights of the decoder, after the attention softmax, used to compute the weighted average in the
self-attention heads.</p>
</li>
<li>
<p><strong>cross_attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights of the decoder\u2019s cross-attention layer, after the attention softmax, used to compute the
weighted average in the cross-attention heads.</p>
</li>
<li>
<p><strong>encoder_last_hidden_state</strong> (<code>torch.FloatTensor</code> of shape <code>(batch_size, sequence_length, hidden_size)</code>, <em>optional</em>) \u2014 Sequence of hidden-states at the output of the last layer of the encoder of the model.</p>
</li>
<li>
<p><strong>encoder_hidden_states</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_hidden_states=True</code> is passed or when <code>config.output_hidden_states=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for the output of the embeddings + one for the output of each layer) of
shape <code>(batch_size, sequence_length, hidden_size)</code>.</p>
<p>Hidden-states of the encoder at the output of each layer plus the initial embedding outputs.</p>
</li>
<li>
<p><strong>encoder_attentions</strong> (<code>tuple(torch.FloatTensor)</code>, <em>optional</em>, returned when <code>output_attentions=True</code> is passed or when <code>config.output_attentions=True</code>) \u2014 Tuple of <code>torch.FloatTensor</code> (one for each layer) of shape <code>(batch_size, num_heads, sequence_length, sequence_length)</code>.</p>
<p>Attentions weights of the encoder, after the attention softmax, used to compute the weighted average in the
self-attention heads.</p>
</li>
</ul>
`,returnType:`
<p><a
  href="/docs/transformers/pr_highlight/en/main_classes/output#transformers.modeling_outputs.Seq2SeqLMOutput"
>transformers.modeling_outputs.Seq2SeqLMOutput</a> or <code>tuple(torch.FloatTensor)</code></p>
`}}),ge=new Da({props:{$$slots:{default:[Ha]},$$scope:{ctx:E}}}),ke=new Xo({props:{anchor:"transformers.FSMTForConditionalGeneration.forward.example",$$slots:{default:[Va]},$$scope:{ctx:E}}}),{c(){m=n("meta"),k=l(),f=n("h1"),u=n("a"),T=n("span"),v(d.$$.fragment),g=l(),A=n("span"),Jo=a("FSMT"),fo=l(),U=n("p"),zt=n("strong"),Zo=a("DISCLAIMER:"),en=a(" If you see something strange, file a "),we=n("a"),tn=a("Github Issue"),on=a(` and assign
@stas00.`),uo=l(),H=n("h2"),se=n("a"),qt=n("span"),v(Fe.$$.fragment),nn=l(),xt=n("span"),sn=a("Overview"),_o=l(),re=n("p"),rn=a("FSMT (FairSeq MachineTranslation) models were introduced in "),$e=n("a"),an=a("Facebook FAIR\u2019s WMT19 News Translation Task Submission"),dn=a(" by Nathan Ng, Kyra Yee, Alexei Baevski, Myle Ott, Michael Auli, Sergey Edunov."),go=l(),st=n("p"),ln=a("The abstract of the paper is the following:"),ko=l(),rt=n("p"),Et=n("em"),cn=a(`This paper describes Facebook FAIR\u2019s submission to the WMT19 shared news translation task. We participate in two
language pairs and four language directions, English <-> German and English <-> Russian. Following our submission from
last year, our baseline systems are large BPE-based transformer models trained with the Fairseq sequence modeling
toolkit which rely on sampled back-translations. This year we experiment with different bitext data filtering schemes,
as well as with adding filtered back-translated data. We also ensemble and fine-tune our models on domain-specific
data, then decode using noisy channel model reranking. Our submissions are ranked first in all four directions of the
human evaluation campaign. On En->De, our system significantly outperforms other systems as well as human translations.
This system improves upon our WMT\u201918 submission by 4.5 BLEU points.`),To=l(),j=n("p"),hn=a("This model was contributed by "),Se=n("a"),mn=a("stas"),pn=a(`. The original code can be found
`),ze=n("a"),fn=a("here"),un=a("."),vo=l(),V=n("h2"),ae=n("a"),Ct=n("span"),v(qe.$$.fragment),_n=l(),Pt=n("span"),gn=a("Implementation Notes"),bo=l(),at=n("ul"),Q=n("li"),kn=a(`FSMT uses source and target vocabulary pairs that aren\u2019t combined into one. It doesn\u2019t share embeddings tokens
either. Its tokenizer is very similar to `),it=n("a"),Tn=a("XLMTokenizer"),vn=a(` and the main model is derived from
`),dt=n("a"),bn=a("BartModel"),yn=a("."),yo=l(),X=n("h2"),ie=n("a"),It=n("span"),v(xe.$$.fragment),Mn=l(),At=n("span"),wn=a("FSMTConfig"),Mo=l(),z=n("div"),v(Ee.$$.fragment),Fn=l(),Ce=n("p"),$n=a("This is the configuration class to store the configuration of a "),lt=n("a"),Sn=a("FSMTModel"),zn=a(`. It is used to instantiate a FSMT
model according to the specified arguments, defining the model architecture.`),qn=l(),K=n("p"),xn=a("Configuration objects inherit from "),ct=n("a"),En=a("PretrainedConfig"),Cn=a(` and can be used to control the model outputs. Read the
documentation from `),ht=n("a"),Pn=a("PretrainedConfig"),In=a(" for more information."),An=l(),v(de.$$.fragment),Dn=l(),le=n("div"),v(Pe.$$.fragment),Nn=l(),Y=n("p"),Ln=a("Serializes this instance to a Python dictionary. Override the default "),Dt=n("em"),jn=a("to_dict()"),On=a(" from "),Nt=n("em"),Gn=a("PretrainedConfig"),Rn=a("."),wo=l(),J=n("h2"),ce=n("a"),Lt=n("span"),v(Ie.$$.fragment),Wn=l(),jt=n("span"),Bn=a("FSMTTokenizer"),Fo=l(),$=n("div"),v(Ae.$$.fragment),Un=l(),Ot=n("p"),Hn=a("Construct an FAIRSEQ Transformer tokenizer. Based on Byte-Pair Encoding. The tokenization process is the following:"),Vn=l(),D=n("ul"),Gt=n("li"),Qn=a("Moses preprocessing and tokenization."),Xn=l(),Rt=n("li"),Kn=a("Normalizing all inputs text."),Yn=l(),N=n("li"),Jn=a("The arguments "),Wt=n("code"),Zn=a("special_tokens"),es=a(" and the function "),Bt=n("code"),ts=a("set_special_tokens"),os=a(`, can be used to add additional symbols (like
\u201D`),Ut=n("strong"),ns=a("classify"),ss=a("\u201D) to a vocabulary."),rs=l(),De=n("li"),as=a("The argument "),Ht=n("code"),is=a("langs"),ds=a(" defines a pair of languages."),ls=l(),Ne=n("p"),cs=a("This tokenizer inherits from "),mt=n("a"),hs=a("PreTrainedTokenizer"),ms=a(` which contains most of the main methods. Users should refer to
this superclass for more information regarding those methods.`),ps=l(),O=n("div"),v(Le.$$.fragment),fs=l(),Vt=n("p"),us=a(`Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and
adding special tokens. A FAIRSEQ Transformer sequence has the following format:`),_s=l(),je=n("ul"),pt=n("li"),gs=a("single sequence: "),Qt=n("code"),ks=a("<s> X </s>"),Ts=l(),ft=n("li"),vs=a("pair of sequences: "),Xt=n("code"),bs=a("<s> A </s> B </s>"),ys=l(),he=n("div"),v(Oe.$$.fragment),Ms=l(),Ge=n("p"),ws=a(`Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding
special tokens using the tokenizer `),Kt=n("code"),Fs=a("prepare_for_model"),$s=a(" method."),Ss=l(),C=n("div"),v(Re.$$.fragment),zs=l(),Yt=n("p"),qs=a(`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A FAIRSEQ
Transformer sequence pair mask has the following format:`),xs=l(),v(me.$$.fragment),Es=l(),Z=n("p"),Cs=a("If "),Jt=n("code"),Ps=a("token_ids_1"),Is=a(" is "),Zt=n("code"),As=a("None"),Ds=a(", this method only returns the first portion of the mask (0s)."),Ns=l(),eo=n("p"),Ls=a(`Creates a mask from the two sequences passed to be used in a sequence-pair classification task. An
FAIRSEQ_TRANSFORMER sequence pair mask has the following format:`),js=l(),ut=n("div"),v(We.$$.fragment),$o=l(),ee=n("h2"),pe=n("a"),to=n("span"),v(Be.$$.fragment),Os=l(),oo=n("span"),Gs=a("FSMTModel"),So=l(),q=n("div"),v(Ue.$$.fragment),Rs=l(),no=n("p"),Ws=a("The bare FSMT Model outputting raw hidden-states without any specific head on top."),Bs=l(),He=n("p"),Us=a("This model inherits from "),_t=n("a"),Hs=a("PreTrainedModel"),Vs=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Qs=l(),Ve=n("p"),Xs=a("This model is also a PyTorch "),Qe=n("a"),Ks=a("torch.nn.Module"),Ys=a(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Js=l(),P=n("div"),v(Xe.$$.fragment),Zs=l(),te=n("p"),er=a("The "),gt=n("a"),tr=a("FSMTModel"),or=a(" forward method, overrides the "),so=n("code"),nr=a("__call__"),sr=a(" special method."),rr=l(),v(fe.$$.fragment),ar=l(),v(ue.$$.fragment),zo=l(),oe=n("h2"),_e=n("a"),ro=n("span"),v(Ke.$$.fragment),ir=l(),ao=n("span"),dr=a("FSMTForConditionalGeneration"),qo=l(),x=n("div"),v(Ye.$$.fragment),lr=l(),io=n("p"),cr=a("The FSMT Model with a language modeling head. Can be used for summarization."),hr=l(),Je=n("p"),mr=a("This model inherits from "),kt=n("a"),pr=a("PreTrainedModel"),fr=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),ur=l(),Ze=n("p"),_r=a("This model is also a PyTorch "),et=n("a"),gr=a("torch.nn.Module"),kr=a(` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Tr=l(),I=n("div"),v(tt.$$.fragment),vr=l(),ne=n("p"),br=a("The "),Tt=n("a"),yr=a("FSMTForConditionalGeneration"),Mr=a(" forward method, overrides the "),lo=n("code"),wr=a("__call__"),Fr=a(" special method."),$r=l(),v(ge.$$.fragment),Sr=l(),v(ke.$$.fragment),this.h()},l(t){const p=Oa('[data-svelte="svelte-1phssyn"]',document.head);m=s(p,"META",{name:!0,content:!0}),p.forEach(o),k=c(t),f=s(t,"H1",{class:!0});var ot=r(f);u=s(ot,"A",{id:!0,class:!0,href:!0});var co=r(u);T=s(co,"SPAN",{});var ho=r(T);b(d.$$.fragment,ho),ho.forEach(o),co.forEach(o),g=c(ot),A=s(ot,"SPAN",{});var mo=r(A);Jo=i(mo,"FSMT"),mo.forEach(o),ot.forEach(o),fo=c(t),U=s(t,"P",{});var Te=r(U);zt=s(Te,"STRONG",{});var po=r(zt);Zo=i(po,"DISCLAIMER:"),po.forEach(o),en=i(Te," If you see something strange, file a "),we=s(Te,"A",{href:!0,rel:!0});var xr=r(we);tn=i(xr,"Github Issue"),xr.forEach(o),on=i(Te,` and assign
@stas00.`),Te.forEach(o),uo=c(t),H=s(t,"H2",{class:!0});var Eo=r(H);se=s(Eo,"A",{id:!0,class:!0,href:!0});var Er=r(se);qt=s(Er,"SPAN",{});var Cr=r(qt);b(Fe.$$.fragment,Cr),Cr.forEach(o),Er.forEach(o),nn=c(Eo),xt=s(Eo,"SPAN",{});var Pr=r(xt);sn=i(Pr,"Overview"),Pr.forEach(o),Eo.forEach(o),_o=c(t),re=s(t,"P",{});var Co=r(re);rn=i(Co,"FSMT (FairSeq MachineTranslation) models were introduced in "),$e=s(Co,"A",{href:!0,rel:!0});var Ir=r($e);an=i(Ir,"Facebook FAIR\u2019s WMT19 News Translation Task Submission"),Ir.forEach(o),dn=i(Co," by Nathan Ng, Kyra Yee, Alexei Baevski, Myle Ott, Michael Auli, Sergey Edunov."),Co.forEach(o),go=c(t),st=s(t,"P",{});var Ar=r(st);ln=i(Ar,"The abstract of the paper is the following:"),Ar.forEach(o),ko=c(t),rt=s(t,"P",{});var Dr=r(rt);Et=s(Dr,"EM",{});var Nr=r(Et);cn=i(Nr,`This paper describes Facebook FAIR\u2019s submission to the WMT19 shared news translation task. We participate in two
language pairs and four language directions, English <-> German and English <-> Russian. Following our submission from
last year, our baseline systems are large BPE-based transformer models trained with the Fairseq sequence modeling
toolkit which rely on sampled back-translations. This year we experiment with different bitext data filtering schemes,
as well as with adding filtered back-translated data. We also ensemble and fine-tune our models on domain-specific
data, then decode using noisy channel model reranking. Our submissions are ranked first in all four directions of the
human evaluation campaign. On En->De, our system significantly outperforms other systems as well as human translations.
This system improves upon our WMT\u201918 submission by 4.5 BLEU points.`),Nr.forEach(o),Dr.forEach(o),To=c(t),j=s(t,"P",{});var vt=r(j);hn=i(vt,"This model was contributed by "),Se=s(vt,"A",{href:!0,rel:!0});var Lr=r(Se);mn=i(Lr,"stas"),Lr.forEach(o),pn=i(vt,`. The original code can be found
`),ze=s(vt,"A",{href:!0,rel:!0});var jr=r(ze);fn=i(jr,"here"),jr.forEach(o),un=i(vt,"."),vt.forEach(o),vo=c(t),V=s(t,"H2",{class:!0});var Po=r(V);ae=s(Po,"A",{id:!0,class:!0,href:!0});var Or=r(ae);Ct=s(Or,"SPAN",{});var Gr=r(Ct);b(qe.$$.fragment,Gr),Gr.forEach(o),Or.forEach(o),_n=c(Po),Pt=s(Po,"SPAN",{});var Rr=r(Pt);gn=i(Rr,"Implementation Notes"),Rr.forEach(o),Po.forEach(o),bo=c(t),at=s(t,"UL",{});var Wr=r(at);Q=s(Wr,"LI",{});var bt=r(Q);kn=i(bt,`FSMT uses source and target vocabulary pairs that aren\u2019t combined into one. It doesn\u2019t share embeddings tokens
either. Its tokenizer is very similar to `),it=s(bt,"A",{href:!0});var Br=r(it);Tn=i(Br,"XLMTokenizer"),Br.forEach(o),vn=i(bt,` and the main model is derived from
`),dt=s(bt,"A",{href:!0});var Ur=r(dt);bn=i(Ur,"BartModel"),Ur.forEach(o),yn=i(bt,"."),bt.forEach(o),Wr.forEach(o),yo=c(t),X=s(t,"H2",{class:!0});var Io=r(X);ie=s(Io,"A",{id:!0,class:!0,href:!0});var Hr=r(ie);It=s(Hr,"SPAN",{});var Vr=r(It);b(xe.$$.fragment,Vr),Vr.forEach(o),Hr.forEach(o),Mn=c(Io),At=s(Io,"SPAN",{});var Qr=r(At);wn=i(Qr,"FSMTConfig"),Qr.forEach(o),Io.forEach(o),Mo=c(t),z=s(t,"DIV",{class:!0});var G=r(z);b(Ee.$$.fragment,G),Fn=c(G),Ce=s(G,"P",{});var Ao=r(Ce);$n=i(Ao,"This is the configuration class to store the configuration of a "),lt=s(Ao,"A",{href:!0});var Xr=r(lt);Sn=i(Xr,"FSMTModel"),Xr.forEach(o),zn=i(Ao,`. It is used to instantiate a FSMT
model according to the specified arguments, defining the model architecture.`),Ao.forEach(o),qn=c(G),K=s(G,"P",{});var yt=r(K);xn=i(yt,"Configuration objects inherit from "),ct=s(yt,"A",{href:!0});var Kr=r(ct);En=i(Kr,"PretrainedConfig"),Kr.forEach(o),Cn=i(yt,` and can be used to control the model outputs. Read the
documentation from `),ht=s(yt,"A",{href:!0});var Yr=r(ht);Pn=i(Yr,"PretrainedConfig"),Yr.forEach(o),In=i(yt," for more information."),yt.forEach(o),An=c(G),b(de.$$.fragment,G),Dn=c(G),le=s(G,"DIV",{class:!0});var Do=r(le);b(Pe.$$.fragment,Do),Nn=c(Do),Y=s(Do,"P",{});var Mt=r(Y);Ln=i(Mt,"Serializes this instance to a Python dictionary. Override the default "),Dt=s(Mt,"EM",{});var Jr=r(Dt);jn=i(Jr,"to_dict()"),Jr.forEach(o),On=i(Mt," from "),Nt=s(Mt,"EM",{});var Zr=r(Nt);Gn=i(Zr,"PretrainedConfig"),Zr.forEach(o),Rn=i(Mt,"."),Mt.forEach(o),Do.forEach(o),G.forEach(o),wo=c(t),J=s(t,"H2",{class:!0});var No=r(J);ce=s(No,"A",{id:!0,class:!0,href:!0});var ea=r(ce);Lt=s(ea,"SPAN",{});var ta=r(Lt);b(Ie.$$.fragment,ta),ta.forEach(o),ea.forEach(o),Wn=c(No),jt=s(No,"SPAN",{});var oa=r(jt);Bn=i(oa,"FSMTTokenizer"),oa.forEach(o),No.forEach(o),Fo=c(t),$=s(t,"DIV",{class:!0});var S=r($);b(Ae.$$.fragment,S),Un=c(S),Ot=s(S,"P",{});var na=r(Ot);Hn=i(na,"Construct an FAIRSEQ Transformer tokenizer. Based on Byte-Pair Encoding. The tokenization process is the following:"),na.forEach(o),Vn=c(S),D=s(S,"UL",{});var ve=r(D);Gt=s(ve,"LI",{});var sa=r(Gt);Qn=i(sa,"Moses preprocessing and tokenization."),sa.forEach(o),Xn=c(ve),Rt=s(ve,"LI",{});var ra=r(Rt);Kn=i(ra,"Normalizing all inputs text."),ra.forEach(o),Yn=c(ve),N=s(ve,"LI",{});var be=r(N);Jn=i(be,"The arguments "),Wt=s(be,"CODE",{});var aa=r(Wt);Zn=i(aa,"special_tokens"),aa.forEach(o),es=i(be," and the function "),Bt=s(be,"CODE",{});var ia=r(Bt);ts=i(ia,"set_special_tokens"),ia.forEach(o),os=i(be,`, can be used to add additional symbols (like
\u201D`),Ut=s(be,"STRONG",{});var da=r(Ut);ns=i(da,"classify"),da.forEach(o),ss=i(be,"\u201D) to a vocabulary."),be.forEach(o),rs=c(ve),De=s(ve,"LI",{});var Lo=r(De);as=i(Lo,"The argument "),Ht=s(Lo,"CODE",{});var la=r(Ht);is=i(la,"langs"),la.forEach(o),ds=i(Lo," defines a pair of languages."),Lo.forEach(o),ve.forEach(o),ls=c(S),Ne=s(S,"P",{});var jo=r(Ne);cs=i(jo,"This tokenizer inherits from "),mt=s(jo,"A",{href:!0});var ca=r(mt);hs=i(ca,"PreTrainedTokenizer"),ca.forEach(o),ms=i(jo,` which contains most of the main methods. Users should refer to
this superclass for more information regarding those methods.`),jo.forEach(o),ps=c(S),O=s(S,"DIV",{class:!0});var wt=r(O);b(Le.$$.fragment,wt),fs=c(wt),Vt=s(wt,"P",{});var ha=r(Vt);us=i(ha,`Build model inputs from a sequence or a pair of sequence for sequence classification tasks by concatenating and
adding special tokens. A FAIRSEQ Transformer sequence has the following format:`),ha.forEach(o),_s=c(wt),je=s(wt,"UL",{});var Oo=r(je);pt=s(Oo,"LI",{});var zr=r(pt);gs=i(zr,"single sequence: "),Qt=s(zr,"CODE",{});var ma=r(Qt);ks=i(ma,"<s> X </s>"),ma.forEach(o),zr.forEach(o),Ts=c(Oo),ft=s(Oo,"LI",{});var qr=r(ft);vs=i(qr,"pair of sequences: "),Xt=s(qr,"CODE",{});var pa=r(Xt);bs=i(pa,"<s> A </s> B </s>"),pa.forEach(o),qr.forEach(o),Oo.forEach(o),wt.forEach(o),ys=c(S),he=s(S,"DIV",{class:!0});var Go=r(he);b(Oe.$$.fragment,Go),Ms=c(Go),Ge=s(Go,"P",{});var Ro=r(Ge);ws=i(Ro,`Retrieve sequence ids from a token list that has no special tokens added. This method is called when adding
special tokens using the tokenizer `),Kt=s(Ro,"CODE",{});var fa=r(Kt);Fs=i(fa,"prepare_for_model"),fa.forEach(o),$s=i(Ro," method."),Ro.forEach(o),Go.forEach(o),Ss=c(S),C=s(S,"DIV",{class:!0});var R=r(C);b(Re.$$.fragment,R),zs=c(R),Yt=s(R,"P",{});var ua=r(Yt);qs=i(ua,`Create a mask from the two sequences passed to be used in a sequence-pair classification task. A FAIRSEQ
Transformer sequence pair mask has the following format:`),ua.forEach(o),xs=c(R),b(me.$$.fragment,R),Es=c(R),Z=s(R,"P",{});var Ft=r(Z);Cs=i(Ft,"If "),Jt=s(Ft,"CODE",{});var _a=r(Jt);Ps=i(_a,"token_ids_1"),_a.forEach(o),Is=i(Ft," is "),Zt=s(Ft,"CODE",{});var ga=r(Zt);As=i(ga,"None"),ga.forEach(o),Ds=i(Ft,", this method only returns the first portion of the mask (0s)."),Ft.forEach(o),Ns=c(R),eo=s(R,"P",{});var ka=r(eo);Ls=i(ka,`Creates a mask from the two sequences passed to be used in a sequence-pair classification task. An
FAIRSEQ_TRANSFORMER sequence pair mask has the following format:`),ka.forEach(o),R.forEach(o),js=c(S),ut=s(S,"DIV",{class:!0});var Ta=r(ut);b(We.$$.fragment,Ta),Ta.forEach(o),S.forEach(o),$o=c(t),ee=s(t,"H2",{class:!0});var Wo=r(ee);pe=s(Wo,"A",{id:!0,class:!0,href:!0});var va=r(pe);to=s(va,"SPAN",{});var ba=r(to);b(Be.$$.fragment,ba),ba.forEach(o),va.forEach(o),Os=c(Wo),oo=s(Wo,"SPAN",{});var ya=r(oo);Gs=i(ya,"FSMTModel"),ya.forEach(o),Wo.forEach(o),So=c(t),q=s(t,"DIV",{class:!0});var W=r(q);b(Ue.$$.fragment,W),Rs=c(W),no=s(W,"P",{});var Ma=r(no);Ws=i(Ma,"The bare FSMT Model outputting raw hidden-states without any specific head on top."),Ma.forEach(o),Bs=c(W),He=s(W,"P",{});var Bo=r(He);Us=i(Bo,"This model inherits from "),_t=s(Bo,"A",{href:!0});var wa=r(_t);Hs=i(wa,"PreTrainedModel"),wa.forEach(o),Vs=i(Bo,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Bo.forEach(o),Qs=c(W),Ve=s(W,"P",{});var Uo=r(Ve);Xs=i(Uo,"This model is also a PyTorch "),Qe=s(Uo,"A",{href:!0,rel:!0});var Fa=r(Qe);Ks=i(Fa,"torch.nn.Module"),Fa.forEach(o),Ys=i(Uo,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Uo.forEach(o),Js=c(W),P=s(W,"DIV",{class:!0});var ye=r(P);b(Xe.$$.fragment,ye),Zs=c(ye),te=s(ye,"P",{});var $t=r(te);er=i($t,"The "),gt=s($t,"A",{href:!0});var $a=r(gt);tr=i($a,"FSMTModel"),$a.forEach(o),or=i($t," forward method, overrides the "),so=s($t,"CODE",{});var Sa=r(so);nr=i(Sa,"__call__"),Sa.forEach(o),sr=i($t," special method."),$t.forEach(o),rr=c(ye),b(fe.$$.fragment,ye),ar=c(ye),b(ue.$$.fragment,ye),ye.forEach(o),W.forEach(o),zo=c(t),oe=s(t,"H2",{class:!0});var Ho=r(oe);_e=s(Ho,"A",{id:!0,class:!0,href:!0});var za=r(_e);ro=s(za,"SPAN",{});var qa=r(ro);b(Ke.$$.fragment,qa),qa.forEach(o),za.forEach(o),ir=c(Ho),ao=s(Ho,"SPAN",{});var xa=r(ao);dr=i(xa,"FSMTForConditionalGeneration"),xa.forEach(o),Ho.forEach(o),qo=c(t),x=s(t,"DIV",{class:!0});var B=r(x);b(Ye.$$.fragment,B),lr=c(B),io=s(B,"P",{});var Ea=r(io);cr=i(Ea,"The FSMT Model with a language modeling head. Can be used for summarization."),Ea.forEach(o),hr=c(B),Je=s(B,"P",{});var Vo=r(Je);mr=i(Vo,"This model inherits from "),kt=s(Vo,"A",{href:!0});var Ca=r(kt);pr=i(Ca,"PreTrainedModel"),Ca.forEach(o),fr=i(Vo,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving, resizing the input embeddings, pruning heads
etc.)`),Vo.forEach(o),ur=c(B),Ze=s(B,"P",{});var Qo=r(Ze);_r=i(Qo,"This model is also a PyTorch "),et=s(Qo,"A",{href:!0,rel:!0});var Pa=r(et);gr=i(Pa,"torch.nn.Module"),Pa.forEach(o),kr=i(Qo,` subclass.
Use it as a regular PyTorch Module and refer to the PyTorch documentation for all matter related to general usage
and behavior.`),Qo.forEach(o),Tr=c(B),I=s(B,"DIV",{class:!0});var Me=r(I);b(tt.$$.fragment,Me),vr=c(Me),ne=s(Me,"P",{});var St=r(ne);br=i(St,"The "),Tt=s(St,"A",{href:!0});var Ia=r(Tt);yr=i(Ia,"FSMTForConditionalGeneration"),Ia.forEach(o),Mr=i(St," forward method, overrides the "),lo=s(St,"CODE",{});var Aa=r(lo);wr=i(Aa,"__call__"),Aa.forEach(o),Fr=i(St," special method."),St.forEach(o),$r=c(Me),b(ge.$$.fragment,Me),Sr=c(Me),b(ke.$$.fragment,Me),Me.forEach(o),B.forEach(o),this.h()},h(){h(m,"name","hf:doc:metadata"),h(m,"content",JSON.stringify(Xa)),h(u,"id","fsmt"),h(u,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(u,"href","#fsmt"),h(f,"class","relative group"),h(we,"href","https://github.com/huggingface/transformers/issues/new?assignees=&labels=&template=bug-report.md&title"),h(we,"rel","nofollow"),h(se,"id","overview"),h(se,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(se,"href","#overview"),h(H,"class","relative group"),h($e,"href","https://arxiv.org/abs/1907.06616"),h($e,"rel","nofollow"),h(Se,"href","https://huggingface.co/stas"),h(Se,"rel","nofollow"),h(ze,"href","https://github.com/pytorch/fairseq/tree/master/examples/wmt19"),h(ze,"rel","nofollow"),h(ae,"id","implementation-notes"),h(ae,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(ae,"href","#implementation-notes"),h(V,"class","relative group"),h(it,"href","/docs/transformers/pr_highlight/en/model_doc/xlm#transformers.XLMTokenizer"),h(dt,"href","/docs/transformers/pr_highlight/en/model_doc/bart#transformers.BartModel"),h(ie,"id","transformers.FSMTConfig"),h(ie,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(ie,"href","#transformers.FSMTConfig"),h(X,"class","relative group"),h(lt,"href","/docs/transformers/pr_highlight/en/model_doc/fsmt#transformers.FSMTModel"),h(ct,"href","/docs/transformers/pr_highlight/en/main_classes/configuration#transformers.PretrainedConfig"),h(ht,"href","/docs/transformers/pr_highlight/en/main_classes/configuration#transformers.PretrainedConfig"),h(le,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(z,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(ce,"id","transformers.FSMTTokenizer"),h(ce,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(ce,"href","#transformers.FSMTTokenizer"),h(J,"class","relative group"),h(mt,"href","/docs/transformers/pr_highlight/en/main_classes/tokenizer#transformers.PreTrainedTokenizer"),h(O,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(he,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(C,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(ut,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h($,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(pe,"id","transformers.FSMTModel"),h(pe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(pe,"href","#transformers.FSMTModel"),h(ee,"class","relative group"),h(_t,"href","/docs/transformers/pr_highlight/en/main_classes/model#transformers.PreTrainedModel"),h(Qe,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),h(Qe,"rel","nofollow"),h(gt,"href","/docs/transformers/pr_highlight/en/model_doc/fsmt#transformers.FSMTModel"),h(P,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(q,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(_e,"id","transformers.FSMTForConditionalGeneration"),h(_e,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(_e,"href","#transformers.FSMTForConditionalGeneration"),h(oe,"class","relative group"),h(kt,"href","/docs/transformers/pr_highlight/en/main_classes/model#transformers.PreTrainedModel"),h(et,"href","https://pytorch.org/docs/stable/nn.html#torch.nn.Module"),h(et,"rel","nofollow"),h(Tt,"href","/docs/transformers/pr_highlight/en/model_doc/fsmt#transformers.FSMTForConditionalGeneration"),h(I,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8"),h(x,"class","docstring border-l-2 border-t-2 pl-4 pt-3.5 border-gray-100 rounded-tl-xl mb-6 mt-8")},m(t,p){e(document.head,m),_(t,k,p),_(t,f,p),e(f,u),e(u,T),y(d,T,null),e(f,g),e(f,A),e(A,Jo),_(t,fo,p),_(t,U,p),e(U,zt),e(zt,Zo),e(U,en),e(U,we),e(we,tn),e(U,on),_(t,uo,p),_(t,H,p),e(H,se),e(se,qt),y(Fe,qt,null),e(H,nn),e(H,xt),e(xt,sn),_(t,_o,p),_(t,re,p),e(re,rn),e(re,$e),e($e,an),e(re,dn),_(t,go,p),_(t,st,p),e(st,ln),_(t,ko,p),_(t,rt,p),e(rt,Et),e(Et,cn),_(t,To,p),_(t,j,p),e(j,hn),e(j,Se),e(Se,mn),e(j,pn),e(j,ze),e(ze,fn),e(j,un),_(t,vo,p),_(t,V,p),e(V,ae),e(ae,Ct),y(qe,Ct,null),e(V,_n),e(V,Pt),e(Pt,gn),_(t,bo,p),_(t,at,p),e(at,Q),e(Q,kn),e(Q,it),e(it,Tn),e(Q,vn),e(Q,dt),e(dt,bn),e(Q,yn),_(t,yo,p),_(t,X,p),e(X,ie),e(ie,It),y(xe,It,null),e(X,Mn),e(X,At),e(At,wn),_(t,Mo,p),_(t,z,p),y(Ee,z,null),e(z,Fn),e(z,Ce),e(Ce,$n),e(Ce,lt),e(lt,Sn),e(Ce,zn),e(z,qn),e(z,K),e(K,xn),e(K,ct),e(ct,En),e(K,Cn),e(K,ht),e(ht,Pn),e(K,In),e(z,An),y(de,z,null),e(z,Dn),e(z,le),y(Pe,le,null),e(le,Nn),e(le,Y),e(Y,Ln),e(Y,Dt),e(Dt,jn),e(Y,On),e(Y,Nt),e(Nt,Gn),e(Y,Rn),_(t,wo,p),_(t,J,p),e(J,ce),e(ce,Lt),y(Ie,Lt,null),e(J,Wn),e(J,jt),e(jt,Bn),_(t,Fo,p),_(t,$,p),y(Ae,$,null),e($,Un),e($,Ot),e(Ot,Hn),e($,Vn),e($,D),e(D,Gt),e(Gt,Qn),e(D,Xn),e(D,Rt),e(Rt,Kn),e(D,Yn),e(D,N),e(N,Jn),e(N,Wt),e(Wt,Zn),e(N,es),e(N,Bt),e(Bt,ts),e(N,os),e(N,Ut),e(Ut,ns),e(N,ss),e(D,rs),e(D,De),e(De,as),e(De,Ht),e(Ht,is),e(De,ds),e($,ls),e($,Ne),e(Ne,cs),e(Ne,mt),e(mt,hs),e(Ne,ms),e($,ps),e($,O),y(Le,O,null),e(O,fs),e(O,Vt),e(Vt,us),e(O,_s),e(O,je),e(je,pt),e(pt,gs),e(pt,Qt),e(Qt,ks),e(je,Ts),e(je,ft),e(ft,vs),e(ft,Xt),e(Xt,bs),e($,ys),e($,he),y(Oe,he,null),e(he,Ms),e(he,Ge),e(Ge,ws),e(Ge,Kt),e(Kt,Fs),e(Ge,$s),e($,Ss),e($,C),y(Re,C,null),e(C,zs),e(C,Yt),e(Yt,qs),e(C,xs),y(me,C,null),e(C,Es),e(C,Z),e(Z,Cs),e(Z,Jt),e(Jt,Ps),e(Z,Is),e(Z,Zt),e(Zt,As),e(Z,Ds),e(C,Ns),e(C,eo),e(eo,Ls),e($,js),e($,ut),y(We,ut,null),_(t,$o,p),_(t,ee,p),e(ee,pe),e(pe,to),y(Be,to,null),e(ee,Os),e(ee,oo),e(oo,Gs),_(t,So,p),_(t,q,p),y(Ue,q,null),e(q,Rs),e(q,no),e(no,Ws),e(q,Bs),e(q,He),e(He,Us),e(He,_t),e(_t,Hs),e(He,Vs),e(q,Qs),e(q,Ve),e(Ve,Xs),e(Ve,Qe),e(Qe,Ks),e(Ve,Ys),e(q,Js),e(q,P),y(Xe,P,null),e(P,Zs),e(P,te),e(te,er),e(te,gt),e(gt,tr),e(te,or),e(te,so),e(so,nr),e(te,sr),e(P,rr),y(fe,P,null),e(P,ar),y(ue,P,null),_(t,zo,p),_(t,oe,p),e(oe,_e),e(_e,ro),y(Ke,ro,null),e(oe,ir),e(oe,ao),e(ao,dr),_(t,qo,p),_(t,x,p),y(Ye,x,null),e(x,lr),e(x,io),e(io,cr),e(x,hr),e(x,Je),e(Je,mr),e(Je,kt),e(kt,pr),e(Je,fr),e(x,ur),e(x,Ze),e(Ze,_r),e(Ze,et),e(et,gr),e(Ze,kr),e(x,Tr),e(x,I),y(tt,I,null),e(I,vr),e(I,ne),e(ne,br),e(ne,Tt),e(Tt,yr),e(ne,Mr),e(ne,lo),e(lo,wr),e(ne,Fr),e(I,$r),y(ge,I,null),e(I,Sr),y(ke,I,null),xo=!0},p(t,[p]){const ot={};p&2&&(ot.$$scope={dirty:p,ctx:t}),de.$set(ot);const co={};p&2&&(co.$$scope={dirty:p,ctx:t}),me.$set(co);const ho={};p&2&&(ho.$$scope={dirty:p,ctx:t}),fe.$set(ho);const mo={};p&2&&(mo.$$scope={dirty:p,ctx:t}),ue.$set(mo);const Te={};p&2&&(Te.$$scope={dirty:p,ctx:t}),ge.$set(Te);const po={};p&2&&(po.$$scope={dirty:p,ctx:t}),ke.$set(po)},i(t){xo||(M(d.$$.fragment,t),M(Fe.$$.fragment,t),M(qe.$$.fragment,t),M(xe.$$.fragment,t),M(Ee.$$.fragment,t),M(de.$$.fragment,t),M(Pe.$$.fragment,t),M(Ie.$$.fragment,t),M(Ae.$$.fragment,t),M(Le.$$.fragment,t),M(Oe.$$.fragment,t),M(Re.$$.fragment,t),M(me.$$.fragment,t),M(We.$$.fragment,t),M(Be.$$.fragment,t),M(Ue.$$.fragment,t),M(Xe.$$.fragment,t),M(fe.$$.fragment,t),M(ue.$$.fragment,t),M(Ke.$$.fragment,t),M(Ye.$$.fragment,t),M(tt.$$.fragment,t),M(ge.$$.fragment,t),M(ke.$$.fragment,t),xo=!0)},o(t){w(d.$$.fragment,t),w(Fe.$$.fragment,t),w(qe.$$.fragment,t),w(xe.$$.fragment,t),w(Ee.$$.fragment,t),w(de.$$.fragment,t),w(Pe.$$.fragment,t),w(Ie.$$.fragment,t),w(Ae.$$.fragment,t),w(Le.$$.fragment,t),w(Oe.$$.fragment,t),w(Re.$$.fragment,t),w(me.$$.fragment,t),w(We.$$.fragment,t),w(Be.$$.fragment,t),w(Ue.$$.fragment,t),w(Xe.$$.fragment,t),w(fe.$$.fragment,t),w(ue.$$.fragment,t),w(Ke.$$.fragment,t),w(Ye.$$.fragment,t),w(tt.$$.fragment,t),w(ge.$$.fragment,t),w(ke.$$.fragment,t),xo=!1},d(t){o(m),t&&o(k),t&&o(f),F(d),t&&o(fo),t&&o(U),t&&o(uo),t&&o(H),F(Fe),t&&o(_o),t&&o(re),t&&o(go),t&&o(st),t&&o(ko),t&&o(rt),t&&o(To),t&&o(j),t&&o(vo),t&&o(V),F(qe),t&&o(bo),t&&o(at),t&&o(yo),t&&o(X),F(xe),t&&o(Mo),t&&o(z),F(Ee),F(de),F(Pe),t&&o(wo),t&&o(J),F(Ie),t&&o(Fo),t&&o($),F(Ae),F(Le),F(Oe),F(Re),F(me),F(We),t&&o($o),t&&o(ee),F(Be),t&&o(So),t&&o(q),F(Ue),F(Xe),F(fe),F(ue),t&&o(zo),t&&o(oe),F(Ke),t&&o(qo),t&&o(x),F(Ye),F(tt),F(ge),F(ke)}}}const Xa={local:"fsmt",sections:[{local:"overview",title:"Overview"},{local:"implementation-notes",title:"Implementation Notes"},{local:"transformers.FSMTConfig",title:"FSMTConfig"},{local:"transformers.FSMTTokenizer",title:"FSMTTokenizer"},{local:"transformers.FSMTModel",title:"FSMTModel"},{local:"transformers.FSMTForConditionalGeneration",title:"FSMTForConditionalGeneration"}],title:"FSMT"};function Ka(E){return Ga(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class ni extends Na{constructor(m){super();La(this,m,Ka,Qa,ja,{})}}export{ni as default,Xa as metadata};
