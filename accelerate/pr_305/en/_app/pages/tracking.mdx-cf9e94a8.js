import{S as Bn,i as Sn,s as zn,e as s,k as i,w as m,t as r,M as Nn,c as n,d as a,m as p,a as l,x as h,h as o,b as u,F as t,g as d,y as f,L as Wn,q as g,o as _,B as v,v as Mn}from"../chunks/vendor-19e06bd2.js";import{D as w}from"../chunks/Docstring-395e5a9c.js";import{C as M}from"../chunks/CodeBlock-9dd1fdfb.js";import{I as or}from"../chunks/IconCopyLink-3c713d38.js";function Vn(Os){let P,Xt,O,V,nt,se,sr,lt,nr,Yt,ne,lr,Ue,cr,Zt,I,G,ct,le,ir,it,pr,ea,R,dr,pt,ur,mr,ta,y,ce,hr,q,fr,dt,gr,_r,ut,vr,yr,kr,U,ie,$r,pe,br,mt,wr,Er,Tr,H,de,Ar,ue,jr,ht,Dr,Cr,xr,F,me,Lr,he,Pr,ft,Or,Ir,aa,k,fe,qr,B,Br,gt,Sr,zr,_t,Nr,Wr,Mr,J,ge,Vr,_e,Gr,vt,Rr,Ur,Hr,K,ve,Fr,ye,Jr,yt,Kr,Qr,Xr,Q,ke,Yr,$e,Zr,kt,eo,to,ra,$,be,ao,S,ro,$t,oo,so,bt,no,lo,co,wt,io,po,X,we,uo,Ee,mo,Et,ho,fo,go,Y,Te,_o,Ae,vo,Tt,yo,ko,oa,E,$o,At,bo,wo,jt,Eo,To,sa,je,na,Z,Ao,He,jo,Do,la,De,ca,T,Co,Fe,xo,Lo,Dt,Po,Oo,ia,Ce,pa,ee,Io,Je,qo,Bo,da,xe,ua,Ke,So,ma,Le,ha,z,te,Ct,Pe,zo,xt,No,fa,A,Wo,Lt,Mo,Vo,Pt,Go,Ro,ga,j,Oe,Ot,Uo,Ho,Ie,qe,Fo,It,Jo,Ko,Qo,Be,Xo,qt,Yo,Zo,es,Se,Bt,ts,as,St,ze,rs,zt,os,ss,ns,Ne,Nt,ls,cs,Wt,N,is,Mt,ps,ds,Vt,us,ms,_a,Qe,hs,va,We,ya,b,fs,Gt,gs,_s,Rt,vs,ys,Ut,ks,$s,ka,Me,$a,ae,bs,Ht,ws,Es,ba,Ve,wa,W,re,Ft,Ge,Ts,Jt,As,Ea,D,js,Kt,Ds,Cs,Qt,xs,Ls,Ta,Re,Aa;return se=new or({}),le=new or({}),ce=new w({props:{name:"class accelerate.tracking.TensorBoardTracker",anchor:"accelerate.tracking.TensorBoardTracker",parameters:[{name:"run_name",val:": str"},{name:"logging_dir",val:": typing.Union[str, os.PathLike, NoneType] = ''"}],source:"https://github.com/huggingface/accelerate/blob/pr_305/src/accelerate/tracking.py#L92",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run`,name:"run_name"},{anchor:"accelerate.tracking.TensorBoardTracker.logging_dir",description:`<strong>logging_dir</strong> (<code>str</code>, <code>os.PathLike</code>) &#x2014;
Location for TensorBoard logs to be stored.`,name:"logging_dir"}]}}),ie=new w({props:{name:"finish",anchor:"accelerate.tracking.TensorBoardTracker.finish",parameters:[],source:"https://github.com/huggingface/accelerate/blob/pr_305/src/accelerate/tracking.py#L143"}}),de=new w({props:{name:"log",anchor:"accelerate.tracking.TensorBoardTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_305/src/accelerate/tracking.py#L125",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.TensorBoardTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),me=new w({props:{name:"store_init_configuration",anchor:"accelerate.tracking.TensorBoardTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_305/src/accelerate/tracking.py#L112",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),fe=new w({props:{name:"class accelerate.tracking.WandBTracker",anchor:"accelerate.tracking.WandBTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_305/src/accelerate/tracking.py#L151",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run.`,name:"run_name"}]}}),ge=new w({props:{name:"finish",anchor:"accelerate.tracking.WandBTracker.finish",parameters:[],source:"https://github.com/huggingface/accelerate/blob/pr_305/src/accelerate/tracking.py#L193"}}),ve=new w({props:{name:"log",anchor:"accelerate.tracking.WandBTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_305/src/accelerate/tracking.py#L180",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.WandBTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),ke=new w({props:{name:"store_init_configuration",anchor:"accelerate.tracking.WandBTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_305/src/accelerate/tracking.py#L168",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),be=new w({props:{name:"class accelerate.tracking.CometMLTracker",anchor:"accelerate.tracking.CometMLTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_305/src/accelerate/tracking.py#L201",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run.`,name:"run_name"}]}}),we=new w({props:{name:"log",anchor:"accelerate.tracking.CometMLTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_305/src/accelerate/tracking.py#L232",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.CometMLTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),Te=new w({props:{name:"store_init_configuration",anchor:"accelerate.tracking.CometMLTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_305/src/accelerate/tracking.py#L220",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),je=new M({props:{code:`from accelerate import Accelerate
from accelerate.utils import LoggerType

accelerator = Accelerate(log_with="all")  # For all available trackers in the environment
accelerator = Accelerate(log_with="wandb")
accelerator = Accelerate(log_with=["wandb", LoggerType.TENSORBOARD])`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerate
<span class="hljs-keyword">from</span> accelerate.utils <span class="hljs-keyword">import</span> LoggerType

accelerator = Accelerate(log_with=<span class="hljs-string">&quot;all&quot;</span>)  <span class="hljs-comment"># For all available trackers in the environment</span>
accelerator = Accelerate(log_with=<span class="hljs-string">&quot;wandb&quot;</span>)
accelerator = Accelerate(log_with=[<span class="hljs-string">&quot;wandb&quot;</span>, LoggerType.TENSORBOARD])`}}),De=new M({props:{code:`hps = {"num_iterations": 5, "learning_rate": 1e-2}
accelerator.init_trackers("my_project", config=hps)`,highlighted:`hps = {<span class="hljs-string">&quot;num_iterations&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&quot;learning_rate&quot;</span>: <span class="hljs-number">1e-2</span>}
accelerator.init_trackers(<span class="hljs-string">&quot;my_project&quot;</span>, config=hps)`}}),Ce=new M({props:{code:'accelerator.log({"train_loss": 1.12, "valid_loss": 0.8}, step=1)',highlighted:'accelerator.log({<span class="hljs-string">&quot;train_loss&quot;</span>: <span class="hljs-number">1.12</span>, <span class="hljs-string">&quot;valid_loss&quot;</span>: <span class="hljs-number">0.8</span>}, step=<span class="hljs-number">1</span>)'}}),xe=new M({props:{code:"accelerator.end_training()",highlighted:"accelerator.end_training()"}}),Le=new M({props:{code:`from accelerate import Accelerator

accelerator = Accelerator(log_with="all")
config = {
    "num_iterations": 5,
    "learning_rate": 1e-2,
    "loss_function": str(my_loss_function),
}

accelerator.init_trackers("example_project", config=config)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config["num_iterations"]:
    for step, batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        accelerator.backward(loss)
        my_optimizer.step()
        accelerator.log({"training_loss": loss}, step=step)
accelerator.end_training()`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator

accelerator = Accelerator(log_with=<span class="hljs-string">&quot;all&quot;</span>)
config = {
    <span class="hljs-string">&quot;num_iterations&quot;</span>: <span class="hljs-number">5</span>,
    <span class="hljs-string">&quot;learning_rate&quot;</span>: <span class="hljs-number">1e-2</span>,
    <span class="hljs-string">&quot;loss_function&quot;</span>: <span class="hljs-built_in">str</span>(my_loss_function),
}

accelerator.init_trackers(<span class="hljs-string">&quot;example_project&quot;</span>, config=config)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

<span class="hljs-keyword">for</span> iteration <span class="hljs-keyword">in</span> config[<span class="hljs-string">&quot;num_iterations&quot;</span>]:
    <span class="hljs-keyword">for</span> step, batch <span class="hljs-keyword">in</span> my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        accelerator.backward(loss)
        my_optimizer.step()
        accelerator.log({<span class="hljs-string">&quot;training_loss&quot;</span>: loss}, step=step)
accelerator.end_training()`}}),Pe=new or({}),We=new M({props:{code:`from accelerate.tracking import GeneralTracker
from typing import Optional

import wandb


class MyCustomTracker(GeneralTracker):
    def __init__(self, run_name: str):
        self.run_name = run_name
        wandb.init(self.run_name)

    def store_init_configuration(self, values: dict):
        wandb.config(values)

    def log(self, values: dict, step: Optional[int] = None):
        wandb.log(values, step=step)`,highlighted:`<span class="hljs-keyword">from</span> accelerate.tracking <span class="hljs-keyword">import</span> GeneralTracker
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>

<span class="hljs-keyword">import</span> wandb


<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCustomTracker</span>(<span class="hljs-title class_ inherited__">GeneralTracker</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, run_name: <span class="hljs-built_in">str</span></span>):
        self.run_name = run_name
        wandb.init(self.run_name)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">store_init_configuration</span>(<span class="hljs-params">self, values: <span class="hljs-built_in">dict</span></span>):
        wandb.config(values)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">self, values: <span class="hljs-built_in">dict</span>, step: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span></span>):
        wandb.log(values, step=step)`}}),Me=new M({props:{code:`tracker = MyCustomTracker("some_run_name")
accelerator = Accelerate(log_with=tracker)`,highlighted:`tracker = MyCustomTracker(<span class="hljs-string">&quot;some_run_name&quot;</span>)
accelerator = Accelerate(log_with=tracker)`}}),Ve=new M({props:{code:`tracker = MyCustomTracker("some_run_name")
accelerator = Accelerate(log_with=[tracker, "all"])`,highlighted:`tracker = MyCustomTracker(<span class="hljs-string">&quot;some_run_name&quot;</span>)
accelerator = Accelerate(log_with=[tracker, <span class="hljs-string">&quot;all&quot;</span>])`}}),Ge=new or({}),Re=new M({props:{code:`from accelerate import Accelerator
+ import neptune.new as neptune

accelerator = Accelerator()
+ run = neptune.init(...)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config["num_iterations"]:
    for batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        total_loss += loss
        accelerator.backward(loss)
        my_optimizer.step()
+       if accelerator.is_main_process:
+           run["logs/training/batch/loss"].log(loss)`,highlighted:`from accelerate import Accelerator
<span class="hljs-addition">+ import neptune.new as neptune</span>

accelerator = Accelerator()
<span class="hljs-addition">+ run = neptune.init(...)</span>

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config[&quot;num_iterations&quot;]:
    for batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        total_loss += loss
        accelerator.backward(loss)
        my_optimizer.step()
<span class="hljs-addition">+       if accelerator.is_main_process:</span>
<span class="hljs-addition">+           run[&quot;logs/training/batch/loss&quot;].log(loss)</span>`}}),{c(){P=s("meta"),Xt=i(),O=s("h1"),V=s("a"),nt=s("span"),m(se.$$.fragment),sr=i(),lt=s("span"),nr=r("Tracking"),Yt=i(),ne=s("p"),lr=r(`There are a large number of experiment tracking API\u2019s available, however getting them all to work with in a multi-processing environment can oftentimes be complex.
Accelerate provides a general tracking API that can be used to log useful items during your script through `),Ue=s("a"),cr=r("log()"),Zt=i(),I=s("h2"),G=s("a"),ct=s("span"),m(le.$$.fragment),ir=i(),it=s("span"),pr=r("Integrated Trackers"),ea=i(),R=s("p"),dr=r("Currently "),pt=s("code"),ur=r("Accelerate"),mr=r(" supports three trackers out-of-the-box:"),ta=i(),y=s("div"),m(ce.$$.fragment),hr=i(),q=s("p"),fr=r("A "),dt=s("code"),gr=r("Tracker"),_r=r(" class that supports "),ut=s("code"),vr=r("tensorboard"),yr=r(". Should be initialized at the start of your script."),kr=i(),U=s("div"),m(ie.$$.fragment),$r=i(),pe=s("p"),br=r("Closes "),mt=s("code"),wr=r("TensorBoard"),Er=r(" writer"),Tr=i(),H=s("div"),m(de.$$.fragment),Ar=i(),ue=s("p"),jr=r("Logs "),ht=s("code"),Dr=r("values"),Cr=r(" to the current run."),xr=i(),F=s("div"),m(me.$$.fragment),Lr=i(),he=s("p"),Pr=r("Logs "),ft=s("code"),Or=r("values"),Ir=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),aa=i(),k=s("div"),m(fe.$$.fragment),qr=i(),B=s("p"),Br=r("A "),gt=s("code"),Sr=r("Tracker"),zr=r(" class that supports "),_t=s("code"),Nr=r("wandb"),Wr=r(". Should be initialized at the start of your script."),Mr=i(),J=s("div"),m(ge.$$.fragment),Vr=i(),_e=s("p"),Gr=r("Closes "),vt=s("code"),Rr=r("wandb"),Ur=r(" writer"),Hr=i(),K=s("div"),m(ve.$$.fragment),Fr=i(),ye=s("p"),Jr=r("Logs "),yt=s("code"),Kr=r("values"),Qr=r(" to the current run."),Xr=i(),Q=s("div"),m(ke.$$.fragment),Yr=i(),$e=s("p"),Zr=r("Logs "),kt=s("code"),eo=r("values"),to=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),ra=i(),$=s("div"),m(be.$$.fragment),ao=i(),S=s("p"),ro=r("A "),$t=s("code"),oo=r("Tracker"),so=r(" class that supports "),bt=s("code"),no=r("comet_ml"),lo=r(". Should be initialized at the start of your script."),co=i(),wt=s("p"),io=r("API keys must be stored in a Comet config file."),po=i(),X=s("div"),m(we.$$.fragment),uo=i(),Ee=s("p"),mo=r("Logs "),Et=s("code"),ho=r("values"),fo=r(" to the current run."),go=i(),Y=s("div"),m(Te.$$.fragment),_o=i(),Ae=s("p"),vo=r("Logs "),Tt=s("code"),yo=r("values"),ko=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),oa=i(),E=s("p"),$o=r("To use any of them, pass in the selected type(s) to the "),At=s("code"),bo=r("log_with"),wo=r(" parameter in "),jt=s("code"),Eo=r("Accelerate"),To=r(":"),sa=i(),m(je.$$.fragment),na=i(),Z=s("p"),Ao=r("At the start of your experiment "),He=s("a"),jo=r("init_trackers()"),Do=r(" should be used to setup your project, and potentially add any experiment hyperparameters to be logged:"),la=i(),m(De.$$.fragment),ca=i(),T=s("p"),Co=r("When you are ready to log any data, "),Fe=s("a"),xo=r("log()"),Lo=r(` should be used.
A `),Dt=s("code"),Po=r("step"),Oo=r(" can also be passed in to correlate the data with a particular step in the training loop."),ia=i(),m(Ce.$$.fragment),pa=i(),ee=s("p"),Io=r("Once you\u2019ve finished training, make sure to run "),Je=s("a"),qo=r("end_training()"),Bo=r(" so that all the trackers can run their finish functionalities if they have any."),da=i(),m(xe.$$.fragment),ua=i(),Ke=s("p"),So=r("A full example is below:"),ma=i(),m(Le.$$.fragment),ha=i(),z=s("h2"),te=s("a"),Ct=s("span"),m(Pe.$$.fragment),zo=i(),xt=s("span"),No=r("Implementing Custom Trackers"),fa=i(),A=s("p"),Wo=r("To implement a new tracker to be used in "),Lt=s("code"),Mo=r("Accelerator"),Vo=r(", a new one can be made through implementing the "),Pt=s("code"),Go=r("~GeneralTracker"),Ro=r(` class.
Every tracker must implement three functions:`),ga=i(),j=s("ul"),Oe=s("li"),Ot=s("code"),Uo=r("__init__"),Ho=r(": "),Ie=s("ul"),qe=s("li"),Fo=r("Should store a "),It=s("code"),Jo=r("run_name"),Ko=r(" and initialize the tracker API of the integrated library."),Qo=i(),Be=s("li"),Xo=r("If a tracker stores their data locally (such as TensorBoard), a "),qt=s("code"),Yo=r("logging_dir"),Zo=r(" parameter can be added."),es=i(),Se=s("li"),Bt=s("code"),ts=r("store_init_configuration"),as=r(": "),St=s("ul"),ze=s("li"),rs=r("Should take in a "),zt=s("code"),os=r("values"),ss=r(" dictionary and store them as a one-time experiment configuration"),ns=i(),Ne=s("li"),Nt=s("code"),ls=r("log"),cs=r(": "),Wt=s("ul"),N=s("li"),is=r("Should take in a "),Mt=s("code"),ps=r("values"),ds=r(" dictionary and a "),Vt=s("code"),us=r("step"),ms=r(", and should log them to the run"),_a=i(),Qe=s("p"),hs=r("A brief example can be seen below with an integration with Weights and Biases, containing only the relevent information:"),va=i(),m(We.$$.fragment),ya=i(),b=s("p"),fs=r("When you are ready to build your "),Gt=s("code"),gs=r("Accelerator"),_s=r(" object, pass in an "),Rt=s("strong"),vs=r("instance"),ys=r(" of your tracker to "),Ut=s("code"),ks=r("log_with"),$s=r(` to have it automatically
be used with the API:`),ka=i(),m(Me.$$.fragment),$a=i(),ae=s("p"),bs=r("These also can be mixed with existing trackers, including with "),Ht=s("code"),ws=r('"all"'),Es=r(":"),ba=i(),m(Ve.$$.fragment),wa=i(),W=s("h2"),re=s("a"),Ft=s("span"),m(Ge.$$.fragment),Ts=i(),Jt=s("span"),As=r("When a wrapper cannot work"),Ea=i(),D=s("p"),js=r("If a library has an API that does not follow a strict "),Kt=s("code"),Ds=r(".log"),Cs=r(" with an overall dictionary such as Neptune.AI, logging can be done manually under an "),Qt=s("code"),xs=r("if accelerator.is_main_process"),Ls=r(" statement:"),Ta=i(),m(Re.$$.fragment),this.h()},l(e){const c=Nn('[data-svelte="svelte-1phssyn"]',document.head);P=n(c,"META",{name:!0,content:!0}),c.forEach(a),Xt=p(e),O=n(e,"H1",{class:!0});var ja=l(O);V=n(ja,"A",{id:!0,class:!0,href:!0});var Is=l(V);nt=n(Is,"SPAN",{});var qs=l(nt);h(se.$$.fragment,qs),qs.forEach(a),Is.forEach(a),sr=p(ja),lt=n(ja,"SPAN",{});var Bs=l(lt);nr=o(Bs,"Tracking"),Bs.forEach(a),ja.forEach(a),Yt=p(e),ne=n(e,"P",{});var Ps=l(ne);lr=o(Ps,`There are a large number of experiment tracking API\u2019s available, however getting them all to work with in a multi-processing environment can oftentimes be complex.
Accelerate provides a general tracking API that can be used to log useful items during your script through `),Ue=n(Ps,"A",{href:!0});var Ss=l(Ue);cr=o(Ss,"log()"),Ss.forEach(a),Ps.forEach(a),Zt=p(e),I=n(e,"H2",{class:!0});var Da=l(I);G=n(Da,"A",{id:!0,class:!0,href:!0});var zs=l(G);ct=n(zs,"SPAN",{});var Ns=l(ct);h(le.$$.fragment,Ns),Ns.forEach(a),zs.forEach(a),ir=p(Da),it=n(Da,"SPAN",{});var Ws=l(it);pr=o(Ws,"Integrated Trackers"),Ws.forEach(a),Da.forEach(a),ea=p(e),R=n(e,"P",{});var Ca=l(R);dr=o(Ca,"Currently "),pt=n(Ca,"CODE",{});var Ms=l(pt);ur=o(Ms,"Accelerate"),Ms.forEach(a),mr=o(Ca," supports three trackers out-of-the-box:"),Ca.forEach(a),ta=p(e),y=n(e,"DIV",{class:!0});var C=l(y);h(ce.$$.fragment,C),hr=p(C),q=n(C,"P",{});var Xe=l(q);fr=o(Xe,"A "),dt=n(Xe,"CODE",{});var Vs=l(dt);gr=o(Vs,"Tracker"),Vs.forEach(a),_r=o(Xe," class that supports "),ut=n(Xe,"CODE",{});var Gs=l(ut);vr=o(Gs,"tensorboard"),Gs.forEach(a),yr=o(Xe,". Should be initialized at the start of your script."),Xe.forEach(a),kr=p(C),U=n(C,"DIV",{class:!0});var xa=l(U);h(ie.$$.fragment,xa),$r=p(xa),pe=n(xa,"P",{});var La=l(pe);br=o(La,"Closes "),mt=n(La,"CODE",{});var Rs=l(mt);wr=o(Rs,"TensorBoard"),Rs.forEach(a),Er=o(La," writer"),La.forEach(a),xa.forEach(a),Tr=p(C),H=n(C,"DIV",{class:!0});var Pa=l(H);h(de.$$.fragment,Pa),Ar=p(Pa),ue=n(Pa,"P",{});var Oa=l(ue);jr=o(Oa,"Logs "),ht=n(Oa,"CODE",{});var Us=l(ht);Dr=o(Us,"values"),Us.forEach(a),Cr=o(Oa," to the current run."),Oa.forEach(a),Pa.forEach(a),xr=p(C),F=n(C,"DIV",{class:!0});var Ia=l(F);h(me.$$.fragment,Ia),Lr=p(Ia),he=n(Ia,"P",{});var qa=l(he);Pr=o(qa,"Logs "),ft=n(qa,"CODE",{});var Hs=l(ft);Or=o(Hs,"values"),Hs.forEach(a),Ir=o(qa," as hyperparameters for the run. Should be run at the beginning of your experiment."),qa.forEach(a),Ia.forEach(a),C.forEach(a),aa=p(e),k=n(e,"DIV",{class:!0});var x=l(k);h(fe.$$.fragment,x),qr=p(x),B=n(x,"P",{});var Ye=l(B);Br=o(Ye,"A "),gt=n(Ye,"CODE",{});var Fs=l(gt);Sr=o(Fs,"Tracker"),Fs.forEach(a),zr=o(Ye," class that supports "),_t=n(Ye,"CODE",{});var Js=l(_t);Nr=o(Js,"wandb"),Js.forEach(a),Wr=o(Ye,". Should be initialized at the start of your script."),Ye.forEach(a),Mr=p(x),J=n(x,"DIV",{class:!0});var Ba=l(J);h(ge.$$.fragment,Ba),Vr=p(Ba),_e=n(Ba,"P",{});var Sa=l(_e);Gr=o(Sa,"Closes "),vt=n(Sa,"CODE",{});var Ks=l(vt);Rr=o(Ks,"wandb"),Ks.forEach(a),Ur=o(Sa," writer"),Sa.forEach(a),Ba.forEach(a),Hr=p(x),K=n(x,"DIV",{class:!0});var za=l(K);h(ve.$$.fragment,za),Fr=p(za),ye=n(za,"P",{});var Na=l(ye);Jr=o(Na,"Logs "),yt=n(Na,"CODE",{});var Qs=l(yt);Kr=o(Qs,"values"),Qs.forEach(a),Qr=o(Na," to the current run."),Na.forEach(a),za.forEach(a),Xr=p(x),Q=n(x,"DIV",{class:!0});var Wa=l(Q);h(ke.$$.fragment,Wa),Yr=p(Wa),$e=n(Wa,"P",{});var Ma=l($e);Zr=o(Ma,"Logs "),kt=n(Ma,"CODE",{});var Xs=l(kt);eo=o(Xs,"values"),Xs.forEach(a),to=o(Ma," as hyperparameters for the run. Should be run at the beginning of your experiment."),Ma.forEach(a),Wa.forEach(a),x.forEach(a),ra=p(e),$=n(e,"DIV",{class:!0});var L=l($);h(be.$$.fragment,L),ao=p(L),S=n(L,"P",{});var Ze=l(S);ro=o(Ze,"A "),$t=n(Ze,"CODE",{});var Ys=l($t);oo=o(Ys,"Tracker"),Ys.forEach(a),so=o(Ze," class that supports "),bt=n(Ze,"CODE",{});var Zs=l(bt);no=o(Zs,"comet_ml"),Zs.forEach(a),lo=o(Ze,". Should be initialized at the start of your script."),Ze.forEach(a),co=p(L),wt=n(L,"P",{});var en=l(wt);io=o(en,"API keys must be stored in a Comet config file."),en.forEach(a),po=p(L),X=n(L,"DIV",{class:!0});var Va=l(X);h(we.$$.fragment,Va),uo=p(Va),Ee=n(Va,"P",{});var Ga=l(Ee);mo=o(Ga,"Logs "),Et=n(Ga,"CODE",{});var tn=l(Et);ho=o(tn,"values"),tn.forEach(a),fo=o(Ga," to the current run."),Ga.forEach(a),Va.forEach(a),go=p(L),Y=n(L,"DIV",{class:!0});var Ra=l(Y);h(Te.$$.fragment,Ra),_o=p(Ra),Ae=n(Ra,"P",{});var Ua=l(Ae);vo=o(Ua,"Logs "),Tt=n(Ua,"CODE",{});var an=l(Tt);yo=o(an,"values"),an.forEach(a),ko=o(Ua," as hyperparameters for the run. Should be run at the beginning of your experiment."),Ua.forEach(a),Ra.forEach(a),L.forEach(a),oa=p(e),E=n(e,"P",{});var et=l(E);$o=o(et,"To use any of them, pass in the selected type(s) to the "),At=n(et,"CODE",{});var rn=l(At);bo=o(rn,"log_with"),rn.forEach(a),wo=o(et," parameter in "),jt=n(et,"CODE",{});var on=l(jt);Eo=o(on,"Accelerate"),on.forEach(a),To=o(et,":"),et.forEach(a),sa=p(e),h(je.$$.fragment,e),na=p(e),Z=n(e,"P",{});var Ha=l(Z);Ao=o(Ha,"At the start of your experiment "),He=n(Ha,"A",{href:!0});var sn=l(He);jo=o(sn,"init_trackers()"),sn.forEach(a),Do=o(Ha," should be used to setup your project, and potentially add any experiment hyperparameters to be logged:"),Ha.forEach(a),la=p(e),h(De.$$.fragment,e),ca=p(e),T=n(e,"P",{});var tt=l(T);Co=o(tt,"When you are ready to log any data, "),Fe=n(tt,"A",{href:!0});var nn=l(Fe);xo=o(nn,"log()"),nn.forEach(a),Lo=o(tt,` should be used.
A `),Dt=n(tt,"CODE",{});var ln=l(Dt);Po=o(ln,"step"),ln.forEach(a),Oo=o(tt," can also be passed in to correlate the data with a particular step in the training loop."),tt.forEach(a),ia=p(e),h(Ce.$$.fragment,e),pa=p(e),ee=n(e,"P",{});var Fa=l(ee);Io=o(Fa,"Once you\u2019ve finished training, make sure to run "),Je=n(Fa,"A",{href:!0});var cn=l(Je);qo=o(cn,"end_training()"),cn.forEach(a),Bo=o(Fa," so that all the trackers can run their finish functionalities if they have any."),Fa.forEach(a),da=p(e),h(xe.$$.fragment,e),ua=p(e),Ke=n(e,"P",{});var pn=l(Ke);So=o(pn,"A full example is below:"),pn.forEach(a),ma=p(e),h(Le.$$.fragment,e),ha=p(e),z=n(e,"H2",{class:!0});var Ja=l(z);te=n(Ja,"A",{id:!0,class:!0,href:!0});var dn=l(te);Ct=n(dn,"SPAN",{});var un=l(Ct);h(Pe.$$.fragment,un),un.forEach(a),dn.forEach(a),zo=p(Ja),xt=n(Ja,"SPAN",{});var mn=l(xt);No=o(mn,"Implementing Custom Trackers"),mn.forEach(a),Ja.forEach(a),fa=p(e),A=n(e,"P",{});var at=l(A);Wo=o(at,"To implement a new tracker to be used in "),Lt=n(at,"CODE",{});var hn=l(Lt);Mo=o(hn,"Accelerator"),hn.forEach(a),Vo=o(at,", a new one can be made through implementing the "),Pt=n(at,"CODE",{});var fn=l(Pt);Go=o(fn,"~GeneralTracker"),fn.forEach(a),Ro=o(at,` class.
Every tracker must implement three functions:`),at.forEach(a),ga=p(e),j=n(e,"UL",{});var rt=l(j);Oe=n(rt,"LI",{});var Ka=l(Oe);Ot=n(Ka,"CODE",{});var gn=l(Ot);Uo=o(gn,"__init__"),gn.forEach(a),Ho=o(Ka,": "),Ie=n(Ka,"UL",{});var Qa=l(Ie);qe=n(Qa,"LI",{});var Xa=l(qe);Fo=o(Xa,"Should store a "),It=n(Xa,"CODE",{});var _n=l(It);Jo=o(_n,"run_name"),_n.forEach(a),Ko=o(Xa," and initialize the tracker API of the integrated library."),Xa.forEach(a),Qo=p(Qa),Be=n(Qa,"LI",{});var Ya=l(Be);Xo=o(Ya,"If a tracker stores their data locally (such as TensorBoard), a "),qt=n(Ya,"CODE",{});var vn=l(qt);Yo=o(vn,"logging_dir"),vn.forEach(a),Zo=o(Ya," parameter can be added."),Ya.forEach(a),Qa.forEach(a),Ka.forEach(a),es=p(rt),Se=n(rt,"LI",{});var Za=l(Se);Bt=n(Za,"CODE",{});var yn=l(Bt);ts=o(yn,"store_init_configuration"),yn.forEach(a),as=o(Za,": "),St=n(Za,"UL",{});var kn=l(St);ze=n(kn,"LI",{});var er=l(ze);rs=o(er,"Should take in a "),zt=n(er,"CODE",{});var $n=l(zt);os=o($n,"values"),$n.forEach(a),ss=o(er," dictionary and store them as a one-time experiment configuration"),er.forEach(a),kn.forEach(a),Za.forEach(a),ns=p(rt),Ne=n(rt,"LI",{});var tr=l(Ne);Nt=n(tr,"CODE",{});var bn=l(Nt);ls=o(bn,"log"),bn.forEach(a),cs=o(tr,": "),Wt=n(tr,"UL",{});var wn=l(Wt);N=n(wn,"LI",{});var ot=l(N);is=o(ot,"Should take in a "),Mt=n(ot,"CODE",{});var En=l(Mt);ps=o(En,"values"),En.forEach(a),ds=o(ot," dictionary and a "),Vt=n(ot,"CODE",{});var Tn=l(Vt);us=o(Tn,"step"),Tn.forEach(a),ms=o(ot,", and should log them to the run"),ot.forEach(a),wn.forEach(a),tr.forEach(a),rt.forEach(a),_a=p(e),Qe=n(e,"P",{});var An=l(Qe);hs=o(An,"A brief example can be seen below with an integration with Weights and Biases, containing only the relevent information:"),An.forEach(a),va=p(e),h(We.$$.fragment,e),ya=p(e),b=n(e,"P",{});var oe=l(b);fs=o(oe,"When you are ready to build your "),Gt=n(oe,"CODE",{});var jn=l(Gt);gs=o(jn,"Accelerator"),jn.forEach(a),_s=o(oe," object, pass in an "),Rt=n(oe,"STRONG",{});var Dn=l(Rt);vs=o(Dn,"instance"),Dn.forEach(a),ys=o(oe," of your tracker to "),Ut=n(oe,"CODE",{});var Cn=l(Ut);ks=o(Cn,"log_with"),Cn.forEach(a),$s=o(oe,` to have it automatically
be used with the API:`),oe.forEach(a),ka=p(e),h(Me.$$.fragment,e),$a=p(e),ae=n(e,"P",{});var ar=l(ae);bs=o(ar,"These also can be mixed with existing trackers, including with "),Ht=n(ar,"CODE",{});var xn=l(Ht);ws=o(xn,'"all"'),xn.forEach(a),Es=o(ar,":"),ar.forEach(a),ba=p(e),h(Ve.$$.fragment,e),wa=p(e),W=n(e,"H2",{class:!0});var rr=l(W);re=n(rr,"A",{id:!0,class:!0,href:!0});var Ln=l(re);Ft=n(Ln,"SPAN",{});var Pn=l(Ft);h(Ge.$$.fragment,Pn),Pn.forEach(a),Ln.forEach(a),Ts=p(rr),Jt=n(rr,"SPAN",{});var On=l(Jt);As=o(On,"When a wrapper cannot work"),On.forEach(a),rr.forEach(a),Ea=p(e),D=n(e,"P",{});var st=l(D);js=o(st,"If a library has an API that does not follow a strict "),Kt=n(st,"CODE",{});var In=l(Kt);Ds=o(In,".log"),In.forEach(a),Cs=o(st," with an overall dictionary such as Neptune.AI, logging can be done manually under an "),Qt=n(st,"CODE",{});var qn=l(Qt);xs=o(qn,"if accelerator.is_main_process"),qn.forEach(a),Ls=o(st," statement:"),st.forEach(a),Ta=p(e),h(Re.$$.fragment,e),this.h()},h(){u(P,"name","hf:doc:metadata"),u(P,"content",JSON.stringify(Gn)),u(V,"id","tracking"),u(V,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(V,"href","#tracking"),u(O,"class","relative group"),u(Ue,"href","/docs/accelerate/pr_305/en/accelerator#accelerate.Accelerator.log"),u(G,"id","accelerate.tracking.TensorBoardTracker"),u(G,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(G,"href","#accelerate.tracking.TensorBoardTracker"),u(I,"class","relative group"),u(U,"class","docstring"),u(H,"class","docstring"),u(F,"class","docstring"),u(y,"class","docstring"),u(J,"class","docstring"),u(K,"class","docstring"),u(Q,"class","docstring"),u(k,"class","docstring"),u(X,"class","docstring"),u(Y,"class","docstring"),u($,"class","docstring"),u(He,"href","/docs/accelerate/pr_305/en/accelerator#accelerate.Accelerator.init_trackers"),u(Fe,"href","/docs/accelerate/pr_305/en/accelerator#accelerate.Accelerator.log"),u(Je,"href","/docs/accelerate/pr_305/en/accelerator#accelerate.Accelerator.end_training"),u(te,"id","implementing-custom-trackers"),u(te,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(te,"href","#implementing-custom-trackers"),u(z,"class","relative group"),u(re,"id","when-a-wrapper-cannot-work"),u(re,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(re,"href","#when-a-wrapper-cannot-work"),u(W,"class","relative group")},m(e,c){t(document.head,P),d(e,Xt,c),d(e,O,c),t(O,V),t(V,nt),f(se,nt,null),t(O,sr),t(O,lt),t(lt,nr),d(e,Yt,c),d(e,ne,c),t(ne,lr),t(ne,Ue),t(Ue,cr),d(e,Zt,c),d(e,I,c),t(I,G),t(G,ct),f(le,ct,null),t(I,ir),t(I,it),t(it,pr),d(e,ea,c),d(e,R,c),t(R,dr),t(R,pt),t(pt,ur),t(R,mr),d(e,ta,c),d(e,y,c),f(ce,y,null),t(y,hr),t(y,q),t(q,fr),t(q,dt),t(dt,gr),t(q,_r),t(q,ut),t(ut,vr),t(q,yr),t(y,kr),t(y,U),f(ie,U,null),t(U,$r),t(U,pe),t(pe,br),t(pe,mt),t(mt,wr),t(pe,Er),t(y,Tr),t(y,H),f(de,H,null),t(H,Ar),t(H,ue),t(ue,jr),t(ue,ht),t(ht,Dr),t(ue,Cr),t(y,xr),t(y,F),f(me,F,null),t(F,Lr),t(F,he),t(he,Pr),t(he,ft),t(ft,Or),t(he,Ir),d(e,aa,c),d(e,k,c),f(fe,k,null),t(k,qr),t(k,B),t(B,Br),t(B,gt),t(gt,Sr),t(B,zr),t(B,_t),t(_t,Nr),t(B,Wr),t(k,Mr),t(k,J),f(ge,J,null),t(J,Vr),t(J,_e),t(_e,Gr),t(_e,vt),t(vt,Rr),t(_e,Ur),t(k,Hr),t(k,K),f(ve,K,null),t(K,Fr),t(K,ye),t(ye,Jr),t(ye,yt),t(yt,Kr),t(ye,Qr),t(k,Xr),t(k,Q),f(ke,Q,null),t(Q,Yr),t(Q,$e),t($e,Zr),t($e,kt),t(kt,eo),t($e,to),d(e,ra,c),d(e,$,c),f(be,$,null),t($,ao),t($,S),t(S,ro),t(S,$t),t($t,oo),t(S,so),t(S,bt),t(bt,no),t(S,lo),t($,co),t($,wt),t(wt,io),t($,po),t($,X),f(we,X,null),t(X,uo),t(X,Ee),t(Ee,mo),t(Ee,Et),t(Et,ho),t(Ee,fo),t($,go),t($,Y),f(Te,Y,null),t(Y,_o),t(Y,Ae),t(Ae,vo),t(Ae,Tt),t(Tt,yo),t(Ae,ko),d(e,oa,c),d(e,E,c),t(E,$o),t(E,At),t(At,bo),t(E,wo),t(E,jt),t(jt,Eo),t(E,To),d(e,sa,c),f(je,e,c),d(e,na,c),d(e,Z,c),t(Z,Ao),t(Z,He),t(He,jo),t(Z,Do),d(e,la,c),f(De,e,c),d(e,ca,c),d(e,T,c),t(T,Co),t(T,Fe),t(Fe,xo),t(T,Lo),t(T,Dt),t(Dt,Po),t(T,Oo),d(e,ia,c),f(Ce,e,c),d(e,pa,c),d(e,ee,c),t(ee,Io),t(ee,Je),t(Je,qo),t(ee,Bo),d(e,da,c),f(xe,e,c),d(e,ua,c),d(e,Ke,c),t(Ke,So),d(e,ma,c),f(Le,e,c),d(e,ha,c),d(e,z,c),t(z,te),t(te,Ct),f(Pe,Ct,null),t(z,zo),t(z,xt),t(xt,No),d(e,fa,c),d(e,A,c),t(A,Wo),t(A,Lt),t(Lt,Mo),t(A,Vo),t(A,Pt),t(Pt,Go),t(A,Ro),d(e,ga,c),d(e,j,c),t(j,Oe),t(Oe,Ot),t(Ot,Uo),t(Oe,Ho),t(Oe,Ie),t(Ie,qe),t(qe,Fo),t(qe,It),t(It,Jo),t(qe,Ko),t(Ie,Qo),t(Ie,Be),t(Be,Xo),t(Be,qt),t(qt,Yo),t(Be,Zo),t(j,es),t(j,Se),t(Se,Bt),t(Bt,ts),t(Se,as),t(Se,St),t(St,ze),t(ze,rs),t(ze,zt),t(zt,os),t(ze,ss),t(j,ns),t(j,Ne),t(Ne,Nt),t(Nt,ls),t(Ne,cs),t(Ne,Wt),t(Wt,N),t(N,is),t(N,Mt),t(Mt,ps),t(N,ds),t(N,Vt),t(Vt,us),t(N,ms),d(e,_a,c),d(e,Qe,c),t(Qe,hs),d(e,va,c),f(We,e,c),d(e,ya,c),d(e,b,c),t(b,fs),t(b,Gt),t(Gt,gs),t(b,_s),t(b,Rt),t(Rt,vs),t(b,ys),t(b,Ut),t(Ut,ks),t(b,$s),d(e,ka,c),f(Me,e,c),d(e,$a,c),d(e,ae,c),t(ae,bs),t(ae,Ht),t(Ht,ws),t(ae,Es),d(e,ba,c),f(Ve,e,c),d(e,wa,c),d(e,W,c),t(W,re),t(re,Ft),f(Ge,Ft,null),t(W,Ts),t(W,Jt),t(Jt,As),d(e,Ea,c),d(e,D,c),t(D,js),t(D,Kt),t(Kt,Ds),t(D,Cs),t(D,Qt),t(Qt,xs),t(D,Ls),d(e,Ta,c),f(Re,e,c),Aa=!0},p:Wn,i(e){Aa||(g(se.$$.fragment,e),g(le.$$.fragment,e),g(ce.$$.fragment,e),g(ie.$$.fragment,e),g(de.$$.fragment,e),g(me.$$.fragment,e),g(fe.$$.fragment,e),g(ge.$$.fragment,e),g(ve.$$.fragment,e),g(ke.$$.fragment,e),g(be.$$.fragment,e),g(we.$$.fragment,e),g(Te.$$.fragment,e),g(je.$$.fragment,e),g(De.$$.fragment,e),g(Ce.$$.fragment,e),g(xe.$$.fragment,e),g(Le.$$.fragment,e),g(Pe.$$.fragment,e),g(We.$$.fragment,e),g(Me.$$.fragment,e),g(Ve.$$.fragment,e),g(Ge.$$.fragment,e),g(Re.$$.fragment,e),Aa=!0)},o(e){_(se.$$.fragment,e),_(le.$$.fragment,e),_(ce.$$.fragment,e),_(ie.$$.fragment,e),_(de.$$.fragment,e),_(me.$$.fragment,e),_(fe.$$.fragment,e),_(ge.$$.fragment,e),_(ve.$$.fragment,e),_(ke.$$.fragment,e),_(be.$$.fragment,e),_(we.$$.fragment,e),_(Te.$$.fragment,e),_(je.$$.fragment,e),_(De.$$.fragment,e),_(Ce.$$.fragment,e),_(xe.$$.fragment,e),_(Le.$$.fragment,e),_(Pe.$$.fragment,e),_(We.$$.fragment,e),_(Me.$$.fragment,e),_(Ve.$$.fragment,e),_(Ge.$$.fragment,e),_(Re.$$.fragment,e),Aa=!1},d(e){a(P),e&&a(Xt),e&&a(O),v(se),e&&a(Yt),e&&a(ne),e&&a(Zt),e&&a(I),v(le),e&&a(ea),e&&a(R),e&&a(ta),e&&a(y),v(ce),v(ie),v(de),v(me),e&&a(aa),e&&a(k),v(fe),v(ge),v(ve),v(ke),e&&a(ra),e&&a($),v(be),v(we),v(Te),e&&a(oa),e&&a(E),e&&a(sa),v(je,e),e&&a(na),e&&a(Z),e&&a(la),v(De,e),e&&a(ca),e&&a(T),e&&a(ia),v(Ce,e),e&&a(pa),e&&a(ee),e&&a(da),v(xe,e),e&&a(ua),e&&a(Ke),e&&a(ma),v(Le,e),e&&a(ha),e&&a(z),v(Pe),e&&a(fa),e&&a(A),e&&a(ga),e&&a(j),e&&a(_a),e&&a(Qe),e&&a(va),v(We,e),e&&a(ya),e&&a(b),e&&a(ka),v(Me,e),e&&a($a),e&&a(ae),e&&a(ba),v(Ve,e),e&&a(wa),e&&a(W),v(Ge),e&&a(Ea),e&&a(D),e&&a(Ta),v(Re,e)}}}const Gn={local:"tracking",sections:[{local:"accelerate.tracking.TensorBoardTracker",title:"Integrated Trackers"},{local:"implementing-custom-trackers",title:"Implementing Custom Trackers"},{local:"when-a-wrapper-cannot-work",title:"When a wrapper cannot work"}],title:"Tracking"};function Rn(Os){return Mn(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Kn extends Bn{constructor(P){super();Sn(this,P,Rn,Vn,zn,{})}}export{Kn as default,Gn as metadata};
