import{S as un,i as gn,s as _n,e as o,k as l,w as m,t as r,M as vn,c,d as t,m as i,a as s,x as f,h as a,b as h,F as e,g as L,y as u,L as bn,q as g,o as _,B as v}from"../chunks/vendor-19e06bd2.js";import{D as $}from"../chunks/Docstring-f53307d4.js";import{I as $n}from"../chunks/IconCopyLink-3c713d38.js";function yn(Mr){let I,We,x,P,pt,de,Fr,ht,Hr,nr,W,Kr,Re,Xr,Yr,lr,E,N,Br,Me,Jr,Qr,mt,Zr,ea,ta,pe,ra,Fe,aa,oa,ca,T,sa,ft,na,la,ut,ia,da,gt,pa,ha,ma,S,fa,_t,ua,ga,vt,_a,va,ba,he,$a,He,ya,Ea,ir,R,wa,bt,Aa,xa,dr,b,M,$t,Da,La,Ke,Pa,Ta,Ia,me,ka,yt,Oa,Ua,Ca,fe,za,Et,Na,Sa,qa,ue,ja,Xe,Va,Ga,Wa,ge,Ra,Ye,Ma,Fa,Ha,q,Ka,Be,Xa,Ya,wt,Ba,Ja,Qa,A,Za,F,eo,At,to,ro,ao,xt,oo,co,H,so,Dt,no,lo,io,Lt,po,ho,pr,d,_e,mo,Pt,fo,uo,Tt,go,_o,ve,K,It,vo,bo,kt,$o,yo,Eo,X,Ot,wo,Ao,Je,xo,Do,Lo,Y,be,Po,Ut,To,Io,B,$e,ko,j,Oo,Ct,Uo,Co,zt,zo,No,So,J,ye,qo,Ee,jo,Nt,Vo,Go,Wo,Q,we,Ro,Ae,Mo,St,Fo,Ho,Ko,Z,xe,Xo,qt,Yo,Bo,k,De,Jo,Le,Qo,jt,Zo,ec,tc,Vt,rc,ac,ee,Pe,oc,Gt,cc,sc,O,Te,nc,Wt,lc,ic,Rt,dc,pc,U,Ie,hc,Mt,mc,fc,Ft,uc,gc,te,ke,_c,Ht,vc,bc,D,Oe,$c,Ue,yc,Kt,Ec,wc,Ac,Xt,xc,Dc,V,Qe,Yt,Lc,Pc,Tc,Ze,Bt,Ic,kc,Oc,et,Jt,Uc,Cc,zc,re,Ce,Nc,ze,Sc,Qt,qc,jc,Vc,ae,Ne,Gc,Se,Wc,Zt,Rc,Mc,Fc,oe,qe,Hc,er,Kc,Xc,ce,je,Yc,tr,Bc,Jc,se,Ve,Qc,G,Zc,rr,es,ts,tt,rs,as,os,ne,Ge,cs,ar,ss,hr;return de=new $n({}),_e=new $({props:{name:"class accelerate.Accelerator",anchor:"accelerate.Accelerator",parameters:[{name:"device_placement",val:": bool = True"},{name:"split_batches",val:": bool = False"},{name:"fp16",val:": bool = None"},{name:"mixed_precision",val:": str = None"},{name:"cpu",val:": bool = False"},{name:"deepspeed_plugin",val:": DeepSpeedPlugin = None"},{name:"rng_types",val:": typing.Union[typing.List[typing.Union[str, accelerate.utils.RNGType]], NoneType] = None"},{name:"dispatch_batches",val:": typing.Optional[bool] = None"},{name:"kwargs_handlers",val:": typing.Optional[typing.List[accelerate.kwargs_handlers.KwargsHandler]] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L53",parametersDescription:[{anchor:"accelerate.Accelerator.device_placement",description:`<strong>device_placement</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>True</code>) &#x2014;
Whether or not the accelerator should put objects on device (tensors yielded by the dataloader, model,
etc&#x2026;).`,name:"device_placement"},{anchor:"accelerate.Accelerator.split_batches",description:`<strong>split_batches</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not the accelerator should split the batches yielded by the dataloaders across the devices. If
<code>True</code> the actual batch size used will be the same on any kind of distributed processes, but it must be a
round multiple of the <code>num_processes</code> you are using. If <code>False</code>, actual batch size used will be the one set
in your script multiplied by the number of processes.`,name:"split_batches"},{anchor:"accelerate.Accelerator.mixed_precision",description:`<strong>mixed_precision</strong> (<code>str</code>, <em>optional</em>) &#x2014;
Whether or not to use mixed precision training (fp16 or bfloat16). Choose from &#x2018;no&#x2019;,&#x2018;fp16&#x2019;,&#x2018;bf16&#x2019;. Will
default to the value in the environment variable <code>MIXED_PRECISION</code>, which will use the default value in the
accelerate config of the current system or the flag passed with the <code>accelerate.launch</code> command. &#x2018;fp16&#x2019;
requires pytorch 1.6 or higher. &#x2018;bf16&#x2019; requires pytorch 1.10 or higher.`,name:"mixed_precision"},{anchor:"accelerate.Accelerator.cpu",description:`<strong>cpu</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
Whether or not to force the script to execute on CPU. Will ignore GPU available if set to <code>True</code> and force
the execution on one process only.`,name:"cpu"},{anchor:"accelerate.Accelerator.deepspeed_plugin",description:`<strong>deepspeed_plugin</strong> (<code>DeepSpeedPlugin</code>, <em>optional</em>) &#x2014;
Tweak your DeepSpeed related args using this argument. This argument is optional and can be configured
directly using <em>accelerate config</em>`,name:"deepspeed_plugin"},{anchor:"accelerate.Accelerator.rng_types",description:`<strong>rng_types</strong> (list of <code>str</code> or <code>RNGType</code> &#x2014;
The list of random number generators to synchronize at the beginning of each iteration in your prepared
dataloaders. Should be one or several of:</p>
<ul>
<li><code>&quot;torch&quot;</code>: the base torch random number generator</li>
<li><code>&quot;cuda&quot;</code>: the CUDA random number generator (GPU only)</li>
<li><code>&quot;xla&quot;</code>: the XLA random number generator (TPU only)</li>
<li><code>&quot;generator&quot;</code>: the <code>torch.Generator</code> of the sampler (or batch sampler if there is no sampler in your
dataloader) or of the iterable dataset (if it exists) if the underlying dataset is of that type.</li>
</ul>
<p>Will default to <code>[&quot;torch&quot;]</code> for PyTorch versions &lt;=1.5.1 and <code>[&quot;generator&quot;]</code> for PyTorch versions &gt;= 1.6.`,name:"rng_types"},{anchor:"accelerate.Accelerator.dispatch_batches",description:`<strong>dispatch_batches</strong> (<code>bool</code>, <em>optional</em>) &#x2014;
If set to <code>True</code>, the dataloader prepared by the Accelerator is only iterated through on the main process
and then the batches are split and broadcast to each process. Will default to <code>True</code> for <code>DataLoader</code> whose
underlying dataset is an <code>IterableDataset</code>, <code>False</code> otherwise.`,name:"dispatch_batches"},{anchor:"accelerate.Accelerator.kwargs_handlers",description:`<strong>kwargs_handlers</strong> (<code>List[KwargHandler]</code>, <em>optional</em>) &#x2014;
A list of <code>KwargHandler</code> to customize how the objects related to distributed training or mixed precision
are created. See <a href="kwargs">kwargs</a> for more information.`,name:"kwargs_handlers"}]}}),be=new $({props:{name:"autocast",anchor:"accelerate.Accelerator.autocast",parameters:[],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L651"}}),$e=new $({props:{name:"backward",anchor:"accelerate.Accelerator.backward",parameters:[{name:"loss",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L458"}}),ye=new $({props:{name:"clip_grad_norm_",anchor:"accelerate.Accelerator.clip_grad_norm_",parameters:[{name:"parameters",val:""},{name:"max_norm",val:""},{name:"norm_type",val:" = 2"}],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L489"}}),we=new $({props:{name:"clip_grad_value_",anchor:"accelerate.Accelerator.clip_grad_value_",parameters:[{name:"parameters",val:""},{name:"clip_value",val:""}],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L496"}}),xe=new $({props:{name:"free_memory",anchor:"accelerate.Accelerator.free_memory",parameters:[],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L597"}}),De=new $({props:{name:"gather",anchor:"accelerate.Accelerator.gather",parameters:[{name:"tensor",val:""}],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L503",parametersDescription:[{anchor:"accelerate.Accelerator.gather.tensor",description:`<strong>tensor</strong> (<code>torch.Tensor</code>, or a nested tuple/list/dictionary of <code>torch.Tensor</code>) &#x2014;
The tensors to gather across all processes.`,name:"tensor"}],returnDescription:`
<p>The gathered tensor(s). Note that the
first dimension of the result is <em>num_processes</em> multiplied by the first dimension of the input tensors.</p>
`}}),Pe=new $({props:{name:"load_state",anchor:"accelerate.Accelerator.load_state",parameters:[{name:"input_dir",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L582",parametersDescription:[{anchor:"accelerate.Accelerator.load_state.input_dir",description:`<strong>input_dir</strong> (<code>str</code> or <code>os.PathLike</code>) &#x2014;
The name of the folder all relevant weights and states were saved in.`,name:"input_dir"}]}}),Te=new $({props:{name:"local_main_process_first",anchor:"accelerate.Accelerator.local_main_process_first",parameters:[],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L247"}}),Ie=new $({props:{name:"main_process_first",anchor:"accelerate.Accelerator.main_process_first",parameters:[],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L256"}}),ke=new $({props:{name:"pad_across_processes",anchor:"accelerate.Accelerator.pad_across_processes",parameters:[{name:"tensor",val:""},{name:"dim",val:" = 0"},{name:"pad_index",val:" = 0"},{name:"pad_first",val:" = False"}],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L521",parametersDescription:[{anchor:"accelerate.Accelerator.pad_across_processes.tensor",description:`<strong>tensor</strong> (nested list/tuple/dictionary of <code>torch.Tensor</code>) &#x2014;
The data to gather.`,name:"tensor"},{anchor:"accelerate.Accelerator.pad_across_processes.dim",description:`<strong>dim</strong> (<code>int</code>, <em>optional</em>, defaults to 0) &#x2014;
The dimension on which to pad.`,name:"dim"},{anchor:"accelerate.Accelerator.pad_across_processes.pad_index",description:`<strong>pad_index</strong> (<code>int</code>, <em>optional</em>, defaults to 0) &#x2014;
The value with which to pad.`,name:"pad_index"},{anchor:"accelerate.Accelerator.pad_across_processes.pad_first",description:`<strong>pad_first</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether to pad at the beginning or the end.`,name:"pad_first"}]}}),Oe=new $({props:{name:"prepare",anchor:"accelerate.Accelerator.prepare",parameters:[{name:"*args",val:""}],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L294"}}),Ce=new $({props:{name:"print",anchor:"accelerate.Accelerator.print",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L274"}}),Ne=new $({props:{name:"save",anchor:"accelerate.Accelerator.save",parameters:[{name:"obj",val:""},{name:"f",val:""}],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L556",parametersDescription:[{anchor:"accelerate.Accelerator.save.f",description:`<strong>f</strong> (<code>str</code> or <code>os.PathLike</code>) &#x2014;
Where to save the content of <code>obj</code>.`,name:"f"}]}}),qe=new $({props:{name:"save_state",anchor:"accelerate.Accelerator.save_state",parameters:[{name:"output_dir",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L567",parametersDescription:[{anchor:"accelerate.Accelerator.save_state.output_dir",description:`<strong>output_dir</strong> (<code>str</code> or <code>os.PathLike</code>) &#x2014;
The name of the folder to save all relevant weights and states.`,name:"output_dir"}]}}),je=new $({props:{name:"unscale_gradients",anchor:"accelerate.Accelerator.unscale_gradients",parameters:[{name:"optimizer",val:" = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L469",parametersDescription:[{anchor:"accelerate.Accelerator.unscale_gradients.optimizer",description:`<strong>optimizer</strong> (<code>torch.optim.Optimizer</code> or <code>List[torch.optim.Optimizer]</code>, <em>optional</em>) &#x2014;
The optimizer(s) for which to unscale gradients. If not set, will unscale gradients on all optimizers
that were passed to <a href="/docs/accelerate/pr_271/en/accelerator#accelerate.Accelerator.prepare">prepare()</a>.`,name:"optimizer"}]}}),Ve=new $({props:{name:"unwrap_model",anchor:"accelerate.Accelerator.unwrap_model",parameters:[{name:"model",val:""}],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L538",parametersDescription:[{anchor:"accelerate.Accelerator.unwrap_model.model",description:`<strong>model</strong> (<code>torch.nn.Module</code>) &#x2014;
The model to unwrap.`,name:"model"}]}}),Ge=new $({props:{name:"wait_for_everyone",anchor:"accelerate.Accelerator.wait_for_everyone",parameters:[],source:"https://github.com/huggingface/accelerate/blob/pr_271/src/accelerate/accelerator.py#L549"}}),{c(){I=o("meta"),We=l(),x=o("h1"),P=o("a"),pt=o("span"),m(de.$$.fragment),Fr=l(),ht=o("span"),Hr=r("Accelerator"),nr=l(),W=o("p"),Kr=r("The "),Re=o("a"),Xr=r("Accelerator"),Yr=r(` is the main class provided by \u{1F917} Accelerate. It serves at the main entrypoint for
the API. To quickly adapt your script to work on any kind of setup with \u{1F917} Accelerate juste:`),lr=l(),E=o("ol"),N=o("li"),Br=r("Initialize an "),Me=o("a"),Jr=r("Accelerator"),Qr=r(" object (that we will call "),mt=o("code"),Zr=r("accelerator"),ea=r(` in the rest of this
page) as early as possible in your script.`),ta=l(),pe=o("li"),ra=r("Pass along your model(s), optimizer(s), dataloader(s) to the "),Fe=o("a"),aa=r("prepare()"),oa=r(" method."),ca=l(),T=o("li"),sa=r("(Optional but best practice) Remove all the "),ft=o("code"),na=r(".cuda()"),la=r(" or "),ut=o("code"),ia=r(".to(device)"),da=r(` in your code and let the
`),gt=o("code"),pa=r("accelerator"),ha=r(" handle device placement for you."),ma=l(),S=o("li"),fa=r("Replace the "),_t=o("code"),ua=r("loss.backward()"),ga=r(" in your code by "),vt=o("code"),_a=r("accelerator.backward(loss)"),va=r("."),ba=l(),he=o("li"),$a=r(`(Optional, when using distributed evaluation) Gather your predictions and labelsbefore storing them or using them
for metric computation using `),He=o("a"),ya=r("gather()"),Ea=r("."),ir=l(),R=o("p"),wa=r(`This is all what is needed in most cases. For more advanced case or a nicer experience here are the functions you
should search for and replace by the corresponding methods of your `),bt=o("code"),Aa=r("accelerator"),xa=r(":"),dr=l(),b=o("ul"),M=o("li"),$t=o("code"),Da=r("print"),La=r(" statements should be replaced by "),Ke=o("a"),Pa=r("print()"),Ta=r(` to be only printed once per
process.`),Ia=l(),me=o("li"),ka=r("Use "),yt=o("code"),Oa=r("is_local_main_process()"),Ua=r("for statements that should be executed once per server."),Ca=l(),fe=o("li"),za=r("Use "),Et=o("code"),Na=r("is_main_process()"),Sa=r("for statements that should be executed once only."),qa=l(),ue=o("li"),ja=r("Use "),Xe=o("a"),Va=r("wait_for_everyone()"),Ga=r(` to make sure all processes join that point before continuing
(useful before a model save for instance).`),Wa=l(),ge=o("li"),Ra=r("Use "),Ye=o("a"),Ma=r("unwrap_model()"),Fa=r(" to unwrap your model before saving it."),Ha=l(),q=o("li"),Ka=r("Use "),Be=o("a"),Xa=r("save()"),Ya=r(" instead of "),wt=o("code"),Ba=r("torch.save"),Ja=r("."),Qa=l(),A=o("li"),Za=r("Use "),F=o("a"),eo=r("clip"),At=o("em"),to=r("grad_norm"),ro=r("()"),ao=r(" instead of "),xt=o("code"),oo=r("torch.nn.utils.clip_grad_norm_"),co=r(` and
`),H=o("a"),so=r("clip"),Dt=o("em"),no=r("grad_value"),lo=r("()"),io=r(" instead of "),Lt=o("code"),po=r("torch.nn.utils.clip_grad_value_"),ho=r("."),pr=l(),d=o("div"),m(_e.$$.fragment),mo=l(),Pt=o("p"),fo=r("Creates an instance of an accelerator for distributed training (on multi-GPU, TPU) or mixed precision training."),uo=l(),Tt=o("p"),go=r("Attributes"),_o=l(),ve=o("ul"),K=o("li"),It=o("strong"),vo=r("device"),bo=r(" ("),kt=o("code"),$o=r("torch.device"),yo=r(") \u2014 The device to use."),Eo=l(),X=o("li"),Ot=o("strong"),wo=r("state"),Ao=r(" ("),Je=o("a"),xo=r("AcceleratorState"),Do=r(") \u2014 The distributed setup state."),Lo=l(),Y=o("div"),m(be.$$.fragment),Po=l(),Ut=o("p"),To=r(`Will apply automatic mixed-precision inside the block inside this context manager, if it is enabled. Nothing
different will happen otherwise.`),Io=l(),B=o("div"),m($e.$$.fragment),ko=l(),j=o("p"),Oo=r("Use "),Ct=o("code"),Uo=r("accelerator.backward(loss)"),Co=r(" in lieu of "),zt=o("code"),zo=r("loss.backward()"),No=r("."),So=l(),J=o("div"),m(ye.$$.fragment),qo=l(),Ee=o("p"),jo=r("Should be used in place of "),Nt=o("code"),Vo=r("torch.nn.utils.clip_grad_norm_"),Go=r("."),Wo=l(),Q=o("div"),m(we.$$.fragment),Ro=l(),Ae=o("p"),Mo=r("Should be used in place of "),St=o("code"),Fo=r("torch.nn.utils.clip_grad_value_"),Ho=r("."),Ko=l(),Z=o("div"),m(xe.$$.fragment),Xo=l(),qt=o("p"),Yo=r(`Will release all references to the internal objects stored and call the garbage collector. You should call this
method between two trainings with different models/optimizers.`),Bo=l(),k=o("div"),m(De.$$.fragment),Jo=l(),Le=o("p"),Qo=r("Gather the values in "),jt=o("em"),Zo=r("tensor"),ec=r(` accross all processes and concatenate them on the first dimension. Useful to
regroup the predictions from all processes when doing evaluation.`),tc=l(),Vt=o("p"),rc=r(`Note:
This gather happens in all processes.`),ac=l(),ee=o("div"),m(Pe.$$.fragment),oc=l(),Gt=o("p"),cc=r("Loads the current states of the model, optimizer, scaler, and RNG generators."),sc=l(),O=o("div"),m(Te.$$.fragment),nc=l(),Wt=o("p"),lc=r("Lets the local main process go inside a with block."),ic=l(),Rt=o("p"),dc=r("The other processes will enter the with block after the main process exits."),pc=l(),U=o("div"),m(Ie.$$.fragment),hc=l(),Mt=o("p"),mc=r("Lets the main process go first inside a with block."),fc=l(),Ft=o("p"),uc=r("The other processes will enter the with block after the main process exits."),gc=l(),te=o("div"),m(ke.$$.fragment),_c=l(),Ht=o("p"),vc=r(`Recursively pad the tensors in a nested list/tuple/dictionary of tensors from all devices to the same size so
they can safely be gathered.`),bc=l(),D=o("div"),m(Oe.$$.fragment),$c=l(),Ue=o("p"),yc=r("Prepare all objects passed in "),Kt=o("code"),Ec=r("args"),wc=r(` for distributed training and mixed precision, then return them in the same
order.`),Ac=l(),Xt=o("p"),xc=r("Accepts the following type of objects:"),Dc=l(),V=o("ul"),Qe=o("li"),Yt=o("code"),Lc=r("torch.utils.data.DataLoader"),Pc=r(": PyTorch Dataloader"),Tc=l(),Ze=o("li"),Bt=o("code"),Ic=r("torch.nn.Module"),kc=r(": PyTorch Module"),Oc=l(),et=o("li"),Jt=o("code"),Uc=r("torch.optim.Optimizer"),Cc=r(": PyTorch Optimizer"),zc=l(),re=o("div"),m(Ce.$$.fragment),Nc=l(),ze=o("p"),Sc=r("Use in replacement of "),Qt=o("code"),qc=r("print()"),jc=r(" to only print once per server."),Vc=l(),ae=o("div"),m(Ne.$$.fragment),Gc=l(),Se=o("p"),Wc=r("Save the object passed to disk once per machine. Use in place of "),Zt=o("code"),Rc=r("torch.save"),Mc=r("."),Fc=l(),oe=o("div"),m(qe.$$.fragment),Hc=l(),er=o("p"),Kc=r("Saves the current states of the model, optimizer, scaler, and RNG generators."),Xc=l(),ce=o("div"),m(je.$$.fragment),Yc=l(),tr=o("p"),Bc=r("Unscale the gradients in mixed precision training with AMP. This is a noop in all other settings."),Jc=l(),se=o("div"),m(Ve.$$.fragment),Qc=l(),G=o("p"),Zc=r("Unwraps the "),rr=o("code"),es=r("model"),ts=r(" from the additional layer possible added by "),tt=o("a"),rs=r("prepare()"),as=r(`. Useful before saving
the model.`),os=l(),ne=o("div"),m(Ge.$$.fragment),cs=l(),ar=o("p"),ss=r(`Will stop the execution of the current process until every other process has reached that point (so this does
nothing when the script is only run in one process). Useful to do before saving a model.`),this.h()},l(n){const y=vn('[data-svelte="svelte-1phssyn"]',document.head);I=c(y,"META",{name:!0,content:!0}),y.forEach(t),We=i(n),x=c(n,"H1",{class:!0});var mr=s(x);P=c(mr,"A",{id:!0,class:!0,href:!0});var ds=s(P);pt=c(ds,"SPAN",{});var ps=s(pt);f(de.$$.fragment,ps),ps.forEach(t),ds.forEach(t),Fr=i(mr),ht=c(mr,"SPAN",{});var hs=s(ht);Hr=a(hs,"Accelerator"),hs.forEach(t),mr.forEach(t),nr=i(n),W=c(n,"P",{});var fr=s(W);Kr=a(fr,"The "),Re=c(fr,"A",{href:!0});var ms=s(Re);Xr=a(ms,"Accelerator"),ms.forEach(t),Yr=a(fr,` is the main class provided by \u{1F917} Accelerate. It serves at the main entrypoint for
the API. To quickly adapt your script to work on any kind of setup with \u{1F917} Accelerate juste:`),fr.forEach(t),lr=i(n),E=c(n,"OL",{});var C=s(E);N=c(C,"LI",{});var rt=s(N);Br=a(rt,"Initialize an "),Me=c(rt,"A",{href:!0});var fs=s(Me);Jr=a(fs,"Accelerator"),fs.forEach(t),Qr=a(rt," object (that we will call "),mt=c(rt,"CODE",{});var us=s(mt);Zr=a(us,"accelerator"),us.forEach(t),ea=a(rt,` in the rest of this
page) as early as possible in your script.`),rt.forEach(t),ta=i(C),pe=c(C,"LI",{});var ur=s(pe);ra=a(ur,"Pass along your model(s), optimizer(s), dataloader(s) to the "),Fe=c(ur,"A",{href:!0});var gs=s(Fe);aa=a(gs,"prepare()"),gs.forEach(t),oa=a(ur," method."),ur.forEach(t),ca=i(C),T=c(C,"LI",{});var le=s(T);sa=a(le,"(Optional but best practice) Remove all the "),ft=c(le,"CODE",{});var _s=s(ft);na=a(_s,".cuda()"),_s.forEach(t),la=a(le," or "),ut=c(le,"CODE",{});var vs=s(ut);ia=a(vs,".to(device)"),vs.forEach(t),da=a(le,` in your code and let the
`),gt=c(le,"CODE",{});var bs=s(gt);pa=a(bs,"accelerator"),bs.forEach(t),ha=a(le," handle device placement for you."),le.forEach(t),ma=i(C),S=c(C,"LI",{});var at=s(S);fa=a(at,"Replace the "),_t=c(at,"CODE",{});var $s=s(_t);ua=a($s,"loss.backward()"),$s.forEach(t),ga=a(at," in your code by "),vt=c(at,"CODE",{});var ys=s(vt);_a=a(ys,"accelerator.backward(loss)"),ys.forEach(t),va=a(at,"."),at.forEach(t),ba=i(C),he=c(C,"LI",{});var gr=s(he);$a=a(gr,`(Optional, when using distributed evaluation) Gather your predictions and labelsbefore storing them or using them
for metric computation using `),He=c(gr,"A",{href:!0});var Es=s(He);ya=a(Es,"gather()"),Es.forEach(t),Ea=a(gr,"."),gr.forEach(t),C.forEach(t),ir=i(n),R=c(n,"P",{});var _r=s(R);wa=a(_r,`This is all what is needed in most cases. For more advanced case or a nicer experience here are the functions you
should search for and replace by the corresponding methods of your `),bt=c(_r,"CODE",{});var ws=s(bt);Aa=a(ws,"accelerator"),ws.forEach(t),xa=a(_r,":"),_r.forEach(t),dr=i(n),b=c(n,"UL",{});var w=s(b);M=c(w,"LI",{});var or=s(M);$t=c(or,"CODE",{});var As=s($t);Da=a(As,"print"),As.forEach(t),La=a(or," statements should be replaced by "),Ke=c(or,"A",{href:!0});var xs=s(Ke);Pa=a(xs,"print()"),xs.forEach(t),Ta=a(or,` to be only printed once per
process.`),or.forEach(t),Ia=i(w),me=c(w,"LI",{});var vr=s(me);ka=a(vr,"Use "),yt=c(vr,"CODE",{});var Ds=s(yt);Oa=a(Ds,"is_local_main_process()"),Ds.forEach(t),Ua=a(vr,"for statements that should be executed once per server."),vr.forEach(t),Ca=i(w),fe=c(w,"LI",{});var br=s(fe);za=a(br,"Use "),Et=c(br,"CODE",{});var Ls=s(Et);Na=a(Ls,"is_main_process()"),Ls.forEach(t),Sa=a(br,"for statements that should be executed once only."),br.forEach(t),qa=i(w),ue=c(w,"LI",{});var $r=s(ue);ja=a($r,"Use "),Xe=c($r,"A",{href:!0});var Ps=s(Xe);Va=a(Ps,"wait_for_everyone()"),Ps.forEach(t),Ga=a($r,` to make sure all processes join that point before continuing
(useful before a model save for instance).`),$r.forEach(t),Wa=i(w),ge=c(w,"LI",{});var yr=s(ge);Ra=a(yr,"Use "),Ye=c(yr,"A",{href:!0});var Ts=s(Ye);Ma=a(Ts,"unwrap_model()"),Ts.forEach(t),Fa=a(yr," to unwrap your model before saving it."),yr.forEach(t),Ha=i(w),q=c(w,"LI",{});var ot=s(q);Ka=a(ot,"Use "),Be=c(ot,"A",{href:!0});var Is=s(Be);Xa=a(Is,"save()"),Is.forEach(t),Ya=a(ot," instead of "),wt=c(ot,"CODE",{});var ks=s(wt);Ba=a(ks,"torch.save"),ks.forEach(t),Ja=a(ot,"."),ot.forEach(t),Qa=i(w),A=c(w,"LI",{});var z=s(A);Za=a(z,"Use "),F=c(z,"A",{href:!0});var Er=s(F);eo=a(Er,"clip"),At=c(Er,"EM",{});var Os=s(At);to=a(Os,"grad_norm"),Os.forEach(t),ro=a(Er,"()"),Er.forEach(t),ao=a(z," instead of "),xt=c(z,"CODE",{});var Us=s(xt);oo=a(Us,"torch.nn.utils.clip_grad_norm_"),Us.forEach(t),co=a(z,` and
`),H=c(z,"A",{href:!0});var wr=s(H);so=a(wr,"clip"),Dt=c(wr,"EM",{});var Cs=s(Dt);no=a(Cs,"grad_value"),Cs.forEach(t),lo=a(wr,"()"),wr.forEach(t),io=a(z," instead of "),Lt=c(z,"CODE",{});var zs=s(Lt);po=a(zs,"torch.nn.utils.clip_grad_value_"),zs.forEach(t),ho=a(z,"."),z.forEach(t),w.forEach(t),pr=i(n),d=c(n,"DIV",{class:!0});var p=s(d);f(_e.$$.fragment,p),mo=i(p),Pt=c(p,"P",{});var Ns=s(Pt);fo=a(Ns,"Creates an instance of an accelerator for distributed training (on multi-GPU, TPU) or mixed precision training."),Ns.forEach(t),uo=i(p),Tt=c(p,"P",{});var Ss=s(Tt);go=a(Ss,"Attributes"),Ss.forEach(t),_o=i(p),ve=c(p,"UL",{});var Ar=s(ve);K=c(Ar,"LI",{});var cr=s(K);It=c(cr,"STRONG",{});var qs=s(It);vo=a(qs,"device"),qs.forEach(t),bo=a(cr," ("),kt=c(cr,"CODE",{});var js=s(kt);$o=a(js,"torch.device"),js.forEach(t),yo=a(cr,") \u2014 The device to use."),cr.forEach(t),Eo=i(Ar),X=c(Ar,"LI",{});var sr=s(X);Ot=c(sr,"STRONG",{});var Vs=s(Ot);wo=a(Vs,"state"),Vs.forEach(t),Ao=a(sr," ("),Je=c(sr,"A",{href:!0});var Gs=s(Je);xo=a(Gs,"AcceleratorState"),Gs.forEach(t),Do=a(sr,") \u2014 The distributed setup state."),sr.forEach(t),Ar.forEach(t),Lo=i(p),Y=c(p,"DIV",{class:!0});var xr=s(Y);f(be.$$.fragment,xr),Po=i(xr),Ut=c(xr,"P",{});var Ws=s(Ut);To=a(Ws,`Will apply automatic mixed-precision inside the block inside this context manager, if it is enabled. Nothing
different will happen otherwise.`),Ws.forEach(t),xr.forEach(t),Io=i(p),B=c(p,"DIV",{class:!0});var Dr=s(B);f($e.$$.fragment,Dr),ko=i(Dr),j=c(Dr,"P",{});var ct=s(j);Oo=a(ct,"Use "),Ct=c(ct,"CODE",{});var Rs=s(Ct);Uo=a(Rs,"accelerator.backward(loss)"),Rs.forEach(t),Co=a(ct," in lieu of "),zt=c(ct,"CODE",{});var Ms=s(zt);zo=a(Ms,"loss.backward()"),Ms.forEach(t),No=a(ct,"."),ct.forEach(t),Dr.forEach(t),So=i(p),J=c(p,"DIV",{class:!0});var Lr=s(J);f(ye.$$.fragment,Lr),qo=i(Lr),Ee=c(Lr,"P",{});var Pr=s(Ee);jo=a(Pr,"Should be used in place of "),Nt=c(Pr,"CODE",{});var Fs=s(Nt);Vo=a(Fs,"torch.nn.utils.clip_grad_norm_"),Fs.forEach(t),Go=a(Pr,"."),Pr.forEach(t),Lr.forEach(t),Wo=i(p),Q=c(p,"DIV",{class:!0});var Tr=s(Q);f(we.$$.fragment,Tr),Ro=i(Tr),Ae=c(Tr,"P",{});var Ir=s(Ae);Mo=a(Ir,"Should be used in place of "),St=c(Ir,"CODE",{});var Hs=s(St);Fo=a(Hs,"torch.nn.utils.clip_grad_value_"),Hs.forEach(t),Ho=a(Ir,"."),Ir.forEach(t),Tr.forEach(t),Ko=i(p),Z=c(p,"DIV",{class:!0});var kr=s(Z);f(xe.$$.fragment,kr),Xo=i(kr),qt=c(kr,"P",{});var Ks=s(qt);Yo=a(Ks,`Will release all references to the internal objects stored and call the garbage collector. You should call this
method between two trainings with different models/optimizers.`),Ks.forEach(t),kr.forEach(t),Bo=i(p),k=c(p,"DIV",{class:!0});var st=s(k);f(De.$$.fragment,st),Jo=i(st),Le=c(st,"P",{});var Or=s(Le);Qo=a(Or,"Gather the values in "),jt=c(Or,"EM",{});var Xs=s(jt);Zo=a(Xs,"tensor"),Xs.forEach(t),ec=a(Or,` accross all processes and concatenate them on the first dimension. Useful to
regroup the predictions from all processes when doing evaluation.`),Or.forEach(t),tc=i(st),Vt=c(st,"P",{});var Ys=s(Vt);rc=a(Ys,`Note:
This gather happens in all processes.`),Ys.forEach(t),st.forEach(t),ac=i(p),ee=c(p,"DIV",{class:!0});var Ur=s(ee);f(Pe.$$.fragment,Ur),oc=i(Ur),Gt=c(Ur,"P",{});var Bs=s(Gt);cc=a(Bs,"Loads the current states of the model, optimizer, scaler, and RNG generators."),Bs.forEach(t),Ur.forEach(t),sc=i(p),O=c(p,"DIV",{class:!0});var nt=s(O);f(Te.$$.fragment,nt),nc=i(nt),Wt=c(nt,"P",{});var Js=s(Wt);lc=a(Js,"Lets the local main process go inside a with block."),Js.forEach(t),ic=i(nt),Rt=c(nt,"P",{});var Qs=s(Rt);dc=a(Qs,"The other processes will enter the with block after the main process exits."),Qs.forEach(t),nt.forEach(t),pc=i(p),U=c(p,"DIV",{class:!0});var lt=s(U);f(Ie.$$.fragment,lt),hc=i(lt),Mt=c(lt,"P",{});var Zs=s(Mt);mc=a(Zs,"Lets the main process go first inside a with block."),Zs.forEach(t),fc=i(lt),Ft=c(lt,"P",{});var en=s(Ft);uc=a(en,"The other processes will enter the with block after the main process exits."),en.forEach(t),lt.forEach(t),gc=i(p),te=c(p,"DIV",{class:!0});var Cr=s(te);f(ke.$$.fragment,Cr),_c=i(Cr),Ht=c(Cr,"P",{});var tn=s(Ht);vc=a(tn,`Recursively pad the tensors in a nested list/tuple/dictionary of tensors from all devices to the same size so
they can safely be gathered.`),tn.forEach(t),Cr.forEach(t),bc=i(p),D=c(p,"DIV",{class:!0});var ie=s(D);f(Oe.$$.fragment,ie),$c=i(ie),Ue=c(ie,"P",{});var zr=s(Ue);yc=a(zr,"Prepare all objects passed in "),Kt=c(zr,"CODE",{});var rn=s(Kt);Ec=a(rn,"args"),rn.forEach(t),wc=a(zr,` for distributed training and mixed precision, then return them in the same
order.`),zr.forEach(t),Ac=i(ie),Xt=c(ie,"P",{});var an=s(Xt);xc=a(an,"Accepts the following type of objects:"),an.forEach(t),Dc=i(ie),V=c(ie,"UL",{});var it=s(V);Qe=c(it,"LI",{});var ns=s(Qe);Yt=c(ns,"CODE",{});var on=s(Yt);Lc=a(on,"torch.utils.data.DataLoader"),on.forEach(t),Pc=a(ns,": PyTorch Dataloader"),ns.forEach(t),Tc=i(it),Ze=c(it,"LI",{});var ls=s(Ze);Bt=c(ls,"CODE",{});var cn=s(Bt);Ic=a(cn,"torch.nn.Module"),cn.forEach(t),kc=a(ls,": PyTorch Module"),ls.forEach(t),Oc=i(it),et=c(it,"LI",{});var is=s(et);Jt=c(is,"CODE",{});var sn=s(Jt);Uc=a(sn,"torch.optim.Optimizer"),sn.forEach(t),Cc=a(is,": PyTorch Optimizer"),is.forEach(t),it.forEach(t),ie.forEach(t),zc=i(p),re=c(p,"DIV",{class:!0});var Nr=s(re);f(Ce.$$.fragment,Nr),Nc=i(Nr),ze=c(Nr,"P",{});var Sr=s(ze);Sc=a(Sr,"Use in replacement of "),Qt=c(Sr,"CODE",{});var nn=s(Qt);qc=a(nn,"print()"),nn.forEach(t),jc=a(Sr," to only print once per server."),Sr.forEach(t),Nr.forEach(t),Vc=i(p),ae=c(p,"DIV",{class:!0});var qr=s(ae);f(Ne.$$.fragment,qr),Gc=i(qr),Se=c(qr,"P",{});var jr=s(Se);Wc=a(jr,"Save the object passed to disk once per machine. Use in place of "),Zt=c(jr,"CODE",{});var ln=s(Zt);Rc=a(ln,"torch.save"),ln.forEach(t),Mc=a(jr,"."),jr.forEach(t),qr.forEach(t),Fc=i(p),oe=c(p,"DIV",{class:!0});var Vr=s(oe);f(qe.$$.fragment,Vr),Hc=i(Vr),er=c(Vr,"P",{});var dn=s(er);Kc=a(dn,"Saves the current states of the model, optimizer, scaler, and RNG generators."),dn.forEach(t),Vr.forEach(t),Xc=i(p),ce=c(p,"DIV",{class:!0});var Gr=s(ce);f(je.$$.fragment,Gr),Yc=i(Gr),tr=c(Gr,"P",{});var pn=s(tr);Bc=a(pn,"Unscale the gradients in mixed precision training with AMP. This is a noop in all other settings."),pn.forEach(t),Gr.forEach(t),Jc=i(p),se=c(p,"DIV",{class:!0});var Wr=s(se);f(Ve.$$.fragment,Wr),Qc=i(Wr),G=c(Wr,"P",{});var dt=s(G);Zc=a(dt,"Unwraps the "),rr=c(dt,"CODE",{});var hn=s(rr);es=a(hn,"model"),hn.forEach(t),ts=a(dt," from the additional layer possible added by "),tt=c(dt,"A",{href:!0});var mn=s(tt);rs=a(mn,"prepare()"),mn.forEach(t),as=a(dt,`. Useful before saving
the model.`),dt.forEach(t),Wr.forEach(t),os=i(p),ne=c(p,"DIV",{class:!0});var Rr=s(ne);f(Ge.$$.fragment,Rr),cs=i(Rr),ar=c(Rr,"P",{});var fn=s(ar);ss=a(fn,`Will stop the execution of the current process until every other process has reached that point (so this does
nothing when the script is only run in one process). Useful to do before saving a model.`),fn.forEach(t),Rr.forEach(t),p.forEach(t),this.h()},h(){h(I,"name","hf:doc:metadata"),h(I,"content",JSON.stringify(En)),h(P,"id","accelerate.Accelerator"),h(P,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),h(P,"href","#accelerate.Accelerator"),h(x,"class","relative group"),h(Re,"href","/docs/accelerate/pr_271/en/accelerator#accelerate.Accelerator"),h(Me,"href","/docs/accelerate/pr_271/en/accelerator#accelerate.Accelerator"),h(Fe,"href","/docs/accelerate/pr_271/en/accelerator#accelerate.Accelerator.prepare"),h(He,"href","/docs/accelerate/pr_271/en/accelerator#accelerate.Accelerator.gather"),h(Ke,"href","/docs/accelerate/pr_271/en/accelerator#accelerate.Accelerator.print"),h(Xe,"href","/docs/accelerate/pr_271/en/accelerator#accelerate.Accelerator.wait_for_everyone"),h(Ye,"href","/docs/accelerate/pr_271/en/accelerator#accelerate.Accelerator.unwrap_model"),h(Be,"href","/docs/accelerate/pr_271/en/accelerator#accelerate.Accelerator.save"),h(F,"href","/docs/accelerate/pr_271/en/accelerator#accelerate.Accelerator.clip_grad_norm_"),h(H,"href","/docs/accelerate/pr_271/en/accelerator#accelerate.Accelerator.clip_grad_value_"),h(Je,"href","/docs/accelerate/pr_271/en/internal#accelerate.state.AcceleratorState"),h(Y,"class","docstring"),h(B,"class","docstring"),h(J,"class","docstring"),h(Q,"class","docstring"),h(Z,"class","docstring"),h(k,"class","docstring"),h(ee,"class","docstring"),h(O,"class","docstring"),h(U,"class","docstring"),h(te,"class","docstring"),h(D,"class","docstring"),h(re,"class","docstring"),h(ae,"class","docstring"),h(oe,"class","docstring"),h(ce,"class","docstring"),h(tt,"href","/docs/accelerate/pr_271/en/accelerator#accelerate.Accelerator.prepare"),h(se,"class","docstring"),h(ne,"class","docstring"),h(d,"class","docstring")},m(n,y){e(document.head,I),L(n,We,y),L(n,x,y),e(x,P),e(P,pt),u(de,pt,null),e(x,Fr),e(x,ht),e(ht,Hr),L(n,nr,y),L(n,W,y),e(W,Kr),e(W,Re),e(Re,Xr),e(W,Yr),L(n,lr,y),L(n,E,y),e(E,N),e(N,Br),e(N,Me),e(Me,Jr),e(N,Qr),e(N,mt),e(mt,Zr),e(N,ea),e(E,ta),e(E,pe),e(pe,ra),e(pe,Fe),e(Fe,aa),e(pe,oa),e(E,ca),e(E,T),e(T,sa),e(T,ft),e(ft,na),e(T,la),e(T,ut),e(ut,ia),e(T,da),e(T,gt),e(gt,pa),e(T,ha),e(E,ma),e(E,S),e(S,fa),e(S,_t),e(_t,ua),e(S,ga),e(S,vt),e(vt,_a),e(S,va),e(E,ba),e(E,he),e(he,$a),e(he,He),e(He,ya),e(he,Ea),L(n,ir,y),L(n,R,y),e(R,wa),e(R,bt),e(bt,Aa),e(R,xa),L(n,dr,y),L(n,b,y),e(b,M),e(M,$t),e($t,Da),e(M,La),e(M,Ke),e(Ke,Pa),e(M,Ta),e(b,Ia),e(b,me),e(me,ka),e(me,yt),e(yt,Oa),e(me,Ua),e(b,Ca),e(b,fe),e(fe,za),e(fe,Et),e(Et,Na),e(fe,Sa),e(b,qa),e(b,ue),e(ue,ja),e(ue,Xe),e(Xe,Va),e(ue,Ga),e(b,Wa),e(b,ge),e(ge,Ra),e(ge,Ye),e(Ye,Ma),e(ge,Fa),e(b,Ha),e(b,q),e(q,Ka),e(q,Be),e(Be,Xa),e(q,Ya),e(q,wt),e(wt,Ba),e(q,Ja),e(b,Qa),e(b,A),e(A,Za),e(A,F),e(F,eo),e(F,At),e(At,to),e(F,ro),e(A,ao),e(A,xt),e(xt,oo),e(A,co),e(A,H),e(H,so),e(H,Dt),e(Dt,no),e(H,lo),e(A,io),e(A,Lt),e(Lt,po),e(A,ho),L(n,pr,y),L(n,d,y),u(_e,d,null),e(d,mo),e(d,Pt),e(Pt,fo),e(d,uo),e(d,Tt),e(Tt,go),e(d,_o),e(d,ve),e(ve,K),e(K,It),e(It,vo),e(K,bo),e(K,kt),e(kt,$o),e(K,yo),e(ve,Eo),e(ve,X),e(X,Ot),e(Ot,wo),e(X,Ao),e(X,Je),e(Je,xo),e(X,Do),e(d,Lo),e(d,Y),u(be,Y,null),e(Y,Po),e(Y,Ut),e(Ut,To),e(d,Io),e(d,B),u($e,B,null),e(B,ko),e(B,j),e(j,Oo),e(j,Ct),e(Ct,Uo),e(j,Co),e(j,zt),e(zt,zo),e(j,No),e(d,So),e(d,J),u(ye,J,null),e(J,qo),e(J,Ee),e(Ee,jo),e(Ee,Nt),e(Nt,Vo),e(Ee,Go),e(d,Wo),e(d,Q),u(we,Q,null),e(Q,Ro),e(Q,Ae),e(Ae,Mo),e(Ae,St),e(St,Fo),e(Ae,Ho),e(d,Ko),e(d,Z),u(xe,Z,null),e(Z,Xo),e(Z,qt),e(qt,Yo),e(d,Bo),e(d,k),u(De,k,null),e(k,Jo),e(k,Le),e(Le,Qo),e(Le,jt),e(jt,Zo),e(Le,ec),e(k,tc),e(k,Vt),e(Vt,rc),e(d,ac),e(d,ee),u(Pe,ee,null),e(ee,oc),e(ee,Gt),e(Gt,cc),e(d,sc),e(d,O),u(Te,O,null),e(O,nc),e(O,Wt),e(Wt,lc),e(O,ic),e(O,Rt),e(Rt,dc),e(d,pc),e(d,U),u(Ie,U,null),e(U,hc),e(U,Mt),e(Mt,mc),e(U,fc),e(U,Ft),e(Ft,uc),e(d,gc),e(d,te),u(ke,te,null),e(te,_c),e(te,Ht),e(Ht,vc),e(d,bc),e(d,D),u(Oe,D,null),e(D,$c),e(D,Ue),e(Ue,yc),e(Ue,Kt),e(Kt,Ec),e(Ue,wc),e(D,Ac),e(D,Xt),e(Xt,xc),e(D,Dc),e(D,V),e(V,Qe),e(Qe,Yt),e(Yt,Lc),e(Qe,Pc),e(V,Tc),e(V,Ze),e(Ze,Bt),e(Bt,Ic),e(Ze,kc),e(V,Oc),e(V,et),e(et,Jt),e(Jt,Uc),e(et,Cc),e(d,zc),e(d,re),u(Ce,re,null),e(re,Nc),e(re,ze),e(ze,Sc),e(ze,Qt),e(Qt,qc),e(ze,jc),e(d,Vc),e(d,ae),u(Ne,ae,null),e(ae,Gc),e(ae,Se),e(Se,Wc),e(Se,Zt),e(Zt,Rc),e(Se,Mc),e(d,Fc),e(d,oe),u(qe,oe,null),e(oe,Hc),e(oe,er),e(er,Kc),e(d,Xc),e(d,ce),u(je,ce,null),e(ce,Yc),e(ce,tr),e(tr,Bc),e(d,Jc),e(d,se),u(Ve,se,null),e(se,Qc),e(se,G),e(G,Zc),e(G,rr),e(rr,es),e(G,ts),e(G,tt),e(tt,rs),e(G,as),e(d,os),e(d,ne),u(Ge,ne,null),e(ne,cs),e(ne,ar),e(ar,ss),hr=!0},p:bn,i(n){hr||(g(de.$$.fragment,n),g(_e.$$.fragment,n),g(be.$$.fragment,n),g($e.$$.fragment,n),g(ye.$$.fragment,n),g(we.$$.fragment,n),g(xe.$$.fragment,n),g(De.$$.fragment,n),g(Pe.$$.fragment,n),g(Te.$$.fragment,n),g(Ie.$$.fragment,n),g(ke.$$.fragment,n),g(Oe.$$.fragment,n),g(Ce.$$.fragment,n),g(Ne.$$.fragment,n),g(qe.$$.fragment,n),g(je.$$.fragment,n),g(Ve.$$.fragment,n),g(Ge.$$.fragment,n),hr=!0)},o(n){_(de.$$.fragment,n),_(_e.$$.fragment,n),_(be.$$.fragment,n),_($e.$$.fragment,n),_(ye.$$.fragment,n),_(we.$$.fragment,n),_(xe.$$.fragment,n),_(De.$$.fragment,n),_(Pe.$$.fragment,n),_(Te.$$.fragment,n),_(Ie.$$.fragment,n),_(ke.$$.fragment,n),_(Oe.$$.fragment,n),_(Ce.$$.fragment,n),_(Ne.$$.fragment,n),_(qe.$$.fragment,n),_(je.$$.fragment,n),_(Ve.$$.fragment,n),_(Ge.$$.fragment,n),hr=!1},d(n){t(I),n&&t(We),n&&t(x),v(de),n&&t(nr),n&&t(W),n&&t(lr),n&&t(E),n&&t(ir),n&&t(R),n&&t(dr),n&&t(b),n&&t(pr),n&&t(d),v(_e),v(be),v($e),v(ye),v(we),v(xe),v(De),v(Pe),v(Te),v(Ie),v(ke),v(Oe),v(Ce),v(Ne),v(qe),v(je),v(Ve),v(Ge)}}}const En={local:"accelerate.Accelerator",title:"Accelerator"};function wn(Mr,I,We){let{fw:x}=I;return Mr.$$set=P=>{"fw"in P&&We(0,x=P.fw)},[x]}class Ln extends un{constructor(I){super();gn(this,I,wn,yn,_n,{fw:0})}}export{Ln as default,En as metadata};
