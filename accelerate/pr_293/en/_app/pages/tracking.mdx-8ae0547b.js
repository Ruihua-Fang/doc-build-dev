import{S as Nn,i as Wn,s as Vn,e as n,k as i,w as m,t as r,M as Mn,c as s,d as a,m as p,a as l,x as h,h as o,b as u,F as t,g as d,y as f,L as Gn,q as g,o as _,B as v,v as Rn}from"../chunks/vendor-19e06bd2.js";import{D as b}from"../chunks/Docstring-395e5a9c.js";import{C as qe}from"../chunks/CodeBlock-9dd1fdfb.js";import{I as La}from"../chunks/IconCopyLink-3c713d38.js";function Hn(Go){let P,Bt,O,W,Ke,re,Pa,Qe,Oa,St,oe,Ia,Be,qa,zt,I,V,Xe,ne,Ba,Ye,Sa,Nt,M,za,Ze,Na,Wa,Wt,y,se,Va,q,Ma,et,Ga,Ra,tt,Ha,Fa,Ua,G,le,Ja,ce,Ka,at,Qa,Xa,Ya,R,ie,Za,pe,er,rt,tr,ar,rr,H,de,or,ue,nr,ot,sr,lr,Vt,k,me,cr,B,ir,nt,pr,dr,st,ur,mr,hr,F,he,fr,fe,gr,lt,_r,vr,yr,U,ge,kr,_e,$r,ct,br,wr,Er,J,ve,Tr,ye,Ar,it,jr,Dr,Mt,$,ke,Cr,S,xr,pt,Lr,Pr,dt,Or,Ir,qr,ut,Br,Sr,K,$e,zr,be,Nr,mt,Wr,Vr,Mr,Q,we,Gr,Ee,Rr,ht,Hr,Fr,Gt,w,Ur,ft,Jr,Kr,gt,Qr,Xr,Rt,Te,Ht,X,Yr,_t,Zr,eo,Ft,Ae,Ut,E,to,Se,ao,ro,vt,oo,no,Jt,je,Kt,Y,so,ze,lo,co,Qt,De,Xt,Ne,io,Yt,Ce,Zt,z,Z,yt,xe,po,kt,uo,ea,T,mo,$t,ho,fo,bt,go,_o,ta,A,ee,wt,vo,yo,Et,ko,$o,bo,te,Tt,wo,Eo,At,To,Ao,jo,j,jt,Do,Co,Dt,xo,Lo,Ct,Po,Oo,aa,We,Io,ra,Le,oa,N,ae,xt,Pe,qo,Lt,Bo,na,D,So,Pt,zo,No,Ot,Wo,Vo,sa,Oe,la;return re=new La({}),ne=new La({}),se=new b({props:{name:"class accelerate.tracking.TensorBoardTracker",anchor:"accelerate.tracking.TensorBoardTracker",parameters:[{name:"run_name",val:": str"},{name:"logging_dir",val:": typing.Union[str, os.PathLike, NoneType] = ''"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L92",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run`,name:"run_name"},{anchor:"accelerate.tracking.TensorBoardTracker.logging_dir",description:`<strong>logging_dir</strong> (<code>str</code>, <code>os.PathLike</code>) &#x2014;
Location for TensorBoard logs to be stored.`,name:"logging_dir"}]}}),le=new b({props:{name:"finish",anchor:"accelerate.tracking.TensorBoardTracker.finish",parameters:[],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L143"}}),ie=new b({props:{name:"log",anchor:"accelerate.tracking.TensorBoardTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L125",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.TensorBoardTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),de=new b({props:{name:"store_init_configuration",anchor:"accelerate.tracking.TensorBoardTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L112",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),me=new b({props:{name:"class accelerate.tracking.WandBTracker",anchor:"accelerate.tracking.WandBTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L151",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run.`,name:"run_name"}]}}),he=new b({props:{name:"finish",anchor:"accelerate.tracking.WandBTracker.finish",parameters:[],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L193"}}),ge=new b({props:{name:"log",anchor:"accelerate.tracking.WandBTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L180",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.WandBTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),ve=new b({props:{name:"store_init_configuration",anchor:"accelerate.tracking.WandBTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L168",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),ke=new b({props:{name:"class accelerate.tracking.CometMLTracker",anchor:"accelerate.tracking.CometMLTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L201",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run.`,name:"run_name"}]}}),$e=new b({props:{name:"log",anchor:"accelerate.tracking.CometMLTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L232",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.CometMLTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),we=new b({props:{name:"store_init_configuration",anchor:"accelerate.tracking.CometMLTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L220",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),Te=new qe({props:{code:`from accelerate import Accelerate
from accelerate.utils import LoggerType

accelerator = Accelerate(log_with="all")  # For all available trackers in the environment
accelerator = Accelerate(log_with="wandb")
accelerator = Accelerate(log_with=["wandb", LoggerType.TENSORBOARD])`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerate
<span class="hljs-keyword">from</span> accelerate.utils <span class="hljs-keyword">import</span> LoggerType

accelerator = Accelerate(log_with=<span class="hljs-string">&quot;all&quot;</span>)  <span class="hljs-comment"># For all available trackers in the environment</span>
accelerator = Accelerate(log_with=<span class="hljs-string">&quot;wandb&quot;</span>)
accelerator = Accelerate(log_with=[<span class="hljs-string">&quot;wandb&quot;</span>, LoggerType.TENSORBOARD])`}}),Ae=new qe({props:{code:`hps = {"num_iterations": 5, "learning_rate": 1e-2}
accelerator.init_trackers("my_project", config=hps)`,highlighted:`hps = {<span class="hljs-string">&quot;num_iterations&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&quot;learning_rate&quot;</span>: <span class="hljs-number">1e-2</span>}
accelerator.init_trackers(<span class="hljs-string">&quot;my_project&quot;</span>, config=hps)`}}),je=new qe({props:{code:'accelerator.log({"train_loss": 1.12, "valid_loss": 0.8}, step=1)',highlighted:'accelerator.log({<span class="hljs-string">&quot;train_loss&quot;</span>: <span class="hljs-number">1.12</span>, <span class="hljs-string">&quot;valid_loss&quot;</span>: <span class="hljs-number">0.8</span>}, step=<span class="hljs-number">1</span>)'}}),De=new qe({props:{code:"accelerator.end_training()",highlighted:"accelerator.end_training()"}}),Ce=new qe({props:{code:`from accelerate import Accelerator

accelerator = Accelerator(log_with="all")
config = {
    "num_iterations": 5,
    "learning_rate": 1e-2,
    "loss_function": str(my_loss_function),
}

accelerator.init_trackers("example_project", config=config)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config["num_iterations"]:
    for step, batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        accelerator.backward(loss)
        my_optimizer.step()
        accelerator.log({"training_loss": loss}, step=step)
accelerator.end_training()`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator

accelerator = Accelerator(log_with=<span class="hljs-string">&quot;all&quot;</span>)
config = {
    <span class="hljs-string">&quot;num_iterations&quot;</span>: <span class="hljs-number">5</span>,
    <span class="hljs-string">&quot;learning_rate&quot;</span>: <span class="hljs-number">1e-2</span>,
    <span class="hljs-string">&quot;loss_function&quot;</span>: <span class="hljs-built_in">str</span>(my_loss_function),
}

accelerator.init_trackers(<span class="hljs-string">&quot;example_project&quot;</span>, config=config)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

<span class="hljs-keyword">for</span> iteration <span class="hljs-keyword">in</span> config[<span class="hljs-string">&quot;num_iterations&quot;</span>]:
    <span class="hljs-keyword">for</span> step, batch <span class="hljs-keyword">in</span> my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        accelerator.backward(loss)
        my_optimizer.step()
        accelerator.log({<span class="hljs-string">&quot;training_loss&quot;</span>: loss}, step=step)
accelerator.end_training()`}}),xe=new La({}),Le=new qe({props:{code:`from accelerate.tracking import GeneralTracker
from typing import Optional

import wandb


class WandBTracker(GeneralTracker):
    def __init__(self, run_name: str):
        self.run_name = run_name
        wandb.init(self.run_name)

    def store_init_configuration(self, values: dict):
        wandb.config(values)

    def log(self, values: dict, step: Optional[int] = None):
        wandb.log(values, step=step)`,highlighted:`<span class="hljs-keyword">from</span> accelerate.tracking <span class="hljs-keyword">import</span> GeneralTracker
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>

<span class="hljs-keyword">import</span> wandb


<span class="hljs-keyword">class</span> <span class="hljs-title class_">WandBTracker</span>(<span class="hljs-title class_ inherited__">GeneralTracker</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, run_name: <span class="hljs-built_in">str</span></span>):
        self.run_name = run_name
        wandb.init(self.run_name)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">store_init_configuration</span>(<span class="hljs-params">self, values: <span class="hljs-built_in">dict</span></span>):
        wandb.config(values)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">self, values: <span class="hljs-built_in">dict</span>, step: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span></span>):
        wandb.log(values, step=step)`}}),Pe=new La({}),Oe=new qe({props:{code:`from accelerate import Accelerator
+ import neptune.new as neptune

accelerator = Accelerator()
+ run = neptune.init(...)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config["num_iterations"]:
    for batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        total_loss += loss
        accelerator.backward(loss)
        my_optimizer.step()
+       if accelerator.is_main_process:
+           run["logs/training/batch/loss"].log(loss)`,highlighted:`from accelerate import Accelerator
<span class="hljs-addition">+ import neptune.new as neptune</span>

accelerator = Accelerator()
<span class="hljs-addition">+ run = neptune.init(...)</span>

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config[&quot;num_iterations&quot;]:
    for batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        total_loss += loss
        accelerator.backward(loss)
        my_optimizer.step()
<span class="hljs-addition">+       if accelerator.is_main_process:</span>
<span class="hljs-addition">+           run[&quot;logs/training/batch/loss&quot;].log(loss)</span>`}}),{c(){P=n("meta"),Bt=i(),O=n("h1"),W=n("a"),Ke=n("span"),m(re.$$.fragment),Pa=i(),Qe=n("span"),Oa=r("Tracking"),St=i(),oe=n("p"),Ia=r(`There are a large number of experiment tracking API\u2019s available, however getting them all to work with in a multi-processing environment can oftentimes be complex.
Accelerate provides a general tracking API that can be used to log useful items during your script through `),Be=n("a"),qa=r("log()"),zt=i(),I=n("h2"),V=n("a"),Xe=n("span"),m(ne.$$.fragment),Ba=i(),Ye=n("span"),Sa=r("Integrated Trackers"),Nt=i(),M=n("p"),za=r("Currently "),Ze=n("code"),Na=r("Accelerate"),Wa=r(" supports three trackers out-of-the-box:"),Wt=i(),y=n("div"),m(se.$$.fragment),Va=i(),q=n("p"),Ma=r("A "),et=n("code"),Ga=r("Tracker"),Ra=r(" class that supports "),tt=n("code"),Ha=r("tensorboard"),Fa=r(". Should be initialized at the start of your script."),Ua=i(),G=n("div"),m(le.$$.fragment),Ja=i(),ce=n("p"),Ka=r("Closes "),at=n("code"),Qa=r("TensorBoard"),Xa=r(" writer"),Ya=i(),R=n("div"),m(ie.$$.fragment),Za=i(),pe=n("p"),er=r("Logs "),rt=n("code"),tr=r("values"),ar=r(" to the current run."),rr=i(),H=n("div"),m(de.$$.fragment),or=i(),ue=n("p"),nr=r("Logs "),ot=n("code"),sr=r("values"),lr=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Vt=i(),k=n("div"),m(me.$$.fragment),cr=i(),B=n("p"),ir=r("A "),nt=n("code"),pr=r("Tracker"),dr=r(" class that supports "),st=n("code"),ur=r("wandb"),mr=r(". Should be initialized at the start of your script."),hr=i(),F=n("div"),m(he.$$.fragment),fr=i(),fe=n("p"),gr=r("Closes "),lt=n("code"),_r=r("wandb"),vr=r(" writer"),yr=i(),U=n("div"),m(ge.$$.fragment),kr=i(),_e=n("p"),$r=r("Logs "),ct=n("code"),br=r("values"),wr=r(" to the current run."),Er=i(),J=n("div"),m(ve.$$.fragment),Tr=i(),ye=n("p"),Ar=r("Logs "),it=n("code"),jr=r("values"),Dr=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Mt=i(),$=n("div"),m(ke.$$.fragment),Cr=i(),S=n("p"),xr=r("A "),pt=n("code"),Lr=r("Tracker"),Pr=r(" class that supports "),dt=n("code"),Or=r("comet_ml"),Ir=r(". Should be initialized at the start of your script."),qr=i(),ut=n("p"),Br=r("API keys must be stored in a Comet config file."),Sr=i(),K=n("div"),m($e.$$.fragment),zr=i(),be=n("p"),Nr=r("Logs "),mt=n("code"),Wr=r("values"),Vr=r(" to the current run."),Mr=i(),Q=n("div"),m(we.$$.fragment),Gr=i(),Ee=n("p"),Rr=r("Logs "),ht=n("code"),Hr=r("values"),Fr=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Gt=i(),w=n("p"),Ur=r("To use any of them, pass in the selected type(s) to the "),ft=n("code"),Jr=r("log_with"),Kr=r(" parameter in "),gt=n("code"),Qr=r("__init__"),Xr=r(":"),Rt=i(),m(Te.$$.fragment),Ht=i(),X=n("p"),Yr=r("At the start of your experiment "),_t=n("code"),Zr=r("init_tracker"),eo=r(" should be used to setup your project, and potentially add any experiment hyperparameters to be logged:"),Ft=i(),m(Ae.$$.fragment),Ut=i(),E=n("p"),to=r("When you are ready to log any data, "),Se=n("a"),ao=r("log()"),ro=r(` should be used.
A `),vt=n("code"),oo=r("step"),no=r(" can also be passed in to correlate the data with a particular step in the training loop."),Jt=i(),m(je.$$.fragment),Kt=i(),Y=n("p"),so=r("Once you\u2019ve finished training, make sure to run "),ze=n("a"),lo=r("end_training()"),co=r(" so that all the trackers can run their finish functionalities if they have any."),Qt=i(),m(De.$$.fragment),Xt=i(),Ne=n("p"),io=r("A full example is below:"),Yt=i(),m(Ce.$$.fragment),Zt=i(),z=n("h2"),Z=n("a"),yt=n("span"),m(xe.$$.fragment),po=i(),kt=n("span"),uo=r("Implementing Custom Trackers"),ea=i(),T=n("p"),mo=r("To implement a new tracker to be used in "),$t=n("code"),ho=r("Accelerator"),fo=r(", a new one can be made through implementing the "),bt=n("code"),go=r("~GeneralTracker"),_o=r(` class.
Every tracker must implement three functions:`),ta=i(),A=n("ul"),ee=n("li"),wt=n("code"),vo=r("__init__"),yo=r(": Should store a "),Et=n("code"),ko=r("run_name"),$o=r(" and initialize the tracker API of the integrated library"),bo=i(),te=n("li"),Tt=n("code"),wo=r("store_init_configuration"),Eo=r(": Should take in a "),At=n("code"),To=r("values"),Ao=r(" dictionary and store them as a one-time experiment configuration"),jo=i(),j=n("li"),jt=n("code"),Do=r("log"),Co=r(": Should take in a "),Dt=n("code"),xo=r("values"),Lo=r(" dictionary and a "),Ct=n("code"),Po=r("step"),Oo=r(", and should log them to the run"),aa=i(),We=n("p"),Io=r("A brief example can be seen below with an integration with Weights and Biases, containing only the relevent information:"),ra=i(),m(Le.$$.fragment),oa=i(),N=n("h2"),ae=n("a"),xt=n("span"),m(Pe.$$.fragment),qo=i(),Lt=n("span"),Bo=r("When a wrapper cannot work"),na=i(),D=n("p"),So=r("If a library has an API that does not follow a strict "),Pt=n("code"),zo=r(".log"),No=r(" with an overall dictionary such as Neptune.AI, logging can be done manually under an "),Ot=n("code"),Wo=r("if accelerator.is_main_process"),Vo=r(" statement:"),sa=i(),m(Oe.$$.fragment),this.h()},l(e){const c=Mn('[data-svelte="svelte-1phssyn"]',document.head);P=s(c,"META",{name:!0,content:!0}),c.forEach(a),Bt=p(e),O=s(e,"H1",{class:!0});var ca=l(O);W=s(ca,"A",{id:!0,class:!0,href:!0});var Ro=l(W);Ke=s(Ro,"SPAN",{});var Ho=l(Ke);h(re.$$.fragment,Ho),Ho.forEach(a),Ro.forEach(a),Pa=p(ca),Qe=s(ca,"SPAN",{});var Fo=l(Qe);Oa=o(Fo,"Tracking"),Fo.forEach(a),ca.forEach(a),St=p(e),oe=s(e,"P",{});var Mo=l(oe);Ia=o(Mo,`There are a large number of experiment tracking API\u2019s available, however getting them all to work with in a multi-processing environment can oftentimes be complex.
Accelerate provides a general tracking API that can be used to log useful items during your script through `),Be=s(Mo,"A",{href:!0});var Uo=l(Be);qa=o(Uo,"log()"),Uo.forEach(a),Mo.forEach(a),zt=p(e),I=s(e,"H2",{class:!0});var ia=l(I);V=s(ia,"A",{id:!0,class:!0,href:!0});var Jo=l(V);Xe=s(Jo,"SPAN",{});var Ko=l(Xe);h(ne.$$.fragment,Ko),Ko.forEach(a),Jo.forEach(a),Ba=p(ia),Ye=s(ia,"SPAN",{});var Qo=l(Ye);Sa=o(Qo,"Integrated Trackers"),Qo.forEach(a),ia.forEach(a),Nt=p(e),M=s(e,"P",{});var pa=l(M);za=o(pa,"Currently "),Ze=s(pa,"CODE",{});var Xo=l(Ze);Na=o(Xo,"Accelerate"),Xo.forEach(a),Wa=o(pa," supports three trackers out-of-the-box:"),pa.forEach(a),Wt=p(e),y=s(e,"DIV",{class:!0});var C=l(y);h(se.$$.fragment,C),Va=p(C),q=s(C,"P",{});var Ve=l(q);Ma=o(Ve,"A "),et=s(Ve,"CODE",{});var Yo=l(et);Ga=o(Yo,"Tracker"),Yo.forEach(a),Ra=o(Ve," class that supports "),tt=s(Ve,"CODE",{});var Zo=l(tt);Ha=o(Zo,"tensorboard"),Zo.forEach(a),Fa=o(Ve,". Should be initialized at the start of your script."),Ve.forEach(a),Ua=p(C),G=s(C,"DIV",{class:!0});var da=l(G);h(le.$$.fragment,da),Ja=p(da),ce=s(da,"P",{});var ua=l(ce);Ka=o(ua,"Closes "),at=s(ua,"CODE",{});var en=l(at);Qa=o(en,"TensorBoard"),en.forEach(a),Xa=o(ua," writer"),ua.forEach(a),da.forEach(a),Ya=p(C),R=s(C,"DIV",{class:!0});var ma=l(R);h(ie.$$.fragment,ma),Za=p(ma),pe=s(ma,"P",{});var ha=l(pe);er=o(ha,"Logs "),rt=s(ha,"CODE",{});var tn=l(rt);tr=o(tn,"values"),tn.forEach(a),ar=o(ha," to the current run."),ha.forEach(a),ma.forEach(a),rr=p(C),H=s(C,"DIV",{class:!0});var fa=l(H);h(de.$$.fragment,fa),or=p(fa),ue=s(fa,"P",{});var ga=l(ue);nr=o(ga,"Logs "),ot=s(ga,"CODE",{});var an=l(ot);sr=o(an,"values"),an.forEach(a),lr=o(ga," as hyperparameters for the run. Should be run at the beginning of your experiment."),ga.forEach(a),fa.forEach(a),C.forEach(a),Vt=p(e),k=s(e,"DIV",{class:!0});var x=l(k);h(me.$$.fragment,x),cr=p(x),B=s(x,"P",{});var Me=l(B);ir=o(Me,"A "),nt=s(Me,"CODE",{});var rn=l(nt);pr=o(rn,"Tracker"),rn.forEach(a),dr=o(Me," class that supports "),st=s(Me,"CODE",{});var on=l(st);ur=o(on,"wandb"),on.forEach(a),mr=o(Me,". Should be initialized at the start of your script."),Me.forEach(a),hr=p(x),F=s(x,"DIV",{class:!0});var _a=l(F);h(he.$$.fragment,_a),fr=p(_a),fe=s(_a,"P",{});var va=l(fe);gr=o(va,"Closes "),lt=s(va,"CODE",{});var nn=l(lt);_r=o(nn,"wandb"),nn.forEach(a),vr=o(va," writer"),va.forEach(a),_a.forEach(a),yr=p(x),U=s(x,"DIV",{class:!0});var ya=l(U);h(ge.$$.fragment,ya),kr=p(ya),_e=s(ya,"P",{});var ka=l(_e);$r=o(ka,"Logs "),ct=s(ka,"CODE",{});var sn=l(ct);br=o(sn,"values"),sn.forEach(a),wr=o(ka," to the current run."),ka.forEach(a),ya.forEach(a),Er=p(x),J=s(x,"DIV",{class:!0});var $a=l(J);h(ve.$$.fragment,$a),Tr=p($a),ye=s($a,"P",{});var ba=l(ye);Ar=o(ba,"Logs "),it=s(ba,"CODE",{});var ln=l(it);jr=o(ln,"values"),ln.forEach(a),Dr=o(ba," as hyperparameters for the run. Should be run at the beginning of your experiment."),ba.forEach(a),$a.forEach(a),x.forEach(a),Mt=p(e),$=s(e,"DIV",{class:!0});var L=l($);h(ke.$$.fragment,L),Cr=p(L),S=s(L,"P",{});var Ge=l(S);xr=o(Ge,"A "),pt=s(Ge,"CODE",{});var cn=l(pt);Lr=o(cn,"Tracker"),cn.forEach(a),Pr=o(Ge," class that supports "),dt=s(Ge,"CODE",{});var pn=l(dt);Or=o(pn,"comet_ml"),pn.forEach(a),Ir=o(Ge,". Should be initialized at the start of your script."),Ge.forEach(a),qr=p(L),ut=s(L,"P",{});var dn=l(ut);Br=o(dn,"API keys must be stored in a Comet config file."),dn.forEach(a),Sr=p(L),K=s(L,"DIV",{class:!0});var wa=l(K);h($e.$$.fragment,wa),zr=p(wa),be=s(wa,"P",{});var Ea=l(be);Nr=o(Ea,"Logs "),mt=s(Ea,"CODE",{});var un=l(mt);Wr=o(un,"values"),un.forEach(a),Vr=o(Ea," to the current run."),Ea.forEach(a),wa.forEach(a),Mr=p(L),Q=s(L,"DIV",{class:!0});var Ta=l(Q);h(we.$$.fragment,Ta),Gr=p(Ta),Ee=s(Ta,"P",{});var Aa=l(Ee);Rr=o(Aa,"Logs "),ht=s(Aa,"CODE",{});var mn=l(ht);Hr=o(mn,"values"),mn.forEach(a),Fr=o(Aa," as hyperparameters for the run. Should be run at the beginning of your experiment."),Aa.forEach(a),Ta.forEach(a),L.forEach(a),Gt=p(e),w=s(e,"P",{});var Re=l(w);Ur=o(Re,"To use any of them, pass in the selected type(s) to the "),ft=s(Re,"CODE",{});var hn=l(ft);Jr=o(hn,"log_with"),hn.forEach(a),Kr=o(Re," parameter in "),gt=s(Re,"CODE",{});var fn=l(gt);Qr=o(fn,"__init__"),fn.forEach(a),Xr=o(Re,":"),Re.forEach(a),Rt=p(e),h(Te.$$.fragment,e),Ht=p(e),X=s(e,"P",{});var ja=l(X);Yr=o(ja,"At the start of your experiment "),_t=s(ja,"CODE",{});var gn=l(_t);Zr=o(gn,"init_tracker"),gn.forEach(a),eo=o(ja," should be used to setup your project, and potentially add any experiment hyperparameters to be logged:"),ja.forEach(a),Ft=p(e),h(Ae.$$.fragment,e),Ut=p(e),E=s(e,"P",{});var He=l(E);to=o(He,"When you are ready to log any data, "),Se=s(He,"A",{href:!0});var _n=l(Se);ao=o(_n,"log()"),_n.forEach(a),ro=o(He,` should be used.
A `),vt=s(He,"CODE",{});var vn=l(vt);oo=o(vn,"step"),vn.forEach(a),no=o(He," can also be passed in to correlate the data with a particular step in the training loop."),He.forEach(a),Jt=p(e),h(je.$$.fragment,e),Kt=p(e),Y=s(e,"P",{});var Da=l(Y);so=o(Da,"Once you\u2019ve finished training, make sure to run "),ze=s(Da,"A",{href:!0});var yn=l(ze);lo=o(yn,"end_training()"),yn.forEach(a),co=o(Da," so that all the trackers can run their finish functionalities if they have any."),Da.forEach(a),Qt=p(e),h(De.$$.fragment,e),Xt=p(e),Ne=s(e,"P",{});var kn=l(Ne);io=o(kn,"A full example is below:"),kn.forEach(a),Yt=p(e),h(Ce.$$.fragment,e),Zt=p(e),z=s(e,"H2",{class:!0});var Ca=l(z);Z=s(Ca,"A",{id:!0,class:!0,href:!0});var $n=l(Z);yt=s($n,"SPAN",{});var bn=l(yt);h(xe.$$.fragment,bn),bn.forEach(a),$n.forEach(a),po=p(Ca),kt=s(Ca,"SPAN",{});var wn=l(kt);uo=o(wn,"Implementing Custom Trackers"),wn.forEach(a),Ca.forEach(a),ea=p(e),T=s(e,"P",{});var Fe=l(T);mo=o(Fe,"To implement a new tracker to be used in "),$t=s(Fe,"CODE",{});var En=l($t);ho=o(En,"Accelerator"),En.forEach(a),fo=o(Fe,", a new one can be made through implementing the "),bt=s(Fe,"CODE",{});var Tn=l(bt);go=o(Tn,"~GeneralTracker"),Tn.forEach(a),_o=o(Fe,` class.
Every tracker must implement three functions:`),Fe.forEach(a),ta=p(e),A=s(e,"UL",{});var Ue=l(A);ee=s(Ue,"LI",{});var It=l(ee);wt=s(It,"CODE",{});var An=l(wt);vo=o(An,"__init__"),An.forEach(a),yo=o(It,": Should store a "),Et=s(It,"CODE",{});var jn=l(Et);ko=o(jn,"run_name"),jn.forEach(a),$o=o(It," and initialize the tracker API of the integrated library"),It.forEach(a),bo=p(Ue),te=s(Ue,"LI",{});var qt=l(te);Tt=s(qt,"CODE",{});var Dn=l(Tt);wo=o(Dn,"store_init_configuration"),Dn.forEach(a),Eo=o(qt,": Should take in a "),At=s(qt,"CODE",{});var Cn=l(At);To=o(Cn,"values"),Cn.forEach(a),Ao=o(qt," dictionary and store them as a one-time experiment configuration"),qt.forEach(a),jo=p(Ue),j=s(Ue,"LI",{});var Ie=l(j);jt=s(Ie,"CODE",{});var xn=l(jt);Do=o(xn,"log"),xn.forEach(a),Co=o(Ie,": Should take in a "),Dt=s(Ie,"CODE",{});var Ln=l(Dt);xo=o(Ln,"values"),Ln.forEach(a),Lo=o(Ie," dictionary and a "),Ct=s(Ie,"CODE",{});var Pn=l(Ct);Po=o(Pn,"step"),Pn.forEach(a),Oo=o(Ie,", and should log them to the run"),Ie.forEach(a),Ue.forEach(a),aa=p(e),We=s(e,"P",{});var On=l(We);Io=o(On,"A brief example can be seen below with an integration with Weights and Biases, containing only the relevent information:"),On.forEach(a),ra=p(e),h(Le.$$.fragment,e),oa=p(e),N=s(e,"H2",{class:!0});var xa=l(N);ae=s(xa,"A",{id:!0,class:!0,href:!0});var In=l(ae);xt=s(In,"SPAN",{});var qn=l(xt);h(Pe.$$.fragment,qn),qn.forEach(a),In.forEach(a),qo=p(xa),Lt=s(xa,"SPAN",{});var Bn=l(Lt);Bo=o(Bn,"When a wrapper cannot work"),Bn.forEach(a),xa.forEach(a),na=p(e),D=s(e,"P",{});var Je=l(D);So=o(Je,"If a library has an API that does not follow a strict "),Pt=s(Je,"CODE",{});var Sn=l(Pt);zo=o(Sn,".log"),Sn.forEach(a),No=o(Je," with an overall dictionary such as Neptune.AI, logging can be done manually under an "),Ot=s(Je,"CODE",{});var zn=l(Ot);Wo=o(zn,"if accelerator.is_main_process"),zn.forEach(a),Vo=o(Je," statement:"),Je.forEach(a),sa=p(e),h(Oe.$$.fragment,e),this.h()},h(){u(P,"name","hf:doc:metadata"),u(P,"content",JSON.stringify(Fn)),u(W,"id","tracking"),u(W,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(W,"href","#tracking"),u(O,"class","relative group"),u(Be,"href","/docs/accelerate/pr_293/en/accelerator#accelerate.Accelerator.log"),u(V,"id","accelerate.tracking.TensorBoardTracker"),u(V,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(V,"href","#accelerate.tracking.TensorBoardTracker"),u(I,"class","relative group"),u(G,"class","docstring"),u(R,"class","docstring"),u(H,"class","docstring"),u(y,"class","docstring"),u(F,"class","docstring"),u(U,"class","docstring"),u(J,"class","docstring"),u(k,"class","docstring"),u(K,"class","docstring"),u(Q,"class","docstring"),u($,"class","docstring"),u(Se,"href","/docs/accelerate/pr_293/en/accelerator#accelerate.Accelerator.log"),u(ze,"href","/docs/accelerate/pr_293/en/accelerator#accelerate.Accelerator.end_training"),u(Z,"id","implementing-custom-trackers"),u(Z,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Z,"href","#implementing-custom-trackers"),u(z,"class","relative group"),u(ae,"id","when-a-wrapper-cannot-work"),u(ae,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(ae,"href","#when-a-wrapper-cannot-work"),u(N,"class","relative group")},m(e,c){t(document.head,P),d(e,Bt,c),d(e,O,c),t(O,W),t(W,Ke),f(re,Ke,null),t(O,Pa),t(O,Qe),t(Qe,Oa),d(e,St,c),d(e,oe,c),t(oe,Ia),t(oe,Be),t(Be,qa),d(e,zt,c),d(e,I,c),t(I,V),t(V,Xe),f(ne,Xe,null),t(I,Ba),t(I,Ye),t(Ye,Sa),d(e,Nt,c),d(e,M,c),t(M,za),t(M,Ze),t(Ze,Na),t(M,Wa),d(e,Wt,c),d(e,y,c),f(se,y,null),t(y,Va),t(y,q),t(q,Ma),t(q,et),t(et,Ga),t(q,Ra),t(q,tt),t(tt,Ha),t(q,Fa),t(y,Ua),t(y,G),f(le,G,null),t(G,Ja),t(G,ce),t(ce,Ka),t(ce,at),t(at,Qa),t(ce,Xa),t(y,Ya),t(y,R),f(ie,R,null),t(R,Za),t(R,pe),t(pe,er),t(pe,rt),t(rt,tr),t(pe,ar),t(y,rr),t(y,H),f(de,H,null),t(H,or),t(H,ue),t(ue,nr),t(ue,ot),t(ot,sr),t(ue,lr),d(e,Vt,c),d(e,k,c),f(me,k,null),t(k,cr),t(k,B),t(B,ir),t(B,nt),t(nt,pr),t(B,dr),t(B,st),t(st,ur),t(B,mr),t(k,hr),t(k,F),f(he,F,null),t(F,fr),t(F,fe),t(fe,gr),t(fe,lt),t(lt,_r),t(fe,vr),t(k,yr),t(k,U),f(ge,U,null),t(U,kr),t(U,_e),t(_e,$r),t(_e,ct),t(ct,br),t(_e,wr),t(k,Er),t(k,J),f(ve,J,null),t(J,Tr),t(J,ye),t(ye,Ar),t(ye,it),t(it,jr),t(ye,Dr),d(e,Mt,c),d(e,$,c),f(ke,$,null),t($,Cr),t($,S),t(S,xr),t(S,pt),t(pt,Lr),t(S,Pr),t(S,dt),t(dt,Or),t(S,Ir),t($,qr),t($,ut),t(ut,Br),t($,Sr),t($,K),f($e,K,null),t(K,zr),t(K,be),t(be,Nr),t(be,mt),t(mt,Wr),t(be,Vr),t($,Mr),t($,Q),f(we,Q,null),t(Q,Gr),t(Q,Ee),t(Ee,Rr),t(Ee,ht),t(ht,Hr),t(Ee,Fr),d(e,Gt,c),d(e,w,c),t(w,Ur),t(w,ft),t(ft,Jr),t(w,Kr),t(w,gt),t(gt,Qr),t(w,Xr),d(e,Rt,c),f(Te,e,c),d(e,Ht,c),d(e,X,c),t(X,Yr),t(X,_t),t(_t,Zr),t(X,eo),d(e,Ft,c),f(Ae,e,c),d(e,Ut,c),d(e,E,c),t(E,to),t(E,Se),t(Se,ao),t(E,ro),t(E,vt),t(vt,oo),t(E,no),d(e,Jt,c),f(je,e,c),d(e,Kt,c),d(e,Y,c),t(Y,so),t(Y,ze),t(ze,lo),t(Y,co),d(e,Qt,c),f(De,e,c),d(e,Xt,c),d(e,Ne,c),t(Ne,io),d(e,Yt,c),f(Ce,e,c),d(e,Zt,c),d(e,z,c),t(z,Z),t(Z,yt),f(xe,yt,null),t(z,po),t(z,kt),t(kt,uo),d(e,ea,c),d(e,T,c),t(T,mo),t(T,$t),t($t,ho),t(T,fo),t(T,bt),t(bt,go),t(T,_o),d(e,ta,c),d(e,A,c),t(A,ee),t(ee,wt),t(wt,vo),t(ee,yo),t(ee,Et),t(Et,ko),t(ee,$o),t(A,bo),t(A,te),t(te,Tt),t(Tt,wo),t(te,Eo),t(te,At),t(At,To),t(te,Ao),t(A,jo),t(A,j),t(j,jt),t(jt,Do),t(j,Co),t(j,Dt),t(Dt,xo),t(j,Lo),t(j,Ct),t(Ct,Po),t(j,Oo),d(e,aa,c),d(e,We,c),t(We,Io),d(e,ra,c),f(Le,e,c),d(e,oa,c),d(e,N,c),t(N,ae),t(ae,xt),f(Pe,xt,null),t(N,qo),t(N,Lt),t(Lt,Bo),d(e,na,c),d(e,D,c),t(D,So),t(D,Pt),t(Pt,zo),t(D,No),t(D,Ot),t(Ot,Wo),t(D,Vo),d(e,sa,c),f(Oe,e,c),la=!0},p:Gn,i(e){la||(g(re.$$.fragment,e),g(ne.$$.fragment,e),g(se.$$.fragment,e),g(le.$$.fragment,e),g(ie.$$.fragment,e),g(de.$$.fragment,e),g(me.$$.fragment,e),g(he.$$.fragment,e),g(ge.$$.fragment,e),g(ve.$$.fragment,e),g(ke.$$.fragment,e),g($e.$$.fragment,e),g(we.$$.fragment,e),g(Te.$$.fragment,e),g(Ae.$$.fragment,e),g(je.$$.fragment,e),g(De.$$.fragment,e),g(Ce.$$.fragment,e),g(xe.$$.fragment,e),g(Le.$$.fragment,e),g(Pe.$$.fragment,e),g(Oe.$$.fragment,e),la=!0)},o(e){_(re.$$.fragment,e),_(ne.$$.fragment,e),_(se.$$.fragment,e),_(le.$$.fragment,e),_(ie.$$.fragment,e),_(de.$$.fragment,e),_(me.$$.fragment,e),_(he.$$.fragment,e),_(ge.$$.fragment,e),_(ve.$$.fragment,e),_(ke.$$.fragment,e),_($e.$$.fragment,e),_(we.$$.fragment,e),_(Te.$$.fragment,e),_(Ae.$$.fragment,e),_(je.$$.fragment,e),_(De.$$.fragment,e),_(Ce.$$.fragment,e),_(xe.$$.fragment,e),_(Le.$$.fragment,e),_(Pe.$$.fragment,e),_(Oe.$$.fragment,e),la=!1},d(e){a(P),e&&a(Bt),e&&a(O),v(re),e&&a(St),e&&a(oe),e&&a(zt),e&&a(I),v(ne),e&&a(Nt),e&&a(M),e&&a(Wt),e&&a(y),v(se),v(le),v(ie),v(de),e&&a(Vt),e&&a(k),v(me),v(he),v(ge),v(ve),e&&a(Mt),e&&a($),v(ke),v($e),v(we),e&&a(Gt),e&&a(w),e&&a(Rt),v(Te,e),e&&a(Ht),e&&a(X),e&&a(Ft),v(Ae,e),e&&a(Ut),e&&a(E),e&&a(Jt),v(je,e),e&&a(Kt),e&&a(Y),e&&a(Qt),v(De,e),e&&a(Xt),e&&a(Ne),e&&a(Yt),v(Ce,e),e&&a(Zt),e&&a(z),v(xe),e&&a(ea),e&&a(T),e&&a(ta),e&&a(A),e&&a(aa),e&&a(We),e&&a(ra),v(Le,e),e&&a(oa),e&&a(N),v(Pe),e&&a(na),e&&a(D),e&&a(sa),v(Oe,e)}}}const Fn={local:"tracking",sections:[{local:"accelerate.tracking.TensorBoardTracker",title:"Integrated Trackers"},{local:"implementing-custom-trackers",title:"Implementing Custom Trackers"},{local:"when-a-wrapper-cannot-work",title:"When a wrapper cannot work"}],title:"Tracking"};function Un(Go){return Rn(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Yn extends Nn{constructor(P){super();Wn(this,P,Un,Hn,Vn,{})}}export{Yn as default,Fn as metadata};
