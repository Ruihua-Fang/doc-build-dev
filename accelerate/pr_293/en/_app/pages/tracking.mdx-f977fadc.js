import{S as Gn,i as Rn,s as Hn,e as n,k as i,w as m,t as r,M as Fn,c as s,d as a,m as p,a as c,x as h,h as o,b as u,F as t,g as d,y as f,L as Un,q as g,o as _,B as v,v as Jn}from"../chunks/vendor-19e06bd2.js";import{D as b}from"../chunks/Docstring-395e5a9c.js";import{C as Be}from"../chunks/CodeBlock-9dd1fdfb.js";import{I as Pa}from"../chunks/IconCopyLink-3c713d38.js";function Kn(Fo){let O,St,I,V,Xe,re,Oa,Ye,Ia,zt,oe,qa,Se,Ba,Nt,q,M,Ze,ne,Sa,et,za,Wt,G,Na,tt,Wa,Va,Vt,y,se,Ma,B,Ga,at,Ra,Ha,rt,Fa,Ua,Ja,R,ce,Ka,le,Qa,ot,Xa,Ya,Za,H,ie,er,pe,tr,nt,ar,rr,or,F,de,nr,ue,sr,st,cr,lr,Mt,k,me,ir,S,pr,ct,dr,ur,lt,mr,hr,fr,U,he,gr,fe,_r,it,vr,yr,kr,J,ge,$r,_e,br,pt,wr,Er,Tr,K,ve,Ar,ye,jr,dt,Dr,Cr,Gt,$,ke,xr,z,Lr,ut,Pr,Or,mt,Ir,qr,Br,ht,Sr,zr,Q,$e,Nr,be,Wr,ft,Vr,Mr,Gr,X,we,Rr,Ee,Hr,gt,Fr,Ur,Rt,w,Jr,_t,Kr,Qr,vt,Xr,Yr,Ht,Te,Ft,Y,Zr,ze,eo,to,Ut,Ae,Jt,E,ao,Ne,ro,oo,yt,no,so,Kt,je,Qt,Z,co,We,lo,io,Xt,De,Yt,Ve,po,Zt,Ce,ea,N,ee,kt,xe,uo,$t,mo,ta,T,ho,bt,fo,go,wt,_o,vo,aa,A,j,Et,yo,ko,Tt,$o,bo,At,wo,Eo,To,te,jt,Ao,jo,Dt,Do,Co,xo,D,Ct,Lo,Po,xt,Oo,Io,Lt,qo,Bo,ra,Me,So,oa,Le,na,W,ae,Pt,Pe,zo,Ot,No,sa,C,Wo,It,Vo,Mo,qt,Go,Ro,ca,Oe,la;return re=new Pa({}),ne=new Pa({}),se=new b({props:{name:"class accelerate.tracking.TensorBoardTracker",anchor:"accelerate.tracking.TensorBoardTracker",parameters:[{name:"run_name",val:": str"},{name:"logging_dir",val:": typing.Union[str, os.PathLike, NoneType] = ''"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L92",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run`,name:"run_name"},{anchor:"accelerate.tracking.TensorBoardTracker.logging_dir",description:`<strong>logging_dir</strong> (<code>str</code>, <code>os.PathLike</code>) &#x2014;
Location for TensorBoard logs to be stored.`,name:"logging_dir"}]}}),ce=new b({props:{name:"finish",anchor:"accelerate.tracking.TensorBoardTracker.finish",parameters:[],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L143"}}),ie=new b({props:{name:"log",anchor:"accelerate.tracking.TensorBoardTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L125",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.TensorBoardTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),de=new b({props:{name:"store_init_configuration",anchor:"accelerate.tracking.TensorBoardTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L112",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),me=new b({props:{name:"class accelerate.tracking.WandBTracker",anchor:"accelerate.tracking.WandBTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L151",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run.`,name:"run_name"}]}}),he=new b({props:{name:"finish",anchor:"accelerate.tracking.WandBTracker.finish",parameters:[],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L193"}}),ge=new b({props:{name:"log",anchor:"accelerate.tracking.WandBTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L180",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.WandBTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),ve=new b({props:{name:"store_init_configuration",anchor:"accelerate.tracking.WandBTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L168",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),ke=new b({props:{name:"class accelerate.tracking.CometMLTracker",anchor:"accelerate.tracking.CometMLTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L201",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run.`,name:"run_name"}]}}),$e=new b({props:{name:"log",anchor:"accelerate.tracking.CometMLTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L232",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.CometMLTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),we=new b({props:{name:"store_init_configuration",anchor:"accelerate.tracking.CometMLTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L220",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),Te=new Be({props:{code:`from accelerate import Accelerate
from accelerate.utils import LoggerType

accelerator = Accelerate(log_with="all")  # For all available trackers in the environment
accelerator = Accelerate(log_with="wandb")
accelerator = Accelerate(log_with=["wandb", LoggerType.TENSORBOARD])`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerate
<span class="hljs-keyword">from</span> accelerate.utils <span class="hljs-keyword">import</span> LoggerType

accelerator = Accelerate(log_with=<span class="hljs-string">&quot;all&quot;</span>)  <span class="hljs-comment"># For all available trackers in the environment</span>
accelerator = Accelerate(log_with=<span class="hljs-string">&quot;wandb&quot;</span>)
accelerator = Accelerate(log_with=[<span class="hljs-string">&quot;wandb&quot;</span>, LoggerType.TENSORBOARD])`}}),Ae=new Be({props:{code:`hps = {"num_iterations": 5, "learning_rate": 1e-2}
accelerator.init_trackers("my_project", config=hps)`,highlighted:`hps = {<span class="hljs-string">&quot;num_iterations&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&quot;learning_rate&quot;</span>: <span class="hljs-number">1e-2</span>}
accelerator.init_trackers(<span class="hljs-string">&quot;my_project&quot;</span>, config=hps)`}}),je=new Be({props:{code:'accelerator.log({"train_loss": 1.12, "valid_loss": 0.8}, step=1)',highlighted:'accelerator.log({<span class="hljs-string">&quot;train_loss&quot;</span>: <span class="hljs-number">1.12</span>, <span class="hljs-string">&quot;valid_loss&quot;</span>: <span class="hljs-number">0.8</span>}, step=<span class="hljs-number">1</span>)'}}),De=new Be({props:{code:"accelerator.end_training()",highlighted:"accelerator.end_training()"}}),Ce=new Be({props:{code:`from accelerate import Accelerator

accelerator = Accelerator(log_with="all")
config = {
    "num_iterations": 5,
    "learning_rate": 1e-2,
    "loss_function": str(my_loss_function),
}

accelerator.init_trackers("example_project", config=config)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config["num_iterations"]:
    for step, batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        accelerator.backward(loss)
        my_optimizer.step()
        accelerator.log({"training_loss": loss}, step=step)
accelerator.end_training()`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator

accelerator = Accelerator(log_with=<span class="hljs-string">&quot;all&quot;</span>)
config = {
    <span class="hljs-string">&quot;num_iterations&quot;</span>: <span class="hljs-number">5</span>,
    <span class="hljs-string">&quot;learning_rate&quot;</span>: <span class="hljs-number">1e-2</span>,
    <span class="hljs-string">&quot;loss_function&quot;</span>: <span class="hljs-built_in">str</span>(my_loss_function),
}

accelerator.init_trackers(<span class="hljs-string">&quot;example_project&quot;</span>, config=config)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

<span class="hljs-keyword">for</span> iteration <span class="hljs-keyword">in</span> config[<span class="hljs-string">&quot;num_iterations&quot;</span>]:
    <span class="hljs-keyword">for</span> step, batch <span class="hljs-keyword">in</span> my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        accelerator.backward(loss)
        my_optimizer.step()
        accelerator.log({<span class="hljs-string">&quot;training_loss&quot;</span>: loss}, step=step)
accelerator.end_training()`}}),xe=new Pa({}),Le=new Be({props:{code:`from accelerate.tracking import GeneralTracker
from typing import Optional

import wandb


class WandBTracker(GeneralTracker):
    def __init__(self, run_name: str):
        self.run_name = run_name
        wandb.init(self.run_name)

    def store_init_configuration(self, values: dict):
        wandb.config(values)

    def log(self, values: dict, step: Optional[int] = None):
        wandb.log(values, step=step)`,highlighted:`<span class="hljs-keyword">from</span> accelerate.tracking <span class="hljs-keyword">import</span> GeneralTracker
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>

<span class="hljs-keyword">import</span> wandb


<span class="hljs-keyword">class</span> <span class="hljs-title class_">WandBTracker</span>(<span class="hljs-title class_ inherited__">GeneralTracker</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, run_name: <span class="hljs-built_in">str</span></span>):
        self.run_name = run_name
        wandb.init(self.run_name)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">store_init_configuration</span>(<span class="hljs-params">self, values: <span class="hljs-built_in">dict</span></span>):
        wandb.config(values)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">self, values: <span class="hljs-built_in">dict</span>, step: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span></span>):
        wandb.log(values, step=step)`}}),Pe=new Pa({}),Oe=new Be({props:{code:`from accelerate import Accelerator
+ import neptune.new as neptune

accelerator = Accelerator()
+ run = neptune.init(...)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config["num_iterations"]:
    for batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        total_loss += loss
        accelerator.backward(loss)
        my_optimizer.step()
+       if accelerator.is_main_process:
+           run["logs/training/batch/loss"].log(loss)`,highlighted:`from accelerate import Accelerator
<span class="hljs-addition">+ import neptune.new as neptune</span>

accelerator = Accelerator()
<span class="hljs-addition">+ run = neptune.init(...)</span>

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config[&quot;num_iterations&quot;]:
    for batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        total_loss += loss
        accelerator.backward(loss)
        my_optimizer.step()
<span class="hljs-addition">+       if accelerator.is_main_process:</span>
<span class="hljs-addition">+           run[&quot;logs/training/batch/loss&quot;].log(loss)</span>`}}),{c(){O=n("meta"),St=i(),I=n("h1"),V=n("a"),Xe=n("span"),m(re.$$.fragment),Oa=i(),Ye=n("span"),Ia=r("Tracking"),zt=i(),oe=n("p"),qa=r(`There are a large number of experiment tracking API\u2019s available, however getting them all to work with in a multi-processing environment can oftentimes be complex.
Accelerate provides a general tracking API that can be used to log useful items during your script through `),Se=n("a"),Ba=r("log()"),Nt=i(),q=n("h2"),M=n("a"),Ze=n("span"),m(ne.$$.fragment),Sa=i(),et=n("span"),za=r("Integrated Trackers"),Wt=i(),G=n("p"),Na=r("Currently "),tt=n("code"),Wa=r("Accelerate"),Va=r(" supports three trackers out-of-the-box:"),Vt=i(),y=n("div"),m(se.$$.fragment),Ma=i(),B=n("p"),Ga=r("A "),at=n("code"),Ra=r("Tracker"),Ha=r(" class that supports "),rt=n("code"),Fa=r("tensorboard"),Ua=r(". Should be initialized at the start of your script."),Ja=i(),R=n("div"),m(ce.$$.fragment),Ka=i(),le=n("p"),Qa=r("Closes "),ot=n("code"),Xa=r("TensorBoard"),Ya=r(" writer"),Za=i(),H=n("div"),m(ie.$$.fragment),er=i(),pe=n("p"),tr=r("Logs "),nt=n("code"),ar=r("values"),rr=r(" to the current run."),or=i(),F=n("div"),m(de.$$.fragment),nr=i(),ue=n("p"),sr=r("Logs "),st=n("code"),cr=r("values"),lr=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Mt=i(),k=n("div"),m(me.$$.fragment),ir=i(),S=n("p"),pr=r("A "),ct=n("code"),dr=r("Tracker"),ur=r(" class that supports "),lt=n("code"),mr=r("wandb"),hr=r(". Should be initialized at the start of your script."),fr=i(),U=n("div"),m(he.$$.fragment),gr=i(),fe=n("p"),_r=r("Closes "),it=n("code"),vr=r("wandb"),yr=r(" writer"),kr=i(),J=n("div"),m(ge.$$.fragment),$r=i(),_e=n("p"),br=r("Logs "),pt=n("code"),wr=r("values"),Er=r(" to the current run."),Tr=i(),K=n("div"),m(ve.$$.fragment),Ar=i(),ye=n("p"),jr=r("Logs "),dt=n("code"),Dr=r("values"),Cr=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Gt=i(),$=n("div"),m(ke.$$.fragment),xr=i(),z=n("p"),Lr=r("A "),ut=n("code"),Pr=r("Tracker"),Or=r(" class that supports "),mt=n("code"),Ir=r("comet_ml"),qr=r(". Should be initialized at the start of your script."),Br=i(),ht=n("p"),Sr=r("API keys must be stored in a Comet config file."),zr=i(),Q=n("div"),m($e.$$.fragment),Nr=i(),be=n("p"),Wr=r("Logs "),ft=n("code"),Vr=r("values"),Mr=r(" to the current run."),Gr=i(),X=n("div"),m(we.$$.fragment),Rr=i(),Ee=n("p"),Hr=r("Logs "),gt=n("code"),Fr=r("values"),Ur=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Rt=i(),w=n("p"),Jr=r("To use any of them, pass in the selected type(s) to the "),_t=n("code"),Kr=r("log_with"),Qr=r(" parameter in "),vt=n("code"),Xr=r("Accelerate"),Yr=r(":"),Ht=i(),m(Te.$$.fragment),Ft=i(),Y=n("p"),Zr=r("At the start of your experiment "),ze=n("a"),eo=r("init_trackers()"),to=r(" should be used to setup your project, and potentially add any experiment hyperparameters to be logged:"),Ut=i(),m(Ae.$$.fragment),Jt=i(),E=n("p"),ao=r("When you are ready to log any data, "),Ne=n("a"),ro=r("log()"),oo=r(` should be used.
A `),yt=n("code"),no=r("step"),so=r(" can also be passed in to correlate the data with a particular step in the training loop."),Kt=i(),m(je.$$.fragment),Qt=i(),Z=n("p"),co=r("Once you\u2019ve finished training, make sure to run "),We=n("a"),lo=r("end_training()"),io=r(" so that all the trackers can run their finish functionalities if they have any."),Xt=i(),m(De.$$.fragment),Yt=i(),Ve=n("p"),po=r("A full example is below:"),Zt=i(),m(Ce.$$.fragment),ea=i(),N=n("h2"),ee=n("a"),kt=n("span"),m(xe.$$.fragment),uo=i(),$t=n("span"),mo=r("Implementing Custom Trackers"),ta=i(),T=n("p"),ho=r("To implement a new tracker to be used in "),bt=n("code"),fo=r("Accelerator"),go=r(", a new one can be made through implementing the "),wt=n("code"),_o=r("~GeneralTracker"),vo=r(` class.
Every tracker must implement three functions:`),aa=i(),A=n("ul"),j=n("li"),Et=n("code"),yo=r("__init__"),ko=r(`:
Should store a `),Tt=n("code"),$o=r("run_name"),bo=r(` and initialize the tracker API of the integrated library.
If a tracker stores their data locally (such as TensorBoard), a `),At=n("code"),wo=r("logging_dir"),Eo=r(" parameter can be added."),To=i(),te=n("li"),jt=n("code"),Ao=r("store_init_configuration"),jo=r(`:
Should take in a `),Dt=n("code"),Do=r("values"),Co=r(" dictionary and store them as a one-time experiment configuration"),xo=i(),D=n("li"),Ct=n("code"),Lo=r("log"),Po=r(`:
Should take in a `),xt=n("code"),Oo=r("values"),Io=r(" dictionary and a "),Lt=n("code"),qo=r("step"),Bo=r(", and should log them to the run"),ra=i(),Me=n("p"),So=r("A brief example can be seen below with an integration with Weights and Biases, containing only the relevent information:"),oa=i(),m(Le.$$.fragment),na=i(),W=n("h2"),ae=n("a"),Pt=n("span"),m(Pe.$$.fragment),zo=i(),Ot=n("span"),No=r("When a wrapper cannot work"),sa=i(),C=n("p"),Wo=r("If a library has an API that does not follow a strict "),It=n("code"),Vo=r(".log"),Mo=r(" with an overall dictionary such as Neptune.AI, logging can be done manually under an "),qt=n("code"),Go=r("if accelerator.is_main_process"),Ro=r(" statement:"),ca=i(),m(Oe.$$.fragment),this.h()},l(e){const l=Fn('[data-svelte="svelte-1phssyn"]',document.head);O=s(l,"META",{name:!0,content:!0}),l.forEach(a),St=p(e),I=s(e,"H1",{class:!0});var ia=c(I);V=s(ia,"A",{id:!0,class:!0,href:!0});var Uo=c(V);Xe=s(Uo,"SPAN",{});var Jo=c(Xe);h(re.$$.fragment,Jo),Jo.forEach(a),Uo.forEach(a),Oa=p(ia),Ye=s(ia,"SPAN",{});var Ko=c(Ye);Ia=o(Ko,"Tracking"),Ko.forEach(a),ia.forEach(a),zt=p(e),oe=s(e,"P",{});var Ho=c(oe);qa=o(Ho,`There are a large number of experiment tracking API\u2019s available, however getting them all to work with in a multi-processing environment can oftentimes be complex.
Accelerate provides a general tracking API that can be used to log useful items during your script through `),Se=s(Ho,"A",{href:!0});var Qo=c(Se);Ba=o(Qo,"log()"),Qo.forEach(a),Ho.forEach(a),Nt=p(e),q=s(e,"H2",{class:!0});var pa=c(q);M=s(pa,"A",{id:!0,class:!0,href:!0});var Xo=c(M);Ze=s(Xo,"SPAN",{});var Yo=c(Ze);h(ne.$$.fragment,Yo),Yo.forEach(a),Xo.forEach(a),Sa=p(pa),et=s(pa,"SPAN",{});var Zo=c(et);za=o(Zo,"Integrated Trackers"),Zo.forEach(a),pa.forEach(a),Wt=p(e),G=s(e,"P",{});var da=c(G);Na=o(da,"Currently "),tt=s(da,"CODE",{});var en=c(tt);Wa=o(en,"Accelerate"),en.forEach(a),Va=o(da," supports three trackers out-of-the-box:"),da.forEach(a),Vt=p(e),y=s(e,"DIV",{class:!0});var x=c(y);h(se.$$.fragment,x),Ma=p(x),B=s(x,"P",{});var Ge=c(B);Ga=o(Ge,"A "),at=s(Ge,"CODE",{});var tn=c(at);Ra=o(tn,"Tracker"),tn.forEach(a),Ha=o(Ge," class that supports "),rt=s(Ge,"CODE",{});var an=c(rt);Fa=o(an,"tensorboard"),an.forEach(a),Ua=o(Ge,". Should be initialized at the start of your script."),Ge.forEach(a),Ja=p(x),R=s(x,"DIV",{class:!0});var ua=c(R);h(ce.$$.fragment,ua),Ka=p(ua),le=s(ua,"P",{});var ma=c(le);Qa=o(ma,"Closes "),ot=s(ma,"CODE",{});var rn=c(ot);Xa=o(rn,"TensorBoard"),rn.forEach(a),Ya=o(ma," writer"),ma.forEach(a),ua.forEach(a),Za=p(x),H=s(x,"DIV",{class:!0});var ha=c(H);h(ie.$$.fragment,ha),er=p(ha),pe=s(ha,"P",{});var fa=c(pe);tr=o(fa,"Logs "),nt=s(fa,"CODE",{});var on=c(nt);ar=o(on,"values"),on.forEach(a),rr=o(fa," to the current run."),fa.forEach(a),ha.forEach(a),or=p(x),F=s(x,"DIV",{class:!0});var ga=c(F);h(de.$$.fragment,ga),nr=p(ga),ue=s(ga,"P",{});var _a=c(ue);sr=o(_a,"Logs "),st=s(_a,"CODE",{});var nn=c(st);cr=o(nn,"values"),nn.forEach(a),lr=o(_a," as hyperparameters for the run. Should be run at the beginning of your experiment."),_a.forEach(a),ga.forEach(a),x.forEach(a),Mt=p(e),k=s(e,"DIV",{class:!0});var L=c(k);h(me.$$.fragment,L),ir=p(L),S=s(L,"P",{});var Re=c(S);pr=o(Re,"A "),ct=s(Re,"CODE",{});var sn=c(ct);dr=o(sn,"Tracker"),sn.forEach(a),ur=o(Re," class that supports "),lt=s(Re,"CODE",{});var cn=c(lt);mr=o(cn,"wandb"),cn.forEach(a),hr=o(Re,". Should be initialized at the start of your script."),Re.forEach(a),fr=p(L),U=s(L,"DIV",{class:!0});var va=c(U);h(he.$$.fragment,va),gr=p(va),fe=s(va,"P",{});var ya=c(fe);_r=o(ya,"Closes "),it=s(ya,"CODE",{});var ln=c(it);vr=o(ln,"wandb"),ln.forEach(a),yr=o(ya," writer"),ya.forEach(a),va.forEach(a),kr=p(L),J=s(L,"DIV",{class:!0});var ka=c(J);h(ge.$$.fragment,ka),$r=p(ka),_e=s(ka,"P",{});var $a=c(_e);br=o($a,"Logs "),pt=s($a,"CODE",{});var pn=c(pt);wr=o(pn,"values"),pn.forEach(a),Er=o($a," to the current run."),$a.forEach(a),ka.forEach(a),Tr=p(L),K=s(L,"DIV",{class:!0});var ba=c(K);h(ve.$$.fragment,ba),Ar=p(ba),ye=s(ba,"P",{});var wa=c(ye);jr=o(wa,"Logs "),dt=s(wa,"CODE",{});var dn=c(dt);Dr=o(dn,"values"),dn.forEach(a),Cr=o(wa," as hyperparameters for the run. Should be run at the beginning of your experiment."),wa.forEach(a),ba.forEach(a),L.forEach(a),Gt=p(e),$=s(e,"DIV",{class:!0});var P=c($);h(ke.$$.fragment,P),xr=p(P),z=s(P,"P",{});var He=c(z);Lr=o(He,"A "),ut=s(He,"CODE",{});var un=c(ut);Pr=o(un,"Tracker"),un.forEach(a),Or=o(He," class that supports "),mt=s(He,"CODE",{});var mn=c(mt);Ir=o(mn,"comet_ml"),mn.forEach(a),qr=o(He,". Should be initialized at the start of your script."),He.forEach(a),Br=p(P),ht=s(P,"P",{});var hn=c(ht);Sr=o(hn,"API keys must be stored in a Comet config file."),hn.forEach(a),zr=p(P),Q=s(P,"DIV",{class:!0});var Ea=c(Q);h($e.$$.fragment,Ea),Nr=p(Ea),be=s(Ea,"P",{});var Ta=c(be);Wr=o(Ta,"Logs "),ft=s(Ta,"CODE",{});var fn=c(ft);Vr=o(fn,"values"),fn.forEach(a),Mr=o(Ta," to the current run."),Ta.forEach(a),Ea.forEach(a),Gr=p(P),X=s(P,"DIV",{class:!0});var Aa=c(X);h(we.$$.fragment,Aa),Rr=p(Aa),Ee=s(Aa,"P",{});var ja=c(Ee);Hr=o(ja,"Logs "),gt=s(ja,"CODE",{});var gn=c(gt);Fr=o(gn,"values"),gn.forEach(a),Ur=o(ja," as hyperparameters for the run. Should be run at the beginning of your experiment."),ja.forEach(a),Aa.forEach(a),P.forEach(a),Rt=p(e),w=s(e,"P",{});var Fe=c(w);Jr=o(Fe,"To use any of them, pass in the selected type(s) to the "),_t=s(Fe,"CODE",{});var _n=c(_t);Kr=o(_n,"log_with"),_n.forEach(a),Qr=o(Fe," parameter in "),vt=s(Fe,"CODE",{});var vn=c(vt);Xr=o(vn,"Accelerate"),vn.forEach(a),Yr=o(Fe,":"),Fe.forEach(a),Ht=p(e),h(Te.$$.fragment,e),Ft=p(e),Y=s(e,"P",{});var Da=c(Y);Zr=o(Da,"At the start of your experiment "),ze=s(Da,"A",{href:!0});var yn=c(ze);eo=o(yn,"init_trackers()"),yn.forEach(a),to=o(Da," should be used to setup your project, and potentially add any experiment hyperparameters to be logged:"),Da.forEach(a),Ut=p(e),h(Ae.$$.fragment,e),Jt=p(e),E=s(e,"P",{});var Ue=c(E);ao=o(Ue,"When you are ready to log any data, "),Ne=s(Ue,"A",{href:!0});var kn=c(Ne);ro=o(kn,"log()"),kn.forEach(a),oo=o(Ue,` should be used.
A `),yt=s(Ue,"CODE",{});var $n=c(yt);no=o($n,"step"),$n.forEach(a),so=o(Ue," can also be passed in to correlate the data with a particular step in the training loop."),Ue.forEach(a),Kt=p(e),h(je.$$.fragment,e),Qt=p(e),Z=s(e,"P",{});var Ca=c(Z);co=o(Ca,"Once you\u2019ve finished training, make sure to run "),We=s(Ca,"A",{href:!0});var bn=c(We);lo=o(bn,"end_training()"),bn.forEach(a),io=o(Ca," so that all the trackers can run their finish functionalities if they have any."),Ca.forEach(a),Xt=p(e),h(De.$$.fragment,e),Yt=p(e),Ve=s(e,"P",{});var wn=c(Ve);po=o(wn,"A full example is below:"),wn.forEach(a),Zt=p(e),h(Ce.$$.fragment,e),ea=p(e),N=s(e,"H2",{class:!0});var xa=c(N);ee=s(xa,"A",{id:!0,class:!0,href:!0});var En=c(ee);kt=s(En,"SPAN",{});var Tn=c(kt);h(xe.$$.fragment,Tn),Tn.forEach(a),En.forEach(a),uo=p(xa),$t=s(xa,"SPAN",{});var An=c($t);mo=o(An,"Implementing Custom Trackers"),An.forEach(a),xa.forEach(a),ta=p(e),T=s(e,"P",{});var Je=c(T);ho=o(Je,"To implement a new tracker to be used in "),bt=s(Je,"CODE",{});var jn=c(bt);fo=o(jn,"Accelerator"),jn.forEach(a),go=o(Je,", a new one can be made through implementing the "),wt=s(Je,"CODE",{});var Dn=c(wt);_o=o(Dn,"~GeneralTracker"),Dn.forEach(a),vo=o(Je,` class.
Every tracker must implement three functions:`),Je.forEach(a),aa=p(e),A=s(e,"UL",{});var Ke=c(A);j=s(Ke,"LI",{});var Ie=c(j);Et=s(Ie,"CODE",{});var Cn=c(Et);yo=o(Cn,"__init__"),Cn.forEach(a),ko=o(Ie,`:
Should store a `),Tt=s(Ie,"CODE",{});var xn=c(Tt);$o=o(xn,"run_name"),xn.forEach(a),bo=o(Ie,` and initialize the tracker API of the integrated library.
If a tracker stores their data locally (such as TensorBoard), a `),At=s(Ie,"CODE",{});var Ln=c(At);wo=o(Ln,"logging_dir"),Ln.forEach(a),Eo=o(Ie," parameter can be added."),Ie.forEach(a),To=p(Ke),te=s(Ke,"LI",{});var Bt=c(te);jt=s(Bt,"CODE",{});var Pn=c(jt);Ao=o(Pn,"store_init_configuration"),Pn.forEach(a),jo=o(Bt,`:
Should take in a `),Dt=s(Bt,"CODE",{});var On=c(Dt);Do=o(On,"values"),On.forEach(a),Co=o(Bt," dictionary and store them as a one-time experiment configuration"),Bt.forEach(a),xo=p(Ke),D=s(Ke,"LI",{});var qe=c(D);Ct=s(qe,"CODE",{});var In=c(Ct);Lo=o(In,"log"),In.forEach(a),Po=o(qe,`:
Should take in a `),xt=s(qe,"CODE",{});var qn=c(xt);Oo=o(qn,"values"),qn.forEach(a),Io=o(qe," dictionary and a "),Lt=s(qe,"CODE",{});var Bn=c(Lt);qo=o(Bn,"step"),Bn.forEach(a),Bo=o(qe,", and should log them to the run"),qe.forEach(a),Ke.forEach(a),ra=p(e),Me=s(e,"P",{});var Sn=c(Me);So=o(Sn,"A brief example can be seen below with an integration with Weights and Biases, containing only the relevent information:"),Sn.forEach(a),oa=p(e),h(Le.$$.fragment,e),na=p(e),W=s(e,"H2",{class:!0});var La=c(W);ae=s(La,"A",{id:!0,class:!0,href:!0});var zn=c(ae);Pt=s(zn,"SPAN",{});var Nn=c(Pt);h(Pe.$$.fragment,Nn),Nn.forEach(a),zn.forEach(a),zo=p(La),Ot=s(La,"SPAN",{});var Wn=c(Ot);No=o(Wn,"When a wrapper cannot work"),Wn.forEach(a),La.forEach(a),sa=p(e),C=s(e,"P",{});var Qe=c(C);Wo=o(Qe,"If a library has an API that does not follow a strict "),It=s(Qe,"CODE",{});var Vn=c(It);Vo=o(Vn,".log"),Vn.forEach(a),Mo=o(Qe," with an overall dictionary such as Neptune.AI, logging can be done manually under an "),qt=s(Qe,"CODE",{});var Mn=c(qt);Go=o(Mn,"if accelerator.is_main_process"),Mn.forEach(a),Ro=o(Qe," statement:"),Qe.forEach(a),ca=p(e),h(Oe.$$.fragment,e),this.h()},h(){u(O,"name","hf:doc:metadata"),u(O,"content",JSON.stringify(Qn)),u(V,"id","tracking"),u(V,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(V,"href","#tracking"),u(I,"class","relative group"),u(Se,"href","/docs/accelerate/pr_293/en/accelerator#accelerate.Accelerator.log"),u(M,"id","accelerate.tracking.TensorBoardTracker"),u(M,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(M,"href","#accelerate.tracking.TensorBoardTracker"),u(q,"class","relative group"),u(R,"class","docstring"),u(H,"class","docstring"),u(F,"class","docstring"),u(y,"class","docstring"),u(U,"class","docstring"),u(J,"class","docstring"),u(K,"class","docstring"),u(k,"class","docstring"),u(Q,"class","docstring"),u(X,"class","docstring"),u($,"class","docstring"),u(ze,"href","/docs/accelerate/pr_293/en/accelerator#accelerate.Accelerator.init_trackers"),u(Ne,"href","/docs/accelerate/pr_293/en/accelerator#accelerate.Accelerator.log"),u(We,"href","/docs/accelerate/pr_293/en/accelerator#accelerate.Accelerator.end_training"),u(ee,"id","implementing-custom-trackers"),u(ee,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(ee,"href","#implementing-custom-trackers"),u(N,"class","relative group"),u(ae,"id","when-a-wrapper-cannot-work"),u(ae,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(ae,"href","#when-a-wrapper-cannot-work"),u(W,"class","relative group")},m(e,l){t(document.head,O),d(e,St,l),d(e,I,l),t(I,V),t(V,Xe),f(re,Xe,null),t(I,Oa),t(I,Ye),t(Ye,Ia),d(e,zt,l),d(e,oe,l),t(oe,qa),t(oe,Se),t(Se,Ba),d(e,Nt,l),d(e,q,l),t(q,M),t(M,Ze),f(ne,Ze,null),t(q,Sa),t(q,et),t(et,za),d(e,Wt,l),d(e,G,l),t(G,Na),t(G,tt),t(tt,Wa),t(G,Va),d(e,Vt,l),d(e,y,l),f(se,y,null),t(y,Ma),t(y,B),t(B,Ga),t(B,at),t(at,Ra),t(B,Ha),t(B,rt),t(rt,Fa),t(B,Ua),t(y,Ja),t(y,R),f(ce,R,null),t(R,Ka),t(R,le),t(le,Qa),t(le,ot),t(ot,Xa),t(le,Ya),t(y,Za),t(y,H),f(ie,H,null),t(H,er),t(H,pe),t(pe,tr),t(pe,nt),t(nt,ar),t(pe,rr),t(y,or),t(y,F),f(de,F,null),t(F,nr),t(F,ue),t(ue,sr),t(ue,st),t(st,cr),t(ue,lr),d(e,Mt,l),d(e,k,l),f(me,k,null),t(k,ir),t(k,S),t(S,pr),t(S,ct),t(ct,dr),t(S,ur),t(S,lt),t(lt,mr),t(S,hr),t(k,fr),t(k,U),f(he,U,null),t(U,gr),t(U,fe),t(fe,_r),t(fe,it),t(it,vr),t(fe,yr),t(k,kr),t(k,J),f(ge,J,null),t(J,$r),t(J,_e),t(_e,br),t(_e,pt),t(pt,wr),t(_e,Er),t(k,Tr),t(k,K),f(ve,K,null),t(K,Ar),t(K,ye),t(ye,jr),t(ye,dt),t(dt,Dr),t(ye,Cr),d(e,Gt,l),d(e,$,l),f(ke,$,null),t($,xr),t($,z),t(z,Lr),t(z,ut),t(ut,Pr),t(z,Or),t(z,mt),t(mt,Ir),t(z,qr),t($,Br),t($,ht),t(ht,Sr),t($,zr),t($,Q),f($e,Q,null),t(Q,Nr),t(Q,be),t(be,Wr),t(be,ft),t(ft,Vr),t(be,Mr),t($,Gr),t($,X),f(we,X,null),t(X,Rr),t(X,Ee),t(Ee,Hr),t(Ee,gt),t(gt,Fr),t(Ee,Ur),d(e,Rt,l),d(e,w,l),t(w,Jr),t(w,_t),t(_t,Kr),t(w,Qr),t(w,vt),t(vt,Xr),t(w,Yr),d(e,Ht,l),f(Te,e,l),d(e,Ft,l),d(e,Y,l),t(Y,Zr),t(Y,ze),t(ze,eo),t(Y,to),d(e,Ut,l),f(Ae,e,l),d(e,Jt,l),d(e,E,l),t(E,ao),t(E,Ne),t(Ne,ro),t(E,oo),t(E,yt),t(yt,no),t(E,so),d(e,Kt,l),f(je,e,l),d(e,Qt,l),d(e,Z,l),t(Z,co),t(Z,We),t(We,lo),t(Z,io),d(e,Xt,l),f(De,e,l),d(e,Yt,l),d(e,Ve,l),t(Ve,po),d(e,Zt,l),f(Ce,e,l),d(e,ea,l),d(e,N,l),t(N,ee),t(ee,kt),f(xe,kt,null),t(N,uo),t(N,$t),t($t,mo),d(e,ta,l),d(e,T,l),t(T,ho),t(T,bt),t(bt,fo),t(T,go),t(T,wt),t(wt,_o),t(T,vo),d(e,aa,l),d(e,A,l),t(A,j),t(j,Et),t(Et,yo),t(j,ko),t(j,Tt),t(Tt,$o),t(j,bo),t(j,At),t(At,wo),t(j,Eo),t(A,To),t(A,te),t(te,jt),t(jt,Ao),t(te,jo),t(te,Dt),t(Dt,Do),t(te,Co),t(A,xo),t(A,D),t(D,Ct),t(Ct,Lo),t(D,Po),t(D,xt),t(xt,Oo),t(D,Io),t(D,Lt),t(Lt,qo),t(D,Bo),d(e,ra,l),d(e,Me,l),t(Me,So),d(e,oa,l),f(Le,e,l),d(e,na,l),d(e,W,l),t(W,ae),t(ae,Pt),f(Pe,Pt,null),t(W,zo),t(W,Ot),t(Ot,No),d(e,sa,l),d(e,C,l),t(C,Wo),t(C,It),t(It,Vo),t(C,Mo),t(C,qt),t(qt,Go),t(C,Ro),d(e,ca,l),f(Oe,e,l),la=!0},p:Un,i(e){la||(g(re.$$.fragment,e),g(ne.$$.fragment,e),g(se.$$.fragment,e),g(ce.$$.fragment,e),g(ie.$$.fragment,e),g(de.$$.fragment,e),g(me.$$.fragment,e),g(he.$$.fragment,e),g(ge.$$.fragment,e),g(ve.$$.fragment,e),g(ke.$$.fragment,e),g($e.$$.fragment,e),g(we.$$.fragment,e),g(Te.$$.fragment,e),g(Ae.$$.fragment,e),g(je.$$.fragment,e),g(De.$$.fragment,e),g(Ce.$$.fragment,e),g(xe.$$.fragment,e),g(Le.$$.fragment,e),g(Pe.$$.fragment,e),g(Oe.$$.fragment,e),la=!0)},o(e){_(re.$$.fragment,e),_(ne.$$.fragment,e),_(se.$$.fragment,e),_(ce.$$.fragment,e),_(ie.$$.fragment,e),_(de.$$.fragment,e),_(me.$$.fragment,e),_(he.$$.fragment,e),_(ge.$$.fragment,e),_(ve.$$.fragment,e),_(ke.$$.fragment,e),_($e.$$.fragment,e),_(we.$$.fragment,e),_(Te.$$.fragment,e),_(Ae.$$.fragment,e),_(je.$$.fragment,e),_(De.$$.fragment,e),_(Ce.$$.fragment,e),_(xe.$$.fragment,e),_(Le.$$.fragment,e),_(Pe.$$.fragment,e),_(Oe.$$.fragment,e),la=!1},d(e){a(O),e&&a(St),e&&a(I),v(re),e&&a(zt),e&&a(oe),e&&a(Nt),e&&a(q),v(ne),e&&a(Wt),e&&a(G),e&&a(Vt),e&&a(y),v(se),v(ce),v(ie),v(de),e&&a(Mt),e&&a(k),v(me),v(he),v(ge),v(ve),e&&a(Gt),e&&a($),v(ke),v($e),v(we),e&&a(Rt),e&&a(w),e&&a(Ht),v(Te,e),e&&a(Ft),e&&a(Y),e&&a(Ut),v(Ae,e),e&&a(Jt),e&&a(E),e&&a(Kt),v(je,e),e&&a(Qt),e&&a(Z),e&&a(Xt),v(De,e),e&&a(Yt),e&&a(Ve),e&&a(Zt),v(Ce,e),e&&a(ea),e&&a(N),v(xe),e&&a(ta),e&&a(T),e&&a(aa),e&&a(A),e&&a(ra),e&&a(Me),e&&a(oa),v(Le,e),e&&a(na),e&&a(W),v(Pe),e&&a(sa),e&&a(C),e&&a(ca),v(Oe,e)}}}const Qn={local:"tracking",sections:[{local:"accelerate.tracking.TensorBoardTracker",title:"Integrated Trackers"},{local:"implementing-custom-trackers",title:"Implementing Custom Trackers"},{local:"when-a-wrapper-cannot-work",title:"When a wrapper cannot work"}],title:"Tracking"};function Xn(Fo){return Jn(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class as extends Gn{constructor(O){super();Rn(this,O,Xn,Kn,Hn,{})}}export{as as default,Qn as metadata};
