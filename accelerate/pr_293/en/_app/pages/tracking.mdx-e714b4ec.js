import{S as Ss,i as Bs,s as zs,e as s,k as l,w as m,t as r,M as Ns,c as n,d as a,m as i,a as c,x as h,h as o,b as u,F as e,g as d,y as f,L as Vs,q as g,o as _,B as v,v as Ws}from"../chunks/vendor-19e06bd2.js";import{D as w}from"../chunks/Docstring-395e5a9c.js";import{C as Ue}from"../chunks/CodeBlock-9dd1fdfb.js";import{I as Ca}from"../chunks/IconCopyLink-3c713d38.js";function Ms(Wo){let P,St,O,V,Je,re,xa,Ke,La,Bt,oe,Pa,qe,Oa,zt,I,W,Qe,se,Ia,Xe,qa,Nt,M,Sa,Ye,Ba,za,Vt,k,ne,Na,q,Va,Ze,Wa,Ma,et,Ga,Ra,Ha,G,ce,Fa,le,Ua,tt,Ja,Ka,Qa,R,ie,Xa,pe,Ya,at,Za,er,tr,H,de,ar,ue,rr,rt,or,sr,Wt,$,me,nr,S,cr,ot,lr,ir,st,pr,dr,ur,F,he,mr,fe,hr,nt,fr,gr,_r,U,ge,vr,_e,yr,ct,kr,$r,br,J,ve,wr,ye,Er,lt,Tr,jr,Mt,y,ke,Ar,B,Dr,it,Cr,xr,pt,Lr,Pr,Or,dt,Ir,qr,K,$e,Sr,ut,Br,zr,Q,be,Nr,we,Vr,mt,Wr,Mr,Gr,X,Ee,Rr,Te,Hr,ht,Fr,Ur,Gt,E,Jr,ft,Kr,Qr,gt,Xr,Yr,Rt,je,Ht,Y,Zr,_t,eo,to,Ft,Ae,Ut,T,ao,Se,ro,oo,vt,so,no,Jt,De,Kt,Be,co,Qt,Ce,Xt,z,Z,yt,xe,lo,kt,io,Yt,j,po,$t,uo,mo,bt,ho,fo,Zt,A,ee,wt,go,_o,Et,vo,yo,ko,te,Tt,$o,bo,jt,wo,Eo,To,D,At,jo,Ao,Dt,Do,Co,Ct,xo,Lo,ea,ze,Po,ta,Le,aa,N,ae,xt,Pe,Oo,Lt,Io,ra,C,qo,Pt,So,Bo,Ot,zo,No,oa,Oe,sa;return re=new Ca({}),se=new Ca({}),ne=new w({props:{name:"class accelerate.tracking.TensorBoardTracker",anchor:"accelerate.tracking.TensorBoardTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L94",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run`,name:"run_name"}]}}),ce=new w({props:{name:"finish",anchor:"accelerate.tracking.TensorBoardTracker.finish",parameters:[],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L142"}}),ie=new w({props:{name:"log",anchor:"accelerate.tracking.TensorBoardTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L124",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.TensorBoardTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),de=new w({props:{name:"store_init_configuration",anchor:"accelerate.tracking.TensorBoardTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L111",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),me=new w({props:{name:"class accelerate.tracking.WandBTracker",anchor:"accelerate.tracking.WandBTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L150",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run.`,name:"run_name"}]}}),he=new w({props:{name:"finish",anchor:"accelerate.tracking.WandBTracker.finish",parameters:[],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L192"}}),ge=new w({props:{name:"log",anchor:"accelerate.tracking.WandBTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L179",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.WandBTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),ve=new w({props:{name:"store_init_configuration",anchor:"accelerate.tracking.WandBTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L167",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),ke=new w({props:{name:"class accelerate.tracking.CometMLTracker",anchor:"accelerate.tracking.CometMLTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L200",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run.`,name:"run_name"}]}}),$e=new w({props:{name:"finish",anchor:"accelerate.tracking.CometMLTracker.finish",parameters:[],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L246"}}),be=new w({props:{name:"log",anchor:"accelerate.tracking.CometMLTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L231",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.CometMLTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),Ee=new w({props:{name:"store_init_configuration",anchor:"accelerate.tracking.CometMLTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L219",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),je=new Ue({props:{code:`from accelerate import Accelerate
from accelerate.utils import LoggerType

accelerator = Accelerate(log_with="all")  # For all available trackers in the environment
accelerator = Accelerate(log_with="wandb")
accelerator = Accelerate(log_with=["wandb", LoggerType.TENSORBOARD])`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerate
<span class="hljs-keyword">from</span> accelerate.utils <span class="hljs-keyword">import</span> LoggerType

accelerator = Accelerate(log_with=<span class="hljs-string">&quot;all&quot;</span>)  <span class="hljs-comment"># For all available trackers in the environment</span>
accelerator = Accelerate(log_with=<span class="hljs-string">&quot;wandb&quot;</span>)
accelerator = Accelerate(log_with=[<span class="hljs-string">&quot;wandb&quot;</span>, LoggerType.TENSORBOARD])`}}),Ae=new Ue({props:{code:`hps = {"num_iterations": 5, "learning_rate": 1e-2}
accelerator.init_trackers("my_project", config=hps)`,highlighted:`hps = {<span class="hljs-string">&quot;num_iterations&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&quot;learning_rate&quot;</span>: <span class="hljs-number">1e-2</span>}
accelerator.init_trackers(<span class="hljs-string">&quot;my_project&quot;</span>, config=hps)`}}),De=new Ue({props:{code:'accelerator.log({"train_loss": 1.12, "valid_loss": 0.8}, step=1)',highlighted:'accelerator.log({<span class="hljs-string">&quot;train_loss&quot;</span>: <span class="hljs-number">1.12</span>, <span class="hljs-string">&quot;valid_loss&quot;</span>: <span class="hljs-number">0.8</span>}, step=<span class="hljs-number">1</span>)'}}),Ce=new Ue({props:{code:`from accelerate import Accelerator

accelerator = Accelerator(log_with="all")
config = {
    "num_iterations": 5,
    "learning_rate": 1e-2,
    "loss_function": str(my_loss_function),
}

accelerator.init_trackers("example_project", config=config)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config["num_iterations"]:
    for step, batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        accelerator.backward(loss)
        my_optimizer.step()
        accelerator.log({"training_loss": loss}, step=step)`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator

accelerator = Accelerator(log_with=<span class="hljs-string">&quot;all&quot;</span>)
config = {
    <span class="hljs-string">&quot;num_iterations&quot;</span>: <span class="hljs-number">5</span>,
    <span class="hljs-string">&quot;learning_rate&quot;</span>: <span class="hljs-number">1e-2</span>,
    <span class="hljs-string">&quot;loss_function&quot;</span>: <span class="hljs-built_in">str</span>(my_loss_function),
}

accelerator.init_trackers(<span class="hljs-string">&quot;example_project&quot;</span>, config=config)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

<span class="hljs-keyword">for</span> iteration <span class="hljs-keyword">in</span> config[<span class="hljs-string">&quot;num_iterations&quot;</span>]:
    <span class="hljs-keyword">for</span> step, batch <span class="hljs-keyword">in</span> my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        accelerator.backward(loss)
        my_optimizer.step()
        accelerator.log({<span class="hljs-string">&quot;training_loss&quot;</span>: loss}, step=step)`}}),xe=new Ca({}),Le=new Ue({props:{code:`from accelerate.tracking import GeneralTracker
from typing import Optional

import wandb


class WandBTracker(GeneralTracker):
    def __init__(self, run_name: str):
        self.run_name = run_name
        wandb.init(self.run_name)

    def store_init_configuration(self, values: dict):
        wandb.config(values)

    def log(self, values: dict, step: Optional[int] = None):
        wandb.log(values, step=step)`,highlighted:`<span class="hljs-keyword">from</span> accelerate.tracking <span class="hljs-keyword">import</span> GeneralTracker
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>

<span class="hljs-keyword">import</span> wandb


<span class="hljs-keyword">class</span> <span class="hljs-title class_">WandBTracker</span>(<span class="hljs-title class_ inherited__">GeneralTracker</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, run_name: <span class="hljs-built_in">str</span></span>):
        self.run_name = run_name
        wandb.init(self.run_name)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">store_init_configuration</span>(<span class="hljs-params">self, values: <span class="hljs-built_in">dict</span></span>):
        wandb.config(values)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">self, values: <span class="hljs-built_in">dict</span>, step: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span></span>):
        wandb.log(values, step=step)`}}),Pe=new Ca({}),Oe=new Ue({props:{code:`from accelerate import Accelerator
+ import neptune.new as neptune

accelerator = Accelerator()
+ run = neptune.init(...)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config["num_iterations"]:
    for batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        total_loss += loss
        accelerator.backward(loss)
        my_optimizer.step()
+       if accelerator.is_main_process:
+           run["logs/training/batch/loss"].log(loss)`,highlighted:`from accelerate import Accelerator
<span class="hljs-addition">+ import neptune.new as neptune</span>

accelerator = Accelerator()
<span class="hljs-addition">+ run = neptune.init(...)</span>

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config[&quot;num_iterations&quot;]:
    for batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        total_loss += loss
        accelerator.backward(loss)
        my_optimizer.step()
<span class="hljs-addition">+       if accelerator.is_main_process:</span>
<span class="hljs-addition">+           run[&quot;logs/training/batch/loss&quot;].log(loss)</span>`}}),{c(){P=s("meta"),St=l(),O=s("h1"),V=s("a"),Je=s("span"),m(re.$$.fragment),xa=l(),Ke=s("span"),La=r("Tracking"),Bt=l(),oe=s("p"),Pa=r(`There are a large number of experiment tracking API\u2019s available, however getting them all to work with in a multi-processing environment can oftentimes be complex.
Accelerate provides a general tracking API that can be used to log useful items during your script through `),qe=s("a"),Oa=r("log()"),zt=l(),I=s("h2"),W=s("a"),Qe=s("span"),m(se.$$.fragment),Ia=l(),Xe=s("span"),qa=r("Integrated Trackers"),Nt=l(),M=s("p"),Sa=r("Currently "),Ye=s("code"),Ba=r("Accelerate"),za=r(" supports three trackers out-of-the-box:"),Vt=l(),k=s("div"),m(ne.$$.fragment),Na=l(),q=s("p"),Va=r("A "),Ze=s("code"),Wa=r("Tracker"),Ma=r(" class that supports "),et=s("code"),Ga=r("tensorboard"),Ra=r(". Should be initialized at the start of your script."),Ha=l(),G=s("div"),m(ce.$$.fragment),Fa=l(),le=s("p"),Ua=r("Closes "),tt=s("code"),Ja=r("TensorBoard"),Ka=r(" writer"),Qa=l(),R=s("div"),m(ie.$$.fragment),Xa=l(),pe=s("p"),Ya=r("Logs "),at=s("code"),Za=r("values"),er=r(" to the current run."),tr=l(),H=s("div"),m(de.$$.fragment),ar=l(),ue=s("p"),rr=r("Logs "),rt=s("code"),or=r("values"),sr=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Wt=l(),$=s("div"),m(me.$$.fragment),nr=l(),S=s("p"),cr=r("A "),ot=s("code"),lr=r("Tracker"),ir=r(" class that supports "),st=s("code"),pr=r("wandb"),dr=r(". Should be initialized at the start of your script."),ur=l(),F=s("div"),m(he.$$.fragment),mr=l(),fe=s("p"),hr=r("Closes "),nt=s("code"),fr=r("wandb"),gr=r(" writer"),_r=l(),U=s("div"),m(ge.$$.fragment),vr=l(),_e=s("p"),yr=r("Logs "),ct=s("code"),kr=r("values"),$r=r(" to the current run."),br=l(),J=s("div"),m(ve.$$.fragment),wr=l(),ye=s("p"),Er=r("Logs "),lt=s("code"),Tr=r("values"),jr=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Mt=l(),y=s("div"),m(ke.$$.fragment),Ar=l(),B=s("p"),Dr=r("A "),it=s("code"),Cr=r("Tracker"),xr=r(" class that supports "),pt=s("code"),Lr=r("comet_ml"),Pr=r(". Should be initialized at the start of your script."),Or=l(),dt=s("p"),Ir=r("API keys must be stored in a Comet config file."),qr=l(),K=s("div"),m($e.$$.fragment),Sr=l(),ut=s("p"),Br=r("Do nothing"),zr=l(),Q=s("div"),m(be.$$.fragment),Nr=l(),we=s("p"),Vr=r("Logs "),mt=s("code"),Wr=r("values"),Mr=r(" to the current run."),Gr=l(),X=s("div"),m(Ee.$$.fragment),Rr=l(),Te=s("p"),Hr=r("Logs "),ht=s("code"),Fr=r("values"),Ur=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Gt=l(),E=s("p"),Jr=r("To use any of them, pass in the selected type(s) to the "),ft=s("code"),Kr=r("log_with"),Qr=r(" parameter in "),gt=s("code"),Xr=r("__init__"),Yr=r(":"),Rt=l(),m(je.$$.fragment),Ht=l(),Y=s("p"),Zr=r("At the start of your experiment "),_t=s("code"),eo=r("init_tracker"),to=r(" should be used to setup your project, and potentially add any experiment hyperparameters to be logged:"),Ft=l(),m(Ae.$$.fragment),Ut=l(),T=s("p"),ao=r("When you are ready to log any data, "),Se=s("a"),ro=r("log()"),oo=r(` should be used.
A `),vt=s("code"),so=r("step"),no=r(" can also be passed in to correlate the data with a particular step in the training loop."),Jt=l(),m(De.$$.fragment),Kt=l(),Be=s("p"),co=r("A full example is below:"),Qt=l(),m(Ce.$$.fragment),Xt=l(),z=s("h2"),Z=s("a"),yt=s("span"),m(xe.$$.fragment),lo=l(),kt=s("span"),io=r("Implementing Custom Trackers"),Yt=l(),j=s("p"),po=r("To implement a new tracker to be used in "),$t=s("code"),uo=r("Accelerator"),mo=r(", a new one can be made through implementing the "),bt=s("code"),ho=r("~GeneralTracker"),fo=r(` class.
Every tracker must implement three functions:`),Zt=l(),A=s("ul"),ee=s("li"),wt=s("code"),go=r("__init__"),_o=r(": Should store a "),Et=s("code"),vo=r("run_name"),yo=r(" and initialize the tracker API of the integrated library"),ko=l(),te=s("li"),Tt=s("code"),$o=r("store_init_configuration"),bo=r(": Should take in a "),jt=s("code"),wo=r("values"),Eo=r(" dictionary and store them as a one-time experiment configuration"),To=l(),D=s("li"),At=s("code"),jo=r("log"),Ao=r(": Should take in a "),Dt=s("code"),Do=r("values"),Co=r(" dictionary and a "),Ct=s("code"),xo=r("step"),Lo=r(", and should log them to the run"),ea=l(),ze=s("p"),Po=r("A brief example can be seen below with an integration with Weights and Biases, containing only the relevent information:"),ta=l(),m(Le.$$.fragment),aa=l(),N=s("h2"),ae=s("a"),xt=s("span"),m(Pe.$$.fragment),Oo=l(),Lt=s("span"),Io=r("When a wrapper cannot work"),ra=l(),C=s("p"),qo=r("If a library has an API that does not follow a strict "),Pt=s("code"),So=r(".log"),Bo=r(" with an overall dictionary such as Neptune.AI, logging can be done manually under an "),Ot=s("code"),zo=r("if accelerator.is_main_process"),No=r(" statement:"),oa=l(),m(Oe.$$.fragment),this.h()},l(t){const p=Ns('[data-svelte="svelte-1phssyn"]',document.head);P=n(p,"META",{name:!0,content:!0}),p.forEach(a),St=i(t),O=n(t,"H1",{class:!0});var na=c(O);V=n(na,"A",{id:!0,class:!0,href:!0});var Mo=c(V);Je=n(Mo,"SPAN",{});var Go=c(Je);h(re.$$.fragment,Go),Go.forEach(a),Mo.forEach(a),xa=i(na),Ke=n(na,"SPAN",{});var Ro=c(Ke);La=o(Ro,"Tracking"),Ro.forEach(a),na.forEach(a),Bt=i(t),oe=n(t,"P",{});var Vo=c(oe);Pa=o(Vo,`There are a large number of experiment tracking API\u2019s available, however getting them all to work with in a multi-processing environment can oftentimes be complex.
Accelerate provides a general tracking API that can be used to log useful items during your script through `),qe=n(Vo,"A",{href:!0});var Ho=c(qe);Oa=o(Ho,"log()"),Ho.forEach(a),Vo.forEach(a),zt=i(t),I=n(t,"H2",{class:!0});var ca=c(I);W=n(ca,"A",{id:!0,class:!0,href:!0});var Fo=c(W);Qe=n(Fo,"SPAN",{});var Uo=c(Qe);h(se.$$.fragment,Uo),Uo.forEach(a),Fo.forEach(a),Ia=i(ca),Xe=n(ca,"SPAN",{});var Jo=c(Xe);qa=o(Jo,"Integrated Trackers"),Jo.forEach(a),ca.forEach(a),Nt=i(t),M=n(t,"P",{});var la=c(M);Sa=o(la,"Currently "),Ye=n(la,"CODE",{});var Ko=c(Ye);Ba=o(Ko,"Accelerate"),Ko.forEach(a),za=o(la," supports three trackers out-of-the-box:"),la.forEach(a),Vt=i(t),k=n(t,"DIV",{class:!0});var x=c(k);h(ne.$$.fragment,x),Na=i(x),q=n(x,"P",{});var Ne=c(q);Va=o(Ne,"A "),Ze=n(Ne,"CODE",{});var Qo=c(Ze);Wa=o(Qo,"Tracker"),Qo.forEach(a),Ma=o(Ne," class that supports "),et=n(Ne,"CODE",{});var Xo=c(et);Ga=o(Xo,"tensorboard"),Xo.forEach(a),Ra=o(Ne,". Should be initialized at the start of your script."),Ne.forEach(a),Ha=i(x),G=n(x,"DIV",{class:!0});var ia=c(G);h(ce.$$.fragment,ia),Fa=i(ia),le=n(ia,"P",{});var pa=c(le);Ua=o(pa,"Closes "),tt=n(pa,"CODE",{});var Yo=c(tt);Ja=o(Yo,"TensorBoard"),Yo.forEach(a),Ka=o(pa," writer"),pa.forEach(a),ia.forEach(a),Qa=i(x),R=n(x,"DIV",{class:!0});var da=c(R);h(ie.$$.fragment,da),Xa=i(da),pe=n(da,"P",{});var ua=c(pe);Ya=o(ua,"Logs "),at=n(ua,"CODE",{});var Zo=c(at);Za=o(Zo,"values"),Zo.forEach(a),er=o(ua," to the current run."),ua.forEach(a),da.forEach(a),tr=i(x),H=n(x,"DIV",{class:!0});var ma=c(H);h(de.$$.fragment,ma),ar=i(ma),ue=n(ma,"P",{});var ha=c(ue);rr=o(ha,"Logs "),rt=n(ha,"CODE",{});var es=c(rt);or=o(es,"values"),es.forEach(a),sr=o(ha," as hyperparameters for the run. Should be run at the beginning of your experiment."),ha.forEach(a),ma.forEach(a),x.forEach(a),Wt=i(t),$=n(t,"DIV",{class:!0});var L=c($);h(me.$$.fragment,L),nr=i(L),S=n(L,"P",{});var Ve=c(S);cr=o(Ve,"A "),ot=n(Ve,"CODE",{});var ts=c(ot);lr=o(ts,"Tracker"),ts.forEach(a),ir=o(Ve," class that supports "),st=n(Ve,"CODE",{});var as=c(st);pr=o(as,"wandb"),as.forEach(a),dr=o(Ve,". Should be initialized at the start of your script."),Ve.forEach(a),ur=i(L),F=n(L,"DIV",{class:!0});var fa=c(F);h(he.$$.fragment,fa),mr=i(fa),fe=n(fa,"P",{});var ga=c(fe);hr=o(ga,"Closes "),nt=n(ga,"CODE",{});var rs=c(nt);fr=o(rs,"wandb"),rs.forEach(a),gr=o(ga," writer"),ga.forEach(a),fa.forEach(a),_r=i(L),U=n(L,"DIV",{class:!0});var _a=c(U);h(ge.$$.fragment,_a),vr=i(_a),_e=n(_a,"P",{});var va=c(_e);yr=o(va,"Logs "),ct=n(va,"CODE",{});var os=c(ct);kr=o(os,"values"),os.forEach(a),$r=o(va," to the current run."),va.forEach(a),_a.forEach(a),br=i(L),J=n(L,"DIV",{class:!0});var ya=c(J);h(ve.$$.fragment,ya),wr=i(ya),ye=n(ya,"P",{});var ka=c(ye);Er=o(ka,"Logs "),lt=n(ka,"CODE",{});var ss=c(lt);Tr=o(ss,"values"),ss.forEach(a),jr=o(ka," as hyperparameters for the run. Should be run at the beginning of your experiment."),ka.forEach(a),ya.forEach(a),L.forEach(a),Mt=i(t),y=n(t,"DIV",{class:!0});var b=c(y);h(ke.$$.fragment,b),Ar=i(b),B=n(b,"P",{});var We=c(B);Dr=o(We,"A "),it=n(We,"CODE",{});var ns=c(it);Cr=o(ns,"Tracker"),ns.forEach(a),xr=o(We," class that supports "),pt=n(We,"CODE",{});var cs=c(pt);Lr=o(cs,"comet_ml"),cs.forEach(a),Pr=o(We,". Should be initialized at the start of your script."),We.forEach(a),Or=i(b),dt=n(b,"P",{});var ls=c(dt);Ir=o(ls,"API keys must be stored in a Comet config file."),ls.forEach(a),qr=i(b),K=n(b,"DIV",{class:!0});var $a=c(K);h($e.$$.fragment,$a),Sr=i($a),ut=n($a,"P",{});var is=c(ut);Br=o(is,"Do nothing"),is.forEach(a),$a.forEach(a),zr=i(b),Q=n(b,"DIV",{class:!0});var ba=c(Q);h(be.$$.fragment,ba),Nr=i(ba),we=n(ba,"P",{});var wa=c(we);Vr=o(wa,"Logs "),mt=n(wa,"CODE",{});var ps=c(mt);Wr=o(ps,"values"),ps.forEach(a),Mr=o(wa," to the current run."),wa.forEach(a),ba.forEach(a),Gr=i(b),X=n(b,"DIV",{class:!0});var Ea=c(X);h(Ee.$$.fragment,Ea),Rr=i(Ea),Te=n(Ea,"P",{});var Ta=c(Te);Hr=o(Ta,"Logs "),ht=n(Ta,"CODE",{});var ds=c(ht);Fr=o(ds,"values"),ds.forEach(a),Ur=o(Ta," as hyperparameters for the run. Should be run at the beginning of your experiment."),Ta.forEach(a),Ea.forEach(a),b.forEach(a),Gt=i(t),E=n(t,"P",{});var Me=c(E);Jr=o(Me,"To use any of them, pass in the selected type(s) to the "),ft=n(Me,"CODE",{});var us=c(ft);Kr=o(us,"log_with"),us.forEach(a),Qr=o(Me," parameter in "),gt=n(Me,"CODE",{});var ms=c(gt);Xr=o(ms,"__init__"),ms.forEach(a),Yr=o(Me,":"),Me.forEach(a),Rt=i(t),h(je.$$.fragment,t),Ht=i(t),Y=n(t,"P",{});var ja=c(Y);Zr=o(ja,"At the start of your experiment "),_t=n(ja,"CODE",{});var hs=c(_t);eo=o(hs,"init_tracker"),hs.forEach(a),to=o(ja," should be used to setup your project, and potentially add any experiment hyperparameters to be logged:"),ja.forEach(a),Ft=i(t),h(Ae.$$.fragment,t),Ut=i(t),T=n(t,"P",{});var Ge=c(T);ao=o(Ge,"When you are ready to log any data, "),Se=n(Ge,"A",{href:!0});var fs=c(Se);ro=o(fs,"log()"),fs.forEach(a),oo=o(Ge,` should be used.
A `),vt=n(Ge,"CODE",{});var gs=c(vt);so=o(gs,"step"),gs.forEach(a),no=o(Ge," can also be passed in to correlate the data with a particular step in the training loop."),Ge.forEach(a),Jt=i(t),h(De.$$.fragment,t),Kt=i(t),Be=n(t,"P",{});var _s=c(Be);co=o(_s,"A full example is below:"),_s.forEach(a),Qt=i(t),h(Ce.$$.fragment,t),Xt=i(t),z=n(t,"H2",{class:!0});var Aa=c(z);Z=n(Aa,"A",{id:!0,class:!0,href:!0});var vs=c(Z);yt=n(vs,"SPAN",{});var ys=c(yt);h(xe.$$.fragment,ys),ys.forEach(a),vs.forEach(a),lo=i(Aa),kt=n(Aa,"SPAN",{});var ks=c(kt);io=o(ks,"Implementing Custom Trackers"),ks.forEach(a),Aa.forEach(a),Yt=i(t),j=n(t,"P",{});var Re=c(j);po=o(Re,"To implement a new tracker to be used in "),$t=n(Re,"CODE",{});var $s=c($t);uo=o($s,"Accelerator"),$s.forEach(a),mo=o(Re,", a new one can be made through implementing the "),bt=n(Re,"CODE",{});var bs=c(bt);ho=o(bs,"~GeneralTracker"),bs.forEach(a),fo=o(Re,` class.
Every tracker must implement three functions:`),Re.forEach(a),Zt=i(t),A=n(t,"UL",{});var He=c(A);ee=n(He,"LI",{});var It=c(ee);wt=n(It,"CODE",{});var ws=c(wt);go=o(ws,"__init__"),ws.forEach(a),_o=o(It,": Should store a "),Et=n(It,"CODE",{});var Es=c(Et);vo=o(Es,"run_name"),Es.forEach(a),yo=o(It," and initialize the tracker API of the integrated library"),It.forEach(a),ko=i(He),te=n(He,"LI",{});var qt=c(te);Tt=n(qt,"CODE",{});var Ts=c(Tt);$o=o(Ts,"store_init_configuration"),Ts.forEach(a),bo=o(qt,": Should take in a "),jt=n(qt,"CODE",{});var js=c(jt);wo=o(js,"values"),js.forEach(a),Eo=o(qt," dictionary and store them as a one-time experiment configuration"),qt.forEach(a),To=i(He),D=n(He,"LI",{});var Ie=c(D);At=n(Ie,"CODE",{});var As=c(At);jo=o(As,"log"),As.forEach(a),Ao=o(Ie,": Should take in a "),Dt=n(Ie,"CODE",{});var Ds=c(Dt);Do=o(Ds,"values"),Ds.forEach(a),Co=o(Ie," dictionary and a "),Ct=n(Ie,"CODE",{});var Cs=c(Ct);xo=o(Cs,"step"),Cs.forEach(a),Lo=o(Ie,", and should log them to the run"),Ie.forEach(a),He.forEach(a),ea=i(t),ze=n(t,"P",{});var xs=c(ze);Po=o(xs,"A brief example can be seen below with an integration with Weights and Biases, containing only the relevent information:"),xs.forEach(a),ta=i(t),h(Le.$$.fragment,t),aa=i(t),N=n(t,"H2",{class:!0});var Da=c(N);ae=n(Da,"A",{id:!0,class:!0,href:!0});var Ls=c(ae);xt=n(Ls,"SPAN",{});var Ps=c(xt);h(Pe.$$.fragment,Ps),Ps.forEach(a),Ls.forEach(a),Oo=i(Da),Lt=n(Da,"SPAN",{});var Os=c(Lt);Io=o(Os,"When a wrapper cannot work"),Os.forEach(a),Da.forEach(a),ra=i(t),C=n(t,"P",{});var Fe=c(C);qo=o(Fe,"If a library has an API that does not follow a strict "),Pt=n(Fe,"CODE",{});var Is=c(Pt);So=o(Is,".log"),Is.forEach(a),Bo=o(Fe," with an overall dictionary such as Neptune.AI, logging can be done manually under an "),Ot=n(Fe,"CODE",{});var qs=c(Ot);zo=o(qs,"if accelerator.is_main_process"),qs.forEach(a),No=o(Fe," statement:"),Fe.forEach(a),oa=i(t),h(Oe.$$.fragment,t),this.h()},h(){u(P,"name","hf:doc:metadata"),u(P,"content",JSON.stringify(Gs)),u(V,"id","tracking"),u(V,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(V,"href","#tracking"),u(O,"class","relative group"),u(qe,"href","/docs/accelerate/pr_293/en/accelerator#accelerate.Accelerator.log"),u(W,"id","accelerate.tracking.TensorBoardTracker"),u(W,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(W,"href","#accelerate.tracking.TensorBoardTracker"),u(I,"class","relative group"),u(G,"class","docstring"),u(R,"class","docstring"),u(H,"class","docstring"),u(k,"class","docstring"),u(F,"class","docstring"),u(U,"class","docstring"),u(J,"class","docstring"),u($,"class","docstring"),u(K,"class","docstring"),u(Q,"class","docstring"),u(X,"class","docstring"),u(y,"class","docstring"),u(Se,"href","/docs/accelerate/pr_293/en/accelerator#accelerate.Accelerator.log"),u(Z,"id","implementing-custom-trackers"),u(Z,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Z,"href","#implementing-custom-trackers"),u(z,"class","relative group"),u(ae,"id","when-a-wrapper-cannot-work"),u(ae,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(ae,"href","#when-a-wrapper-cannot-work"),u(N,"class","relative group")},m(t,p){e(document.head,P),d(t,St,p),d(t,O,p),e(O,V),e(V,Je),f(re,Je,null),e(O,xa),e(O,Ke),e(Ke,La),d(t,Bt,p),d(t,oe,p),e(oe,Pa),e(oe,qe),e(qe,Oa),d(t,zt,p),d(t,I,p),e(I,W),e(W,Qe),f(se,Qe,null),e(I,Ia),e(I,Xe),e(Xe,qa),d(t,Nt,p),d(t,M,p),e(M,Sa),e(M,Ye),e(Ye,Ba),e(M,za),d(t,Vt,p),d(t,k,p),f(ne,k,null),e(k,Na),e(k,q),e(q,Va),e(q,Ze),e(Ze,Wa),e(q,Ma),e(q,et),e(et,Ga),e(q,Ra),e(k,Ha),e(k,G),f(ce,G,null),e(G,Fa),e(G,le),e(le,Ua),e(le,tt),e(tt,Ja),e(le,Ka),e(k,Qa),e(k,R),f(ie,R,null),e(R,Xa),e(R,pe),e(pe,Ya),e(pe,at),e(at,Za),e(pe,er),e(k,tr),e(k,H),f(de,H,null),e(H,ar),e(H,ue),e(ue,rr),e(ue,rt),e(rt,or),e(ue,sr),d(t,Wt,p),d(t,$,p),f(me,$,null),e($,nr),e($,S),e(S,cr),e(S,ot),e(ot,lr),e(S,ir),e(S,st),e(st,pr),e(S,dr),e($,ur),e($,F),f(he,F,null),e(F,mr),e(F,fe),e(fe,hr),e(fe,nt),e(nt,fr),e(fe,gr),e($,_r),e($,U),f(ge,U,null),e(U,vr),e(U,_e),e(_e,yr),e(_e,ct),e(ct,kr),e(_e,$r),e($,br),e($,J),f(ve,J,null),e(J,wr),e(J,ye),e(ye,Er),e(ye,lt),e(lt,Tr),e(ye,jr),d(t,Mt,p),d(t,y,p),f(ke,y,null),e(y,Ar),e(y,B),e(B,Dr),e(B,it),e(it,Cr),e(B,xr),e(B,pt),e(pt,Lr),e(B,Pr),e(y,Or),e(y,dt),e(dt,Ir),e(y,qr),e(y,K),f($e,K,null),e(K,Sr),e(K,ut),e(ut,Br),e(y,zr),e(y,Q),f(be,Q,null),e(Q,Nr),e(Q,we),e(we,Vr),e(we,mt),e(mt,Wr),e(we,Mr),e(y,Gr),e(y,X),f(Ee,X,null),e(X,Rr),e(X,Te),e(Te,Hr),e(Te,ht),e(ht,Fr),e(Te,Ur),d(t,Gt,p),d(t,E,p),e(E,Jr),e(E,ft),e(ft,Kr),e(E,Qr),e(E,gt),e(gt,Xr),e(E,Yr),d(t,Rt,p),f(je,t,p),d(t,Ht,p),d(t,Y,p),e(Y,Zr),e(Y,_t),e(_t,eo),e(Y,to),d(t,Ft,p),f(Ae,t,p),d(t,Ut,p),d(t,T,p),e(T,ao),e(T,Se),e(Se,ro),e(T,oo),e(T,vt),e(vt,so),e(T,no),d(t,Jt,p),f(De,t,p),d(t,Kt,p),d(t,Be,p),e(Be,co),d(t,Qt,p),f(Ce,t,p),d(t,Xt,p),d(t,z,p),e(z,Z),e(Z,yt),f(xe,yt,null),e(z,lo),e(z,kt),e(kt,io),d(t,Yt,p),d(t,j,p),e(j,po),e(j,$t),e($t,uo),e(j,mo),e(j,bt),e(bt,ho),e(j,fo),d(t,Zt,p),d(t,A,p),e(A,ee),e(ee,wt),e(wt,go),e(ee,_o),e(ee,Et),e(Et,vo),e(ee,yo),e(A,ko),e(A,te),e(te,Tt),e(Tt,$o),e(te,bo),e(te,jt),e(jt,wo),e(te,Eo),e(A,To),e(A,D),e(D,At),e(At,jo),e(D,Ao),e(D,Dt),e(Dt,Do),e(D,Co),e(D,Ct),e(Ct,xo),e(D,Lo),d(t,ea,p),d(t,ze,p),e(ze,Po),d(t,ta,p),f(Le,t,p),d(t,aa,p),d(t,N,p),e(N,ae),e(ae,xt),f(Pe,xt,null),e(N,Oo),e(N,Lt),e(Lt,Io),d(t,ra,p),d(t,C,p),e(C,qo),e(C,Pt),e(Pt,So),e(C,Bo),e(C,Ot),e(Ot,zo),e(C,No),d(t,oa,p),f(Oe,t,p),sa=!0},p:Vs,i(t){sa||(g(re.$$.fragment,t),g(se.$$.fragment,t),g(ne.$$.fragment,t),g(ce.$$.fragment,t),g(ie.$$.fragment,t),g(de.$$.fragment,t),g(me.$$.fragment,t),g(he.$$.fragment,t),g(ge.$$.fragment,t),g(ve.$$.fragment,t),g(ke.$$.fragment,t),g($e.$$.fragment,t),g(be.$$.fragment,t),g(Ee.$$.fragment,t),g(je.$$.fragment,t),g(Ae.$$.fragment,t),g(De.$$.fragment,t),g(Ce.$$.fragment,t),g(xe.$$.fragment,t),g(Le.$$.fragment,t),g(Pe.$$.fragment,t),g(Oe.$$.fragment,t),sa=!0)},o(t){_(re.$$.fragment,t),_(se.$$.fragment,t),_(ne.$$.fragment,t),_(ce.$$.fragment,t),_(ie.$$.fragment,t),_(de.$$.fragment,t),_(me.$$.fragment,t),_(he.$$.fragment,t),_(ge.$$.fragment,t),_(ve.$$.fragment,t),_(ke.$$.fragment,t),_($e.$$.fragment,t),_(be.$$.fragment,t),_(Ee.$$.fragment,t),_(je.$$.fragment,t),_(Ae.$$.fragment,t),_(De.$$.fragment,t),_(Ce.$$.fragment,t),_(xe.$$.fragment,t),_(Le.$$.fragment,t),_(Pe.$$.fragment,t),_(Oe.$$.fragment,t),sa=!1},d(t){a(P),t&&a(St),t&&a(O),v(re),t&&a(Bt),t&&a(oe),t&&a(zt),t&&a(I),v(se),t&&a(Nt),t&&a(M),t&&a(Vt),t&&a(k),v(ne),v(ce),v(ie),v(de),t&&a(Wt),t&&a($),v(me),v(he),v(ge),v(ve),t&&a(Mt),t&&a(y),v(ke),v($e),v(be),v(Ee),t&&a(Gt),t&&a(E),t&&a(Rt),v(je,t),t&&a(Ht),t&&a(Y),t&&a(Ft),v(Ae,t),t&&a(Ut),t&&a(T),t&&a(Jt),v(De,t),t&&a(Kt),t&&a(Be),t&&a(Qt),v(Ce,t),t&&a(Xt),t&&a(z),v(xe),t&&a(Yt),t&&a(j),t&&a(Zt),t&&a(A),t&&a(ea),t&&a(ze),t&&a(ta),v(Le,t),t&&a(aa),t&&a(N),v(Pe),t&&a(ra),t&&a(C),t&&a(oa),v(Oe,t)}}}const Gs={local:"tracking",sections:[{local:"accelerate.tracking.TensorBoardTracker",title:"Integrated Trackers"},{local:"implementing-custom-trackers",title:"Implementing Custom Trackers"},{local:"when-a-wrapper-cannot-work",title:"When a wrapper cannot work"}],title:"Tracking"};function Rs(Wo){return Ws(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Ks extends Ss{constructor(P){super();Bs(this,P,Rs,Ms,zs,{})}}export{Ks as default,Gs as metadata};
