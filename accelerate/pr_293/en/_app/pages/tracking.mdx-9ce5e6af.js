import{S as us,i as ms,s as hs,e as s,k as i,w as m,t as r,M as fs,c as n,d as a,m as p,a as l,x as h,h as o,b as u,F as t,g as d,y as f,L as gs,q as g,o as _,B as v,v as _s}from"../chunks/vendor-19e06bd2.js";import{D as B}from"../chunks/Docstring-395e5a9c.js";import{C as Ne}from"../chunks/CodeBlock-9dd1fdfb.js";import{I as fa}from"../chunks/IconCopyLink-3c713d38.js";function vs(vo){let C,At,O,N,We,te,ga,Ve,_a,Dt,ae,va,Ae,ya,xt,L,W,Me,re,ka,Ge,ba,Ct,V,$a,Re,wa,Ea,Ot,b,oe,Ta,P,ja,He,Aa,Da,Fe,xa,Ca,Oa,M,se,La,ne,Pa,Ue,Ia,qa,Sa,G,le,za,ce,Ba,Je,Na,Wa,Lt,$,ie,Va,I,Ma,Ke,Ga,Ra,Qe,Ha,Fa,Ua,R,pe,Ja,de,Ka,Xe,Qa,Xa,Ya,H,ue,Za,me,er,Ye,tr,ar,Pt,y,he,rr,q,or,Ze,sr,nr,et,lr,cr,ir,tt,pr,dr,F,fe,ur,ge,mr,at,hr,fr,gr,U,_e,_r,ve,vr,rt,yr,kr,It,E,br,ot,$r,wr,st,Er,Tr,qt,ye,St,J,jr,nt,Ar,Dr,zt,ke,Bt,T,xr,De,Cr,Or,lt,Lr,Pr,Nt,be,Wt,xe,Ir,Vt,$e,Mt,S,K,ct,we,qr,it,Sr,Gt,j,zr,pt,Br,Nr,dt,Wr,Vr,Rt,A,Q,ut,Mr,Gr,mt,Rr,Hr,Fr,X,ht,Ur,Jr,ft,Kr,Qr,Xr,k,gt,Yr,Zr,_t,eo,to,vt,ao,ro,yt,oo,so,kt,no,lo,Ht,Ce,co,Ft,Ee,Ut,z,Y,bt,Te,io,$t,po,Jt,D,uo,wt,mo,ho,Et,fo,go,Kt,je,Qt;return te=new fa({}),re=new fa({}),oe=new B({props:{name:"class accelerate.tracking.TensorBoardTracker",anchor:"accelerate.tracking.TensorBoardTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L76",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run. Logs are then stored in <code>tensorboard/{run_name}</code>`,name:"run_name"}]}}),se=new B({props:{name:"log",anchor:"accelerate.tracking.TensorBoardTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L108",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.TensorBoardTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),le=new B({props:{name:"store_init_configuration",anchor:"accelerate.tracking.TensorBoardTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L95",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),ie=new B({props:{name:"class accelerate.tracking.WandBTracker",anchor:"accelerate.tracking.WandBTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L127",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run.`,name:"run_name"}]}}),pe=new B({props:{name:"log",anchor:"accelerate.tracking.WandBTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L158",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.WandBTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),ue=new B({props:{name:"store_init_configuration",anchor:"accelerate.tracking.WandBTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L146",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),he=new B({props:{name:"class accelerate.tracking.CometMLTracker",anchor:"accelerate.tracking.CometMLTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L172",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run.`,name:"run_name"}]}}),fe=new B({props:{name:"log",anchor:"accelerate.tracking.CometMLTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L205",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.CometMLTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),_e=new B({props:{name:"store_init_configuration",anchor:"accelerate.tracking.CometMLTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L193",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),ye=new Ne({props:{code:`from accelerate import Accelerate
from accelerate.utils import LoggerType

accelerator = Accelerate(log_with="all")  # For all available trackers in the environment
accelerator = Accelerate(log_with="wandb")
accelerator = Accelerate(log_with=["wandb", LoggerType.TENSORBOARD])`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerate
<span class="hljs-keyword">from</span> accelerate.utils <span class="hljs-keyword">import</span> LoggerType

accelerator = Accelerate(log_with=<span class="hljs-string">&quot;all&quot;</span>)  <span class="hljs-comment"># For all available trackers in the environment</span>
accelerator = Accelerate(log_with=<span class="hljs-string">&quot;wandb&quot;</span>)
accelerator = Accelerate(log_with=[<span class="hljs-string">&quot;wandb&quot;</span>, LoggerType.TENSORBOARD])`}}),ke=new Ne({props:{code:`hps = {"num_iterations": 5, "learning_rate": 1e-2}
accelerator.init_trackers("my_project", config=hps)`,highlighted:`hps = {<span class="hljs-string">&quot;num_iterations&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&quot;learning_rate&quot;</span>: <span class="hljs-number">1e-2</span>}
accelerator.init_trackers(<span class="hljs-string">&quot;my_project&quot;</span>, config=hps)`}}),be=new Ne({props:{code:'accelerator.log({"train_loss": 1.12, "valid_loss": 0.8}, step=1)',highlighted:'accelerator.log({<span class="hljs-string">&quot;train_loss&quot;</span>: <span class="hljs-number">1.12</span>, <span class="hljs-string">&quot;valid_loss&quot;</span>: <span class="hljs-number">0.8</span>}, step=<span class="hljs-number">1</span>)'}}),$e=new Ne({props:{code:`from accelerate import Accelerator

accelerator = Accelerator(log_with="all")
config = {
    "num_iterations": 5,
    "learning_rate": 1e-2,
    "loss_function": str(my_loss_function),
}

accelerator.init_trackers("example_project", config=config)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config["num_iterations"]:
    for step, batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        accelerator.backward(loss)
        my_optimizer.step()
        accelerator.log({"training_loss": loss}, step=step)`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator

accelerator = Accelerator(log_with=<span class="hljs-string">&quot;all&quot;</span>)
config = {
    <span class="hljs-string">&quot;num_iterations&quot;</span>: <span class="hljs-number">5</span>,
    <span class="hljs-string">&quot;learning_rate&quot;</span>: <span class="hljs-number">1e-2</span>,
    <span class="hljs-string">&quot;loss_function&quot;</span>: <span class="hljs-built_in">str</span>(my_loss_function),
}

accelerator.init_trackers(<span class="hljs-string">&quot;example_project&quot;</span>, config=config)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

<span class="hljs-keyword">for</span> iteration <span class="hljs-keyword">in</span> config[<span class="hljs-string">&quot;num_iterations&quot;</span>]:
    <span class="hljs-keyword">for</span> step, batch <span class="hljs-keyword">in</span> my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        accelerator.backward(loss)
        my_optimizer.step()
        accelerator.log({<span class="hljs-string">&quot;training_loss&quot;</span>: loss}, step=step)`}}),we=new fa({}),Ee=new Ne({props:{code:`from accelerate.tracking import GeneralTracker
from typing import Optional

import wandb


class WandBTracker(GeneralTracker):
    log_directory = None

    def __init__(self, run_name: str):
        self.run_name = run_name
        wandb.init(self.run_name)

    def store_init_configuration(self, values: dict):
        wandb.config(values)

    def log(self, values: dict, step: Optional[int] = None):
        wandb.log(values, step=step)`,highlighted:`<span class="hljs-keyword">from</span> accelerate.tracking <span class="hljs-keyword">import</span> GeneralTracker
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>

<span class="hljs-keyword">import</span> wandb


<span class="hljs-keyword">class</span> <span class="hljs-title class_">WandBTracker</span>(<span class="hljs-title class_ inherited__">GeneralTracker</span>):
    log_directory = <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, run_name: <span class="hljs-built_in">str</span></span>):
        self.run_name = run_name
        wandb.init(self.run_name)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">store_init_configuration</span>(<span class="hljs-params">self, values: <span class="hljs-built_in">dict</span></span>):
        wandb.config(values)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">self, values: <span class="hljs-built_in">dict</span>, step: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span></span>):
        wandb.log(values, step=step)`}}),Te=new fa({}),je=new Ne({props:{code:`from accelerate import Accelerator
+ import neptune.new as neptune

accelerator = Accelerator()
+ run = neptune.init(...)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config["num_iterations"]:
    for batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        total_loss += loss
        accelerator.backward(loss)
        my_optimizer.step()
+       if accelerator.is_main_process:
+           run["logs/training/batch/loss"].log(loss)`,highlighted:`from accelerate import Accelerator
<span class="hljs-addition">+ import neptune.new as neptune</span>

accelerator = Accelerator()
<span class="hljs-addition">+ run = neptune.init(...)</span>

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config[&quot;num_iterations&quot;]:
    for batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        total_loss += loss
        accelerator.backward(loss)
        my_optimizer.step()
<span class="hljs-addition">+       if accelerator.is_main_process:</span>
<span class="hljs-addition">+           run[&quot;logs/training/batch/loss&quot;].log(loss)</span>`}}),{c(){C=s("meta"),At=i(),O=s("h1"),N=s("a"),We=s("span"),m(te.$$.fragment),ga=i(),Ve=s("span"),_a=r("Tracking"),Dt=i(),ae=s("p"),va=r(`There are a large number of experiment tracking API\u2019s available, however getting them all to work with in a multi-processing environment can oftentimes be complex.
Accelerate provides a general tracking API that can be used to log useful items during your script through `),Ae=s("a"),ya=r("log()"),xt=i(),L=s("h2"),W=s("a"),Me=s("span"),m(re.$$.fragment),ka=i(),Ge=s("span"),ba=r("Integrated Trackers"),Ct=i(),V=s("p"),$a=r("Currently "),Re=s("code"),wa=r("Accelerate"),Ea=r(" supports three trackers out-of-the-box:"),Ot=i(),b=s("div"),m(oe.$$.fragment),Ta=i(),P=s("p"),ja=r("A "),He=s("code"),Aa=r("Tracker"),Da=r(" class that supports "),Fe=s("code"),xa=r("tensorboard"),Ca=r(". Should be initialized at the start of your script."),Oa=i(),M=s("div"),m(se.$$.fragment),La=i(),ne=s("p"),Pa=r("Logs "),Ue=s("code"),Ia=r("values"),qa=r(" to the current run."),Sa=i(),G=s("div"),m(le.$$.fragment),za=i(),ce=s("p"),Ba=r("Logs "),Je=s("code"),Na=r("values"),Wa=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Lt=i(),$=s("div"),m(ie.$$.fragment),Va=i(),I=s("p"),Ma=r("A "),Ke=s("code"),Ga=r("Tracker"),Ra=r(" class that supports "),Qe=s("code"),Ha=r("wandb"),Fa=r(". Should be initialized at the start of your script."),Ua=i(),R=s("div"),m(pe.$$.fragment),Ja=i(),de=s("p"),Ka=r("Logs "),Xe=s("code"),Qa=r("values"),Xa=r(" to the current run."),Ya=i(),H=s("div"),m(ue.$$.fragment),Za=i(),me=s("p"),er=r("Logs "),Ye=s("code"),tr=r("values"),ar=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Pt=i(),y=s("div"),m(he.$$.fragment),rr=i(),q=s("p"),or=r("A "),Ze=s("code"),sr=r("Tracker"),nr=r(" class that supports "),et=s("code"),lr=r("comet_ml"),cr=r(". Should be initialized at the start of your script."),ir=i(),tt=s("p"),pr=r("API keys must be stored in a Comet config file."),dr=i(),F=s("div"),m(fe.$$.fragment),ur=i(),ge=s("p"),mr=r("Logs "),at=s("code"),hr=r("values"),fr=r(" to the current run."),gr=i(),U=s("div"),m(_e.$$.fragment),_r=i(),ve=s("p"),vr=r("Logs "),rt=s("code"),yr=r("values"),kr=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),It=i(),E=s("p"),br=r("To use any of them, pass in the selected type(s) to the "),ot=s("code"),$r=r("log_with"),wr=r(" parameter in "),st=s("code"),Er=r("__init__"),Tr=r(":"),qt=i(),m(ye.$$.fragment),St=i(),J=s("p"),jr=r("At the start of your experiment "),nt=s("code"),Ar=r("init_tracker"),Dr=r(" should be used to setup your project, and potentially add any experiment hyperparameters to be logged:"),zt=i(),m(ke.$$.fragment),Bt=i(),T=s("p"),xr=r("When you are ready to log any data, "),De=s("a"),Cr=r("log()"),Or=r(` should be used.
A `),lt=s("code"),Lr=r("step"),Pr=r(" can also be passed in to correlate the data with a particular step in the training loop."),Nt=i(),m(be.$$.fragment),Wt=i(),xe=s("p"),Ir=r("A full example is below:"),Vt=i(),m($e.$$.fragment),Mt=i(),S=s("h2"),K=s("a"),ct=s("span"),m(we.$$.fragment),qr=i(),it=s("span"),Sr=r("Implementing Custom Trackers"),Gt=i(),j=s("p"),zr=r("To implement a new tracker to be used in "),pt=s("code"),Br=r("Accelerator"),Nr=r(", a new one can be made through implementing the "),dt=s("code"),Wr=r("~GeneralTracker"),Vr=r(` class.
Every tracker must implement three functions:`),Rt=i(),A=s("ul"),Q=s("li"),ut=s("code"),Mr=r("__init__"),Gr=r(": Should store a "),mt=s("code"),Rr=r("run_name"),Hr=r(" and initialize the tracker API of the integrated library"),Fr=i(),X=s("li"),ht=s("code"),Ur=r("store_init_configuration"),Jr=r(": Should take in a "),ft=s("code"),Kr=r("values"),Qr=r(" dictionary and store them as a one-time experiment configuration"),Xr=i(),k=s("li"),gt=s("code"),Yr=r("log"),Zr=r(": Should take in a "),_t=s("code"),eo=r("values"),to=r(" dictionary and a "),vt=s("code"),ao=r("step"),ro=r(`, and should log them to the run
As well as contain a `),yt=s("code"),oo=r("log_directory"),so=r(" attribute. If the integrated library does not store anything locally, should be set to "),kt=s("code"),no=r("None"),lo=r("."),Ht=i(),Ce=s("p"),co=r("A brief example can be seen below with an integration with Weights and Biases, containing only the relevent information:"),Ft=i(),m(Ee.$$.fragment),Ut=i(),z=s("h2"),Y=s("a"),bt=s("span"),m(Te.$$.fragment),io=i(),$t=s("span"),po=r("When a wrapper cannot work"),Jt=i(),D=s("p"),uo=r("If a library has an API that does not follow a strict "),wt=s("code"),mo=r(".log"),ho=r(" with an overall dictionary such as Neptune.AI, logging can be done manually under an "),Et=s("code"),fo=r("if accelerator.is_main_process"),go=r(" statement:"),Kt=i(),m(je.$$.fragment),this.h()},l(e){const c=fs('[data-svelte="svelte-1phssyn"]',document.head);C=n(c,"META",{name:!0,content:!0}),c.forEach(a),At=p(e),O=n(e,"H1",{class:!0});var Xt=l(O);N=n(Xt,"A",{id:!0,class:!0,href:!0});var yo=l(N);We=n(yo,"SPAN",{});var ko=l(We);h(te.$$.fragment,ko),ko.forEach(a),yo.forEach(a),ga=p(Xt),Ve=n(Xt,"SPAN",{});var bo=l(Ve);_a=o(bo,"Tracking"),bo.forEach(a),Xt.forEach(a),Dt=p(e),ae=n(e,"P",{});var _o=l(ae);va=o(_o,`There are a large number of experiment tracking API\u2019s available, however getting them all to work with in a multi-processing environment can oftentimes be complex.
Accelerate provides a general tracking API that can be used to log useful items during your script through `),Ae=n(_o,"A",{href:!0});var $o=l(Ae);ya=o($o,"log()"),$o.forEach(a),_o.forEach(a),xt=p(e),L=n(e,"H2",{class:!0});var Yt=l(L);W=n(Yt,"A",{id:!0,class:!0,href:!0});var wo=l(W);Me=n(wo,"SPAN",{});var Eo=l(Me);h(re.$$.fragment,Eo),Eo.forEach(a),wo.forEach(a),ka=p(Yt),Ge=n(Yt,"SPAN",{});var To=l(Ge);ba=o(To,"Integrated Trackers"),To.forEach(a),Yt.forEach(a),Ct=p(e),V=n(e,"P",{});var Zt=l(V);$a=o(Zt,"Currently "),Re=n(Zt,"CODE",{});var jo=l(Re);wa=o(jo,"Accelerate"),jo.forEach(a),Ea=o(Zt," supports three trackers out-of-the-box:"),Zt.forEach(a),Ot=p(e),b=n(e,"DIV",{class:!0});var Z=l(b);h(oe.$$.fragment,Z),Ta=p(Z),P=n(Z,"P",{});var Oe=l(P);ja=o(Oe,"A "),He=n(Oe,"CODE",{});var Ao=l(He);Aa=o(Ao,"Tracker"),Ao.forEach(a),Da=o(Oe," class that supports "),Fe=n(Oe,"CODE",{});var Do=l(Fe);xa=o(Do,"tensorboard"),Do.forEach(a),Ca=o(Oe,". Should be initialized at the start of your script."),Oe.forEach(a),Oa=p(Z),M=n(Z,"DIV",{class:!0});var ea=l(M);h(se.$$.fragment,ea),La=p(ea),ne=n(ea,"P",{});var ta=l(ne);Pa=o(ta,"Logs "),Ue=n(ta,"CODE",{});var xo=l(Ue);Ia=o(xo,"values"),xo.forEach(a),qa=o(ta," to the current run."),ta.forEach(a),ea.forEach(a),Sa=p(Z),G=n(Z,"DIV",{class:!0});var aa=l(G);h(le.$$.fragment,aa),za=p(aa),ce=n(aa,"P",{});var ra=l(ce);Ba=o(ra,"Logs "),Je=n(ra,"CODE",{});var Co=l(Je);Na=o(Co,"values"),Co.forEach(a),Wa=o(ra," as hyperparameters for the run. Should be run at the beginning of your experiment."),ra.forEach(a),aa.forEach(a),Z.forEach(a),Lt=p(e),$=n(e,"DIV",{class:!0});var ee=l($);h(ie.$$.fragment,ee),Va=p(ee),I=n(ee,"P",{});var Le=l(I);Ma=o(Le,"A "),Ke=n(Le,"CODE",{});var Oo=l(Ke);Ga=o(Oo,"Tracker"),Oo.forEach(a),Ra=o(Le," class that supports "),Qe=n(Le,"CODE",{});var Lo=l(Qe);Ha=o(Lo,"wandb"),Lo.forEach(a),Fa=o(Le,". Should be initialized at the start of your script."),Le.forEach(a),Ua=p(ee),R=n(ee,"DIV",{class:!0});var oa=l(R);h(pe.$$.fragment,oa),Ja=p(oa),de=n(oa,"P",{});var sa=l(de);Ka=o(sa,"Logs "),Xe=n(sa,"CODE",{});var Po=l(Xe);Qa=o(Po,"values"),Po.forEach(a),Xa=o(sa," to the current run."),sa.forEach(a),oa.forEach(a),Ya=p(ee),H=n(ee,"DIV",{class:!0});var na=l(H);h(ue.$$.fragment,na),Za=p(na),me=n(na,"P",{});var la=l(me);er=o(la,"Logs "),Ye=n(la,"CODE",{});var Io=l(Ye);tr=o(Io,"values"),Io.forEach(a),ar=o(la," as hyperparameters for the run. Should be run at the beginning of your experiment."),la.forEach(a),na.forEach(a),ee.forEach(a),Pt=p(e),y=n(e,"DIV",{class:!0});var x=l(y);h(he.$$.fragment,x),rr=p(x),q=n(x,"P",{});var Pe=l(q);or=o(Pe,"A "),Ze=n(Pe,"CODE",{});var qo=l(Ze);sr=o(qo,"Tracker"),qo.forEach(a),nr=o(Pe," class that supports "),et=n(Pe,"CODE",{});var So=l(et);lr=o(So,"comet_ml"),So.forEach(a),cr=o(Pe,". Should be initialized at the start of your script."),Pe.forEach(a),ir=p(x),tt=n(x,"P",{});var zo=l(tt);pr=o(zo,"API keys must be stored in a Comet config file."),zo.forEach(a),dr=p(x),F=n(x,"DIV",{class:!0});var ca=l(F);h(fe.$$.fragment,ca),ur=p(ca),ge=n(ca,"P",{});var ia=l(ge);mr=o(ia,"Logs "),at=n(ia,"CODE",{});var Bo=l(at);hr=o(Bo,"values"),Bo.forEach(a),fr=o(ia," to the current run."),ia.forEach(a),ca.forEach(a),gr=p(x),U=n(x,"DIV",{class:!0});var pa=l(U);h(_e.$$.fragment,pa),_r=p(pa),ve=n(pa,"P",{});var da=l(ve);vr=o(da,"Logs "),rt=n(da,"CODE",{});var No=l(rt);yr=o(No,"values"),No.forEach(a),kr=o(da," as hyperparameters for the run. Should be run at the beginning of your experiment."),da.forEach(a),pa.forEach(a),x.forEach(a),It=p(e),E=n(e,"P",{});var Ie=l(E);br=o(Ie,"To use any of them, pass in the selected type(s) to the "),ot=n(Ie,"CODE",{});var Wo=l(ot);$r=o(Wo,"log_with"),Wo.forEach(a),wr=o(Ie," parameter in "),st=n(Ie,"CODE",{});var Vo=l(st);Er=o(Vo,"__init__"),Vo.forEach(a),Tr=o(Ie,":"),Ie.forEach(a),qt=p(e),h(ye.$$.fragment,e),St=p(e),J=n(e,"P",{});var ua=l(J);jr=o(ua,"At the start of your experiment "),nt=n(ua,"CODE",{});var Mo=l(nt);Ar=o(Mo,"init_tracker"),Mo.forEach(a),Dr=o(ua," should be used to setup your project, and potentially add any experiment hyperparameters to be logged:"),ua.forEach(a),zt=p(e),h(ke.$$.fragment,e),Bt=p(e),T=n(e,"P",{});var qe=l(T);xr=o(qe,"When you are ready to log any data, "),De=n(qe,"A",{href:!0});var Go=l(De);Cr=o(Go,"log()"),Go.forEach(a),Or=o(qe,` should be used.
A `),lt=n(qe,"CODE",{});var Ro=l(lt);Lr=o(Ro,"step"),Ro.forEach(a),Pr=o(qe," can also be passed in to correlate the data with a particular step in the training loop."),qe.forEach(a),Nt=p(e),h(be.$$.fragment,e),Wt=p(e),xe=n(e,"P",{});var Ho=l(xe);Ir=o(Ho,"A full example is below:"),Ho.forEach(a),Vt=p(e),h($e.$$.fragment,e),Mt=p(e),S=n(e,"H2",{class:!0});var ma=l(S);K=n(ma,"A",{id:!0,class:!0,href:!0});var Fo=l(K);ct=n(Fo,"SPAN",{});var Uo=l(ct);h(we.$$.fragment,Uo),Uo.forEach(a),Fo.forEach(a),qr=p(ma),it=n(ma,"SPAN",{});var Jo=l(it);Sr=o(Jo,"Implementing Custom Trackers"),Jo.forEach(a),ma.forEach(a),Gt=p(e),j=n(e,"P",{});var Se=l(j);zr=o(Se,"To implement a new tracker to be used in "),pt=n(Se,"CODE",{});var Ko=l(pt);Br=o(Ko,"Accelerator"),Ko.forEach(a),Nr=o(Se,", a new one can be made through implementing the "),dt=n(Se,"CODE",{});var Qo=l(dt);Wr=o(Qo,"~GeneralTracker"),Qo.forEach(a),Vr=o(Se,` class.
Every tracker must implement three functions:`),Se.forEach(a),Rt=p(e),A=n(e,"UL",{});var ze=l(A);Q=n(ze,"LI",{});var Tt=l(Q);ut=n(Tt,"CODE",{});var Xo=l(ut);Mr=o(Xo,"__init__"),Xo.forEach(a),Gr=o(Tt,": Should store a "),mt=n(Tt,"CODE",{});var Yo=l(mt);Rr=o(Yo,"run_name"),Yo.forEach(a),Hr=o(Tt," and initialize the tracker API of the integrated library"),Tt.forEach(a),Fr=p(ze),X=n(ze,"LI",{});var jt=l(X);ht=n(jt,"CODE",{});var Zo=l(ht);Ur=o(Zo,"store_init_configuration"),Zo.forEach(a),Jr=o(jt,": Should take in a "),ft=n(jt,"CODE",{});var es=l(ft);Kr=o(es,"values"),es.forEach(a),Qr=o(jt," dictionary and store them as a one-time experiment configuration"),jt.forEach(a),Xr=p(ze),k=n(ze,"LI",{});var w=l(k);gt=n(w,"CODE",{});var ts=l(gt);Yr=o(ts,"log"),ts.forEach(a),Zr=o(w,": Should take in a "),_t=n(w,"CODE",{});var as=l(_t);eo=o(as,"values"),as.forEach(a),to=o(w," dictionary and a "),vt=n(w,"CODE",{});var rs=l(vt);ao=o(rs,"step"),rs.forEach(a),ro=o(w,`, and should log them to the run
As well as contain a `),yt=n(w,"CODE",{});var os=l(yt);oo=o(os,"log_directory"),os.forEach(a),so=o(w," attribute. If the integrated library does not store anything locally, should be set to "),kt=n(w,"CODE",{});var ss=l(kt);no=o(ss,"None"),ss.forEach(a),lo=o(w,"."),w.forEach(a),ze.forEach(a),Ht=p(e),Ce=n(e,"P",{});var ns=l(Ce);co=o(ns,"A brief example can be seen below with an integration with Weights and Biases, containing only the relevent information:"),ns.forEach(a),Ft=p(e),h(Ee.$$.fragment,e),Ut=p(e),z=n(e,"H2",{class:!0});var ha=l(z);Y=n(ha,"A",{id:!0,class:!0,href:!0});var ls=l(Y);bt=n(ls,"SPAN",{});var cs=l(bt);h(Te.$$.fragment,cs),cs.forEach(a),ls.forEach(a),io=p(ha),$t=n(ha,"SPAN",{});var is=l($t);po=o(is,"When a wrapper cannot work"),is.forEach(a),ha.forEach(a),Jt=p(e),D=n(e,"P",{});var Be=l(D);uo=o(Be,"If a library has an API that does not follow a strict "),wt=n(Be,"CODE",{});var ps=l(wt);mo=o(ps,".log"),ps.forEach(a),ho=o(Be," with an overall dictionary such as Neptune.AI, logging can be done manually under an "),Et=n(Be,"CODE",{});var ds=l(Et);fo=o(ds,"if accelerator.is_main_process"),ds.forEach(a),go=o(Be," statement:"),Be.forEach(a),Kt=p(e),h(je.$$.fragment,e),this.h()},h(){u(C,"name","hf:doc:metadata"),u(C,"content",JSON.stringify(ys)),u(N,"id","tracking"),u(N,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(N,"href","#tracking"),u(O,"class","relative group"),u(Ae,"href","/docs/accelerate/pr_293/en/accelerator#accelerate.Accelerator.log"),u(W,"id","accelerate.tracking.TensorBoardTracker"),u(W,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(W,"href","#accelerate.tracking.TensorBoardTracker"),u(L,"class","relative group"),u(M,"class","docstring"),u(G,"class","docstring"),u(b,"class","docstring"),u(R,"class","docstring"),u(H,"class","docstring"),u($,"class","docstring"),u(F,"class","docstring"),u(U,"class","docstring"),u(y,"class","docstring"),u(De,"href","/docs/accelerate/pr_293/en/accelerator#accelerate.Accelerator.log"),u(K,"id","implementing-custom-trackers"),u(K,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(K,"href","#implementing-custom-trackers"),u(S,"class","relative group"),u(Y,"id","when-a-wrapper-cannot-work"),u(Y,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Y,"href","#when-a-wrapper-cannot-work"),u(z,"class","relative group")},m(e,c){t(document.head,C),d(e,At,c),d(e,O,c),t(O,N),t(N,We),f(te,We,null),t(O,ga),t(O,Ve),t(Ve,_a),d(e,Dt,c),d(e,ae,c),t(ae,va),t(ae,Ae),t(Ae,ya),d(e,xt,c),d(e,L,c),t(L,W),t(W,Me),f(re,Me,null),t(L,ka),t(L,Ge),t(Ge,ba),d(e,Ct,c),d(e,V,c),t(V,$a),t(V,Re),t(Re,wa),t(V,Ea),d(e,Ot,c),d(e,b,c),f(oe,b,null),t(b,Ta),t(b,P),t(P,ja),t(P,He),t(He,Aa),t(P,Da),t(P,Fe),t(Fe,xa),t(P,Ca),t(b,Oa),t(b,M),f(se,M,null),t(M,La),t(M,ne),t(ne,Pa),t(ne,Ue),t(Ue,Ia),t(ne,qa),t(b,Sa),t(b,G),f(le,G,null),t(G,za),t(G,ce),t(ce,Ba),t(ce,Je),t(Je,Na),t(ce,Wa),d(e,Lt,c),d(e,$,c),f(ie,$,null),t($,Va),t($,I),t(I,Ma),t(I,Ke),t(Ke,Ga),t(I,Ra),t(I,Qe),t(Qe,Ha),t(I,Fa),t($,Ua),t($,R),f(pe,R,null),t(R,Ja),t(R,de),t(de,Ka),t(de,Xe),t(Xe,Qa),t(de,Xa),t($,Ya),t($,H),f(ue,H,null),t(H,Za),t(H,me),t(me,er),t(me,Ye),t(Ye,tr),t(me,ar),d(e,Pt,c),d(e,y,c),f(he,y,null),t(y,rr),t(y,q),t(q,or),t(q,Ze),t(Ze,sr),t(q,nr),t(q,et),t(et,lr),t(q,cr),t(y,ir),t(y,tt),t(tt,pr),t(y,dr),t(y,F),f(fe,F,null),t(F,ur),t(F,ge),t(ge,mr),t(ge,at),t(at,hr),t(ge,fr),t(y,gr),t(y,U),f(_e,U,null),t(U,_r),t(U,ve),t(ve,vr),t(ve,rt),t(rt,yr),t(ve,kr),d(e,It,c),d(e,E,c),t(E,br),t(E,ot),t(ot,$r),t(E,wr),t(E,st),t(st,Er),t(E,Tr),d(e,qt,c),f(ye,e,c),d(e,St,c),d(e,J,c),t(J,jr),t(J,nt),t(nt,Ar),t(J,Dr),d(e,zt,c),f(ke,e,c),d(e,Bt,c),d(e,T,c),t(T,xr),t(T,De),t(De,Cr),t(T,Or),t(T,lt),t(lt,Lr),t(T,Pr),d(e,Nt,c),f(be,e,c),d(e,Wt,c),d(e,xe,c),t(xe,Ir),d(e,Vt,c),f($e,e,c),d(e,Mt,c),d(e,S,c),t(S,K),t(K,ct),f(we,ct,null),t(S,qr),t(S,it),t(it,Sr),d(e,Gt,c),d(e,j,c),t(j,zr),t(j,pt),t(pt,Br),t(j,Nr),t(j,dt),t(dt,Wr),t(j,Vr),d(e,Rt,c),d(e,A,c),t(A,Q),t(Q,ut),t(ut,Mr),t(Q,Gr),t(Q,mt),t(mt,Rr),t(Q,Hr),t(A,Fr),t(A,X),t(X,ht),t(ht,Ur),t(X,Jr),t(X,ft),t(ft,Kr),t(X,Qr),t(A,Xr),t(A,k),t(k,gt),t(gt,Yr),t(k,Zr),t(k,_t),t(_t,eo),t(k,to),t(k,vt),t(vt,ao),t(k,ro),t(k,yt),t(yt,oo),t(k,so),t(k,kt),t(kt,no),t(k,lo),d(e,Ht,c),d(e,Ce,c),t(Ce,co),d(e,Ft,c),f(Ee,e,c),d(e,Ut,c),d(e,z,c),t(z,Y),t(Y,bt),f(Te,bt,null),t(z,io),t(z,$t),t($t,po),d(e,Jt,c),d(e,D,c),t(D,uo),t(D,wt),t(wt,mo),t(D,ho),t(D,Et),t(Et,fo),t(D,go),d(e,Kt,c),f(je,e,c),Qt=!0},p:gs,i(e){Qt||(g(te.$$.fragment,e),g(re.$$.fragment,e),g(oe.$$.fragment,e),g(se.$$.fragment,e),g(le.$$.fragment,e),g(ie.$$.fragment,e),g(pe.$$.fragment,e),g(ue.$$.fragment,e),g(he.$$.fragment,e),g(fe.$$.fragment,e),g(_e.$$.fragment,e),g(ye.$$.fragment,e),g(ke.$$.fragment,e),g(be.$$.fragment,e),g($e.$$.fragment,e),g(we.$$.fragment,e),g(Ee.$$.fragment,e),g(Te.$$.fragment,e),g(je.$$.fragment,e),Qt=!0)},o(e){_(te.$$.fragment,e),_(re.$$.fragment,e),_(oe.$$.fragment,e),_(se.$$.fragment,e),_(le.$$.fragment,e),_(ie.$$.fragment,e),_(pe.$$.fragment,e),_(ue.$$.fragment,e),_(he.$$.fragment,e),_(fe.$$.fragment,e),_(_e.$$.fragment,e),_(ye.$$.fragment,e),_(ke.$$.fragment,e),_(be.$$.fragment,e),_($e.$$.fragment,e),_(we.$$.fragment,e),_(Ee.$$.fragment,e),_(Te.$$.fragment,e),_(je.$$.fragment,e),Qt=!1},d(e){a(C),e&&a(At),e&&a(O),v(te),e&&a(Dt),e&&a(ae),e&&a(xt),e&&a(L),v(re),e&&a(Ct),e&&a(V),e&&a(Ot),e&&a(b),v(oe),v(se),v(le),e&&a(Lt),e&&a($),v(ie),v(pe),v(ue),e&&a(Pt),e&&a(y),v(he),v(fe),v(_e),e&&a(It),e&&a(E),e&&a(qt),v(ye,e),e&&a(St),e&&a(J),e&&a(zt),v(ke,e),e&&a(Bt),e&&a(T),e&&a(Nt),v(be,e),e&&a(Wt),e&&a(xe),e&&a(Vt),v($e,e),e&&a(Mt),e&&a(S),v(we),e&&a(Gt),e&&a(j),e&&a(Rt),e&&a(A),e&&a(Ht),e&&a(Ce),e&&a(Ft),v(Ee,e),e&&a(Ut),e&&a(z),v(Te),e&&a(Jt),e&&a(D),e&&a(Kt),v(je,e)}}}const ys={local:"tracking",sections:[{local:"accelerate.tracking.TensorBoardTracker",title:"Integrated Trackers"},{local:"implementing-custom-trackers",title:"Implementing Custom Trackers"},{local:"when-a-wrapper-cannot-work",title:"When a wrapper cannot work"}],title:"Tracking"};function ks(vo){return _s(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Ts extends us{constructor(C){super();ms(this,C,ks,vs,hs,{})}}export{Ts as default,ys as metadata};
