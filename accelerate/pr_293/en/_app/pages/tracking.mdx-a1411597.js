import{S as Os,i as Is,s as Ps,e as s,k as i,w as m,t as r,M as qs,c as n,d as a,m as p,a as l,x as h,h as o,b as u,F as t,g as d,y as f,L as Ss,q as g,o as _,B as v,v as Bs}from"../chunks/vendor-19e06bd2.js";import{D as N}from"../chunks/Docstring-395e5a9c.js";import{C as Ve}from"../chunks/CodeBlock-9dd1fdfb.js";import{I as Ea}from"../chunks/IconCopyLink-3c713d38.js";function zs(Oo){let L,qt,O,W,Me,ae,Ta,Ge,ja,St,re,Aa,De,Da,Bt,I,V,Re,oe,Ca,He,xa,zt,M,La,Fe,Oa,Ia,Nt,E,Ue,Je,Pa,qa,Ke,Qe,Sa,Ba,Xe,Ye,za,Wt,T,Na,Ze,Wa,Va,et,Ma,Ga,Vt,se,Mt,G,Ra,tt,Ha,Fa,Gt,ne,Rt,j,Ua,Ce,Ja,Ka,at,Qa,Xa,Ht,le,Ft,xe,Ya,Ut,ce,Jt,b,ie,Za,P,er,rt,tr,ar,ot,rr,or,sr,R,pe,nr,de,lr,st,cr,ir,pr,H,ue,dr,me,ur,nt,mr,hr,Kt,$,he,fr,q,gr,lt,_r,vr,ct,yr,kr,br,F,fe,$r,ge,wr,it,Er,Tr,jr,U,_e,Ar,ve,Dr,pt,Cr,xr,Qt,y,ye,Lr,S,Or,dt,Ir,Pr,ut,qr,Sr,Br,mt,zr,Nr,J,ke,Wr,be,Vr,ht,Mr,Gr,Rr,K,$e,Hr,we,Fr,ft,Ur,Jr,Xt,B,Q,gt,Ee,Kr,_t,Qr,Yt,A,Xr,vt,Yr,Zr,yt,eo,to,Zt,D,X,kt,ao,ro,bt,oo,so,no,Y,$t,lo,co,wt,io,po,uo,k,Et,mo,ho,Tt,fo,go,jt,_o,vo,At,yo,ko,Dt,bo,$o,ea,Le,wo,ta,Te,aa,z,Z,Ct,je,Eo,xt,To,ra,C,jo,Lt,Ao,Do,Ot,Co,xo,oa,Ae,sa;return ae=new Ea({}),oe=new Ea({}),se=new Ve({props:{code:`from accelerate import Accelerate
from accelerate.utils import LoggerType

accelerator = Accelerate(log_with="all")  # For all available trackers in the environment
accelerator = Accelerate(log_with="wandb")
accelerator = Accelerate(log_with=["wandb", LoggerType.TENSORBOARD])`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerate
<span class="hljs-keyword">from</span> accelerate.utils <span class="hljs-keyword">import</span> LoggerType

accelerator = Accelerate(log_with=<span class="hljs-string">&quot;all&quot;</span>)  <span class="hljs-comment"># For all available trackers in the environment</span>
accelerator = Accelerate(log_with=<span class="hljs-string">&quot;wandb&quot;</span>)
accelerator = Accelerate(log_with=[<span class="hljs-string">&quot;wandb&quot;</span>, LoggerType.TENSORBOARD])`}}),ne=new Ve({props:{code:`hps = {"num_iterations": 5, "learning_rate": 1e-2}
accelerator.init_trackers("my_project", config=hps)`,highlighted:`hps = {<span class="hljs-string">&quot;num_iterations&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&quot;learning_rate&quot;</span>: <span class="hljs-number">1e-2</span>}
accelerator.init_trackers(<span class="hljs-string">&quot;my_project&quot;</span>, config=hps)`}}),le=new Ve({props:{code:'accelerator.log({"train_loss": 1.12, "valid_loss": 0.8}, step=1)',highlighted:'accelerator.log({<span class="hljs-string">&quot;train_loss&quot;</span>: <span class="hljs-number">1.12</span>, <span class="hljs-string">&quot;valid_loss&quot;</span>: <span class="hljs-number">0.8</span>}, step=<span class="hljs-number">1</span>)'}}),ce=new Ve({props:{code:`from accelerate import Accelerator

accelerator = Accelerator(log_with="all")
config = {
    "num_iterations": 5,
    "learning_rate": 1e-2,
    "loss_function": str(my_loss_function),
}

accelerator.init_trackers("example_project", config=config)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config["num_iterations"]:
    for step, batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        accelerator.backward(loss)
        my_optimizer.step()
        accelerator.log({"training_loss": loss}, step=step)`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator

accelerator = Accelerator(log_with=<span class="hljs-string">&quot;all&quot;</span>)
config = {
    <span class="hljs-string">&quot;num_iterations&quot;</span>: <span class="hljs-number">5</span>,
    <span class="hljs-string">&quot;learning_rate&quot;</span>: <span class="hljs-number">1e-2</span>,
    <span class="hljs-string">&quot;loss_function&quot;</span>: <span class="hljs-built_in">str</span>(my_loss_function),
}

accelerator.init_trackers(<span class="hljs-string">&quot;example_project&quot;</span>, config=config)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

<span class="hljs-keyword">for</span> iteration <span class="hljs-keyword">in</span> config[<span class="hljs-string">&quot;num_iterations&quot;</span>]:
    <span class="hljs-keyword">for</span> step, batch <span class="hljs-keyword">in</span> my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        accelerator.backward(loss)
        my_optimizer.step()
        accelerator.log({<span class="hljs-string">&quot;training_loss&quot;</span>: loss}, step=step)`}}),ie=new N({props:{name:"class accelerate.tracking.TensorBoardTracker",anchor:"accelerate.tracking.TensorBoardTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L68",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run. Logs are then stored in <code>tensorboard/{run_name}</code>`,name:"run_name"}]}}),pe=new N({props:{name:"log",anchor:"accelerate.tracking.TensorBoardTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L100",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.TensorBoardTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),ue=new N({props:{name:"store_init_configuration",anchor:"accelerate.tracking.TensorBoardTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L87",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),he=new N({props:{name:"class accelerate.tracking.WandBTracker",anchor:"accelerate.tracking.WandBTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L119",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run.`,name:"run_name"}]}}),fe=new N({props:{name:"log",anchor:"accelerate.tracking.WandBTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L150",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.WandBTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),_e=new N({props:{name:"store_init_configuration",anchor:"accelerate.tracking.WandBTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L138",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),ye=new N({props:{name:"class accelerate.tracking.CometMLTracker",anchor:"accelerate.tracking.CometMLTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L164",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run.`,name:"run_name"}]}}),ke=new N({props:{name:"log",anchor:"accelerate.tracking.CometMLTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L197",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.CometMLTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),$e=new N({props:{name:"store_init_configuration",anchor:"accelerate.tracking.CometMLTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L185",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),Ee=new Ea({}),Te=new Ve({props:{code:`from accelerate.tracking import GeneralTracker
from typing import Optional

import wandb


class WandBTracker(GeneralTracker):
    log_directory = None

    def __init__(self, run_name: str):
        self.run_name = run_name
        wandb.init(self.run_name)

    def store_init_configuration(self, values: dict):
        wandb.config(values)

    def log(self, values: dict, step: Optional[int] = None):
        wandb.log(values, step=step)`,highlighted:`<span class="hljs-keyword">from</span> accelerate.tracking <span class="hljs-keyword">import</span> GeneralTracker
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>

<span class="hljs-keyword">import</span> wandb


<span class="hljs-keyword">class</span> <span class="hljs-title class_">WandBTracker</span>(<span class="hljs-title class_ inherited__">GeneralTracker</span>):
    log_directory = <span class="hljs-literal">None</span>

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, run_name: <span class="hljs-built_in">str</span></span>):
        self.run_name = run_name
        wandb.init(self.run_name)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">store_init_configuration</span>(<span class="hljs-params">self, values: <span class="hljs-built_in">dict</span></span>):
        wandb.config(values)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">self, values: <span class="hljs-built_in">dict</span>, step: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span></span>):
        wandb.log(values, step=step)`}}),je=new Ea({}),Ae=new Ve({props:{code:`from accelerate import Accelerator
+ import neptune.new as neptune

accelerator = Accelerator()
+ run = neptune.init(...)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config["num_iterations"]:
    for batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        total_loss += loss
        accelerator.backward(loss)
        my_optimizer.step()
+       if accelerator.is_main_process:
+         run["logs/training/batch/loss"].log(loss)`,highlighted:`from accelerate import Accelerator
<span class="hljs-addition">+ import neptune.new as neptune</span>

accelerator = Accelerator()
<span class="hljs-addition">+ run = neptune.init(...)</span>

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config[&quot;num_iterations&quot;]:
    for batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        total_loss += loss
        accelerator.backward(loss)
        my_optimizer.step()
<span class="hljs-addition">+       if accelerator.is_main_process:</span>
<span class="hljs-addition">+         run[&quot;logs/training/batch/loss&quot;].log(loss)</span>`}}),{c(){L=s("meta"),qt=i(),O=s("h1"),W=s("a"),Me=s("span"),m(ae.$$.fragment),Ta=i(),Ge=s("span"),ja=r("Tracking"),St=i(),re=s("p"),Aa=r(`There are a large number of experiment tracking API\u2019s available, however getting them all to work with in a multi-processing environment can oftentimes be complex.
Accelerate provides a general tracking API that can be used to log useful items during your script through `),De=s("a"),Da=r("log()"),Bt=i(),I=s("h2"),V=s("a"),Re=s("span"),m(oe.$$.fragment),Ca=i(),He=s("span"),xa=r("Integrated Trackers"),zt=i(),M=s("p"),La=r("Currently "),Fe=s("code"),Oa=r("Accelerate"),Ia=r(" supports three trackers out-of-the-box:"),Nt=i(),E=s("ul"),Ue=s("li"),Je=s("code"),Pa=r("~TensorBoardTracker"),qa=i(),Ke=s("li"),Qe=s("code"),Sa=r("~WandBTracker"),Ba=i(),Xe=s("li"),Ye=s("code"),za=r("~CometMLTracker"),Wt=i(),T=s("p"),Na=r("To use any of them, pass in the selected type(s) to the "),Ze=s("code"),Wa=r("log_with"),Va=r(" parameter in "),et=s("code"),Ma=r("__init__"),Ga=r(":"),Vt=i(),m(se.$$.fragment),Mt=i(),G=s("p"),Ra=r("At the start of your experiment "),tt=s("code"),Ha=r("init_tracker"),Fa=r(" should be used to setup your project, and potentially add any experiment hyperparameters to be logged:"),Gt=i(),m(ne.$$.fragment),Rt=i(),j=s("p"),Ua=r("When you are ready to log any data, "),Ce=s("a"),Ja=r("log()"),Ka=r(` should be used.
A `),at=s("code"),Qa=r("step"),Xa=r(" can also be passed in to correlate the data with a particular step in the training loop."),Ht=i(),m(le.$$.fragment),Ft=i(),xe=s("p"),Ya=r("A full example is below:"),Ut=i(),m(ce.$$.fragment),Jt=i(),b=s("div"),m(ie.$$.fragment),Za=i(),P=s("p"),er=r("A "),rt=s("code"),tr=r("Tracker"),ar=r(" class that supports "),ot=s("code"),rr=r("tensorboard"),or=r(". Should be initialized at the start of your script."),sr=i(),R=s("div"),m(pe.$$.fragment),nr=i(),de=s("p"),lr=r("Logs "),st=s("code"),cr=r("values"),ir=r(" to the current run."),pr=i(),H=s("div"),m(ue.$$.fragment),dr=i(),me=s("p"),ur=r("Logs "),nt=s("code"),mr=r("values"),hr=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Kt=i(),$=s("div"),m(he.$$.fragment),fr=i(),q=s("p"),gr=r("A "),lt=s("code"),_r=r("Tracker"),vr=r(" class that supports "),ct=s("code"),yr=r("wandb"),kr=r(". Should be initialized at the start of your script."),br=i(),F=s("div"),m(fe.$$.fragment),$r=i(),ge=s("p"),wr=r("Logs "),it=s("code"),Er=r("values"),Tr=r(" to the current run."),jr=i(),U=s("div"),m(_e.$$.fragment),Ar=i(),ve=s("p"),Dr=r("Logs "),pt=s("code"),Cr=r("values"),xr=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Qt=i(),y=s("div"),m(ye.$$.fragment),Lr=i(),S=s("p"),Or=r("A "),dt=s("code"),Ir=r("Tracker"),Pr=r(" class that supports "),ut=s("code"),qr=r("comet_ml"),Sr=r(". Should be initialized at the start of your script."),Br=i(),mt=s("p"),zr=r("API keys must be stored in a Comet config file."),Nr=i(),J=s("div"),m(ke.$$.fragment),Wr=i(),be=s("p"),Vr=r("Logs "),ht=s("code"),Mr=r("values"),Gr=r(" to the current run."),Rr=i(),K=s("div"),m($e.$$.fragment),Hr=i(),we=s("p"),Fr=r("Logs "),ft=s("code"),Ur=r("values"),Jr=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Xt=i(),B=s("h2"),Q=s("a"),gt=s("span"),m(Ee.$$.fragment),Kr=i(),_t=s("span"),Qr=r("Implementing Custom Trackers"),Yt=i(),A=s("p"),Xr=r("To implement a new tracker to be used in "),vt=s("code"),Yr=r("Accelerator"),Zr=r(", a new one can be made through implementing the "),yt=s("code"),eo=r("~GeneralTracker"),to=r(` class.
Every tracker must implement three functions:`),Zt=i(),D=s("ul"),X=s("li"),kt=s("code"),ao=r("__init__"),ro=r(": Should store a "),bt=s("code"),oo=r("run_name"),so=r(" and initialize the tracker API of the integrated library"),no=i(),Y=s("li"),$t=s("code"),lo=r("store_init_configuration"),co=r(": Should take in a "),wt=s("code"),io=r("values"),po=r(" dictionary and store them as a one-time experiment configuration"),uo=i(),k=s("li"),Et=s("code"),mo=r("log"),ho=r(": Should take in a "),Tt=s("code"),fo=r("values"),go=r(" dictionary and a "),jt=s("code"),_o=r("step"),vo=r(`, and should log them to the run
As well as contain a `),At=s("code"),yo=r("log_directory"),ko=r(" attribute. If the integrated library does not store anything locally, should be set to "),Dt=s("code"),bo=r("None"),$o=r("."),ea=i(),Le=s("p"),wo=r("A brief example can be seen below with an integration with Weights and Biases, containing only the relevent information:"),ta=i(),m(Te.$$.fragment),aa=i(),z=s("h2"),Z=s("a"),Ct=s("span"),m(je.$$.fragment),Eo=i(),xt=s("span"),To=r("When a wrapper cannot work"),ra=i(),C=s("p"),jo=r("If a library has an API that does not follow a strict "),Lt=s("code"),Ao=r(".log"),Do=r(" with an overall dictionary such as Neptune.AI, logging can be done manually under an "),Ot=s("code"),Co=r("if accelerator.is_main_process"),xo=r(" statement:"),oa=i(),m(Ae.$$.fragment),this.h()},l(e){const c=qs('[data-svelte="svelte-1phssyn"]',document.head);L=n(c,"META",{name:!0,content:!0}),c.forEach(a),qt=p(e),O=n(e,"H1",{class:!0});var na=l(O);W=n(na,"A",{id:!0,class:!0,href:!0});var Io=l(W);Me=n(Io,"SPAN",{});var Po=l(Me);h(ae.$$.fragment,Po),Po.forEach(a),Io.forEach(a),Ta=p(na),Ge=n(na,"SPAN",{});var qo=l(Ge);ja=o(qo,"Tracking"),qo.forEach(a),na.forEach(a),St=p(e),re=n(e,"P",{});var Lo=l(re);Aa=o(Lo,`There are a large number of experiment tracking API\u2019s available, however getting them all to work with in a multi-processing environment can oftentimes be complex.
Accelerate provides a general tracking API that can be used to log useful items during your script through `),De=n(Lo,"A",{href:!0});var So=l(De);Da=o(So,"log()"),So.forEach(a),Lo.forEach(a),Bt=p(e),I=n(e,"H2",{class:!0});var la=l(I);V=n(la,"A",{id:!0,class:!0,href:!0});var Bo=l(V);Re=n(Bo,"SPAN",{});var zo=l(Re);h(oe.$$.fragment,zo),zo.forEach(a),Bo.forEach(a),Ca=p(la),He=n(la,"SPAN",{});var No=l(He);xa=o(No,"Integrated Trackers"),No.forEach(a),la.forEach(a),zt=p(e),M=n(e,"P",{});var ca=l(M);La=o(ca,"Currently "),Fe=n(ca,"CODE",{});var Wo=l(Fe);Oa=o(Wo,"Accelerate"),Wo.forEach(a),Ia=o(ca," supports three trackers out-of-the-box:"),ca.forEach(a),Nt=p(e),E=n(e,"UL",{});var Oe=l(E);Ue=n(Oe,"LI",{});var Vo=l(Ue);Je=n(Vo,"CODE",{});var Mo=l(Je);Pa=o(Mo,"~TensorBoardTracker"),Mo.forEach(a),Vo.forEach(a),qa=p(Oe),Ke=n(Oe,"LI",{});var Go=l(Ke);Qe=n(Go,"CODE",{});var Ro=l(Qe);Sa=o(Ro,"~WandBTracker"),Ro.forEach(a),Go.forEach(a),Ba=p(Oe),Xe=n(Oe,"LI",{});var Ho=l(Xe);Ye=n(Ho,"CODE",{});var Fo=l(Ye);za=o(Fo,"~CometMLTracker"),Fo.forEach(a),Ho.forEach(a),Oe.forEach(a),Wt=p(e),T=n(e,"P",{});var Ie=l(T);Na=o(Ie,"To use any of them, pass in the selected type(s) to the "),Ze=n(Ie,"CODE",{});var Uo=l(Ze);Wa=o(Uo,"log_with"),Uo.forEach(a),Va=o(Ie," parameter in "),et=n(Ie,"CODE",{});var Jo=l(et);Ma=o(Jo,"__init__"),Jo.forEach(a),Ga=o(Ie,":"),Ie.forEach(a),Vt=p(e),h(se.$$.fragment,e),Mt=p(e),G=n(e,"P",{});var ia=l(G);Ra=o(ia,"At the start of your experiment "),tt=n(ia,"CODE",{});var Ko=l(tt);Ha=o(Ko,"init_tracker"),Ko.forEach(a),Fa=o(ia," should be used to setup your project, and potentially add any experiment hyperparameters to be logged:"),ia.forEach(a),Gt=p(e),h(ne.$$.fragment,e),Rt=p(e),j=n(e,"P",{});var Pe=l(j);Ua=o(Pe,"When you are ready to log any data, "),Ce=n(Pe,"A",{href:!0});var Qo=l(Ce);Ja=o(Qo,"log()"),Qo.forEach(a),Ka=o(Pe,` should be used.
A `),at=n(Pe,"CODE",{});var Xo=l(at);Qa=o(Xo,"step"),Xo.forEach(a),Xa=o(Pe," can also be passed in to correlate the data with a particular step in the training loop."),Pe.forEach(a),Ht=p(e),h(le.$$.fragment,e),Ft=p(e),xe=n(e,"P",{});var Yo=l(xe);Ya=o(Yo,"A full example is below:"),Yo.forEach(a),Ut=p(e),h(ce.$$.fragment,e),Jt=p(e),b=n(e,"DIV",{class:!0});var ee=l(b);h(ie.$$.fragment,ee),Za=p(ee),P=n(ee,"P",{});var qe=l(P);er=o(qe,"A "),rt=n(qe,"CODE",{});var Zo=l(rt);tr=o(Zo,"Tracker"),Zo.forEach(a),ar=o(qe," class that supports "),ot=n(qe,"CODE",{});var es=l(ot);rr=o(es,"tensorboard"),es.forEach(a),or=o(qe,". Should be initialized at the start of your script."),qe.forEach(a),sr=p(ee),R=n(ee,"DIV",{class:!0});var pa=l(R);h(pe.$$.fragment,pa),nr=p(pa),de=n(pa,"P",{});var da=l(de);lr=o(da,"Logs "),st=n(da,"CODE",{});var ts=l(st);cr=o(ts,"values"),ts.forEach(a),ir=o(da," to the current run."),da.forEach(a),pa.forEach(a),pr=p(ee),H=n(ee,"DIV",{class:!0});var ua=l(H);h(ue.$$.fragment,ua),dr=p(ua),me=n(ua,"P",{});var ma=l(me);ur=o(ma,"Logs "),nt=n(ma,"CODE",{});var as=l(nt);mr=o(as,"values"),as.forEach(a),hr=o(ma," as hyperparameters for the run. Should be run at the beginning of your experiment."),ma.forEach(a),ua.forEach(a),ee.forEach(a),Kt=p(e),$=n(e,"DIV",{class:!0});var te=l($);h(he.$$.fragment,te),fr=p(te),q=n(te,"P",{});var Se=l(q);gr=o(Se,"A "),lt=n(Se,"CODE",{});var rs=l(lt);_r=o(rs,"Tracker"),rs.forEach(a),vr=o(Se," class that supports "),ct=n(Se,"CODE",{});var os=l(ct);yr=o(os,"wandb"),os.forEach(a),kr=o(Se,". Should be initialized at the start of your script."),Se.forEach(a),br=p(te),F=n(te,"DIV",{class:!0});var ha=l(F);h(fe.$$.fragment,ha),$r=p(ha),ge=n(ha,"P",{});var fa=l(ge);wr=o(fa,"Logs "),it=n(fa,"CODE",{});var ss=l(it);Er=o(ss,"values"),ss.forEach(a),Tr=o(fa," to the current run."),fa.forEach(a),ha.forEach(a),jr=p(te),U=n(te,"DIV",{class:!0});var ga=l(U);h(_e.$$.fragment,ga),Ar=p(ga),ve=n(ga,"P",{});var _a=l(ve);Dr=o(_a,"Logs "),pt=n(_a,"CODE",{});var ns=l(pt);Cr=o(ns,"values"),ns.forEach(a),xr=o(_a," as hyperparameters for the run. Should be run at the beginning of your experiment."),_a.forEach(a),ga.forEach(a),te.forEach(a),Qt=p(e),y=n(e,"DIV",{class:!0});var x=l(y);h(ye.$$.fragment,x),Lr=p(x),S=n(x,"P",{});var Be=l(S);Or=o(Be,"A "),dt=n(Be,"CODE",{});var ls=l(dt);Ir=o(ls,"Tracker"),ls.forEach(a),Pr=o(Be," class that supports "),ut=n(Be,"CODE",{});var cs=l(ut);qr=o(cs,"comet_ml"),cs.forEach(a),Sr=o(Be,". Should be initialized at the start of your script."),Be.forEach(a),Br=p(x),mt=n(x,"P",{});var is=l(mt);zr=o(is,"API keys must be stored in a Comet config file."),is.forEach(a),Nr=p(x),J=n(x,"DIV",{class:!0});var va=l(J);h(ke.$$.fragment,va),Wr=p(va),be=n(va,"P",{});var ya=l(be);Vr=o(ya,"Logs "),ht=n(ya,"CODE",{});var ps=l(ht);Mr=o(ps,"values"),ps.forEach(a),Gr=o(ya," to the current run."),ya.forEach(a),va.forEach(a),Rr=p(x),K=n(x,"DIV",{class:!0});var ka=l(K);h($e.$$.fragment,ka),Hr=p(ka),we=n(ka,"P",{});var ba=l(we);Fr=o(ba,"Logs "),ft=n(ba,"CODE",{});var ds=l(ft);Ur=o(ds,"values"),ds.forEach(a),Jr=o(ba," as hyperparameters for the run. Should be run at the beginning of your experiment."),ba.forEach(a),ka.forEach(a),x.forEach(a),Xt=p(e),B=n(e,"H2",{class:!0});var $a=l(B);Q=n($a,"A",{id:!0,class:!0,href:!0});var us=l(Q);gt=n(us,"SPAN",{});var ms=l(gt);h(Ee.$$.fragment,ms),ms.forEach(a),us.forEach(a),Kr=p($a),_t=n($a,"SPAN",{});var hs=l(_t);Qr=o(hs,"Implementing Custom Trackers"),hs.forEach(a),$a.forEach(a),Yt=p(e),A=n(e,"P",{});var ze=l(A);Xr=o(ze,"To implement a new tracker to be used in "),vt=n(ze,"CODE",{});var fs=l(vt);Yr=o(fs,"Accelerator"),fs.forEach(a),Zr=o(ze,", a new one can be made through implementing the "),yt=n(ze,"CODE",{});var gs=l(yt);eo=o(gs,"~GeneralTracker"),gs.forEach(a),to=o(ze,` class.
Every tracker must implement three functions:`),ze.forEach(a),Zt=p(e),D=n(e,"UL",{});var Ne=l(D);X=n(Ne,"LI",{});var It=l(X);kt=n(It,"CODE",{});var _s=l(kt);ao=o(_s,"__init__"),_s.forEach(a),ro=o(It,": Should store a "),bt=n(It,"CODE",{});var vs=l(bt);oo=o(vs,"run_name"),vs.forEach(a),so=o(It," and initialize the tracker API of the integrated library"),It.forEach(a),no=p(Ne),Y=n(Ne,"LI",{});var Pt=l(Y);$t=n(Pt,"CODE",{});var ys=l($t);lo=o(ys,"store_init_configuration"),ys.forEach(a),co=o(Pt,": Should take in a "),wt=n(Pt,"CODE",{});var ks=l(wt);io=o(ks,"values"),ks.forEach(a),po=o(Pt," dictionary and store them as a one-time experiment configuration"),Pt.forEach(a),uo=p(Ne),k=n(Ne,"LI",{});var w=l(k);Et=n(w,"CODE",{});var bs=l(Et);mo=o(bs,"log"),bs.forEach(a),ho=o(w,": Should take in a "),Tt=n(w,"CODE",{});var $s=l(Tt);fo=o($s,"values"),$s.forEach(a),go=o(w," dictionary and a "),jt=n(w,"CODE",{});var ws=l(jt);_o=o(ws,"step"),ws.forEach(a),vo=o(w,`, and should log them to the run
As well as contain a `),At=n(w,"CODE",{});var Es=l(At);yo=o(Es,"log_directory"),Es.forEach(a),ko=o(w," attribute. If the integrated library does not store anything locally, should be set to "),Dt=n(w,"CODE",{});var Ts=l(Dt);bo=o(Ts,"None"),Ts.forEach(a),$o=o(w,"."),w.forEach(a),Ne.forEach(a),ea=p(e),Le=n(e,"P",{});var js=l(Le);wo=o(js,"A brief example can be seen below with an integration with Weights and Biases, containing only the relevent information:"),js.forEach(a),ta=p(e),h(Te.$$.fragment,e),aa=p(e),z=n(e,"H2",{class:!0});var wa=l(z);Z=n(wa,"A",{id:!0,class:!0,href:!0});var As=l(Z);Ct=n(As,"SPAN",{});var Ds=l(Ct);h(je.$$.fragment,Ds),Ds.forEach(a),As.forEach(a),Eo=p(wa),xt=n(wa,"SPAN",{});var Cs=l(xt);To=o(Cs,"When a wrapper cannot work"),Cs.forEach(a),wa.forEach(a),ra=p(e),C=n(e,"P",{});var We=l(C);jo=o(We,"If a library has an API that does not follow a strict "),Lt=n(We,"CODE",{});var xs=l(Lt);Ao=o(xs,".log"),xs.forEach(a),Do=o(We," with an overall dictionary such as Neptune.AI, logging can be done manually under an "),Ot=n(We,"CODE",{});var Ls=l(Ot);Co=o(Ls,"if accelerator.is_main_process"),Ls.forEach(a),xo=o(We," statement:"),We.forEach(a),oa=p(e),h(Ae.$$.fragment,e),this.h()},h(){u(L,"name","hf:doc:metadata"),u(L,"content",JSON.stringify(Ns)),u(W,"id","tracking"),u(W,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(W,"href","#tracking"),u(O,"class","relative group"),u(De,"href","/docs/accelerate/pr_293/en/accelerator#accelerate.Accelerator.log"),u(V,"id","accelerate.tracking.TensorBoardTracker"),u(V,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(V,"href","#accelerate.tracking.TensorBoardTracker"),u(I,"class","relative group"),u(Ce,"href","/docs/accelerate/pr_293/en/accelerator#accelerate.Accelerator.log"),u(R,"class","docstring"),u(H,"class","docstring"),u(b,"class","docstring"),u(F,"class","docstring"),u(U,"class","docstring"),u($,"class","docstring"),u(J,"class","docstring"),u(K,"class","docstring"),u(y,"class","docstring"),u(Q,"id","implementing-custom-trackers"),u(Q,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Q,"href","#implementing-custom-trackers"),u(B,"class","relative group"),u(Z,"id","when-a-wrapper-cannot-work"),u(Z,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(Z,"href","#when-a-wrapper-cannot-work"),u(z,"class","relative group")},m(e,c){t(document.head,L),d(e,qt,c),d(e,O,c),t(O,W),t(W,Me),f(ae,Me,null),t(O,Ta),t(O,Ge),t(Ge,ja),d(e,St,c),d(e,re,c),t(re,Aa),t(re,De),t(De,Da),d(e,Bt,c),d(e,I,c),t(I,V),t(V,Re),f(oe,Re,null),t(I,Ca),t(I,He),t(He,xa),d(e,zt,c),d(e,M,c),t(M,La),t(M,Fe),t(Fe,Oa),t(M,Ia),d(e,Nt,c),d(e,E,c),t(E,Ue),t(Ue,Je),t(Je,Pa),t(E,qa),t(E,Ke),t(Ke,Qe),t(Qe,Sa),t(E,Ba),t(E,Xe),t(Xe,Ye),t(Ye,za),d(e,Wt,c),d(e,T,c),t(T,Na),t(T,Ze),t(Ze,Wa),t(T,Va),t(T,et),t(et,Ma),t(T,Ga),d(e,Vt,c),f(se,e,c),d(e,Mt,c),d(e,G,c),t(G,Ra),t(G,tt),t(tt,Ha),t(G,Fa),d(e,Gt,c),f(ne,e,c),d(e,Rt,c),d(e,j,c),t(j,Ua),t(j,Ce),t(Ce,Ja),t(j,Ka),t(j,at),t(at,Qa),t(j,Xa),d(e,Ht,c),f(le,e,c),d(e,Ft,c),d(e,xe,c),t(xe,Ya),d(e,Ut,c),f(ce,e,c),d(e,Jt,c),d(e,b,c),f(ie,b,null),t(b,Za),t(b,P),t(P,er),t(P,rt),t(rt,tr),t(P,ar),t(P,ot),t(ot,rr),t(P,or),t(b,sr),t(b,R),f(pe,R,null),t(R,nr),t(R,de),t(de,lr),t(de,st),t(st,cr),t(de,ir),t(b,pr),t(b,H),f(ue,H,null),t(H,dr),t(H,me),t(me,ur),t(me,nt),t(nt,mr),t(me,hr),d(e,Kt,c),d(e,$,c),f(he,$,null),t($,fr),t($,q),t(q,gr),t(q,lt),t(lt,_r),t(q,vr),t(q,ct),t(ct,yr),t(q,kr),t($,br),t($,F),f(fe,F,null),t(F,$r),t(F,ge),t(ge,wr),t(ge,it),t(it,Er),t(ge,Tr),t($,jr),t($,U),f(_e,U,null),t(U,Ar),t(U,ve),t(ve,Dr),t(ve,pt),t(pt,Cr),t(ve,xr),d(e,Qt,c),d(e,y,c),f(ye,y,null),t(y,Lr),t(y,S),t(S,Or),t(S,dt),t(dt,Ir),t(S,Pr),t(S,ut),t(ut,qr),t(S,Sr),t(y,Br),t(y,mt),t(mt,zr),t(y,Nr),t(y,J),f(ke,J,null),t(J,Wr),t(J,be),t(be,Vr),t(be,ht),t(ht,Mr),t(be,Gr),t(y,Rr),t(y,K),f($e,K,null),t(K,Hr),t(K,we),t(we,Fr),t(we,ft),t(ft,Ur),t(we,Jr),d(e,Xt,c),d(e,B,c),t(B,Q),t(Q,gt),f(Ee,gt,null),t(B,Kr),t(B,_t),t(_t,Qr),d(e,Yt,c),d(e,A,c),t(A,Xr),t(A,vt),t(vt,Yr),t(A,Zr),t(A,yt),t(yt,eo),t(A,to),d(e,Zt,c),d(e,D,c),t(D,X),t(X,kt),t(kt,ao),t(X,ro),t(X,bt),t(bt,oo),t(X,so),t(D,no),t(D,Y),t(Y,$t),t($t,lo),t(Y,co),t(Y,wt),t(wt,io),t(Y,po),t(D,uo),t(D,k),t(k,Et),t(Et,mo),t(k,ho),t(k,Tt),t(Tt,fo),t(k,go),t(k,jt),t(jt,_o),t(k,vo),t(k,At),t(At,yo),t(k,ko),t(k,Dt),t(Dt,bo),t(k,$o),d(e,ea,c),d(e,Le,c),t(Le,wo),d(e,ta,c),f(Te,e,c),d(e,aa,c),d(e,z,c),t(z,Z),t(Z,Ct),f(je,Ct,null),t(z,Eo),t(z,xt),t(xt,To),d(e,ra,c),d(e,C,c),t(C,jo),t(C,Lt),t(Lt,Ao),t(C,Do),t(C,Ot),t(Ot,Co),t(C,xo),d(e,oa,c),f(Ae,e,c),sa=!0},p:Ss,i(e){sa||(g(ae.$$.fragment,e),g(oe.$$.fragment,e),g(se.$$.fragment,e),g(ne.$$.fragment,e),g(le.$$.fragment,e),g(ce.$$.fragment,e),g(ie.$$.fragment,e),g(pe.$$.fragment,e),g(ue.$$.fragment,e),g(he.$$.fragment,e),g(fe.$$.fragment,e),g(_e.$$.fragment,e),g(ye.$$.fragment,e),g(ke.$$.fragment,e),g($e.$$.fragment,e),g(Ee.$$.fragment,e),g(Te.$$.fragment,e),g(je.$$.fragment,e),g(Ae.$$.fragment,e),sa=!0)},o(e){_(ae.$$.fragment,e),_(oe.$$.fragment,e),_(se.$$.fragment,e),_(ne.$$.fragment,e),_(le.$$.fragment,e),_(ce.$$.fragment,e),_(ie.$$.fragment,e),_(pe.$$.fragment,e),_(ue.$$.fragment,e),_(he.$$.fragment,e),_(fe.$$.fragment,e),_(_e.$$.fragment,e),_(ye.$$.fragment,e),_(ke.$$.fragment,e),_($e.$$.fragment,e),_(Ee.$$.fragment,e),_(Te.$$.fragment,e),_(je.$$.fragment,e),_(Ae.$$.fragment,e),sa=!1},d(e){a(L),e&&a(qt),e&&a(O),v(ae),e&&a(St),e&&a(re),e&&a(Bt),e&&a(I),v(oe),e&&a(zt),e&&a(M),e&&a(Nt),e&&a(E),e&&a(Wt),e&&a(T),e&&a(Vt),v(se,e),e&&a(Mt),e&&a(G),e&&a(Gt),v(ne,e),e&&a(Rt),e&&a(j),e&&a(Ht),v(le,e),e&&a(Ft),e&&a(xe),e&&a(Ut),v(ce,e),e&&a(Jt),e&&a(b),v(ie),v(pe),v(ue),e&&a(Kt),e&&a($),v(he),v(fe),v(_e),e&&a(Qt),e&&a(y),v(ye),v(ke),v($e),e&&a(Xt),e&&a(B),v(Ee),e&&a(Yt),e&&a(A),e&&a(Zt),e&&a(D),e&&a(ea),e&&a(Le),e&&a(ta),v(Te,e),e&&a(aa),e&&a(z),v(je),e&&a(ra),e&&a(C),e&&a(oa),v(Ae,e)}}}const Ns={local:"tracking",sections:[{local:"accelerate.tracking.TensorBoardTracker",title:"Integrated Trackers"},{local:"implementing-custom-trackers",title:"Implementing Custom Trackers"},{local:"when-a-wrapper-cannot-work",title:"When a wrapper cannot work"}],title:"Tracking"};function Ws(Oo){return Bs(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Hs extends Os{constructor(L){super();Is(this,L,Ws,zs,Ps,{})}}export{Hs as default,Ns as metadata};
