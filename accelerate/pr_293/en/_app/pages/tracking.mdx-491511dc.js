import{S as os,i as ss,s as ns,e as s,k as i,w as m,t as r,M as ls,c as n,d as a,m as p,a as l,x as h,h as o,b as u,F as t,g as d,y as f,L as cs,q as g,o as _,B as v,v as is}from"../chunks/vendor-19e06bd2.js";import{D as z}from"../chunks/Docstring-395e5a9c.js";import{C as Ne}from"../chunks/CodeBlock-9dd1fdfb.js";import{I as ma}from"../chunks/IconCopyLink-3c713d38.js";function ps(uo){let x,Tt,C,B,We,ee,ha,Ve,fa,jt,te,ga,Ae,_a,At,L,N,Me,ae,va,Ge,ya,Dt,W,ka,Re,ba,$a,xt,k,re,wa,O,Ea,He,Ta,ja,Fe,Aa,Da,xa,V,oe,Ca,se,La,Ue,Oa,Pa,qa,M,ne,Ia,le,Sa,Je,za,Ba,Ct,b,ce,Na,P,Wa,Ke,Va,Ma,Qe,Ga,Ra,Ha,G,ie,Fa,pe,Ua,Xe,Ja,Ka,Qa,R,de,Xa,ue,Ya,Ye,Za,er,Lt,y,me,tr,q,ar,Ze,rr,or,et,sr,nr,lr,tt,cr,ir,H,he,pr,fe,dr,at,ur,mr,hr,F,ge,fr,_e,gr,rt,_r,vr,Ot,$,yr,ot,kr,br,st,$r,wr,Pt,ve,qt,U,Er,nt,Tr,jr,It,ye,St,w,Ar,De,Dr,xr,lt,Cr,Lr,zt,ke,Bt,xe,Or,Nt,be,Wt,I,J,ct,$e,Pr,it,qr,Vt,E,Ir,pt,Sr,zr,dt,Br,Nr,Mt,T,K,ut,Wr,Vr,mt,Mr,Gr,Rr,Q,ht,Hr,Fr,ft,Ur,Jr,Kr,j,gt,Qr,Xr,_t,Yr,Zr,vt,eo,to,Gt,Ce,ao,Rt,we,Ht,S,X,yt,Ee,ro,kt,oo,Ft,A,so,bt,no,lo,$t,co,io,Ut,Te,Jt;return ee=new ma({}),ae=new ma({}),re=new z({props:{name:"class accelerate.tracking.TensorBoardTracker",anchor:"accelerate.tracking.TensorBoardTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L84",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run`,name:"run_name"}]}}),oe=new z({props:{name:"log",anchor:"accelerate.tracking.TensorBoardTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L114",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.TensorBoardTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),ne=new z({props:{name:"store_init_configuration",anchor:"accelerate.tracking.TensorBoardTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L101",parametersDescription:[{anchor:"accelerate.tracking.TensorBoardTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),ce=new z({props:{name:"class accelerate.tracking.WandBTracker",anchor:"accelerate.tracking.WandBTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L133",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run.`,name:"run_name"}]}}),ie=new z({props:{name:"log",anchor:"accelerate.tracking.WandBTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L162",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.WandBTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),de=new z({props:{name:"store_init_configuration",anchor:"accelerate.tracking.WandBTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L150",parametersDescription:[{anchor:"accelerate.tracking.WandBTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),me=new z({props:{name:"class accelerate.tracking.CometMLTracker",anchor:"accelerate.tracking.CometMLTracker",parameters:[{name:"run_name",val:": str"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L176",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.run_name",description:`<strong>run_name</strong> (<code>str</code>) &#x2014;
The name of the experiment run.`,name:"run_name"}]}}),he=new z({props:{name:"log",anchor:"accelerate.tracking.CometMLTracker.log",parameters:[{name:"values",val:": dict"},{name:"step",val:": typing.Optional[int] = None"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L207",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.log.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>str</code>, <code>float</code>, or <code>int</code>) &#x2014;
Values to be logged as key-value pairs. The values need to have type <code>str</code>, <code>float</code>, or <code>int</code>.`,name:"values"},{anchor:"accelerate.tracking.CometMLTracker.log.step",description:`<strong>step</strong> (<code>int</code>, <em>optional</em>) &#x2014;
The run step. If included, the log will be affiliated with this step.`,name:"step"}]}}),ge=new z({props:{name:"store_init_configuration",anchor:"accelerate.tracking.CometMLTracker.store_init_configuration",parameters:[{name:"values",val:": dict"}],source:"https://github.com/huggingface/accelerate/blob/pr_293/src/accelerate/tracking.py#L195",parametersDescription:[{anchor:"accelerate.tracking.CometMLTracker.store_init_configuration.values",description:`<strong>values</strong> (Dictionary <code>str</code> to <code>bool</code>, <code>str</code>, <code>float</code> or <code>int</code>) &#x2014;
Values to be stored as initial hyperparameters as key-value pairs. The values need to have type <code>bool</code>,
<code>str</code>, <code>float</code>, <code>int</code>, or <code>None</code>.`,name:"values"}]}}),ve=new Ne({props:{code:`from accelerate import Accelerate
from accelerate.utils import LoggerType

accelerator = Accelerate(log_with="all")  # For all available trackers in the environment
accelerator = Accelerate(log_with="wandb")
accelerator = Accelerate(log_with=["wandb", LoggerType.TENSORBOARD])`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerate
<span class="hljs-keyword">from</span> accelerate.utils <span class="hljs-keyword">import</span> LoggerType

accelerator = Accelerate(log_with=<span class="hljs-string">&quot;all&quot;</span>)  <span class="hljs-comment"># For all available trackers in the environment</span>
accelerator = Accelerate(log_with=<span class="hljs-string">&quot;wandb&quot;</span>)
accelerator = Accelerate(log_with=[<span class="hljs-string">&quot;wandb&quot;</span>, LoggerType.TENSORBOARD])`}}),ye=new Ne({props:{code:`hps = {"num_iterations": 5, "learning_rate": 1e-2}
accelerator.init_trackers("my_project", config=hps)`,highlighted:`hps = {<span class="hljs-string">&quot;num_iterations&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&quot;learning_rate&quot;</span>: <span class="hljs-number">1e-2</span>}
accelerator.init_trackers(<span class="hljs-string">&quot;my_project&quot;</span>, config=hps)`}}),ke=new Ne({props:{code:'accelerator.log({"train_loss": 1.12, "valid_loss": 0.8}, step=1)',highlighted:'accelerator.log({<span class="hljs-string">&quot;train_loss&quot;</span>: <span class="hljs-number">1.12</span>, <span class="hljs-string">&quot;valid_loss&quot;</span>: <span class="hljs-number">0.8</span>}, step=<span class="hljs-number">1</span>)'}}),be=new Ne({props:{code:`from accelerate import Accelerator

accelerator = Accelerator(log_with="all")
config = {
    "num_iterations": 5,
    "learning_rate": 1e-2,
    "loss_function": str(my_loss_function),
}

accelerator.init_trackers("example_project", config=config)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config["num_iterations"]:
    for step, batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        accelerator.backward(loss)
        my_optimizer.step()
        accelerator.log({"training_loss": loss}, step=step)`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator

accelerator = Accelerator(log_with=<span class="hljs-string">&quot;all&quot;</span>)
config = {
    <span class="hljs-string">&quot;num_iterations&quot;</span>: <span class="hljs-number">5</span>,
    <span class="hljs-string">&quot;learning_rate&quot;</span>: <span class="hljs-number">1e-2</span>,
    <span class="hljs-string">&quot;loss_function&quot;</span>: <span class="hljs-built_in">str</span>(my_loss_function),
}

accelerator.init_trackers(<span class="hljs-string">&quot;example_project&quot;</span>, config=config)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

<span class="hljs-keyword">for</span> iteration <span class="hljs-keyword">in</span> config[<span class="hljs-string">&quot;num_iterations&quot;</span>]:
    <span class="hljs-keyword">for</span> step, batch <span class="hljs-keyword">in</span> my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        accelerator.backward(loss)
        my_optimizer.step()
        accelerator.log({<span class="hljs-string">&quot;training_loss&quot;</span>: loss}, step=step)`}}),$e=new ma({}),we=new Ne({props:{code:`from accelerate.tracking import GeneralTracker
from typing import Optional

import wandb


class WandBTracker(GeneralTracker):
    def __init__(self, run_name: str):
        self.run_name = run_name
        wandb.init(self.run_name)

    def store_init_configuration(self, values: dict):
        wandb.config(values)

    def log(self, values: dict, step: Optional[int] = None):
        wandb.log(values, step=step)`,highlighted:`<span class="hljs-keyword">from</span> accelerate.tracking <span class="hljs-keyword">import</span> GeneralTracker
<span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span>

<span class="hljs-keyword">import</span> wandb


<span class="hljs-keyword">class</span> <span class="hljs-title class_">WandBTracker</span>(<span class="hljs-title class_ inherited__">GeneralTracker</span>):
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, run_name: <span class="hljs-built_in">str</span></span>):
        self.run_name = run_name
        wandb.init(self.run_name)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">store_init_configuration</span>(<span class="hljs-params">self, values: <span class="hljs-built_in">dict</span></span>):
        wandb.config(values)

    <span class="hljs-keyword">def</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">self, values: <span class="hljs-built_in">dict</span>, step: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span></span>):
        wandb.log(values, step=step)`}}),Ee=new ma({}),Te=new Ne({props:{code:`from accelerate import Accelerator
+ import neptune.new as neptune

accelerator = Accelerator()
+ run = neptune.init(...)

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config["num_iterations"]:
    for batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        total_loss += loss
        accelerator.backward(loss)
        my_optimizer.step()
+       if accelerator.is_main_process:
+           run["logs/training/batch/loss"].log(loss)`,highlighted:`from accelerate import Accelerator
<span class="hljs-addition">+ import neptune.new as neptune</span>

accelerator = Accelerator()
<span class="hljs-addition">+ run = neptune.init(...)</span>

my_model, my_optimizer, my_training_dataloader = accelerate.prepare(my_model, my_optimizer, my_training_dataloader)
device = accelerator.device
my_model.to(device)

for iteration in config[&quot;num_iterations&quot;]:
    for batch in my_training_dataloader:
        my_optimizer.zero_grad()
        inputs, targets = batch
        inputs = inputs.to(device)
        targets = targets.to(device)
        outputs = my_model(inputs)
        loss = my_loss_function(outputs, targets)
        total_loss += loss
        accelerator.backward(loss)
        my_optimizer.step()
<span class="hljs-addition">+       if accelerator.is_main_process:</span>
<span class="hljs-addition">+           run[&quot;logs/training/batch/loss&quot;].log(loss)</span>`}}),{c(){x=s("meta"),Tt=i(),C=s("h1"),B=s("a"),We=s("span"),m(ee.$$.fragment),ha=i(),Ve=s("span"),fa=r("Tracking"),jt=i(),te=s("p"),ga=r(`There are a large number of experiment tracking API\u2019s available, however getting them all to work with in a multi-processing environment can oftentimes be complex.
Accelerate provides a general tracking API that can be used to log useful items during your script through `),Ae=s("a"),_a=r("log()"),At=i(),L=s("h2"),N=s("a"),Me=s("span"),m(ae.$$.fragment),va=i(),Ge=s("span"),ya=r("Integrated Trackers"),Dt=i(),W=s("p"),ka=r("Currently "),Re=s("code"),ba=r("Accelerate"),$a=r(" supports three trackers out-of-the-box:"),xt=i(),k=s("div"),m(re.$$.fragment),wa=i(),O=s("p"),Ea=r("A "),He=s("code"),Ta=r("Tracker"),ja=r(" class that supports "),Fe=s("code"),Aa=r("tensorboard"),Da=r(". Should be initialized at the start of your script."),xa=i(),V=s("div"),m(oe.$$.fragment),Ca=i(),se=s("p"),La=r("Logs "),Ue=s("code"),Oa=r("values"),Pa=r(" to the current run."),qa=i(),M=s("div"),m(ne.$$.fragment),Ia=i(),le=s("p"),Sa=r("Logs "),Je=s("code"),za=r("values"),Ba=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Ct=i(),b=s("div"),m(ce.$$.fragment),Na=i(),P=s("p"),Wa=r("A "),Ke=s("code"),Va=r("Tracker"),Ma=r(" class that supports "),Qe=s("code"),Ga=r("wandb"),Ra=r(". Should be initialized at the start of your script."),Ha=i(),G=s("div"),m(ie.$$.fragment),Fa=i(),pe=s("p"),Ua=r("Logs "),Xe=s("code"),Ja=r("values"),Ka=r(" to the current run."),Qa=i(),R=s("div"),m(de.$$.fragment),Xa=i(),ue=s("p"),Ya=r("Logs "),Ye=s("code"),Za=r("values"),er=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Lt=i(),y=s("div"),m(me.$$.fragment),tr=i(),q=s("p"),ar=r("A "),Ze=s("code"),rr=r("Tracker"),or=r(" class that supports "),et=s("code"),sr=r("comet_ml"),nr=r(". Should be initialized at the start of your script."),lr=i(),tt=s("p"),cr=r("API keys must be stored in a Comet config file."),ir=i(),H=s("div"),m(he.$$.fragment),pr=i(),fe=s("p"),dr=r("Logs "),at=s("code"),ur=r("values"),mr=r(" to the current run."),hr=i(),F=s("div"),m(ge.$$.fragment),fr=i(),_e=s("p"),gr=r("Logs "),rt=s("code"),_r=r("values"),vr=r(" as hyperparameters for the run. Should be run at the beginning of your experiment."),Ot=i(),$=s("p"),yr=r("To use any of them, pass in the selected type(s) to the "),ot=s("code"),kr=r("log_with"),br=r(" parameter in "),st=s("code"),$r=r("__init__"),wr=r(":"),Pt=i(),m(ve.$$.fragment),qt=i(),U=s("p"),Er=r("At the start of your experiment "),nt=s("code"),Tr=r("init_tracker"),jr=r(" should be used to setup your project, and potentially add any experiment hyperparameters to be logged:"),It=i(),m(ye.$$.fragment),St=i(),w=s("p"),Ar=r("When you are ready to log any data, "),De=s("a"),Dr=r("log()"),xr=r(` should be used.
A `),lt=s("code"),Cr=r("step"),Lr=r(" can also be passed in to correlate the data with a particular step in the training loop."),zt=i(),m(ke.$$.fragment),Bt=i(),xe=s("p"),Or=r("A full example is below:"),Nt=i(),m(be.$$.fragment),Wt=i(),I=s("h2"),J=s("a"),ct=s("span"),m($e.$$.fragment),Pr=i(),it=s("span"),qr=r("Implementing Custom Trackers"),Vt=i(),E=s("p"),Ir=r("To implement a new tracker to be used in "),pt=s("code"),Sr=r("Accelerator"),zr=r(", a new one can be made through implementing the "),dt=s("code"),Br=r("~GeneralTracker"),Nr=r(` class.
Every tracker must implement three functions:`),Mt=i(),T=s("ul"),K=s("li"),ut=s("code"),Wr=r("__init__"),Vr=r(": Should store a "),mt=s("code"),Mr=r("run_name"),Gr=r(" and initialize the tracker API of the integrated library"),Rr=i(),Q=s("li"),ht=s("code"),Hr=r("store_init_configuration"),Fr=r(": Should take in a "),ft=s("code"),Ur=r("values"),Jr=r(" dictionary and store them as a one-time experiment configuration"),Kr=i(),j=s("li"),gt=s("code"),Qr=r("log"),Xr=r(": Should take in a "),_t=s("code"),Yr=r("values"),Zr=r(" dictionary and a "),vt=s("code"),eo=r("step"),to=r(", and should log them to the run"),Gt=i(),Ce=s("p"),ao=r("A brief example can be seen below with an integration with Weights and Biases, containing only the relevent information:"),Rt=i(),m(we.$$.fragment),Ht=i(),S=s("h2"),X=s("a"),yt=s("span"),m(Ee.$$.fragment),ro=i(),kt=s("span"),oo=r("When a wrapper cannot work"),Ft=i(),A=s("p"),so=r("If a library has an API that does not follow a strict "),bt=s("code"),no=r(".log"),lo=r(" with an overall dictionary such as Neptune.AI, logging can be done manually under an "),$t=s("code"),co=r("if accelerator.is_main_process"),io=r(" statement:"),Ut=i(),m(Te.$$.fragment),this.h()},l(e){const c=ls('[data-svelte="svelte-1phssyn"]',document.head);x=n(c,"META",{name:!0,content:!0}),c.forEach(a),Tt=p(e),C=n(e,"H1",{class:!0});var Kt=l(C);B=n(Kt,"A",{id:!0,class:!0,href:!0});var mo=l(B);We=n(mo,"SPAN",{});var ho=l(We);h(ee.$$.fragment,ho),ho.forEach(a),mo.forEach(a),ha=p(Kt),Ve=n(Kt,"SPAN",{});var fo=l(Ve);fa=o(fo,"Tracking"),fo.forEach(a),Kt.forEach(a),jt=p(e),te=n(e,"P",{});var po=l(te);ga=o(po,`There are a large number of experiment tracking API\u2019s available, however getting them all to work with in a multi-processing environment can oftentimes be complex.
Accelerate provides a general tracking API that can be used to log useful items during your script through `),Ae=n(po,"A",{href:!0});var go=l(Ae);_a=o(go,"log()"),go.forEach(a),po.forEach(a),At=p(e),L=n(e,"H2",{class:!0});var Qt=l(L);N=n(Qt,"A",{id:!0,class:!0,href:!0});var _o=l(N);Me=n(_o,"SPAN",{});var vo=l(Me);h(ae.$$.fragment,vo),vo.forEach(a),_o.forEach(a),va=p(Qt),Ge=n(Qt,"SPAN",{});var yo=l(Ge);ya=o(yo,"Integrated Trackers"),yo.forEach(a),Qt.forEach(a),Dt=p(e),W=n(e,"P",{});var Xt=l(W);ka=o(Xt,"Currently "),Re=n(Xt,"CODE",{});var ko=l(Re);ba=o(ko,"Accelerate"),ko.forEach(a),$a=o(Xt," supports three trackers out-of-the-box:"),Xt.forEach(a),xt=p(e),k=n(e,"DIV",{class:!0});var Y=l(k);h(re.$$.fragment,Y),wa=p(Y),O=n(Y,"P",{});var Le=l(O);Ea=o(Le,"A "),He=n(Le,"CODE",{});var bo=l(He);Ta=o(bo,"Tracker"),bo.forEach(a),ja=o(Le," class that supports "),Fe=n(Le,"CODE",{});var $o=l(Fe);Aa=o($o,"tensorboard"),$o.forEach(a),Da=o(Le,". Should be initialized at the start of your script."),Le.forEach(a),xa=p(Y),V=n(Y,"DIV",{class:!0});var Yt=l(V);h(oe.$$.fragment,Yt),Ca=p(Yt),se=n(Yt,"P",{});var Zt=l(se);La=o(Zt,"Logs "),Ue=n(Zt,"CODE",{});var wo=l(Ue);Oa=o(wo,"values"),wo.forEach(a),Pa=o(Zt," to the current run."),Zt.forEach(a),Yt.forEach(a),qa=p(Y),M=n(Y,"DIV",{class:!0});var ea=l(M);h(ne.$$.fragment,ea),Ia=p(ea),le=n(ea,"P",{});var ta=l(le);Sa=o(ta,"Logs "),Je=n(ta,"CODE",{});var Eo=l(Je);za=o(Eo,"values"),Eo.forEach(a),Ba=o(ta," as hyperparameters for the run. Should be run at the beginning of your experiment."),ta.forEach(a),ea.forEach(a),Y.forEach(a),Ct=p(e),b=n(e,"DIV",{class:!0});var Z=l(b);h(ce.$$.fragment,Z),Na=p(Z),P=n(Z,"P",{});var Oe=l(P);Wa=o(Oe,"A "),Ke=n(Oe,"CODE",{});var To=l(Ke);Va=o(To,"Tracker"),To.forEach(a),Ma=o(Oe," class that supports "),Qe=n(Oe,"CODE",{});var jo=l(Qe);Ga=o(jo,"wandb"),jo.forEach(a),Ra=o(Oe,". Should be initialized at the start of your script."),Oe.forEach(a),Ha=p(Z),G=n(Z,"DIV",{class:!0});var aa=l(G);h(ie.$$.fragment,aa),Fa=p(aa),pe=n(aa,"P",{});var ra=l(pe);Ua=o(ra,"Logs "),Xe=n(ra,"CODE",{});var Ao=l(Xe);Ja=o(Ao,"values"),Ao.forEach(a),Ka=o(ra," to the current run."),ra.forEach(a),aa.forEach(a),Qa=p(Z),R=n(Z,"DIV",{class:!0});var oa=l(R);h(de.$$.fragment,oa),Xa=p(oa),ue=n(oa,"P",{});var sa=l(ue);Ya=o(sa,"Logs "),Ye=n(sa,"CODE",{});var Do=l(Ye);Za=o(Do,"values"),Do.forEach(a),er=o(sa," as hyperparameters for the run. Should be run at the beginning of your experiment."),sa.forEach(a),oa.forEach(a),Z.forEach(a),Lt=p(e),y=n(e,"DIV",{class:!0});var D=l(y);h(me.$$.fragment,D),tr=p(D),q=n(D,"P",{});var Pe=l(q);ar=o(Pe,"A "),Ze=n(Pe,"CODE",{});var xo=l(Ze);rr=o(xo,"Tracker"),xo.forEach(a),or=o(Pe," class that supports "),et=n(Pe,"CODE",{});var Co=l(et);sr=o(Co,"comet_ml"),Co.forEach(a),nr=o(Pe,". Should be initialized at the start of your script."),Pe.forEach(a),lr=p(D),tt=n(D,"P",{});var Lo=l(tt);cr=o(Lo,"API keys must be stored in a Comet config file."),Lo.forEach(a),ir=p(D),H=n(D,"DIV",{class:!0});var na=l(H);h(he.$$.fragment,na),pr=p(na),fe=n(na,"P",{});var la=l(fe);dr=o(la,"Logs "),at=n(la,"CODE",{});var Oo=l(at);ur=o(Oo,"values"),Oo.forEach(a),mr=o(la," to the current run."),la.forEach(a),na.forEach(a),hr=p(D),F=n(D,"DIV",{class:!0});var ca=l(F);h(ge.$$.fragment,ca),fr=p(ca),_e=n(ca,"P",{});var ia=l(_e);gr=o(ia,"Logs "),rt=n(ia,"CODE",{});var Po=l(rt);_r=o(Po,"values"),Po.forEach(a),vr=o(ia," as hyperparameters for the run. Should be run at the beginning of your experiment."),ia.forEach(a),ca.forEach(a),D.forEach(a),Ot=p(e),$=n(e,"P",{});var qe=l($);yr=o(qe,"To use any of them, pass in the selected type(s) to the "),ot=n(qe,"CODE",{});var qo=l(ot);kr=o(qo,"log_with"),qo.forEach(a),br=o(qe," parameter in "),st=n(qe,"CODE",{});var Io=l(st);$r=o(Io,"__init__"),Io.forEach(a),wr=o(qe,":"),qe.forEach(a),Pt=p(e),h(ve.$$.fragment,e),qt=p(e),U=n(e,"P",{});var pa=l(U);Er=o(pa,"At the start of your experiment "),nt=n(pa,"CODE",{});var So=l(nt);Tr=o(So,"init_tracker"),So.forEach(a),jr=o(pa," should be used to setup your project, and potentially add any experiment hyperparameters to be logged:"),pa.forEach(a),It=p(e),h(ye.$$.fragment,e),St=p(e),w=n(e,"P",{});var Ie=l(w);Ar=o(Ie,"When you are ready to log any data, "),De=n(Ie,"A",{href:!0});var zo=l(De);Dr=o(zo,"log()"),zo.forEach(a),xr=o(Ie,` should be used.
A `),lt=n(Ie,"CODE",{});var Bo=l(lt);Cr=o(Bo,"step"),Bo.forEach(a),Lr=o(Ie," can also be passed in to correlate the data with a particular step in the training loop."),Ie.forEach(a),zt=p(e),h(ke.$$.fragment,e),Bt=p(e),xe=n(e,"P",{});var No=l(xe);Or=o(No,"A full example is below:"),No.forEach(a),Nt=p(e),h(be.$$.fragment,e),Wt=p(e),I=n(e,"H2",{class:!0});var da=l(I);J=n(da,"A",{id:!0,class:!0,href:!0});var Wo=l(J);ct=n(Wo,"SPAN",{});var Vo=l(ct);h($e.$$.fragment,Vo),Vo.forEach(a),Wo.forEach(a),Pr=p(da),it=n(da,"SPAN",{});var Mo=l(it);qr=o(Mo,"Implementing Custom Trackers"),Mo.forEach(a),da.forEach(a),Vt=p(e),E=n(e,"P",{});var Se=l(E);Ir=o(Se,"To implement a new tracker to be used in "),pt=n(Se,"CODE",{});var Go=l(pt);Sr=o(Go,"Accelerator"),Go.forEach(a),zr=o(Se,", a new one can be made through implementing the "),dt=n(Se,"CODE",{});var Ro=l(dt);Br=o(Ro,"~GeneralTracker"),Ro.forEach(a),Nr=o(Se,` class.
Every tracker must implement three functions:`),Se.forEach(a),Mt=p(e),T=n(e,"UL",{});var ze=l(T);K=n(ze,"LI",{});var wt=l(K);ut=n(wt,"CODE",{});var Ho=l(ut);Wr=o(Ho,"__init__"),Ho.forEach(a),Vr=o(wt,": Should store a "),mt=n(wt,"CODE",{});var Fo=l(mt);Mr=o(Fo,"run_name"),Fo.forEach(a),Gr=o(wt," and initialize the tracker API of the integrated library"),wt.forEach(a),Rr=p(ze),Q=n(ze,"LI",{});var Et=l(Q);ht=n(Et,"CODE",{});var Uo=l(ht);Hr=o(Uo,"store_init_configuration"),Uo.forEach(a),Fr=o(Et,": Should take in a "),ft=n(Et,"CODE",{});var Jo=l(ft);Ur=o(Jo,"values"),Jo.forEach(a),Jr=o(Et," dictionary and store them as a one-time experiment configuration"),Et.forEach(a),Kr=p(ze),j=n(ze,"LI",{});var je=l(j);gt=n(je,"CODE",{});var Ko=l(gt);Qr=o(Ko,"log"),Ko.forEach(a),Xr=o(je,": Should take in a "),_t=n(je,"CODE",{});var Qo=l(_t);Yr=o(Qo,"values"),Qo.forEach(a),Zr=o(je," dictionary and a "),vt=n(je,"CODE",{});var Xo=l(vt);eo=o(Xo,"step"),Xo.forEach(a),to=o(je,", and should log them to the run"),je.forEach(a),ze.forEach(a),Gt=p(e),Ce=n(e,"P",{});var Yo=l(Ce);ao=o(Yo,"A brief example can be seen below with an integration with Weights and Biases, containing only the relevent information:"),Yo.forEach(a),Rt=p(e),h(we.$$.fragment,e),Ht=p(e),S=n(e,"H2",{class:!0});var ua=l(S);X=n(ua,"A",{id:!0,class:!0,href:!0});var Zo=l(X);yt=n(Zo,"SPAN",{});var es=l(yt);h(Ee.$$.fragment,es),es.forEach(a),Zo.forEach(a),ro=p(ua),kt=n(ua,"SPAN",{});var ts=l(kt);oo=o(ts,"When a wrapper cannot work"),ts.forEach(a),ua.forEach(a),Ft=p(e),A=n(e,"P",{});var Be=l(A);so=o(Be,"If a library has an API that does not follow a strict "),bt=n(Be,"CODE",{});var as=l(bt);no=o(as,".log"),as.forEach(a),lo=o(Be," with an overall dictionary such as Neptune.AI, logging can be done manually under an "),$t=n(Be,"CODE",{});var rs=l($t);co=o(rs,"if accelerator.is_main_process"),rs.forEach(a),io=o(Be," statement:"),Be.forEach(a),Ut=p(e),h(Te.$$.fragment,e),this.h()},h(){u(x,"name","hf:doc:metadata"),u(x,"content",JSON.stringify(ds)),u(B,"id","tracking"),u(B,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(B,"href","#tracking"),u(C,"class","relative group"),u(Ae,"href","/docs/accelerate/pr_293/en/accelerator#accelerate.Accelerator.log"),u(N,"id","accelerate.tracking.TensorBoardTracker"),u(N,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(N,"href","#accelerate.tracking.TensorBoardTracker"),u(L,"class","relative group"),u(V,"class","docstring"),u(M,"class","docstring"),u(k,"class","docstring"),u(G,"class","docstring"),u(R,"class","docstring"),u(b,"class","docstring"),u(H,"class","docstring"),u(F,"class","docstring"),u(y,"class","docstring"),u(De,"href","/docs/accelerate/pr_293/en/accelerator#accelerate.Accelerator.log"),u(J,"id","implementing-custom-trackers"),u(J,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(J,"href","#implementing-custom-trackers"),u(I,"class","relative group"),u(X,"id","when-a-wrapper-cannot-work"),u(X,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),u(X,"href","#when-a-wrapper-cannot-work"),u(S,"class","relative group")},m(e,c){t(document.head,x),d(e,Tt,c),d(e,C,c),t(C,B),t(B,We),f(ee,We,null),t(C,ha),t(C,Ve),t(Ve,fa),d(e,jt,c),d(e,te,c),t(te,ga),t(te,Ae),t(Ae,_a),d(e,At,c),d(e,L,c),t(L,N),t(N,Me),f(ae,Me,null),t(L,va),t(L,Ge),t(Ge,ya),d(e,Dt,c),d(e,W,c),t(W,ka),t(W,Re),t(Re,ba),t(W,$a),d(e,xt,c),d(e,k,c),f(re,k,null),t(k,wa),t(k,O),t(O,Ea),t(O,He),t(He,Ta),t(O,ja),t(O,Fe),t(Fe,Aa),t(O,Da),t(k,xa),t(k,V),f(oe,V,null),t(V,Ca),t(V,se),t(se,La),t(se,Ue),t(Ue,Oa),t(se,Pa),t(k,qa),t(k,M),f(ne,M,null),t(M,Ia),t(M,le),t(le,Sa),t(le,Je),t(Je,za),t(le,Ba),d(e,Ct,c),d(e,b,c),f(ce,b,null),t(b,Na),t(b,P),t(P,Wa),t(P,Ke),t(Ke,Va),t(P,Ma),t(P,Qe),t(Qe,Ga),t(P,Ra),t(b,Ha),t(b,G),f(ie,G,null),t(G,Fa),t(G,pe),t(pe,Ua),t(pe,Xe),t(Xe,Ja),t(pe,Ka),t(b,Qa),t(b,R),f(de,R,null),t(R,Xa),t(R,ue),t(ue,Ya),t(ue,Ye),t(Ye,Za),t(ue,er),d(e,Lt,c),d(e,y,c),f(me,y,null),t(y,tr),t(y,q),t(q,ar),t(q,Ze),t(Ze,rr),t(q,or),t(q,et),t(et,sr),t(q,nr),t(y,lr),t(y,tt),t(tt,cr),t(y,ir),t(y,H),f(he,H,null),t(H,pr),t(H,fe),t(fe,dr),t(fe,at),t(at,ur),t(fe,mr),t(y,hr),t(y,F),f(ge,F,null),t(F,fr),t(F,_e),t(_e,gr),t(_e,rt),t(rt,_r),t(_e,vr),d(e,Ot,c),d(e,$,c),t($,yr),t($,ot),t(ot,kr),t($,br),t($,st),t(st,$r),t($,wr),d(e,Pt,c),f(ve,e,c),d(e,qt,c),d(e,U,c),t(U,Er),t(U,nt),t(nt,Tr),t(U,jr),d(e,It,c),f(ye,e,c),d(e,St,c),d(e,w,c),t(w,Ar),t(w,De),t(De,Dr),t(w,xr),t(w,lt),t(lt,Cr),t(w,Lr),d(e,zt,c),f(ke,e,c),d(e,Bt,c),d(e,xe,c),t(xe,Or),d(e,Nt,c),f(be,e,c),d(e,Wt,c),d(e,I,c),t(I,J),t(J,ct),f($e,ct,null),t(I,Pr),t(I,it),t(it,qr),d(e,Vt,c),d(e,E,c),t(E,Ir),t(E,pt),t(pt,Sr),t(E,zr),t(E,dt),t(dt,Br),t(E,Nr),d(e,Mt,c),d(e,T,c),t(T,K),t(K,ut),t(ut,Wr),t(K,Vr),t(K,mt),t(mt,Mr),t(K,Gr),t(T,Rr),t(T,Q),t(Q,ht),t(ht,Hr),t(Q,Fr),t(Q,ft),t(ft,Ur),t(Q,Jr),t(T,Kr),t(T,j),t(j,gt),t(gt,Qr),t(j,Xr),t(j,_t),t(_t,Yr),t(j,Zr),t(j,vt),t(vt,eo),t(j,to),d(e,Gt,c),d(e,Ce,c),t(Ce,ao),d(e,Rt,c),f(we,e,c),d(e,Ht,c),d(e,S,c),t(S,X),t(X,yt),f(Ee,yt,null),t(S,ro),t(S,kt),t(kt,oo),d(e,Ft,c),d(e,A,c),t(A,so),t(A,bt),t(bt,no),t(A,lo),t(A,$t),t($t,co),t(A,io),d(e,Ut,c),f(Te,e,c),Jt=!0},p:cs,i(e){Jt||(g(ee.$$.fragment,e),g(ae.$$.fragment,e),g(re.$$.fragment,e),g(oe.$$.fragment,e),g(ne.$$.fragment,e),g(ce.$$.fragment,e),g(ie.$$.fragment,e),g(de.$$.fragment,e),g(me.$$.fragment,e),g(he.$$.fragment,e),g(ge.$$.fragment,e),g(ve.$$.fragment,e),g(ye.$$.fragment,e),g(ke.$$.fragment,e),g(be.$$.fragment,e),g($e.$$.fragment,e),g(we.$$.fragment,e),g(Ee.$$.fragment,e),g(Te.$$.fragment,e),Jt=!0)},o(e){_(ee.$$.fragment,e),_(ae.$$.fragment,e),_(re.$$.fragment,e),_(oe.$$.fragment,e),_(ne.$$.fragment,e),_(ce.$$.fragment,e),_(ie.$$.fragment,e),_(de.$$.fragment,e),_(me.$$.fragment,e),_(he.$$.fragment,e),_(ge.$$.fragment,e),_(ve.$$.fragment,e),_(ye.$$.fragment,e),_(ke.$$.fragment,e),_(be.$$.fragment,e),_($e.$$.fragment,e),_(we.$$.fragment,e),_(Ee.$$.fragment,e),_(Te.$$.fragment,e),Jt=!1},d(e){a(x),e&&a(Tt),e&&a(C),v(ee),e&&a(jt),e&&a(te),e&&a(At),e&&a(L),v(ae),e&&a(Dt),e&&a(W),e&&a(xt),e&&a(k),v(re),v(oe),v(ne),e&&a(Ct),e&&a(b),v(ce),v(ie),v(de),e&&a(Lt),e&&a(y),v(me),v(he),v(ge),e&&a(Ot),e&&a($),e&&a(Pt),v(ve,e),e&&a(qt),e&&a(U),e&&a(It),v(ye,e),e&&a(St),e&&a(w),e&&a(zt),v(ke,e),e&&a(Bt),e&&a(xe),e&&a(Nt),v(be,e),e&&a(Wt),e&&a(I),v($e),e&&a(Vt),e&&a(E),e&&a(Mt),e&&a(T),e&&a(Gt),e&&a(Ce),e&&a(Rt),v(we,e),e&&a(Ht),e&&a(S),v(Ee),e&&a(Ft),e&&a(A),e&&a(Ut),v(Te,e)}}}const ds={local:"tracking",sections:[{local:"accelerate.tracking.TensorBoardTracker",title:"Integrated Trackers"},{local:"implementing-custom-trackers",title:"Implementing Custom Trackers"},{local:"when-a-wrapper-cannot-work",title:"When a wrapper cannot work"}],title:"Tracking"};function us(uo){return is(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class _s extends os{constructor(x){super();ss(this,x,us,ps,ns,{})}}export{_s as default,ds as metadata};
