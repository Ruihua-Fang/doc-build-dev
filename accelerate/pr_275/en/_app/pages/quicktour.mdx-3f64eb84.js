import{S as To,i as Co,s as Do,H as gt,e as c,c as u,a as f,d as t,b as w,g as d,F as a,P as qi,U as Em,I as bt,J as Et,K as $t,q as $,o as P,v as $m,Z as Eh,N as om,O as rm,f as Dm,L as lm,w as D,x as S,y as N,B as I,k as g,m as b,n as se,p as ce,_ as km,l as ue,t as n,h as i,j as Pm,$ as Nm,G as Am,a0 as Tm,M as Im}from"../chunks/vendor-1b69db54.js";import{T as Ce}from"../chunks/Tip-1ceee8ba.js";import{I as x}from"../chunks/IconCopyLink-b3ba9a38.js";import{C as H}from"../chunks/CodeBlock-40263a9f.js";function Sm(m){let o,h,l,r,_,p;const v=m[7].default,y=gt(v,m,m[6],null);return{c(){o=c("div"),h=c("ul"),y&&y.c(),this.h()},l(E){o=u(E,"DIV",{class:!0});var k=f(o);h=u(k,"UL",{class:!0});var U=f(h);y&&y.l(U),U.forEach(t),k.forEach(t),this.h()},h(){w(h,"class","min-w-full w-auto"),w(o,"class",l="absolute top-full mt-1 min-w-full w-auto bg-white rounded-xl overflow-hidden shadow-lg z-10 border border-gray-100 "+(m[2]==="right"?"right-0":"left-0")+" "+m[0])},m(E,k){d(E,o,k),a(o,h),y&&y.m(h,null),m[8](o),r=!0,_||(p=qi(o,"click",function(){Em(m[1])&&m[1].apply(this,arguments)}),_=!0)},p(E,[k]){m=E,y&&y.p&&(!r||k&64)&&bt(y,v,m,m[6],r?$t(v,m[6],k,null):Et(m[6]),null),(!r||k&5&&l!==(l="absolute top-full mt-1 min-w-full w-auto bg-white rounded-xl overflow-hidden shadow-lg z-10 border border-gray-100 "+(m[2]==="right"?"right-0":"left-0")+" "+m[0]))&&w(o,"class",l)},i(E){r||($(y,E),r=!0)},o(E){P(y,E),r=!1},d(E){E&&t(o),y&&y.d(E),m[8](null),_=!1,p()}}}function zm(m,o,h){let{$$slots:l={},$$scope:r}=o,{classNames:_=""}=o,{dropdownElement:p=void 0}=o,{forceAlignement:v=void 0}=o,{onClose:y}=o,E=v!=null?v:"left",k;$m(()=>{var z,C;if(document.addEventListener("click",U),!v){const A=document.documentElement.clientWidth,T=(k==null?void 0:k.getBoundingClientRect())||{},L=(z=T.left)!=null?z:0,G=(C=T.width)!=null?C:0;h(2,E=L+G>A?"right":"left")}return()=>{document.removeEventListener("click",U)}});function U(z){const C=z.target;C!==p&&!(p==null?void 0:p.contains(C))&&y()}function j(z){Eh[z?"unshift":"push"](()=>{k=z,h(3,k)})}return m.$$set=z=>{"classNames"in z&&h(0,_=z.classNames),"dropdownElement"in z&&h(4,p=z.dropdownElement),"forceAlignement"in z&&h(5,v=z.forceAlignement),"onClose"in z&&h(1,y=z.onClose),"$$scope"in z&&h(6,r=z.$$scope)},[_,y,E,k,p,v,r,l,j]}class Om extends To{constructor(o){super();Co(this,o,zm,Sm,Do,{classNames:0,dropdownElement:4,forceAlignement:5,onClose:1})}}function jm(m){let o,h;return{c(){o=om("svg"),h=om("path"),this.h()},l(l){o=rm(l,"svg",{class:!0,xmlns:!0,"xmlns:xlink":!0,"aria-hidden":!0,focusable:!0,role:!0,width:!0,height:!0,preserveAspectRatio:!0,viewBox:!0,style:!0});var r=f(o);h=rm(r,"path",{d:!0,fill:!0}),f(h).forEach(t),r.forEach(t),this.h()},h(){w(h,"d","M7 10l5 5l5-5z"),w(h,"fill","currentColor"),w(o,"class",m[0]),w(o,"xmlns","http://www.w3.org/2000/svg"),w(o,"xmlns:xlink","http://www.w3.org/1999/xlink"),w(o,"aria-hidden","true"),w(o,"focusable","false"),w(o,"role","img"),w(o,"width","1em"),w(o,"height","1em"),w(o,"preserveAspectRatio","xMidYMid meet"),w(o,"viewBox","0 0 24 24"),Dm(o,"transform","rotate(360deg)")},m(l,r){d(l,o,r),a(o,h)},p(l,[r]){r&1&&w(o,"class",l[0])},i:lm,o:lm,d(l){l&&t(o)}}}function Lm(m,o,h){let{classNames:l=""}=o;return m.$$set=r=>{"classNames"in r&&h(0,l=r.classNames)},[l]}class Um extends To{constructor(o){super();Co(this,o,Lm,jm,Do,{classNames:0})}}const Mm=m=>({}),nm=m=>({}),Gm=m=>({}),im=m=>({});function Hm(m){let o,h,l,r,_,p=m[2]&&sm(m),v=m[10]&&cm();return{c(){p&&p.c(),o=g(),h=n(m[4]),l=g(),v&&v.c(),r=ue()},l(y){p&&p.l(y),o=b(y),h=i(y,m[4]),l=b(y),v&&v.l(y),r=ue()},m(y,E){p&&p.m(y,E),d(y,o,E),d(y,h,E),d(y,l,E),v&&v.m(y,E),d(y,r,E),_=!0},p(y,E){y[2]?p?(p.p(y,E),E&4&&$(p,1)):(p=sm(y),p.c(),$(p,1),p.m(o.parentNode,o)):p&&(se(),P(p,1,1,()=>{p=null}),ce()),(!_||E&16)&&Pm(h,y[4]),y[10]?v?E&1024&&$(v,1):(v=cm(),v.c(),$(v,1),v.m(r.parentNode,r)):v&&(se(),P(v,1,1,()=>{v=null}),ce())},i(y){_||($(p),$(v),_=!0)},o(y){P(p),P(v),_=!1},d(y){p&&p.d(y),y&&t(o),y&&t(h),y&&t(l),v&&v.d(y),y&&t(r)}}}function Ym(m){let o;const h=m[14].button,l=gt(h,m,m[18],im);return{c(){l&&l.c()},l(r){l&&l.l(r)},m(r,_){l&&l.m(r,_),o=!0},p(r,_){l&&l.p&&(!o||_&262144)&&bt(l,h,r,r[18],o?$t(h,r[18],_,Gm):Et(r[18]),im)},i(r){o||($(l,r),o=!0)},o(r){P(l,r),o=!1},d(r){l&&l.d(r)}}}function sm(m){let o,h,l;var r=m[2];function _(p){return{props:{classNames:"mr-1.5 "+p[3]}}}return r&&(o=new r(_(m))),{c(){o&&D(o.$$.fragment),h=ue()},l(p){o&&S(o.$$.fragment,p),h=ue()},m(p,v){o&&N(o,p,v),d(p,h,v),l=!0},p(p,v){const y={};if(v&8&&(y.classNames="mr-1.5 "+p[3]),r!==(r=p[2])){if(o){se();const E=o;P(E.$$.fragment,1,0,()=>{I(E,1)}),ce()}r?(o=new r(_(p)),D(o.$$.fragment),$(o.$$.fragment,1),N(o,h.parentNode,h)):o=null}else r&&o.$set(y)},i(p){l||(o&&$(o.$$.fragment,p),l=!0)},o(p){o&&P(o.$$.fragment,p),l=!1},d(p){p&&t(h),o&&I(o,p)}}}function cm(m){let o,h;return o=new Um({props:{classNames:"-mr-1 text-gray-500"}}),{c(){D(o.$$.fragment)},l(l){S(o.$$.fragment,l)},m(l,r){N(o,l,r),h=!0},i(l){h||($(o.$$.fragment,l),h=!0)},o(l){P(o.$$.fragment,l),h=!1},d(l){I(o,l)}}}function um(m){let o,h;return o=new Om({props:{classNames:m[6]+" "+(m[9]?"v2-dropdown-menu hidden":""),dropdownElement:m[11],forceAlignement:m[5],onClose:m[16],$$slots:{default:[qm]},$$scope:{ctx:m}}}),{c(){D(o.$$.fragment)},l(l){S(o.$$.fragment,l)},m(l,r){N(o,l,r),h=!0},p(l,r){const _={};r&576&&(_.classNames=l[6]+" "+(l[9]?"v2-dropdown-menu hidden":"")),r&2048&&(_.dropdownElement=l[11]),r&32&&(_.forceAlignement=l[5]),r&4096&&(_.onClose=l[16]),r&262144&&(_.$$scope={dirty:r,ctx:l}),o.$set(_)},i(l){h||($(o.$$.fragment,l),h=!0)},o(l){P(o.$$.fragment,l),h=!1},d(l){I(o,l)}}}function qm(m){let o;const h=m[14].menu,l=gt(h,m,m[18],nm);return{c(){l&&l.c()},l(r){l&&l.l(r)},m(r,_){l&&l.m(r,_),o=!0},p(r,_){l&&l.p&&(!o||_&262144)&&bt(l,h,r,r[18],o?$t(h,r[18],_,Mm):Et(r[18]),nm)},i(r){o||($(l,r),o=!0)},o(r){P(l,r),o=!1},d(r){l&&l.d(r)}}}function Bm(m){let o,h,l,r,_,p,v,y,E,k,U;const j=[Ym,Hm],z=[];function C(T,L){return T[13].button?0:1}l=C(m),r=z[l]=j[l](m);let A=(m[12]||m[9])&&um(m);return{c(){o=c("div"),h=c("button"),r.c(),p=g(),A&&A.c(),this.h()},l(T){o=u(T,"DIV",{class:!0,"selected-value":!0});var L=f(o);h=u(L,"BUTTON",{class:!0,type:!0});var G=f(h);r.l(G),G.forEach(t),p=b(L),A&&A.l(L),L.forEach(t),this.h()},h(){w(h,"class",_=""+m[1]+" "+(m[7]?"":"cursor-pointer w-full btn text-sm")+" "+(m[9]?"v2-dropdown-button":"")),w(h,"type","button"),w(o,"class",v="relative "+m[0]+" "+(m[9]?"v2-dropdown":"")),w(o,"selected-value",y=m[8]||void 0)},m(T,L){d(T,o,L),a(o,h),z[l].m(h,null),a(o,p),A&&A.m(o,null),m[17](o),E=!0,k||(U=qi(h,"click",m[15]),k=!0)},p(T,[L]){let G=l;l=C(T),l===G?z[l].p(T,L):(se(),P(z[G],1,1,()=>{z[G]=null}),ce(),r=z[l],r?r.p(T,L):(r=z[l]=j[l](T),r.c()),$(r,1),r.m(h,null)),(!E||L&642&&_!==(_=""+T[1]+" "+(T[7]?"":"cursor-pointer w-full btn text-sm")+" "+(T[9]?"v2-dropdown-button":"")))&&w(h,"class",_),T[12]||T[9]?A?(A.p(T,L),L&4608&&$(A,1)):(A=um(T),A.c(),$(A,1),A.m(o,null)):A&&(se(),P(A,1,1,()=>{A=null}),ce()),(!E||L&513&&v!==(v="relative "+T[0]+" "+(T[9]?"v2-dropdown":"")))&&w(o,"class",v),(!E||L&256&&y!==(y=T[8]||void 0))&&w(o,"selected-value",y)},i(T){E||($(r),$(A),E=!0)},o(T){P(r),P(A),E=!1},d(T){T&&t(o),z[l].d(),A&&A.d(),m[17](null),k=!1,U()}}}function xm(m,o,h){let{$$slots:l={},$$scope:r}=o;const _=km(l);let{classNames:p=""}=o,{btnClassNames:v=""}=o,{btnIcon:y=void 0}=o,{btnIconClassNames:E=""}=o,{btnLabel:k=""}=o,{forceMenuAlignement:U=void 0}=o,{menuClassNames:j=""}=o,{noBtnClass:z=void 0}=o,{selectedValue:C=void 0}=o,{useDeprecatedJS:A=!0}=o,{withBtnCaret:T=!1}=o,L,G=!1;const O=()=>h(12,G=!G),J=()=>h(12,G=!1);function kt(M){Eh[M?"unshift":"push"](()=>{L=M,h(11,L)})}return m.$$set=M=>{"classNames"in M&&h(0,p=M.classNames),"btnClassNames"in M&&h(1,v=M.btnClassNames),"btnIcon"in M&&h(2,y=M.btnIcon),"btnIconClassNames"in M&&h(3,E=M.btnIconClassNames),"btnLabel"in M&&h(4,k=M.btnLabel),"forceMenuAlignement"in M&&h(5,U=M.forceMenuAlignement),"menuClassNames"in M&&h(6,j=M.menuClassNames),"noBtnClass"in M&&h(7,z=M.noBtnClass),"selectedValue"in M&&h(8,C=M.selectedValue),"useDeprecatedJS"in M&&h(9,A=M.useDeprecatedJS),"withBtnCaret"in M&&h(10,T=M.withBtnCaret),"$$scope"in M&&h(18,r=M.$$scope)},[p,v,y,E,k,U,j,z,C,A,T,L,G,_,l,O,J,kt,r]}class fm extends To{constructor(o){super();Co(this,o,xm,Bm,Do,{classNames:0,btnClassNames:1,btnIcon:2,btnIconClassNames:3,btnLabel:4,forceMenuAlignement:5,menuClassNames:6,noBtnClass:7,selectedValue:8,useDeprecatedJS:9,withBtnCaret:10})}}function Jm(m){let o,h,l,r=m[5]&&hm(m);return{c(){r&&r.c(),o=g(),h=n(m[7])},l(_){r&&r.l(_),o=b(_),h=i(_,m[7])},m(_,p){r&&r.m(_,p),d(_,o,p),d(_,h,p),l=!0},p(_,p){_[5]?r?(r.p(_,p),p&32&&$(r,1)):(r=hm(_),r.c(),$(r,1),r.m(o.parentNode,o)):r&&(se(),P(r,1,1,()=>{r=null}),ce()),(!l||p&128)&&Pm(h,_[7])},i(_){l||($(r),l=!0)},o(_){P(r),l=!1},d(_){r&&r.d(_),_&&t(o),_&&t(h)}}}function Xm(m){let o;const h=m[15].default,l=gt(h,m,m[14],null);return{c(){l&&l.c()},l(r){l&&l.l(r)},m(r,_){l&&l.m(r,_),o=!0},p(r,_){l&&l.p&&(!o||_&16384)&&bt(l,h,r,r[14],o?$t(h,r[14],_,null):Et(r[14]),null)},i(r){o||($(l,r),o=!0)},o(r){P(l,r),o=!1},d(r){l&&l.d(r)}}}function hm(m){let o,h,l;var r=m[5];function _(p){return{props:{classNames:"mr-1.5 "+p[6]}}}return r&&(o=new r(_(m))),{c(){o&&D(o.$$.fragment),h=ue()},l(p){o&&S(o.$$.fragment,p),h=ue()},m(p,v){o&&N(o,p,v),d(p,h,v),l=!0},p(p,v){const y={};if(v&64&&(y.classNames="mr-1.5 "+p[6]),r!==(r=p[5])){if(o){se();const E=o;P(E.$$.fragment,1,0,()=>{I(E,1)}),ce()}r?(o=new r(_(p)),D(o.$$.fragment),$(o.$$.fragment,1),N(o,h.parentNode,h)):o=null}else r&&o.$set(y)},i(p){l||(o&&$(o.$$.fragment,p),l=!0)},o(p){o&&P(o.$$.fragment,p),l=!1},d(p){p&&t(h),o&&I(o,p)}}}function Fm(m){let o,h,l,r,_,p,v,y,E,k;const U=[Xm,Jm],j=[];function z(C,A){return C[13].default?0:1}return l=z(m),r=j[l]=U[l](m),{c(){o=c("li"),h=c("a"),r.c(),this.h()},l(C){o=u(C,"LI",{});var A=f(o);h=u(A,"A",{class:!0,"data-label":!0,"data-url":!0,"data-value":!0,href:!0,rel:!0,target:!0});var T=f(h);r.l(T),T.forEach(t),A.forEach(t),this.h()},h(){w(h,"class",_="flex items-center hover:bg-gray-50 dark:hover:bg-gray-800 cursor-pointer px-3 py-1.5 whitespace-nowrap "+m[0]+" "+(m[9]?"hover:underline":"")+" "+(m[12]?"v2-dropdown-entry":"")),w(h,"data-label",m[1]),w(h,"data-url",m[2]),w(h,"data-value",m[3]),w(h,"href",m[4]),w(h,"rel",p=m[8]?"nofollow":void 0),w(h,"target",v=m[11]?"_blank":void 0)},m(C,A){d(C,o,A),a(o,h),j[l].m(h,null),y=!0,E||(k=qi(h,"click",function(){Em(m[10])&&m[10].apply(this,arguments)}),E=!0)},p(C,[A]){m=C;let T=l;l=z(m),l===T?j[l].p(m,A):(se(),P(j[T],1,1,()=>{j[T]=null}),ce(),r=j[l],r?r.p(m,A):(r=j[l]=U[l](m),r.c()),$(r,1),r.m(h,null)),(!y||A&4609&&_!==(_="flex items-center hover:bg-gray-50 dark:hover:bg-gray-800 cursor-pointer px-3 py-1.5 whitespace-nowrap "+m[0]+" "+(m[9]?"hover:underline":"")+" "+(m[12]?"v2-dropdown-entry":"")))&&w(h,"class",_),(!y||A&2)&&w(h,"data-label",m[1]),(!y||A&4)&&w(h,"data-url",m[2]),(!y||A&8)&&w(h,"data-value",m[3]),(!y||A&16)&&w(h,"href",m[4]),(!y||A&256&&p!==(p=m[8]?"nofollow":void 0))&&w(h,"rel",p),(!y||A&2048&&v!==(v=m[11]?"_blank":void 0))&&w(h,"target",v)},i(C){y||($(r),y=!0)},o(C){P(r),y=!1},d(C){C&&t(o),j[l].d(),E=!1,k()}}}function Rm(m,o,h){let{$$slots:l={},$$scope:r}=o;const _=km(l);let{classNames:p=""}=o,{dataLabel:v=void 0}=o,{dataUrl:y=void 0}=o,{dataValue:E=void 0}=o,{href:k=void 0}=o,{icon:U=void 0}=o,{iconClassNames:j=""}=o,{label:z=""}=o,{noFollow:C=!1}=o,{underline:A=!1}=o,{onClick:T=()=>{}}=o,{targetBlank:L=!1}=o,{useDeprecatedJS:G=!0}=o;return m.$$set=O=>{"classNames"in O&&h(0,p=O.classNames),"dataLabel"in O&&h(1,v=O.dataLabel),"dataUrl"in O&&h(2,y=O.dataUrl),"dataValue"in O&&h(3,E=O.dataValue),"href"in O&&h(4,k=O.href),"icon"in O&&h(5,U=O.icon),"iconClassNames"in O&&h(6,j=O.iconClassNames),"label"in O&&h(7,z=O.label),"noFollow"in O&&h(8,C=O.noFollow),"underline"in O&&h(9,A=O.underline),"onClick"in O&&h(10,T=O.onClick),"targetBlank"in O&&h(11,L=O.targetBlank),"useDeprecatedJS"in O&&h(12,G=O.useDeprecatedJS),"$$scope"in O&&h(14,r=O.$$scope)},[p,v,y,E,k,U,j,z,C,A,T,L,G,_,r,l]}class Cm extends To{constructor(o){super();Co(this,o,Rm,Fm,Do,{classNames:0,dataLabel:1,dataUrl:2,dataValue:3,href:4,icon:5,iconClassNames:6,label:7,noFollow:8,underline:9,onClick:10,targetBlank:11,useDeprecatedJS:12})}}const{window:Wm}=Nm,Vm=m=>({}),pm=m=>({slot:"button"});function dm(m,o,h){const l=m.slice();return l[11]=o[h].label,l[12]=o[h].value,l}const Qm=m=>({}),mm=m=>({slot:"menu"}),Km=m=>({}),_m=m=>({slot:"button"});function ym(m,o,h){const l=m.slice();return l[11]=o[h].label,l[12]=o[h].value,l}const Zm=m=>({}),vm=m=>({slot:"menu"});function e_(m){let o,h;return{c(){o=c("img"),this.h()},l(l){o=u(l,"IMG",{alt:!0,class:!0,src:!0}),this.h()},h(){w(o,"alt","Open In Colab"),w(o,"class","!m-0"),Tm(o.src,h="https://colab.research.google.com/assets/colab-badge.svg")||w(o,"src",h)},m(l,r){d(l,o,r)},d(l){l&&t(o)}}}function t_(m){let o;const h=m[6].default,l=gt(h,m,m[10],_m),r=l||e_();return{c(){r&&r.c()},l(_){r&&r.l(_)},m(_,p){r&&r.m(_,p),o=!0},p(_,p){l&&l.p&&(!o||p&1024)&&bt(l,h,_,_[10],o?$t(h,_[10],p,Km):Et(_[10]),_m)},i(_){o||($(r,_),o=!0)},o(_){P(r,_),o=!1},d(_){r&&r.d(_)}}}function wm(m){let o,h;function l(){return m[7](m[12])}return o=new Cm({props:{classNames:"text-sm !no-underline",iconClassNames:"text-gray-500",label:m[11],onClick:l,useDeprecatedJS:!1}}),{c(){D(o.$$.fragment)},l(r){S(o.$$.fragment,r)},m(r,_){N(o,r,_),h=!0},p(r,_){m=r},i(r){h||($(o.$$.fragment,r),h=!0)},o(r){P(o.$$.fragment,r),h=!1},d(r){I(o,r)}}}function a_(m){let o,h,l=m[2],r=[];for(let p=0;p<l.length;p+=1)r[p]=wm(ym(m,l,p));const _=p=>P(r[p],1,1,()=>{r[p]=null});return{c(){for(let p=0;p<r.length;p+=1)r[p].c();o=ue()},l(p){for(let v=0;v<r.length;v+=1)r[v].l(p);o=ue()},m(p,v){for(let y=0;y<r.length;y+=1)r[y].m(p,v);d(p,o,v),h=!0},p(p,v){if(v&4){l=p[2];let y;for(y=0;y<l.length;y+=1){const E=ym(p,l,y);r[y]?(r[y].p(E,v),$(r[y],1)):(r[y]=wm(E),r[y].c(),$(r[y],1),r[y].m(o.parentNode,o))}for(se(),y=l.length;y<r.length;y+=1)_(y);ce()}},i(p){if(!h){for(let v=0;v<l.length;v+=1)$(r[v]);h=!0}},o(p){r=r.filter(Boolean);for(let v=0;v<r.length;v+=1)P(r[v]);h=!1},d(p){Am(r,p),p&&t(o)}}}function o_(m){let o;const h=m[6].default,l=gt(h,m,m[10],vm),r=l||a_(m);return{c(){r&&r.c()},l(_){r&&r.l(_)},m(_,p){r&&r.m(_,p),o=!0},p(_,p){l&&l.p&&(!o||p&1024)&&bt(l,h,_,_[10],o?$t(h,_[10],p,Zm):Et(_[10]),vm)},i(_){o||($(r,_),o=!0)},o(_){P(r,_),o=!1},d(_){r&&r.d(_)}}}function r_(m){let o,h;return{c(){o=c("img"),this.h()},l(l){o=u(l,"IMG",{alt:!0,class:!0,src:!0}),this.h()},h(){w(o,"alt","Open In Studio Lab"),w(o,"class","!m-0"),Tm(o.src,h="https://studiolab.sagemaker.aws/studiolab.svg")||w(o,"src",h)},m(l,r){d(l,o,r)},d(l){l&&t(o)}}}function l_(m){let o;const h=m[6].default,l=gt(h,m,m[10],pm),r=l||r_();return{c(){r&&r.c()},l(_){r&&r.l(_)},m(_,p){r&&r.m(_,p),o=!0},p(_,p){l&&l.p&&(!o||p&1024)&&bt(l,h,_,_[10],o?$t(h,_[10],p,Vm):Et(_[10]),pm)},i(_){o||($(r,_),o=!0)},o(_){P(r,_),o=!1},d(_){r&&r.d(_)}}}function gm(m){let o,h;function l(){return m[8](m[12])}return o=new Cm({props:{classNames:"text-sm !no-underline",iconClassNames:"text-gray-500",label:m[11],onClick:l,useDeprecatedJS:!1}}),{c(){D(o.$$.fragment)},l(r){S(o.$$.fragment,r)},m(r,_){N(o,r,_),h=!0},p(r,_){m=r},i(r){h||($(o.$$.fragment,r),h=!0)},o(r){P(o.$$.fragment,r),h=!1},d(r){I(o,r)}}}function n_(m){let o,h,l=m[3],r=[];for(let p=0;p<l.length;p+=1)r[p]=gm(dm(m,l,p));const _=p=>P(r[p],1,1,()=>{r[p]=null});return{c(){for(let p=0;p<r.length;p+=1)r[p].c();o=ue()},l(p){for(let v=0;v<r.length;v+=1)r[v].l(p);o=ue()},m(p,v){for(let y=0;y<r.length;y+=1)r[y].m(p,v);d(p,o,v),h=!0},p(p,v){if(v&8){l=p[3];let y;for(y=0;y<l.length;y+=1){const E=dm(p,l,y);r[y]?(r[y].p(E,v),$(r[y],1)):(r[y]=gm(E),r[y].c(),$(r[y],1),r[y].m(o.parentNode,o))}for(se(),y=l.length;y<r.length;y+=1)_(y);ce()}},i(p){if(!h){for(let v=0;v<l.length;v+=1)$(r[v]);h=!0}},o(p){r=r.filter(Boolean);for(let v=0;v<r.length;v+=1)P(r[v]);h=!1},d(p){Am(r,p),p&&t(o)}}}function i_(m){let o;const h=m[6].default,l=gt(h,m,m[10],mm),r=l||n_(m);return{c(){r&&r.c()},l(_){r&&r.l(_)},m(_,p){r&&r.m(_,p),o=!0},p(_,p){l&&l.p&&(!o||p&1024)&&bt(l,h,_,_[10],o?$t(h,_[10],p,Qm):Et(_[10]),mm)},i(_){o||($(r,_),o=!0)},o(_){P(r,_),o=!1},d(_){r&&r.d(_)}}}function s_(m){let o,h,l,r,_,p,v,y;return h=new fm({props:{btnLabel:"",classNames:"colab-dropdown",noBtnClass:!0,useDeprecatedJS:!1,$$slots:{menu:[o_],button:[t_]},$$scope:{ctx:m}}}),r=new fm({props:{btnLabel:"",classNames:"colab-dropdown",noBtnClass:!0,useDeprecatedJS:!1,$$slots:{menu:[i_],button:[l_]},$$scope:{ctx:m}}}),{c(){o=c("div"),D(h.$$.fragment),l=g(),D(r.$$.fragment),this.h()},l(E){o=u(E,"DIV",{class:!0});var k=f(o);S(h.$$.fragment,k),l=b(k),S(r.$$.fragment,k),k.forEach(t),this.h()},h(){w(o,"class",_="flex space-x-1 "+m[0])},m(E,k){d(E,o,k),N(h,o,null),a(o,l),N(r,o,null),m[9](o),p=!0,v||(y=qi(Wm,"resize",m[4]),v=!0)},p(E,[k]){const U={};k&1024&&(U.$$scope={dirty:k,ctx:E}),h.$set(U);const j={};k&1024&&(j.$$scope={dirty:k,ctx:E}),r.$set(j),(!p||k&1&&_!==(_="flex space-x-1 "+E[0]))&&w(o,"class",_)},i(E){p||($(h.$$.fragment,E),$(r.$$.fragment,E),p=!0)},o(E){P(h.$$.fragment,E),P(r.$$.fragment,E),p=!1},d(E){E&&t(o),I(h),I(r),m[9](null),v=!1,y()}}}function bm(m){window.open(m)}function c_(m,o,h){let{$$slots:l={},$$scope:r}=o,{options:_=[]}=o,{classNames:p=""}=o,v;const y=_.filter(C=>C.value.includes("colab.research.google.com")),E=_.filter(C=>C.value.includes("studiolab.sagemaker.aws"));function k(){const C=document.querySelector(".prose-doc h1"),A=document.querySelector(".prose-doc h1 > span");if(C&&A){const{width:T}=C.getBoundingClientRect(),{width:L}=A.getBoundingClientRect();let G=0;for(let J=0;J<v.children.length;J++)G+=v.children.item(J).clientWidth;const O=20;T-L<G+O?v.classList.remove("absolute"):v.classList.add("absolute")}}$m(()=>{k()});const U=C=>bm(C),j=C=>bm(C);function z(C){Eh[C?"unshift":"push"](()=>{v=C,h(1,v)})}return m.$$set=C=>{"options"in C&&h(5,_=C.options),"classNames"in C&&h(0,p=C.classNames),"$$scope"in C&&h(10,r=C.$$scope)},[p,v,y,E,k,_,l,U,j,z,r]}class u_ extends To{constructor(o){super();Co(this,o,c_,s_,Do,{options:5,classNames:0})}}function f_(m){let o,h,l,r,_;return{c(){o=c("p"),h=n(`If you place your objects manually on the proper device, be careful to create your optimizer after putting your
model on `),l=c("code"),r=n("accelerator.device"),_=n(" or your training will fail on TPU.")},l(p){o=u(p,"P",{});var v=f(o);h=i(v,`If you place your objects manually on the proper device, be careful to create your optimizer after putting your
model on `),l=u(v,"CODE",{});var y=f(l);r=i(y,"accelerator.device"),y.forEach(t),_=i(v," or your training will fail on TPU."),v.forEach(t)},m(p,v){d(p,o,v),a(o,h),a(o,l),a(l,r),a(o,_)},d(p){p&&t(o)}}}function h_(m){let o,h;return{c(){o=c("p"),h=n(`The actual batch size for your training will be the number of devices used multiplied by the batch size you set in
your script: for instance training on 4 GPUs with a batch size of 16 set when creating the training dataloader will
train at an actual batch size of 64.`)},l(l){o=u(l,"P",{});var r=f(o);h=i(r,`The actual batch size for your training will be the number of devices used multiplied by the batch size you set in
your script: for instance training on 4 GPUs with a batch size of 16 set when creating the training dataloader will
train at an actual batch size of 64.`),r.forEach(t)},m(l,r){d(l,o,r),a(o,h)},d(l){l&&t(o)}}}function p_(m){let o,h,l,r,_;return{c(){o=c("p"),h=n(`Your training dataloader may change length when going through this method: if you run on X GPUs, it will have its
length divided by X (since your actual batch size will be multiplied by X), unless you set
`),l=c("code"),r=n("split_batches=True"),_=n(".")},l(p){o=u(p,"P",{});var v=f(o);h=i(v,`Your training dataloader may change length when going through this method: if you run on X GPUs, it will have its
length divided by X (since your actual batch size will be multiplied by X), unless you set
`),l=u(v,"CODE",{});var y=f(l);r=i(y,"split_batches=True"),y.forEach(t),_=i(v,"."),v.forEach(t)},m(p,v){d(p,o,v),a(o,h),a(o,l),a(l,r),a(o,_)},d(p){p&&t(o)}}}function d_(m){let o,h,l,r,_,p,v,y,E,k,U,j,z,C;return{c(){o=c("p"),h=n(`Like for the training dataloader, passing your validation dataloader through
`),l=c("a"),r=n("prepare()"),_=n(` may change its: if you run on X GPUs, it will have its length divided by X
(since your actual batch size will be multiplied by X), unless you set `),p=c("code"),v=n("split_batches=True"),y=n("."),E=g(),k=c("p"),U=n(`Any instruction using your training dataloader length (for instance if you need the number of total training steps
to create a learning rate scheduler) should go after the call to `),j=c("a"),z=n("prepare()"),C=n("."),this.h()},l(A){o=u(A,"P",{});var T=f(o);h=i(T,`Like for the training dataloader, passing your validation dataloader through
`),l=u(T,"A",{href:!0});var L=f(l);r=i(L,"prepare()"),L.forEach(t),_=i(T,` may change its: if you run on X GPUs, it will have its length divided by X
(since your actual batch size will be multiplied by X), unless you set `),p=u(T,"CODE",{});var G=f(p);v=i(G,"split_batches=True"),G.forEach(t),y=i(T,"."),T.forEach(t),E=b(A),k=u(A,"P",{});var O=f(k);U=i(O,`Any instruction using your training dataloader length (for instance if you need the number of total training steps
to create a learning rate scheduler) should go after the call to `),j=u(O,"A",{href:!0});var J=f(j);z=i(J,"prepare()"),J.forEach(t),C=i(O,"."),O.forEach(t),this.h()},h(){w(l,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator.prepare"),w(j,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator.prepare")},m(A,T){d(A,o,T),a(o,h),a(o,l),a(l,r),a(o,_),a(o,p),a(p,v),a(o,y),d(A,E,T),d(A,k,T),a(k,U),a(k,j),a(j,z),a(k,C)},d(A){A&&t(o),A&&t(E),A&&t(k)}}}function m_(m){let o,h,l,r,_,p,v,y;return{c(){o=c("p"),h=n("The "),l=c("a"),r=n("gather()"),_=n(` method requires the tensors to be all the same size on each process. If
you have tensors of different sizes on each process (for instance when dynamically padding to the maximum length in
a batch), you should use the `),p=c("a"),v=n("pad_across_processes()"),y=n(` method to pad you tensor to the
biggest size across processes.`),this.h()},l(E){o=u(E,"P",{});var k=f(o);h=i(k,"The "),l=u(k,"A",{href:!0});var U=f(l);r=i(U,"gather()"),U.forEach(t),_=i(k,` method requires the tensors to be all the same size on each process. If
you have tensors of different sizes on each process (for instance when dynamically padding to the maximum length in
a batch), you should use the `),p=u(k,"A",{href:!0});var j=f(p);v=i(j,"pad_across_processes()"),j.forEach(t),y=i(k,` method to pad you tensor to the
biggest size across processes.`),k.forEach(t),this.h()},h(){w(l,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator.gather"),w(p,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator.pad_across_processes")},m(E,k){d(E,o,k),a(o,h),a(o,l),a(l,r),a(o,_),a(o,p),a(p,v),a(o,y)},d(E){E&&t(o)}}}function __(m){let o,h,l,r,_;return{c(){o=c("p"),h=n("Your "),l=c("code"),r=n("Accelerator"),_=n(` object should only be defined inside the training function. This is because the
initialization should be done inside the launcher only.`)},l(p){o=u(p,"P",{});var v=f(o);h=i(v,"Your "),l=u(v,"CODE",{});var y=f(l);r=i(y,"Accelerator"),y.forEach(t),_=i(v,` object should only be defined inside the training function. This is because the
initialization should be done inside the launcher only.`),v.forEach(t)},m(p,v){d(p,o,v),a(o,h),a(o,l),a(l,r),a(o,_)},d(p){p&&t(o)}}}function y_(m){let o,h,l,r,_;return{c(){o=c("p"),h=n("The "),l=c("a"),r=n("notebook_launcher()"),_=n(" does not support the DeepSpeed integration yet."),this.h()},l(p){o=u(p,"P",{});var v=f(o);h=i(v,"The "),l=u(v,"A",{href:!0});var y=f(l);r=i(y,"notebook_launcher()"),y.forEach(t),_=i(v," does not support the DeepSpeed integration yet."),v.forEach(t),this.h()},h(){w(l,"href","/docs/accelerate/pr_275/en/launcher#accelerate.notebook_launcher")},m(p,v){d(p,o,v),a(o,h),a(o,l),a(l,r),a(o,_)},d(p){p&&t(o)}}}function v_(m){let o,h;return{c(){o=c("p"),h=n(`Synchronization the main torch (or CUDA or XLA) random number generator will affect any other potential random
artifacts you could have in your dataset (like random data augmentation) in the sense all processes will get the
same random numbers from the torch random modules (so will apply the same random data augmentation if it\u2019s
controlled by torch).`)},l(l){o=u(l,"P",{});var r=f(o);h=i(r,`Synchronization the main torch (or CUDA or XLA) random number generator will affect any other potential random
artifacts you could have in your dataset (like random data augmentation) in the sense all processes will get the
same random numbers from the torch random modules (so will apply the same random data augmentation if it\u2019s
controlled by torch).`),r.forEach(t)},m(l,r){d(l,o,r),a(o,h)},d(l){l&&t(o)}}}function w_(m){let o,h,l,r,_,p,v,y;return{c(){o=c("p"),h=n(`The randomization part of your custom sampler, batch sampler or iterable dataset should be done using a local
`),l=c("code"),r=n("torch.Generator"),_=n(" object (in PyTorch >= 1.6), see the traditional "),p=c("code"),v=n("RandomSampler"),y=n(", as an example.")},l(E){o=u(E,"P",{});var k=f(o);h=i(k,`The randomization part of your custom sampler, batch sampler or iterable dataset should be done using a local
`),l=u(k,"CODE",{});var U=f(l);r=i(U,"torch.Generator"),U.forEach(t),_=i(k," object (in PyTorch >= 1.6), see the traditional "),p=u(k,"CODE",{});var j=f(p);v=i(j,"RandomSampler"),j.forEach(t),y=i(k,", as an example."),k.forEach(t)},m(E,k){d(E,o,k),a(o,h),a(o,l),a(l,r),a(o,_),a(o,p),a(p,v),a(o,y)},d(E){E&&t(o)}}}function g_(m){let o,h,l,r,_,p,v,y,E,k,U,j,z,C,A,T,L,G,O,J,kt,M,ll,pa,Bi,nl,da,fe,xi,ma,Ji,Xi,No,Fi,Ri,il,Pt,sl,_a,Wi,cl,At,Y,Vi,Io,Qi,Ki,So,Zi,es,zo,ts,as,Oo,os,rs,jo,ls,ns,Lo,is,ss,ul,W,cs,Uo,us,fs,ya,hs,ps,fl,De,hl,Tt,Ct,ds,va,ms,_s,pl,Dt,dl,Ne,ys,Mo,vs,ws,ml,Ie,_l,V,gs,Go,bs,Es,wa,$s,ks,yl,ga,Ps,vl,Se,wl,ze,As,ba,Ts,Cs,gl,Q,Ds,Ea,Ns,Is,$a,Ss,zs,bl,Oe,Os,ka,js,Ls,El,Nt,he,Us,Ho,Ms,Gs,Yo,Hs,Ys,$l,Pa,qs,kl,pe,je,qo,It,Bs,Bo,xs,Pl,K,Js,Aa,Xs,Fs,xo,Rs,Ws,Al,Le,Vs,Ta,Qs,Ks,Tl,St,Cl,Ue,Zs,Ca,ec,tc,Dl,zt,Nl,Me,Il,Ge,Sl,de,He,Jo,Ot,ac,Xo,oc,zl,X,rc,Fo,lc,nc,Ro,ic,sc,Wo,cc,uc,Ol,Da,fc,jl,jt,Ll,Ye,hc,Vo,pc,dc,Ul,Z,me,mc,Qo,_c,yc,Ko,vc,wc,gc,_e,bc,Zo,Ec,$c,er,kc,Pc,Ac,Na,Tc,tr,Cc,Ml,qe,Dc,ar,Nc,Ic,Gl,Ia,Sc,Hl,Lt,Yl,Sa,zc,ql,za,Oc,Bl,Ut,xl,Oa,jc,Jl,Mt,Xl,ja,Lc,Fl,Gt,Rl,La,Uc,Wl,ye,Be,or,Ht,Mc,rr,Gc,Vl,xe,Hc,Ua,Yc,qc,Ql,Ma,Bc,Kl,Yt,Zl,Je,en,ve,Xe,lr,qt,xc,nr,Jc,tn,Ga,Xc,an,Ha,Fc,on,Fe,ir,Rc,Wc,sr,Vc,rn,Ya,Qc,ln,ee,Kc,cr,Zc,eu,ur,tu,au,nn,Bt,sn,Re,ou,xt,ru,lu,cn,te,nu,qa,iu,su,Jt,cu,uu,un,we,We,fr,Xt,fu,hr,hu,fn,Ba,pu,hn,ge,Ve,pr,Ft,du,dr,mu,pn,xa,_u,dn,Rt,mn,Ja,yu,_n,Wt,yn,Qe,vu,mr,wu,gu,vn,Vt,wn,ae,bu,_r,Eu,$u,yr,ku,Pu,gn,be,Ke,vr,Qt,Au,wr,Tu,bn,Xa,Cu,En,Fa,Du,$n,Kt,kn,Ra,Nu,Pn,Ee,Ze,gr,Zt,Iu,br,Su,An,et,zu,Wa,Ou,ju,Tn,tt,Lu,Er,Uu,Mu,Cn,ea,Dn,at,Gu,Va,Hu,Yu,Nn,ta,In,ot,qu,$r,Bu,xu,Sn,$e,rt,kr,aa,Ju,Pr,Xu,zn,q,Fu,Ar,Ru,Wu,Tr,Vu,Qu,Cr,Ku,Zu,Dr,ef,tf,On,ke,lt,Nr,oa,af,Ir,of,jn,nt,rf,Sr,lf,nf,Ln,ra,Un,Qa,sf,Mn,Ka,cf,Gn,la,Hn,Pe,it,zr,na,uf,Or,ff,Yn,Za,hf,qn,oe,pf,jr,df,mf,Lr,_f,yf,Bn,st,xn,Ae,ct,Ur,ia,vf,Mr,wf,Jn,ut,gf,Gr,bf,Ef,Xn,re,$f,eo,kf,Pf,to,Af,Tf,Fn,ft,Cf,ao,Df,Nf,Rn,le,Hr,If,Sf,sa,zf,oo,Of,jf,Lf,ca,Uf,ro,Mf,Gf,Wn,F,Hf,Yr,Yf,qf,qr,Bf,xf,Br,Jf,Xf,Vn,ne,Ff,lo,Rf,Wf,xr,Vf,Qf,Qn,ht,Jr,Kf,Zf,ua,eh,Xr,th,ah,Kn,no,oh,Zn,pt,Te,rh,Fr,lh,nh,Rr,ih,sh,ch,Wr,uh,ei,R,fh,Vr,hh,ph,io,dh,mh,Qr,_h,yh,ti,dt,ai,mt,oi,_t,vh,so,wh,gh,ri;return l=new u_({props:{classNames:"absolute z-10 right-0 top-0",options:[{label:"Mixed",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/accelerate_doc/quicktour.ipynb"},{label:"PyTorch",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/accelerate_doc/pytorch/quicktour.ipynb"},{label:"TensorFlow",value:"https://colab.research.google.com/github/huggingface/notebooks/blob/master/accelerate_doc/tensorflow/quicktour.ipynb"},{label:"Mixed",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/accelerate_doc/quicktour.ipynb"},{label:"PyTorch",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/accelerate_doc/pytorch/quicktour.ipynb"},{label:"TensorFlow",value:"https://studiolab.sagemaker.aws/import/github/huggingface/notebooks/blob/master/accelerate_doc/tensorflow/quicktour.ipynb"}]}}),y=new x({}),O=new x({}),Pt=new H({props:{code:`from accelerate import Accelerator

accelerator = Accelerator()`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> Accelerator

accelerator = Accelerator()`}}),De=new Ce({props:{warning:"&lcub;true}",$$slots:{default:[f_]},$$scope:{ctx:m}}}),Dt=new H({props:{code:"model, optimizer, train_dataloader = accelerator.prepare(model, optimizer, train_dataloader)",highlighted:"model, optimizer, train_dataloader = accelerator.prepare(model, optimizer, train_dataloader)"}}),Ie=new Ce({props:{$$slots:{default:[h_]},$$scope:{ctx:m}}}),Se=new Ce({props:{warning:"&lcub;true}",$$slots:{default:[p_]},$$scope:{ctx:m}}}),It=new x({}),St=new H({props:{code:"validation_dataloader = accelerator.prepare(validation_dataloader)",highlighted:"validation_dataloader = accelerator.prepare(validation_dataloader)"}}),zt=new H({props:{code:`for inputs, targets in validation_dataloader:
    predictions = model(inputs)
    # Gather all predictions and targets
    all_predictions = accelerator.gather(predictions)
    all_targets = accelerator.gather(targets)
    # Example of use with a *Datasets.Metric*
    metric.add_batch(all_predictions, all_targets)`,highlighted:`<span class="hljs-keyword">for</span> inputs, targets <span class="hljs-keyword">in</span> validation_dataloader:
    predictions = model(inputs)
    <span class="hljs-comment"># Gather all predictions and targets</span>
    all_predictions = accelerator.gather(predictions)
    all_targets = accelerator.gather(targets)
    <span class="hljs-comment"># Example of use with a *Datasets.Metric*</span>
    metric.add_batch(all_predictions, all_targets)`}}),Me=new Ce({props:{warning:"&lcub;true}",$$slots:{default:[d_]},$$scope:{ctx:m}}}),Ge=new Ce({props:{warning:"&lcub;true}",$$slots:{default:[m_]},$$scope:{ctx:m}}}),Ot=new x({}),jt=new H({props:{code:"accelerate config",highlighted:"accelerate config"}}),Lt=new H({props:{code:"accelerate test",highlighted:'accelerate <span class="hljs-built_in">test</span>'}}),Ut=new H({props:{code:"accelerate test --config_file path_to_config.yaml",highlighted:'accelerate <span class="hljs-built_in">test</span> --config_file path_to_config.yaml'}}),Mt=new H({props:{code:"accelerate launch path_to_script.py --args_for_the_script",highlighted:"accelerate launch path_to_script.py --args_for_the_script"}}),Gt=new H({props:{code:"accelerate launch --config_file path_to_config.yaml path_to_script.py --args_for_the_script",highlighted:"accelerate launch --config_file path_to_config.yaml path_to_script.py --args_for_the_script"}}),Ht=new x({}),Yt=new H({props:{code:`from accelerate import notebook_launcher

notebook_launcher(training_function)`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> notebook_launcher

notebook_launcher(training_function)`}}),Je=new Ce({props:{warning:"&lcub;true}",$$slots:{default:[__]},$$scope:{ctx:m}}}),qt=new x({}),Bt=new H({props:{code:`from accelerate import DistributedType

if accelerator.distributed_type == DistributedType.TPU:
    # do something of static shape
else:
    # go crazy and be dynamic`,highlighted:`<span class="hljs-keyword">from</span> accelerate <span class="hljs-keyword">import</span> DistributedType

<span class="hljs-keyword">if</span> accelerator.distributed_type == DistributedType.TPU:
    <span class="hljs-comment"># do something of static shape</span>
<span class="hljs-keyword">else</span>:
    <span class="hljs-comment"># go crazy and be dynamic</span>`}}),Xt=new x({}),Ft=new x({}),Rt=new H({props:{code:`if accelerator.is_local_main_process:
    # Is executed once per server`,highlighted:`<span class="hljs-keyword">if</span> accelerator.is_local_main_process:
    <span class="hljs-comment"># Is executed once per server</span>`}}),Wt=new H({props:{code:`from tqdm.auto import tqdm

progress_bar = tqdm(range(args.max_train_steps), disable=not accelerator.is_local_main_process)`,highlighted:`<span class="hljs-keyword">from</span> tqdm.auto <span class="hljs-keyword">import</span> tqdm

progress_bar = tqdm(<span class="hljs-built_in">range</span>(args.max_train_steps), disable=<span class="hljs-keyword">not</span> accelerator.is_local_main_process)`}}),Vt=new H({props:{code:`if accelerator.is_main_process:
    # Is executed once only`,highlighted:`<span class="hljs-keyword">if</span> accelerator.is_main_process:
    <span class="hljs-comment"># Is executed once only</span>`}}),Qt=new x({}),Kt=new H({props:{code:"accelerator.wait_for_everyone()",highlighted:'accelerator.wait<span class="hljs-constructor">_for_everyone()</span>'}}),Zt=new x({}),ea=new H({props:{code:`accelerator.wait_for_everyone()
unwrapped_model = accelerator.unwrap_model(model)
accelerator.save(unwrapped_model.state_dict(), filename)`,highlighted:`accelerator.wait<span class="hljs-constructor">_for_everyone()</span>
unwrapped_model = accelerator.unwrap<span class="hljs-constructor">_model(<span class="hljs-params">model</span>)</span>
accelerator.save(unwrapped_model.state<span class="hljs-constructor">_dict()</span>, filename)`}}),ta=new H({props:{code:`unwrapped_model = accelerator.unwrap_model(model)
unwrapped_model.load_state_dict(torch.load(filename))`,highlighted:`unwrapped_model = accelerator.unwrap<span class="hljs-constructor">_model(<span class="hljs-params">model</span>)</span>
unwrapped_model.load<span class="hljs-constructor">_state_dict(<span class="hljs-params">torch</span>.<span class="hljs-params">load</span>(<span class="hljs-params">filename</span>)</span>)`}}),aa=new x({}),oa=new x({}),ra=new H({props:{code:`with accelerator.autocast():
    loss = complex_loss_function(outputs, target):`,highlighted:`<span class="hljs-keyword">with</span> accelerator.autocast<span class="hljs-literal">()</span>:
    loss = complex<span class="hljs-constructor">_loss_function(<span class="hljs-params">outputs</span>, <span class="hljs-params">target</span>)</span>:`}}),la=new H({props:{code:`if not accelerator.optimizer_step_was_skipped:
    lr_scheduler.step()`,highlighted:`<span class="hljs-keyword">if</span> not accelerator<span class="hljs-selector-class">.optimizer_step_was_skipped</span>:
    lr_scheduler<span class="hljs-selector-class">.step</span>()`}}),na=new x({}),st=new Ce({props:{warning:"&lcub;true}",$$slots:{default:[y_]},$$scope:{ctx:m}}}),ia=new x({}),dt=new Ce({props:{warning:"&lcub;true}",$$slots:{default:[v_]},$$scope:{ctx:m}}}),mt=new Ce({props:{$$slots:{default:[w_]},$$scope:{ctx:m}}}),{c(){o=c("meta"),h=g(),D(l.$$.fragment),r=g(),_=c("h1"),p=c("a"),v=c("span"),D(y.$$.fragment),E=g(),k=c("span"),U=n("Quick tour"),j=g(),z=c("p"),C=n("Let\u2019s have a look at a look at \u{1F917} Accelerate main features and traps to avoid."),A=g(),T=c("h2"),L=c("a"),G=c("span"),D(O.$$.fragment),J=g(),kt=c("span"),M=n("Main use"),ll=g(),pa=c("p"),Bi=n("To use \u{1F917} Accelerate in your own script, you have to change four things:"),nl=g(),da=c("ol"),fe=c("li"),xi=n("Import the "),ma=c("a"),Ji=n("Accelerator"),Xi=n(" main class instantiate one in an "),No=c("code"),Fi=n("accelerator"),Ri=n(" object:"),il=g(),D(Pt.$$.fragment),sl=g(),_a=c("p"),Wi=n(`This should happen as early as possible in your training script as it will initialize everything necessary for
distributed training. You don\u2019t need to indicate the kind of environment you are in (just one machine with a GPU, one
match with several GPUs, several machines with multiple GPUs or a TPU), the library will detect this automatically.`),cl=g(),At=c("ol"),Y=c("li"),Vi=n("Remove the call "),Io=c("code"),Qi=n(".to(device)"),Ki=n(" or "),So=c("code"),Zi=n(".cuda()"),es=n(" for your model and input data. The "),zo=c("code"),ts=n("accelerator"),as=n(` object
will handle this for you and place all those objects on the right device for you. If you know what you\u2019re doing, you
can leave those `),Oo=c("code"),os=n(".to(device)"),rs=n(" calls but you should use the device provided by the "),jo=c("code"),ls=n("accelerator"),ns=n(` object:
`),Lo=c("code"),is=n("accelerator.device"),ss=n("."),ul=g(),W=c("p"),cs=n("To fully deactivate the automatic device placement, pass along "),Uo=c("code"),us=n("device_placement=False"),fs=n(` when initializing your
`),ya=c("a"),hs=n("Accelerator"),ps=n("."),fl=g(),D(De.$$.fragment),hl=g(),Tt=c("ol"),Ct=c("li"),ds=n(`Pass all objects relevant to training (optimizer, model, training dataloader) to the
`),va=c("a"),ms=n("prepare()"),_s=n(" method. This will make sure everything is ready for training."),pl=g(),D(Dt.$$.fragment),dl=g(),Ne=c("p"),ys=n(`In particular, your training dataloader will be sharded accross all GPUs/TPU cores available so that each one sees a
different portion of the training dataset. Also, the random states of all processes will be synchronized at the
beginning of each iteration through your dataloader, to make sure the data is shuffled the same way (if you decided to
use `),Mo=c("code"),vs=n("shuffle=True"),ws=n(" or any kind of random sampler)."),ml=g(),D(Ie.$$.fragment),_l=g(),V=c("p"),gs=n("Alternatively, you can use the option "),Go=c("code"),bs=n("split_batches=True"),Es=n(` when creating initializing your
`),wa=c("a"),$s=n("Accelerator"),ks=n(`, in which case the batch size will always stay the same, whether your run your
script on 1, 2, 4 or 64 GPUs.`),yl=g(),ga=c("p"),Ps=n(`You should execute this instruction as soon as all objects for training are created, before starting your actual
training loop.`),vl=g(),D(Se.$$.fragment),wl=g(),ze=c("p"),As=n(`Any instruction using your training dataloader length (for instance if you need the number of total training steps
to create a learning rate scheduler) should go after the call to `),ba=c("a"),Ts=n("prepare()"),Cs=n("."),gl=g(),Q=c("p"),Ds=n("You can perfectly send your dataloader to "),Ea=c("a"),Ns=n("prepare()"),Is=n(` on its own, but it\u2019s best to send the
model and optimizer to `),$a=c("a"),Ss=n("prepare()"),zs=n(" together."),bl=g(),Oe=c("p"),Os=n("You may or may not want to send your validation dataloader to "),ka=c("a"),js=n("prepare()"),Ls=n(`, depending on
whether you want to run distributed evaluation or not (see below).`),El=g(),Nt=c("ol"),he=c("li"),Us=n("Replace the line "),Ho=c("code"),Ms=n("loss.backward()"),Gs=n(" by "),Yo=c("code"),Hs=n("accelerator.backward(loss)"),Ys=n("."),$l=g(),Pa=c("p"),qs=n(`And you\u2019re all set! With all these changes, your script will run on your local machine as well as on multiple GPUs or a
TPU! You can either use your favorite tool to launch the distributed training, or you can use the \u{1F917} Accelerate
launcher.`),kl=g(),pe=c("h2"),je=c("a"),qo=c("span"),D(It.$$.fragment),Bs=g(),Bo=c("span"),xs=n("Distributed evaluation"),Pl=g(),K=c("p"),Js=n(`You can perform regular evaluation in your training script, if you leave your validation dataloader out of the
`),Aa=c("a"),Xs=n("prepare()"),Fs=n(` method. In this case, you will need to put the input data on the
`),xo=c("code"),Rs=n("accelerator.device"),Ws=n(" manually."),Al=g(),Le=c("p"),Vs=n("To perform distributed evaluation, send along your validation dataloader to the "),Ta=c("a"),Qs=n("prepare()"),Ks=n(`
method:`),Tl=g(),D(St.$$.fragment),Cl=g(),Ue=c("p"),Zs=n(`Like for your training dataloader, it will mean that (should you run your script on multiple devices) each device will
only see part of the evaluation data. This means you will need to group your predictions together. This is very easy to
do with the `),Ca=c("a"),ec=n("gather()"),tc=n(" method."),Dl=g(),D(zt.$$.fragment),Nl=g(),D(Me.$$.fragment),Il=g(),D(Ge.$$.fragment),Sl=g(),de=c("h2"),He=c("a"),Jo=c("span"),D(Ot.$$.fragment),ac=g(),Xo=c("span"),oc=n("Launching your distributed script"),zl=g(),X=c("p"),rc=n("You can use the regular commands to launch your distributed training (like "),Fo=c("code"),lc=n("torch.distributed.launch"),nc=n(` for
PyTorch), they are fully compatible with \u{1F917} Accelerate. The only caveat here is that \u{1F917} Accelerate uses the environment
to determine all useful information, so `),Ro=c("code"),ic=n("torch.distributed.launch"),sc=n(" should be used with the flag "),Wo=c("code"),cc=n("--use_env"),uc=n("."),Ol=g(),Da=c("p"),fc=n(`\u{1F917} Accelerate also provides a CLI tool that unifies all launcher, so you only have to remember one command. To use it,
just run`),jl=g(),D(jt.$$.fragment),Ll=g(),Ye=c("p"),hc=n("on your machine and reply to the questions asked. This will save a "),Vo=c("em"),pc=n("default_config.yaml"),dc=n(` file in your cache folder for
\u{1F917} Accelerate. That cache folder is (with decreasing order of priority):`),Ul=g(),Z=c("ul"),me=c("li"),mc=n("The content of your environment variable "),Qo=c("code"),_c=n("HF_HOME"),yc=n(" suffixed with "),Ko=c("em"),vc=n("accelerate"),wc=n("."),gc=g(),_e=c("li"),bc=n("If it does not exist, the content of your environment variable "),Zo=c("code"),Ec=n("XDG_CACHE_HOME"),$c=n(` suffixed with
`),er=c("em"),kc=n("huggingface/accelerate"),Pc=n("."),Ac=g(),Na=c("li"),Tc=n("If this does not exist either, the folder "),tr=c("em"),Cc=n("~/.cache/huggingface/accelerate"),Ml=g(),qe=c("p"),Dc=n("You can also specify with the flag "),ar=c("code"),Nc=n("--config_file"),Ic=n(" the location of the file you want to save."),Gl=g(),Ia=c("p"),Sc=n("Once this is done, you can test everything is going well on your setup by running"),Hl=g(),D(Lt.$$.fragment),Yl=g(),Sa=c("p"),zc=n(`This will launch a short script that will test the distributed environment. If it runs fine, you are ready for the next
step!`),ql=g(),za=c("p"),Oc=n("Note that if you specified a location for the config file in the previous step, you need to pass it here as well:"),Bl=g(),D(Ut.$$.fragment),xl=g(),Oa=c("p"),jc=n("Now that this is done, you can run your script with the following command:"),Jl=g(),D(Mt.$$.fragment),Xl=g(),ja=c("p"),Lc=n("If you stored the config file in a non-default location, you can indicate it to the launcher like his:"),Fl=g(),D(Gt.$$.fragment),Rl=g(),La=c("p"),Uc=n("You can also override any of the arguments determined by your config file, see TODO: insert ref here."),Wl=g(),ye=c("h2"),Be=c("a"),or=c("span"),D(Ht.$$.fragment),Mc=g(),rr=c("span"),Gc=n("Launching training from a notebook"),Vl=g(),xe=c("p"),Hc=n("In Accelerate 0.3.0, a new "),Ua=c("a"),Yc=n("notebook_launcher()"),qc=n(` has been introduced to help you launch your training
function from a notebook. This launcher supports launching a training with TPUs on Colab or Kaggle, as well as training
on several GPUs (if the machine on which you are running your notebook has them).`),Ql=g(),Ma=c("p"),Bc=n(`Just define a function responsible for your whole training and/or evaluation in a cell of the notebook, then execute a
cell with the following code:`),Kl=g(),D(Yt.$$.fragment),Zl=g(),D(Je.$$.fragment),en=g(),ve=c("h2"),Xe=c("a"),lr=c("span"),D(qt.$$.fragment),xc=g(),nr=c("span"),Jc=n("Training on TPU"),tn=g(),Ga=c("p"),Xc=n(`If you want to launch your script on TPUs, there are a few caveats you should be aware of. Behind the scenes, the TPUs
will create a graph of all the operations happening in your training step (forward pass, backward pass and optimizer
step). This is why your first step of training will always be very long as building and compiling this graph for
optimizations takes some time.`),an=g(),Ha=c("p"),Fc=n(`The good news is that this compilation will be cached so the second step and all the following will be much faster. The
bas news is that it only applies if all of your steps do exactly the same operations, which implies:`),on=g(),Fe=c("ul"),ir=c("li"),Rc=n("having all tensors of the same length in all your lengths"),Wc=g(),sr=c("li"),Vc=n("having static code (i.e., not a for loop of length that could change from step to step)"),rn=g(),Ya=c("p"),Qc=n(`Having any of the things above change between two steps will trigger a new compilation which will, once again, take a
lot of time. In practice, that means you must take special care to have all your tensors in your inputs of the same
shape (so no dynamic padding for instance if you are in an NLP problem) and should not use layer with for loops that
have different lengths depending on the inputs (such as an LSTM) or the training will be excruciatingly slow.`),ln=g(),ee=c("p"),Kc=n("To introduce special behavior in your script for TPUs you can check the "),cr=c("code"),Zc=n("distributed_type"),eu=n(` of your
`),ur=c("code"),tu=n("accelerator"),au=n(":"),nn=g(),D(Bt.$$.fragment),sn=g(),Re=c("p"),ou=n("The "),xt=c("a"),ru=n("NLP example"),lu=n(` shows an example in
situation with dynamic padding.`),cn=g(),te=c("p"),nu=n(`One last thing to pay close attnetion to: if your model has tied weights (such as language models which tie the weights
of the embedding matrix with the weights of the decoder), moving this model to the TPU (either yourself or after you
passed your model to `),qa=c("a"),iu=n("prepare()"),su=n(`) will break the tying. You will need to retie the weights
after. You can find an example of this in the `),Jt=c("a"),cu=n("run_clm_no_trainer"),uu=n(` script in
the Transformers repository.`),un=g(),we=c("h2"),We=c("a"),fr=c("span"),D(Xt.$$.fragment),fu=g(),hr=c("span"),hu=n("Other caveats"),fn=g(),Ba=c("p"),pu=n("We list here all smaller issues you could have in your script conversion and how to resolve them."),hn=g(),ge=c("h3"),Ve=c("a"),pr=c("span"),D(Ft.$$.fragment),du=g(),dr=c("span"),mu=n("Execute a statement only on one processes"),pn=g(),xa=c("p"),_u=n(`Some of your instructions only need to run for one process on a given server: for instance a data download or a log
statement. To do this, wrap the statement in a test like this:`),dn=g(),D(Rt.$$.fragment),mn=g(),Ja=c("p"),yu=n(`Another example is progress bars: to avoid having multiple progress bars in your output, you should only display one on
the local main process:`),_n=g(),D(Wt.$$.fragment),yn=g(),Qe=c("p"),vu=n("The "),mr=c("em"),wu=n("local"),gu=n(` means per machine: if you are running your training on two servers with several GPUs, the instruction will
be executed once on each of those servers. If you need to execute something only once for all processes (and not per
machine) for instance, uploading the final model to the \u{1F917} model hub, wrap it in a test like this:`),vn=g(),D(Vt.$$.fragment),wn=g(),ae=c("p"),bu=n("For printing statements you only want executed once per machine, you can just replace the "),_r=c("code"),Eu=n("print"),$u=n(` function by
`),yr=c("code"),ku=n("accelerator.print"),Pu=n("."),gn=g(),be=c("h3"),Ke=c("a"),vr=c("span"),D(Qt.$$.fragment),Au=g(),wr=c("span"),Tu=n("Defer execution"),bn=g(),Xa=c("p"),Cu=n(`When you run your usual script, instructions are executed in order. Using \u{1F917} Accelerate to deploy your script on several
GPUs at the same time introduces a complication: while each process executes all instructions in order, some may be
faster than others.`),En=g(),Fa=c("p"),Du=n(`You might need to wait for all processes to have reached a certain point before executing a given instruction. For
instance, you shouldn\u2019t save a model before being sure every process is done with training. To do this, just write the
following line in your code:`),$n=g(),D(Kt.$$.fragment),kn=g(),Ra=c("p"),Nu=n(`This instruction will block all the processes that arrive them first until all the other processes have reached that
point (if you run your script on just one GPU or CPU, this wont\u2019 do anything).`),Pn=g(),Ee=c("h3"),Ze=c("a"),gr=c("span"),D(Zt.$$.fragment),Iu=g(),br=c("span"),Su=n("Saving/loading a model"),An=g(),et=c("p"),zu=n(`Saving the model you trained might need a bit of adjustment: first you should wait for all processes to reach that
point in the script as shown above, and then, you should unwrap your model before saving it. This is because when going
through the `),Wa=c("a"),Ou=n("prepare()"),ju=n(` method, your model may have been placed inside a bigger model,
which deals with the distributed training. This in turn means that saving your model state dictionary without taking
any precaution will take that potential extra layer into account, and you will end up with weights you can\u2019t load back
in your base model.`),Tn=g(),tt=c("p"),Lu=n("This is why it\u2019s recommended to "),Er=c("em"),Uu=n("unwrap"),Mu=n(" your model first. Here is an example:"),Cn=g(),D(ea.$$.fragment),Dn=g(),at=c("p"),Gu=n(`If your script contains a logic to load checkpoint, we also recommend you load your weights in the unwrapped model
(this is only useful if you use the load function after making your model go through
`),Va=c("a"),Hu=n("prepare()"),Yu=n("). Here is an example:"),Nn=g(),D(ta.$$.fragment),In=g(),ot=c("p"),qu=n("Note that since all the model parameters are references to tensors, this will load your weights inside "),$r=c("code"),Bu=n("model"),xu=n("."),Sn=g(),$e=c("h3"),rt=c("a"),kr=c("span"),D(aa.$$.fragment),Ju=g(),Pr=c("span"),Xu=n("Gradient clipping"),zn=g(),q=c("p"),Fu=n(`If you are using gradient clipping in your script, you should replace the calls to
`),Ar=c("code"),Ru=n("torch.nn.utils.clip_grad_norm_"),Wu=n(" or "),Tr=c("code"),Vu=n("torch.nn.utils.clip_grad_value_"),Qu=n(" with "),Cr=c("code"),Ku=n("accelerator.clip_grad_norm_"),Zu=n(`
and `),Dr=c("code"),ef=n("accelerator.clip_grad_value_"),tf=n(" respectively."),On=g(),ke=c("h3"),lt=c("a"),Nr=c("span"),D(oa.$$.fragment),af=g(),Ir=c("span"),of=n("Mixed Precision training"),jn=g(),nt=c("p"),rf=n(`If you are running your training in Mixed Precision with Accelerate, you will get the best result with your loss being
computed inside your model (like in Transformer models for instance). Every computation outside of the model will be
executed in full precision (which is generally what you want for loss computation, expecially if it involves a
softmax). However you might want to put your loss computation inside the `),Sr=c("em"),lf=n("accelerator.autocast"),nf=n(" context manager:"),Ln=g(),D(ra.$$.fragment),Un=g(),Qa=c("p"),sf=n(`Another caveat with Mixed Precision training is that the gradient will skip a few updates at the beginning and
sometimes during training: because of the dynamic loss scaling strategy, there are points during training where the
gradients have overflown, and the loss scaling factor is reduced to avoid this happening again at the next step.`),Mn=g(),Ka=c("p"),cf=n(`This means that you may update your learning rate scheduler when there was no update, which is fine in general, but may
have an impact when you have very little training data, or if the first learning rate values of your scheduler are very
important. In this case, you can skip the learning rate scheduler updates when the optimizer step was not done like
this:`),Gn=g(),D(la.$$.fragment),Hn=g(),Pe=c("h3"),it=c("a"),zr=c("span"),D(na.$$.fragment),uf=g(),Or=c("span"),ff=n("DeepSpeed"),Yn=g(),Za=c("p"),hf=n(`DeepSpeed support is experimental, so the underlying API will evolve in the near future and may have some slight
breaking changes. In particular, \u{1F917} Accelerate does not support DeepSpeed config you have written yourself yet, this
will be added in a next version.`),qn=g(),oe=c("p"),pf=n("One main caveat for the DeepSpeed integration is that the DeepSpeed launcher always passes a "),jr=c("code"),df=n("local_rank"),mf=n(` variable to
the training script, so your training script should accept it (whether you launch training with the DeepSpeed launcher
or `),Lr=c("code"),_f=n("accelerate launch"),yf=n(")."),Bn=g(),D(st.$$.fragment),xn=g(),Ae=c("h2"),ct=c("a"),Ur=c("span"),D(ia.$$.fragment),vf=g(),Mr=c("span"),wf=n("Internal mechanism"),Jn=g(),ut=c("p"),gf=n(`Internally, the library works by first analyzing the environment in which the script is launched to determine which
kind of distributed setup is used, how many different processes there are and which one the current script is in. All
that information is stored in the `),Gr=c("code"),bf=n("~AcceleratorState"),Ef=n("."),Xn=g(),re=c("p"),$f=n("This class is initialized the first time you instantiate a "),eo=c("a"),kf=n("Accelerator"),Pf=n(` as well as performing any
specific initialization your distributed setup needs. Its state is then uniquely shared through all instances of
`),to=c("a"),Af=n("AcceleratorState"),Tf=n("."),Fn=g(),ft=c("p"),Cf=n("Then, when calling "),ao=c("a"),Df=n("prepare()"),Nf=n(", the library:"),Rn=g(),le=c("ul"),Hr=c("li"),If=n("wraps your model(s) in the container adapted for the distributed setup,"),Sf=g(),sa=c("li"),zf=n("wraps your optimizer(s) in a "),oo=c("a"),Of=n("AcceleratedOptimizer"),jf=n(","),Lf=g(),ca=c("li"),Uf=n("creates a new version of your dataloader(s) in a "),ro=c("a"),Mf=n("DataLoaderShard"),Gf=n("."),Wn=g(),F=c("p"),Hf=n(`While the model(s) and optimizer(s) are just put in simple wrappers, the dataloader(s) are re-created. This is mostly
because PyTorch does not let the user change the `),Yr=c("code"),Yf=n("batch_sampler"),qf=n(` of a dataloader once it\u2019s been created and the
library handles the sharding of your data between processes by changing that `),qr=c("code"),Bf=n("batch_sampler"),xf=n(` to yield every other
`),Br=c("code"),Jf=n("num_processes"),Xf=n(" batches."),Vn=g(),ne=c("p"),Ff=n("The "),lo=c("a"),Rf=n("DataLoaderShard"),Wf=n(" subclasses "),xr=c("code"),Vf=n("DataLoader"),Qf=n(" to add the following functionality:"),Qn=g(),ht=c("ul"),Jr=c("li"),Kf=n(`it synchronizes the appropriate random number generator of all processes at each new iteration, to ensure any
randomization (like shuffling) is done the exact same way across processes.`),Zf=g(),ua=c("li"),eh=n(`it puts the batches on the proper device before yielding them (unless you have opted out of
`),Xr=c("code"),th=n("device_placement=True"),ah=n(")."),Kn=g(),no=c("p"),oh=n("The random number generator synchronization will by default synchronize:"),Zn=g(),pt=c("ul"),Te=c("li"),rh=n("the "),Fr=c("code"),lh=n("generator"),nh=n(" attribute of a given sampler (like the PyTorch "),Rr=c("code"),ih=n("RandomSampler"),sh=n(") for PyTorch >= 1.6"),ch=g(),Wr=c("li"),uh=n("the main random number generator in PyTorch <=1.5.1"),ei=g(),R=c("p"),fh=n("You can choose which random number generator(s) to synchronize with the "),Vr=c("code"),hh=n("rng_types"),ph=n(` argument of the main
`),io=c("a"),dh=n("Accelerator"),mh=n(". In PyTorch >= 1.6, it is recommended to rely on local "),Qr=c("code"),_h=n("generator"),yh=n(` to avoid
setting the same seed in the main random number generator in all processes.`),ti=g(),D(dt.$$.fragment),ai=g(),D(mt.$$.fragment),oi=g(),_t=c("p"),vh=n("See more details about the internal in the "),so=c("a"),wh=n("Internals page"),gh=n("."),this.h()},l(e){const s=Im('[data-svelte="svelte-1phssyn"]',document.head);o=u(s,"META",{name:!0,content:!0}),s.forEach(t),h=b(e),S(l.$$.fragment,e),r=b(e),_=u(e,"H1",{class:!0});var fa=f(_);p=u(fa,"A",{id:!0,class:!0,href:!0});var Kr=f(p);v=u(Kr,"SPAN",{});var Zr=f(v);S(y.$$.fragment,Zr),Zr.forEach(t),Kr.forEach(t),E=b(fa),k=u(fa,"SPAN",{});var el=f(k);U=i(el,"Quick tour"),el.forEach(t),fa.forEach(t),j=b(e),z=u(e,"P",{});var tl=f(z);C=i(tl,"Let\u2019s have a look at a look at \u{1F917} Accelerate main features and traps to avoid."),tl.forEach(t),A=b(e),T=u(e,"H2",{class:!0});var ha=f(T);L=u(ha,"A",{id:!0,class:!0,href:!0});var al=f(L);G=u(al,"SPAN",{});var ol=f(G);S(O.$$.fragment,ol),ol.forEach(t),al.forEach(t),J=b(ha),kt=u(ha,"SPAN",{});var rl=f(kt);M=i(rl,"Main use"),rl.forEach(t),ha.forEach(t),ll=b(e),pa=u(e,"P",{});var $h=f(pa);Bi=i($h,"To use \u{1F917} Accelerate in your own script, you have to change four things:"),$h.forEach(t),nl=b(e),da=u(e,"OL",{});var kh=f(da);fe=u(kh,"LI",{});var co=f(fe);xi=i(co,"Import the "),ma=u(co,"A",{href:!0});var Ph=f(ma);Ji=i(Ph,"Accelerator"),Ph.forEach(t),Xi=i(co," main class instantiate one in an "),No=u(co,"CODE",{});var Ah=f(No);Fi=i(Ah,"accelerator"),Ah.forEach(t),Ri=i(co," object:"),co.forEach(t),kh.forEach(t),il=b(e),S(Pt.$$.fragment,e),sl=b(e),_a=u(e,"P",{});var Th=f(_a);Wi=i(Th,`This should happen as early as possible in your training script as it will initialize everything necessary for
distributed training. You don\u2019t need to indicate the kind of environment you are in (just one machine with a GPU, one
match with several GPUs, several machines with multiple GPUs or a TPU), the library will detect this automatically.`),Th.forEach(t),cl=b(e),At=u(e,"OL",{start:!0});var Ch=f(At);Y=u(Ch,"LI",{});var B=f(Y);Vi=i(B,"Remove the call "),Io=u(B,"CODE",{});var Dh=f(Io);Qi=i(Dh,".to(device)"),Dh.forEach(t),Ki=i(B," or "),So=u(B,"CODE",{});var Nh=f(So);Zi=i(Nh,".cuda()"),Nh.forEach(t),es=i(B," for your model and input data. The "),zo=u(B,"CODE",{});var Ih=f(zo);ts=i(Ih,"accelerator"),Ih.forEach(t),as=i(B,` object
will handle this for you and place all those objects on the right device for you. If you know what you\u2019re doing, you
can leave those `),Oo=u(B,"CODE",{});var Sh=f(Oo);os=i(Sh,".to(device)"),Sh.forEach(t),rs=i(B," calls but you should use the device provided by the "),jo=u(B,"CODE",{});var zh=f(jo);ls=i(zh,"accelerator"),zh.forEach(t),ns=i(B,` object:
`),Lo=u(B,"CODE",{});var Oh=f(Lo);is=i(Oh,"accelerator.device"),Oh.forEach(t),ss=i(B,"."),B.forEach(t),Ch.forEach(t),ul=b(e),W=u(e,"P",{});var uo=f(W);cs=i(uo,"To fully deactivate the automatic device placement, pass along "),Uo=u(uo,"CODE",{});var jh=f(Uo);us=i(jh,"device_placement=False"),jh.forEach(t),fs=i(uo,` when initializing your
`),ya=u(uo,"A",{href:!0});var Lh=f(ya);hs=i(Lh,"Accelerator"),Lh.forEach(t),ps=i(uo,"."),uo.forEach(t),fl=b(e),S(De.$$.fragment,e),hl=b(e),Tt=u(e,"OL",{start:!0});var Uh=f(Tt);Ct=u(Uh,"LI",{});var li=f(Ct);ds=i(li,`Pass all objects relevant to training (optimizer, model, training dataloader) to the
`),va=u(li,"A",{href:!0});var Mh=f(va);ms=i(Mh,"prepare()"),Mh.forEach(t),_s=i(li," method. This will make sure everything is ready for training."),li.forEach(t),Uh.forEach(t),pl=b(e),S(Dt.$$.fragment,e),dl=b(e),Ne=u(e,"P",{});var ni=f(Ne);ys=i(ni,`In particular, your training dataloader will be sharded accross all GPUs/TPU cores available so that each one sees a
different portion of the training dataset. Also, the random states of all processes will be synchronized at the
beginning of each iteration through your dataloader, to make sure the data is shuffled the same way (if you decided to
use `),Mo=u(ni,"CODE",{});var Gh=f(Mo);vs=i(Gh,"shuffle=True"),Gh.forEach(t),ws=i(ni," or any kind of random sampler)."),ni.forEach(t),ml=b(e),S(Ie.$$.fragment,e),_l=b(e),V=u(e,"P",{});var fo=f(V);gs=i(fo,"Alternatively, you can use the option "),Go=u(fo,"CODE",{});var Hh=f(Go);bs=i(Hh,"split_batches=True"),Hh.forEach(t),Es=i(fo,` when creating initializing your
`),wa=u(fo,"A",{href:!0});var Yh=f(wa);$s=i(Yh,"Accelerator"),Yh.forEach(t),ks=i(fo,`, in which case the batch size will always stay the same, whether your run your
script on 1, 2, 4 or 64 GPUs.`),fo.forEach(t),yl=b(e),ga=u(e,"P",{});var qh=f(ga);Ps=i(qh,`You should execute this instruction as soon as all objects for training are created, before starting your actual
training loop.`),qh.forEach(t),vl=b(e),S(Se.$$.fragment,e),wl=b(e),ze=u(e,"P",{});var ii=f(ze);As=i(ii,`Any instruction using your training dataloader length (for instance if you need the number of total training steps
to create a learning rate scheduler) should go after the call to `),ba=u(ii,"A",{href:!0});var Bh=f(ba);Ts=i(Bh,"prepare()"),Bh.forEach(t),Cs=i(ii,"."),ii.forEach(t),gl=b(e),Q=u(e,"P",{});var ho=f(Q);Ds=i(ho,"You can perfectly send your dataloader to "),Ea=u(ho,"A",{href:!0});var xh=f(Ea);Ns=i(xh,"prepare()"),xh.forEach(t),Is=i(ho,` on its own, but it\u2019s best to send the
model and optimizer to `),$a=u(ho,"A",{href:!0});var Jh=f($a);Ss=i(Jh,"prepare()"),Jh.forEach(t),zs=i(ho," together."),ho.forEach(t),bl=b(e),Oe=u(e,"P",{});var si=f(Oe);Os=i(si,"You may or may not want to send your validation dataloader to "),ka=u(si,"A",{href:!0});var Xh=f(ka);js=i(Xh,"prepare()"),Xh.forEach(t),Ls=i(si,`, depending on
whether you want to run distributed evaluation or not (see below).`),si.forEach(t),El=b(e),Nt=u(e,"OL",{start:!0});var Fh=f(Nt);he=u(Fh,"LI",{});var po=f(he);Us=i(po,"Replace the line "),Ho=u(po,"CODE",{});var Rh=f(Ho);Ms=i(Rh,"loss.backward()"),Rh.forEach(t),Gs=i(po," by "),Yo=u(po,"CODE",{});var Wh=f(Yo);Hs=i(Wh,"accelerator.backward(loss)"),Wh.forEach(t),Ys=i(po,"."),po.forEach(t),Fh.forEach(t),$l=b(e),Pa=u(e,"P",{});var Vh=f(Pa);qs=i(Vh,`And you\u2019re all set! With all these changes, your script will run on your local machine as well as on multiple GPUs or a
TPU! You can either use your favorite tool to launch the distributed training, or you can use the \u{1F917} Accelerate
launcher.`),Vh.forEach(t),kl=b(e),pe=u(e,"H2",{class:!0});var ci=f(pe);je=u(ci,"A",{id:!0,class:!0,href:!0});var Qh=f(je);qo=u(Qh,"SPAN",{});var Kh=f(qo);S(It.$$.fragment,Kh),Kh.forEach(t),Qh.forEach(t),Bs=b(ci),Bo=u(ci,"SPAN",{});var Zh=f(Bo);xs=i(Zh,"Distributed evaluation"),Zh.forEach(t),ci.forEach(t),Pl=b(e),K=u(e,"P",{});var mo=f(K);Js=i(mo,`You can perform regular evaluation in your training script, if you leave your validation dataloader out of the
`),Aa=u(mo,"A",{href:!0});var ep=f(Aa);Xs=i(ep,"prepare()"),ep.forEach(t),Fs=i(mo,` method. In this case, you will need to put the input data on the
`),xo=u(mo,"CODE",{});var tp=f(xo);Rs=i(tp,"accelerator.device"),tp.forEach(t),Ws=i(mo," manually."),mo.forEach(t),Al=b(e),Le=u(e,"P",{});var ui=f(Le);Vs=i(ui,"To perform distributed evaluation, send along your validation dataloader to the "),Ta=u(ui,"A",{href:!0});var ap=f(Ta);Qs=i(ap,"prepare()"),ap.forEach(t),Ks=i(ui,`
method:`),ui.forEach(t),Tl=b(e),S(St.$$.fragment,e),Cl=b(e),Ue=u(e,"P",{});var fi=f(Ue);Zs=i(fi,`Like for your training dataloader, it will mean that (should you run your script on multiple devices) each device will
only see part of the evaluation data. This means you will need to group your predictions together. This is very easy to
do with the `),Ca=u(fi,"A",{href:!0});var op=f(Ca);ec=i(op,"gather()"),op.forEach(t),tc=i(fi," method."),fi.forEach(t),Dl=b(e),S(zt.$$.fragment,e),Nl=b(e),S(Me.$$.fragment,e),Il=b(e),S(Ge.$$.fragment,e),Sl=b(e),de=u(e,"H2",{class:!0});var hi=f(de);He=u(hi,"A",{id:!0,class:!0,href:!0});var rp=f(He);Jo=u(rp,"SPAN",{});var lp=f(Jo);S(Ot.$$.fragment,lp),lp.forEach(t),rp.forEach(t),ac=b(hi),Xo=u(hi,"SPAN",{});var np=f(Xo);oc=i(np,"Launching your distributed script"),np.forEach(t),hi.forEach(t),zl=b(e),X=u(e,"P",{});var yt=f(X);rc=i(yt,"You can use the regular commands to launch your distributed training (like "),Fo=u(yt,"CODE",{});var ip=f(Fo);lc=i(ip,"torch.distributed.launch"),ip.forEach(t),nc=i(yt,` for
PyTorch), they are fully compatible with \u{1F917} Accelerate. The only caveat here is that \u{1F917} Accelerate uses the environment
to determine all useful information, so `),Ro=u(yt,"CODE",{});var sp=f(Ro);ic=i(sp,"torch.distributed.launch"),sp.forEach(t),sc=i(yt," should be used with the flag "),Wo=u(yt,"CODE",{});var cp=f(Wo);cc=i(cp,"--use_env"),cp.forEach(t),uc=i(yt,"."),yt.forEach(t),Ol=b(e),Da=u(e,"P",{});var up=f(Da);fc=i(up,`\u{1F917} Accelerate also provides a CLI tool that unifies all launcher, so you only have to remember one command. To use it,
just run`),up.forEach(t),jl=b(e),S(jt.$$.fragment,e),Ll=b(e),Ye=u(e,"P",{});var pi=f(Ye);hc=i(pi,"on your machine and reply to the questions asked. This will save a "),Vo=u(pi,"EM",{});var fp=f(Vo);pc=i(fp,"default_config.yaml"),fp.forEach(t),dc=i(pi,` file in your cache folder for
\u{1F917} Accelerate. That cache folder is (with decreasing order of priority):`),pi.forEach(t),Ul=b(e),Z=u(e,"UL",{});var _o=f(Z);me=u(_o,"LI",{});var yo=f(me);mc=i(yo,"The content of your environment variable "),Qo=u(yo,"CODE",{});var hp=f(Qo);_c=i(hp,"HF_HOME"),hp.forEach(t),yc=i(yo," suffixed with "),Ko=u(yo,"EM",{});var pp=f(Ko);vc=i(pp,"accelerate"),pp.forEach(t),wc=i(yo,"."),yo.forEach(t),gc=b(_o),_e=u(_o,"LI",{});var vo=f(_e);bc=i(vo,"If it does not exist, the content of your environment variable "),Zo=u(vo,"CODE",{});var dp=f(Zo);Ec=i(dp,"XDG_CACHE_HOME"),dp.forEach(t),$c=i(vo,` suffixed with
`),er=u(vo,"EM",{});var mp=f(er);kc=i(mp,"huggingface/accelerate"),mp.forEach(t),Pc=i(vo,"."),vo.forEach(t),Ac=b(_o),Na=u(_o,"LI",{});var bh=f(Na);Tc=i(bh,"If this does not exist either, the folder "),tr=u(bh,"EM",{});var _p=f(tr);Cc=i(_p,"~/.cache/huggingface/accelerate"),_p.forEach(t),bh.forEach(t),_o.forEach(t),Ml=b(e),qe=u(e,"P",{});var di=f(qe);Dc=i(di,"You can also specify with the flag "),ar=u(di,"CODE",{});var yp=f(ar);Nc=i(yp,"--config_file"),yp.forEach(t),Ic=i(di," the location of the file you want to save."),di.forEach(t),Gl=b(e),Ia=u(e,"P",{});var vp=f(Ia);Sc=i(vp,"Once this is done, you can test everything is going well on your setup by running"),vp.forEach(t),Hl=b(e),S(Lt.$$.fragment,e),Yl=b(e),Sa=u(e,"P",{});var wp=f(Sa);zc=i(wp,`This will launch a short script that will test the distributed environment. If it runs fine, you are ready for the next
step!`),wp.forEach(t),ql=b(e),za=u(e,"P",{});var gp=f(za);Oc=i(gp,"Note that if you specified a location for the config file in the previous step, you need to pass it here as well:"),gp.forEach(t),Bl=b(e),S(Ut.$$.fragment,e),xl=b(e),Oa=u(e,"P",{});var bp=f(Oa);jc=i(bp,"Now that this is done, you can run your script with the following command:"),bp.forEach(t),Jl=b(e),S(Mt.$$.fragment,e),Xl=b(e),ja=u(e,"P",{});var Ep=f(ja);Lc=i(Ep,"If you stored the config file in a non-default location, you can indicate it to the launcher like his:"),Ep.forEach(t),Fl=b(e),S(Gt.$$.fragment,e),Rl=b(e),La=u(e,"P",{});var $p=f(La);Uc=i($p,"You can also override any of the arguments determined by your config file, see TODO: insert ref here."),$p.forEach(t),Wl=b(e),ye=u(e,"H2",{class:!0});var mi=f(ye);Be=u(mi,"A",{id:!0,class:!0,href:!0});var kp=f(Be);or=u(kp,"SPAN",{});var Pp=f(or);S(Ht.$$.fragment,Pp),Pp.forEach(t),kp.forEach(t),Mc=b(mi),rr=u(mi,"SPAN",{});var Ap=f(rr);Gc=i(Ap,"Launching training from a notebook"),Ap.forEach(t),mi.forEach(t),Vl=b(e),xe=u(e,"P",{});var _i=f(xe);Hc=i(_i,"In Accelerate 0.3.0, a new "),Ua=u(_i,"A",{href:!0});var Tp=f(Ua);Yc=i(Tp,"notebook_launcher()"),Tp.forEach(t),qc=i(_i,` has been introduced to help you launch your training
function from a notebook. This launcher supports launching a training with TPUs on Colab or Kaggle, as well as training
on several GPUs (if the machine on which you are running your notebook has them).`),_i.forEach(t),Ql=b(e),Ma=u(e,"P",{});var Cp=f(Ma);Bc=i(Cp,`Just define a function responsible for your whole training and/or evaluation in a cell of the notebook, then execute a
cell with the following code:`),Cp.forEach(t),Kl=b(e),S(Yt.$$.fragment,e),Zl=b(e),S(Je.$$.fragment,e),en=b(e),ve=u(e,"H2",{class:!0});var yi=f(ve);Xe=u(yi,"A",{id:!0,class:!0,href:!0});var Dp=f(Xe);lr=u(Dp,"SPAN",{});var Np=f(lr);S(qt.$$.fragment,Np),Np.forEach(t),Dp.forEach(t),xc=b(yi),nr=u(yi,"SPAN",{});var Ip=f(nr);Jc=i(Ip,"Training on TPU"),Ip.forEach(t),yi.forEach(t),tn=b(e),Ga=u(e,"P",{});var Sp=f(Ga);Xc=i(Sp,`If you want to launch your script on TPUs, there are a few caveats you should be aware of. Behind the scenes, the TPUs
will create a graph of all the operations happening in your training step (forward pass, backward pass and optimizer
step). This is why your first step of training will always be very long as building and compiling this graph for
optimizations takes some time.`),Sp.forEach(t),an=b(e),Ha=u(e,"P",{});var zp=f(Ha);Fc=i(zp,`The good news is that this compilation will be cached so the second step and all the following will be much faster. The
bas news is that it only applies if all of your steps do exactly the same operations, which implies:`),zp.forEach(t),on=b(e),Fe=u(e,"UL",{});var vi=f(Fe);ir=u(vi,"LI",{});var Op=f(ir);Rc=i(Op,"having all tensors of the same length in all your lengths"),Op.forEach(t),Wc=b(vi),sr=u(vi,"LI",{});var jp=f(sr);Vc=i(jp,"having static code (i.e., not a for loop of length that could change from step to step)"),jp.forEach(t),vi.forEach(t),rn=b(e),Ya=u(e,"P",{});var Lp=f(Ya);Qc=i(Lp,`Having any of the things above change between two steps will trigger a new compilation which will, once again, take a
lot of time. In practice, that means you must take special care to have all your tensors in your inputs of the same
shape (so no dynamic padding for instance if you are in an NLP problem) and should not use layer with for loops that
have different lengths depending on the inputs (such as an LSTM) or the training will be excruciatingly slow.`),Lp.forEach(t),ln=b(e),ee=u(e,"P",{});var wo=f(ee);Kc=i(wo,"To introduce special behavior in your script for TPUs you can check the "),cr=u(wo,"CODE",{});var Up=f(cr);Zc=i(Up,"distributed_type"),Up.forEach(t),eu=i(wo,` of your
`),ur=u(wo,"CODE",{});var Mp=f(ur);tu=i(Mp,"accelerator"),Mp.forEach(t),au=i(wo,":"),wo.forEach(t),nn=b(e),S(Bt.$$.fragment,e),sn=b(e),Re=u(e,"P",{});var wi=f(Re);ou=i(wi,"The "),xt=u(wi,"A",{href:!0,rel:!0});var Gp=f(xt);ru=i(Gp,"NLP example"),Gp.forEach(t),lu=i(wi,` shows an example in
situation with dynamic padding.`),wi.forEach(t),cn=b(e),te=u(e,"P",{});var go=f(te);nu=i(go,`One last thing to pay close attnetion to: if your model has tied weights (such as language models which tie the weights
of the embedding matrix with the weights of the decoder), moving this model to the TPU (either yourself or after you
passed your model to `),qa=u(go,"A",{href:!0});var Hp=f(qa);iu=i(Hp,"prepare()"),Hp.forEach(t),su=i(go,`) will break the tying. You will need to retie the weights
after. You can find an example of this in the `),Jt=u(go,"A",{href:!0,rel:!0});var Yp=f(Jt);cu=i(Yp,"run_clm_no_trainer"),Yp.forEach(t),uu=i(go,` script in
the Transformers repository.`),go.forEach(t),un=b(e),we=u(e,"H2",{class:!0});var gi=f(we);We=u(gi,"A",{id:!0,class:!0,href:!0});var qp=f(We);fr=u(qp,"SPAN",{});var Bp=f(fr);S(Xt.$$.fragment,Bp),Bp.forEach(t),qp.forEach(t),fu=b(gi),hr=u(gi,"SPAN",{});var xp=f(hr);hu=i(xp,"Other caveats"),xp.forEach(t),gi.forEach(t),fn=b(e),Ba=u(e,"P",{});var Jp=f(Ba);pu=i(Jp,"We list here all smaller issues you could have in your script conversion and how to resolve them."),Jp.forEach(t),hn=b(e),ge=u(e,"H3",{class:!0});var bi=f(ge);Ve=u(bi,"A",{id:!0,class:!0,href:!0});var Xp=f(Ve);pr=u(Xp,"SPAN",{});var Fp=f(pr);S(Ft.$$.fragment,Fp),Fp.forEach(t),Xp.forEach(t),du=b(bi),dr=u(bi,"SPAN",{});var Rp=f(dr);mu=i(Rp,"Execute a statement only on one processes"),Rp.forEach(t),bi.forEach(t),pn=b(e),xa=u(e,"P",{});var Wp=f(xa);_u=i(Wp,`Some of your instructions only need to run for one process on a given server: for instance a data download or a log
statement. To do this, wrap the statement in a test like this:`),Wp.forEach(t),dn=b(e),S(Rt.$$.fragment,e),mn=b(e),Ja=u(e,"P",{});var Vp=f(Ja);yu=i(Vp,`Another example is progress bars: to avoid having multiple progress bars in your output, you should only display one on
the local main process:`),Vp.forEach(t),_n=b(e),S(Wt.$$.fragment,e),yn=b(e),Qe=u(e,"P",{});var Ei=f(Qe);vu=i(Ei,"The "),mr=u(Ei,"EM",{});var Qp=f(mr);wu=i(Qp,"local"),Qp.forEach(t),gu=i(Ei,` means per machine: if you are running your training on two servers with several GPUs, the instruction will
be executed once on each of those servers. If you need to execute something only once for all processes (and not per
machine) for instance, uploading the final model to the \u{1F917} model hub, wrap it in a test like this:`),Ei.forEach(t),vn=b(e),S(Vt.$$.fragment,e),wn=b(e),ae=u(e,"P",{});var bo=f(ae);bu=i(bo,"For printing statements you only want executed once per machine, you can just replace the "),_r=u(bo,"CODE",{});var Kp=f(_r);Eu=i(Kp,"print"),Kp.forEach(t),$u=i(bo,` function by
`),yr=u(bo,"CODE",{});var Zp=f(yr);ku=i(Zp,"accelerator.print"),Zp.forEach(t),Pu=i(bo,"."),bo.forEach(t),gn=b(e),be=u(e,"H3",{class:!0});var $i=f(be);Ke=u($i,"A",{id:!0,class:!0,href:!0});var ed=f(Ke);vr=u(ed,"SPAN",{});var td=f(vr);S(Qt.$$.fragment,td),td.forEach(t),ed.forEach(t),Au=b($i),wr=u($i,"SPAN",{});var ad=f(wr);Tu=i(ad,"Defer execution"),ad.forEach(t),$i.forEach(t),bn=b(e),Xa=u(e,"P",{});var od=f(Xa);Cu=i(od,`When you run your usual script, instructions are executed in order. Using \u{1F917} Accelerate to deploy your script on several
GPUs at the same time introduces a complication: while each process executes all instructions in order, some may be
faster than others.`),od.forEach(t),En=b(e),Fa=u(e,"P",{});var rd=f(Fa);Du=i(rd,`You might need to wait for all processes to have reached a certain point before executing a given instruction. For
instance, you shouldn\u2019t save a model before being sure every process is done with training. To do this, just write the
following line in your code:`),rd.forEach(t),$n=b(e),S(Kt.$$.fragment,e),kn=b(e),Ra=u(e,"P",{});var ld=f(Ra);Nu=i(ld,`This instruction will block all the processes that arrive them first until all the other processes have reached that
point (if you run your script on just one GPU or CPU, this wont\u2019 do anything).`),ld.forEach(t),Pn=b(e),Ee=u(e,"H3",{class:!0});var ki=f(Ee);Ze=u(ki,"A",{id:!0,class:!0,href:!0});var nd=f(Ze);gr=u(nd,"SPAN",{});var id=f(gr);S(Zt.$$.fragment,id),id.forEach(t),nd.forEach(t),Iu=b(ki),br=u(ki,"SPAN",{});var sd=f(br);Su=i(sd,"Saving/loading a model"),sd.forEach(t),ki.forEach(t),An=b(e),et=u(e,"P",{});var Pi=f(et);zu=i(Pi,`Saving the model you trained might need a bit of adjustment: first you should wait for all processes to reach that
point in the script as shown above, and then, you should unwrap your model before saving it. This is because when going
through the `),Wa=u(Pi,"A",{href:!0});var cd=f(Wa);Ou=i(cd,"prepare()"),cd.forEach(t),ju=i(Pi,` method, your model may have been placed inside a bigger model,
which deals with the distributed training. This in turn means that saving your model state dictionary without taking
any precaution will take that potential extra layer into account, and you will end up with weights you can\u2019t load back
in your base model.`),Pi.forEach(t),Tn=b(e),tt=u(e,"P",{});var Ai=f(tt);Lu=i(Ai,"This is why it\u2019s recommended to "),Er=u(Ai,"EM",{});var ud=f(Er);Uu=i(ud,"unwrap"),ud.forEach(t),Mu=i(Ai," your model first. Here is an example:"),Ai.forEach(t),Cn=b(e),S(ea.$$.fragment,e),Dn=b(e),at=u(e,"P",{});var Ti=f(at);Gu=i(Ti,`If your script contains a logic to load checkpoint, we also recommend you load your weights in the unwrapped model
(this is only useful if you use the load function after making your model go through
`),Va=u(Ti,"A",{href:!0});var fd=f(Va);Hu=i(fd,"prepare()"),fd.forEach(t),Yu=i(Ti,"). Here is an example:"),Ti.forEach(t),Nn=b(e),S(ta.$$.fragment,e),In=b(e),ot=u(e,"P",{});var Ci=f(ot);qu=i(Ci,"Note that since all the model parameters are references to tensors, this will load your weights inside "),$r=u(Ci,"CODE",{});var hd=f($r);Bu=i(hd,"model"),hd.forEach(t),xu=i(Ci,"."),Ci.forEach(t),Sn=b(e),$e=u(e,"H3",{class:!0});var Di=f($e);rt=u(Di,"A",{id:!0,class:!0,href:!0});var pd=f(rt);kr=u(pd,"SPAN",{});var dd=f(kr);S(aa.$$.fragment,dd),dd.forEach(t),pd.forEach(t),Ju=b(Di),Pr=u(Di,"SPAN",{});var md=f(Pr);Xu=i(md,"Gradient clipping"),md.forEach(t),Di.forEach(t),zn=b(e),q=u(e,"P",{});var ie=f(q);Fu=i(ie,`If you are using gradient clipping in your script, you should replace the calls to
`),Ar=u(ie,"CODE",{});var _d=f(Ar);Ru=i(_d,"torch.nn.utils.clip_grad_norm_"),_d.forEach(t),Wu=i(ie," or "),Tr=u(ie,"CODE",{});var yd=f(Tr);Vu=i(yd,"torch.nn.utils.clip_grad_value_"),yd.forEach(t),Qu=i(ie," with "),Cr=u(ie,"CODE",{});var vd=f(Cr);Ku=i(vd,"accelerator.clip_grad_norm_"),vd.forEach(t),Zu=i(ie,`
and `),Dr=u(ie,"CODE",{});var wd=f(Dr);ef=i(wd,"accelerator.clip_grad_value_"),wd.forEach(t),tf=i(ie," respectively."),ie.forEach(t),On=b(e),ke=u(e,"H3",{class:!0});var Ni=f(ke);lt=u(Ni,"A",{id:!0,class:!0,href:!0});var gd=f(lt);Nr=u(gd,"SPAN",{});var bd=f(Nr);S(oa.$$.fragment,bd),bd.forEach(t),gd.forEach(t),af=b(Ni),Ir=u(Ni,"SPAN",{});var Ed=f(Ir);of=i(Ed,"Mixed Precision training"),Ed.forEach(t),Ni.forEach(t),jn=b(e),nt=u(e,"P",{});var Ii=f(nt);rf=i(Ii,`If you are running your training in Mixed Precision with Accelerate, you will get the best result with your loss being
computed inside your model (like in Transformer models for instance). Every computation outside of the model will be
executed in full precision (which is generally what you want for loss computation, expecially if it involves a
softmax). However you might want to put your loss computation inside the `),Sr=u(Ii,"EM",{});var $d=f(Sr);lf=i($d,"accelerator.autocast"),$d.forEach(t),nf=i(Ii," context manager:"),Ii.forEach(t),Ln=b(e),S(ra.$$.fragment,e),Un=b(e),Qa=u(e,"P",{});var kd=f(Qa);sf=i(kd,`Another caveat with Mixed Precision training is that the gradient will skip a few updates at the beginning and
sometimes during training: because of the dynamic loss scaling strategy, there are points during training where the
gradients have overflown, and the loss scaling factor is reduced to avoid this happening again at the next step.`),kd.forEach(t),Mn=b(e),Ka=u(e,"P",{});var Pd=f(Ka);cf=i(Pd,`This means that you may update your learning rate scheduler when there was no update, which is fine in general, but may
have an impact when you have very little training data, or if the first learning rate values of your scheduler are very
important. In this case, you can skip the learning rate scheduler updates when the optimizer step was not done like
this:`),Pd.forEach(t),Gn=b(e),S(la.$$.fragment,e),Hn=b(e),Pe=u(e,"H3",{class:!0});var Si=f(Pe);it=u(Si,"A",{id:!0,class:!0,href:!0});var Ad=f(it);zr=u(Ad,"SPAN",{});var Td=f(zr);S(na.$$.fragment,Td),Td.forEach(t),Ad.forEach(t),uf=b(Si),Or=u(Si,"SPAN",{});var Cd=f(Or);ff=i(Cd,"DeepSpeed"),Cd.forEach(t),Si.forEach(t),Yn=b(e),Za=u(e,"P",{});var Dd=f(Za);hf=i(Dd,`DeepSpeed support is experimental, so the underlying API will evolve in the near future and may have some slight
breaking changes. In particular, \u{1F917} Accelerate does not support DeepSpeed config you have written yourself yet, this
will be added in a next version.`),Dd.forEach(t),qn=b(e),oe=u(e,"P",{});var Eo=f(oe);pf=i(Eo,"One main caveat for the DeepSpeed integration is that the DeepSpeed launcher always passes a "),jr=u(Eo,"CODE",{});var Nd=f(jr);df=i(Nd,"local_rank"),Nd.forEach(t),mf=i(Eo,` variable to
the training script, so your training script should accept it (whether you launch training with the DeepSpeed launcher
or `),Lr=u(Eo,"CODE",{});var Id=f(Lr);_f=i(Id,"accelerate launch"),Id.forEach(t),yf=i(Eo,")."),Eo.forEach(t),Bn=b(e),S(st.$$.fragment,e),xn=b(e),Ae=u(e,"H2",{class:!0});var zi=f(Ae);ct=u(zi,"A",{id:!0,class:!0,href:!0});var Sd=f(ct);Ur=u(Sd,"SPAN",{});var zd=f(Ur);S(ia.$$.fragment,zd),zd.forEach(t),Sd.forEach(t),vf=b(zi),Mr=u(zi,"SPAN",{});var Od=f(Mr);wf=i(Od,"Internal mechanism"),Od.forEach(t),zi.forEach(t),Jn=b(e),ut=u(e,"P",{});var Oi=f(ut);gf=i(Oi,`Internally, the library works by first analyzing the environment in which the script is launched to determine which
kind of distributed setup is used, how many different processes there are and which one the current script is in. All
that information is stored in the `),Gr=u(Oi,"CODE",{});var jd=f(Gr);bf=i(jd,"~AcceleratorState"),jd.forEach(t),Ef=i(Oi,"."),Oi.forEach(t),Xn=b(e),re=u(e,"P",{});var $o=f(re);$f=i($o,"This class is initialized the first time you instantiate a "),eo=u($o,"A",{href:!0});var Ld=f(eo);kf=i(Ld,"Accelerator"),Ld.forEach(t),Pf=i($o,` as well as performing any
specific initialization your distributed setup needs. Its state is then uniquely shared through all instances of
`),to=u($o,"A",{href:!0});var Ud=f(to);Af=i(Ud,"AcceleratorState"),Ud.forEach(t),Tf=i($o,"."),$o.forEach(t),Fn=b(e),ft=u(e,"P",{});var ji=f(ft);Cf=i(ji,"Then, when calling "),ao=u(ji,"A",{href:!0});var Md=f(ao);Df=i(Md,"prepare()"),Md.forEach(t),Nf=i(ji,", the library:"),ji.forEach(t),Rn=b(e),le=u(e,"UL",{});var ko=f(le);Hr=u(ko,"LI",{});var Gd=f(Hr);If=i(Gd,"wraps your model(s) in the container adapted for the distributed setup,"),Gd.forEach(t),Sf=b(ko),sa=u(ko,"LI",{});var Li=f(sa);zf=i(Li,"wraps your optimizer(s) in a "),oo=u(Li,"A",{href:!0});var Hd=f(oo);Of=i(Hd,"AcceleratedOptimizer"),Hd.forEach(t),jf=i(Li,","),Li.forEach(t),Lf=b(ko),ca=u(ko,"LI",{});var Ui=f(ca);Uf=i(Ui,"creates a new version of your dataloader(s) in a "),ro=u(Ui,"A",{href:!0});var Yd=f(ro);Mf=i(Yd,"DataLoaderShard"),Yd.forEach(t),Gf=i(Ui,"."),Ui.forEach(t),ko.forEach(t),Wn=b(e),F=u(e,"P",{});var vt=f(F);Hf=i(vt,`While the model(s) and optimizer(s) are just put in simple wrappers, the dataloader(s) are re-created. This is mostly
because PyTorch does not let the user change the `),Yr=u(vt,"CODE",{});var qd=f(Yr);Yf=i(qd,"batch_sampler"),qd.forEach(t),qf=i(vt,` of a dataloader once it\u2019s been created and the
library handles the sharding of your data between processes by changing that `),qr=u(vt,"CODE",{});var Bd=f(qr);Bf=i(Bd,"batch_sampler"),Bd.forEach(t),xf=i(vt,` to yield every other
`),Br=u(vt,"CODE",{});var xd=f(Br);Jf=i(xd,"num_processes"),xd.forEach(t),Xf=i(vt," batches."),vt.forEach(t),Vn=b(e),ne=u(e,"P",{});var Po=f(ne);Ff=i(Po,"The "),lo=u(Po,"A",{href:!0});var Jd=f(lo);Rf=i(Jd,"DataLoaderShard"),Jd.forEach(t),Wf=i(Po," subclasses "),xr=u(Po,"CODE",{});var Xd=f(xr);Vf=i(Xd,"DataLoader"),Xd.forEach(t),Qf=i(Po," to add the following functionality:"),Po.forEach(t),Qn=b(e),ht=u(e,"UL",{});var Mi=f(ht);Jr=u(Mi,"LI",{});var Fd=f(Jr);Kf=i(Fd,`it synchronizes the appropriate random number generator of all processes at each new iteration, to ensure any
randomization (like shuffling) is done the exact same way across processes.`),Fd.forEach(t),Zf=b(Mi),ua=u(Mi,"LI",{});var Gi=f(ua);eh=i(Gi,`it puts the batches on the proper device before yielding them (unless you have opted out of
`),Xr=u(Gi,"CODE",{});var Rd=f(Xr);th=i(Rd,"device_placement=True"),Rd.forEach(t),ah=i(Gi,")."),Gi.forEach(t),Mi.forEach(t),Kn=b(e),no=u(e,"P",{});var Wd=f(no);oh=i(Wd,"The random number generator synchronization will by default synchronize:"),Wd.forEach(t),Zn=b(e),pt=u(e,"UL",{});var Hi=f(pt);Te=u(Hi,"LI",{});var Ao=f(Te);rh=i(Ao,"the "),Fr=u(Ao,"CODE",{});var Vd=f(Fr);lh=i(Vd,"generator"),Vd.forEach(t),nh=i(Ao," attribute of a given sampler (like the PyTorch "),Rr=u(Ao,"CODE",{});var Qd=f(Rr);ih=i(Qd,"RandomSampler"),Qd.forEach(t),sh=i(Ao,") for PyTorch >= 1.6"),Ao.forEach(t),ch=b(Hi),Wr=u(Hi,"LI",{});var Kd=f(Wr);uh=i(Kd,"the main random number generator in PyTorch <=1.5.1"),Kd.forEach(t),Hi.forEach(t),ei=b(e),R=u(e,"P",{});var wt=f(R);fh=i(wt,"You can choose which random number generator(s) to synchronize with the "),Vr=u(wt,"CODE",{});var Zd=f(Vr);hh=i(Zd,"rng_types"),Zd.forEach(t),ph=i(wt,` argument of the main
`),io=u(wt,"A",{href:!0});var em=f(io);dh=i(em,"Accelerator"),em.forEach(t),mh=i(wt,". In PyTorch >= 1.6, it is recommended to rely on local "),Qr=u(wt,"CODE",{});var tm=f(Qr);_h=i(tm,"generator"),tm.forEach(t),yh=i(wt,` to avoid
setting the same seed in the main random number generator in all processes.`),wt.forEach(t),ti=b(e),S(dt.$$.fragment,e),ai=b(e),S(mt.$$.fragment,e),oi=b(e),_t=u(e,"P",{});var Yi=f(_t);vh=i(Yi,"See more details about the internal in the "),so=u(Yi,"A",{href:!0});var am=f(so);wh=i(am,"Internals page"),am.forEach(t),gh=i(Yi,"."),Yi.forEach(t),this.h()},h(){w(o,"name","hf:doc:metadata"),w(o,"content",JSON.stringify(b_)),w(p,"id","quick-tour"),w(p,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(p,"href","#quick-tour"),w(_,"class","relative group"),w(L,"id","main-use"),w(L,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(L,"href","#main-use"),w(T,"class","relative group"),w(ma,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator"),w(At,"start","2"),w(ya,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator"),w(va,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator.prepare"),w(Tt,"start","3"),w(wa,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator"),w(ba,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator.prepare"),w(Ea,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator.prepare"),w($a,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator.prepare"),w(ka,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator.prepare"),w(Nt,"start","4"),w(je,"id","distributed-evaluation"),w(je,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(je,"href","#distributed-evaluation"),w(pe,"class","relative group"),w(Aa,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator.prepare"),w(Ta,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator.prepare"),w(Ca,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator.gather"),w(He,"id","launching-your-distributed-script"),w(He,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(He,"href","#launching-your-distributed-script"),w(de,"class","relative group"),w(Be,"id","launching-training-from-a-notebook"),w(Be,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(Be,"href","#launching-training-from-a-notebook"),w(ye,"class","relative group"),w(Ua,"href","/docs/accelerate/pr_275/en/launcher#accelerate.notebook_launcher"),w(Xe,"id","training-on-tpu"),w(Xe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(Xe,"href","#training-on-tpu"),w(ve,"class","relative group"),w(xt,"href","https://github.com/huggingface/accelerate/blob/main/examples/nlp_example.py"),w(xt,"rel","nofollow"),w(qa,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator.prepare"),w(Jt,"href","https://github.com/huggingface/transformers/blob/master/examples/pytorch/language-modeling/run_clm.py"),w(Jt,"rel","nofollow"),w(We,"id","other-caveats"),w(We,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(We,"href","#other-caveats"),w(we,"class","relative group"),w(Ve,"id","execute-a-statement-only-on-one-processes"),w(Ve,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(Ve,"href","#execute-a-statement-only-on-one-processes"),w(ge,"class","relative group"),w(Ke,"id","defer-execution"),w(Ke,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(Ke,"href","#defer-execution"),w(be,"class","relative group"),w(Ze,"id","savingloading-a-model"),w(Ze,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(Ze,"href","#savingloading-a-model"),w(Ee,"class","relative group"),w(Wa,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator.prepare"),w(Va,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator.prepare"),w(rt,"id","gradient-clipping"),w(rt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(rt,"href","#gradient-clipping"),w($e,"class","relative group"),w(lt,"id","mixed-precision-training"),w(lt,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(lt,"href","#mixed-precision-training"),w(ke,"class","relative group"),w(it,"id","deepspeed"),w(it,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(it,"href","#deepspeed"),w(Pe,"class","relative group"),w(ct,"id","internal-mechanism"),w(ct,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),w(ct,"href","#internal-mechanism"),w(Ae,"class","relative group"),w(eo,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator"),w(to,"href","/docs/accelerate/pr_275/en/internal#accelerate.state.AcceleratorState"),w(ao,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator.prepare"),w(oo,"href","/docs/accelerate/pr_275/en/internal#accelerate.optimizer.AcceleratedOptimizer"),w(ro,"href","/docs/accelerate/pr_275/en/internal#accelerate.data_loader.DataLoaderShard"),w(lo,"href","/docs/accelerate/pr_275/en/internal#accelerate.data_loader.DataLoaderShard"),w(io,"href","/docs/accelerate/pr_275/en/accelerator#accelerate.Accelerator"),w(so,"href","internal")},m(e,s){a(document.head,o),d(e,h,s),N(l,e,s),d(e,r,s),d(e,_,s),a(_,p),a(p,v),N(y,v,null),a(_,E),a(_,k),a(k,U),d(e,j,s),d(e,z,s),a(z,C),d(e,A,s),d(e,T,s),a(T,L),a(L,G),N(O,G,null),a(T,J),a(T,kt),a(kt,M),d(e,ll,s),d(e,pa,s),a(pa,Bi),d(e,nl,s),d(e,da,s),a(da,fe),a(fe,xi),a(fe,ma),a(ma,Ji),a(fe,Xi),a(fe,No),a(No,Fi),a(fe,Ri),d(e,il,s),N(Pt,e,s),d(e,sl,s),d(e,_a,s),a(_a,Wi),d(e,cl,s),d(e,At,s),a(At,Y),a(Y,Vi),a(Y,Io),a(Io,Qi),a(Y,Ki),a(Y,So),a(So,Zi),a(Y,es),a(Y,zo),a(zo,ts),a(Y,as),a(Y,Oo),a(Oo,os),a(Y,rs),a(Y,jo),a(jo,ls),a(Y,ns),a(Y,Lo),a(Lo,is),a(Y,ss),d(e,ul,s),d(e,W,s),a(W,cs),a(W,Uo),a(Uo,us),a(W,fs),a(W,ya),a(ya,hs),a(W,ps),d(e,fl,s),N(De,e,s),d(e,hl,s),d(e,Tt,s),a(Tt,Ct),a(Ct,ds),a(Ct,va),a(va,ms),a(Ct,_s),d(e,pl,s),N(Dt,e,s),d(e,dl,s),d(e,Ne,s),a(Ne,ys),a(Ne,Mo),a(Mo,vs),a(Ne,ws),d(e,ml,s),N(Ie,e,s),d(e,_l,s),d(e,V,s),a(V,gs),a(V,Go),a(Go,bs),a(V,Es),a(V,wa),a(wa,$s),a(V,ks),d(e,yl,s),d(e,ga,s),a(ga,Ps),d(e,vl,s),N(Se,e,s),d(e,wl,s),d(e,ze,s),a(ze,As),a(ze,ba),a(ba,Ts),a(ze,Cs),d(e,gl,s),d(e,Q,s),a(Q,Ds),a(Q,Ea),a(Ea,Ns),a(Q,Is),a(Q,$a),a($a,Ss),a(Q,zs),d(e,bl,s),d(e,Oe,s),a(Oe,Os),a(Oe,ka),a(ka,js),a(Oe,Ls),d(e,El,s),d(e,Nt,s),a(Nt,he),a(he,Us),a(he,Ho),a(Ho,Ms),a(he,Gs),a(he,Yo),a(Yo,Hs),a(he,Ys),d(e,$l,s),d(e,Pa,s),a(Pa,qs),d(e,kl,s),d(e,pe,s),a(pe,je),a(je,qo),N(It,qo,null),a(pe,Bs),a(pe,Bo),a(Bo,xs),d(e,Pl,s),d(e,K,s),a(K,Js),a(K,Aa),a(Aa,Xs),a(K,Fs),a(K,xo),a(xo,Rs),a(K,Ws),d(e,Al,s),d(e,Le,s),a(Le,Vs),a(Le,Ta),a(Ta,Qs),a(Le,Ks),d(e,Tl,s),N(St,e,s),d(e,Cl,s),d(e,Ue,s),a(Ue,Zs),a(Ue,Ca),a(Ca,ec),a(Ue,tc),d(e,Dl,s),N(zt,e,s),d(e,Nl,s),N(Me,e,s),d(e,Il,s),N(Ge,e,s),d(e,Sl,s),d(e,de,s),a(de,He),a(He,Jo),N(Ot,Jo,null),a(de,ac),a(de,Xo),a(Xo,oc),d(e,zl,s),d(e,X,s),a(X,rc),a(X,Fo),a(Fo,lc),a(X,nc),a(X,Ro),a(Ro,ic),a(X,sc),a(X,Wo),a(Wo,cc),a(X,uc),d(e,Ol,s),d(e,Da,s),a(Da,fc),d(e,jl,s),N(jt,e,s),d(e,Ll,s),d(e,Ye,s),a(Ye,hc),a(Ye,Vo),a(Vo,pc),a(Ye,dc),d(e,Ul,s),d(e,Z,s),a(Z,me),a(me,mc),a(me,Qo),a(Qo,_c),a(me,yc),a(me,Ko),a(Ko,vc),a(me,wc),a(Z,gc),a(Z,_e),a(_e,bc),a(_e,Zo),a(Zo,Ec),a(_e,$c),a(_e,er),a(er,kc),a(_e,Pc),a(Z,Ac),a(Z,Na),a(Na,Tc),a(Na,tr),a(tr,Cc),d(e,Ml,s),d(e,qe,s),a(qe,Dc),a(qe,ar),a(ar,Nc),a(qe,Ic),d(e,Gl,s),d(e,Ia,s),a(Ia,Sc),d(e,Hl,s),N(Lt,e,s),d(e,Yl,s),d(e,Sa,s),a(Sa,zc),d(e,ql,s),d(e,za,s),a(za,Oc),d(e,Bl,s),N(Ut,e,s),d(e,xl,s),d(e,Oa,s),a(Oa,jc),d(e,Jl,s),N(Mt,e,s),d(e,Xl,s),d(e,ja,s),a(ja,Lc),d(e,Fl,s),N(Gt,e,s),d(e,Rl,s),d(e,La,s),a(La,Uc),d(e,Wl,s),d(e,ye,s),a(ye,Be),a(Be,or),N(Ht,or,null),a(ye,Mc),a(ye,rr),a(rr,Gc),d(e,Vl,s),d(e,xe,s),a(xe,Hc),a(xe,Ua),a(Ua,Yc),a(xe,qc),d(e,Ql,s),d(e,Ma,s),a(Ma,Bc),d(e,Kl,s),N(Yt,e,s),d(e,Zl,s),N(Je,e,s),d(e,en,s),d(e,ve,s),a(ve,Xe),a(Xe,lr),N(qt,lr,null),a(ve,xc),a(ve,nr),a(nr,Jc),d(e,tn,s),d(e,Ga,s),a(Ga,Xc),d(e,an,s),d(e,Ha,s),a(Ha,Fc),d(e,on,s),d(e,Fe,s),a(Fe,ir),a(ir,Rc),a(Fe,Wc),a(Fe,sr),a(sr,Vc),d(e,rn,s),d(e,Ya,s),a(Ya,Qc),d(e,ln,s),d(e,ee,s),a(ee,Kc),a(ee,cr),a(cr,Zc),a(ee,eu),a(ee,ur),a(ur,tu),a(ee,au),d(e,nn,s),N(Bt,e,s),d(e,sn,s),d(e,Re,s),a(Re,ou),a(Re,xt),a(xt,ru),a(Re,lu),d(e,cn,s),d(e,te,s),a(te,nu),a(te,qa),a(qa,iu),a(te,su),a(te,Jt),a(Jt,cu),a(te,uu),d(e,un,s),d(e,we,s),a(we,We),a(We,fr),N(Xt,fr,null),a(we,fu),a(we,hr),a(hr,hu),d(e,fn,s),d(e,Ba,s),a(Ba,pu),d(e,hn,s),d(e,ge,s),a(ge,Ve),a(Ve,pr),N(Ft,pr,null),a(ge,du),a(ge,dr),a(dr,mu),d(e,pn,s),d(e,xa,s),a(xa,_u),d(e,dn,s),N(Rt,e,s),d(e,mn,s),d(e,Ja,s),a(Ja,yu),d(e,_n,s),N(Wt,e,s),d(e,yn,s),d(e,Qe,s),a(Qe,vu),a(Qe,mr),a(mr,wu),a(Qe,gu),d(e,vn,s),N(Vt,e,s),d(e,wn,s),d(e,ae,s),a(ae,bu),a(ae,_r),a(_r,Eu),a(ae,$u),a(ae,yr),a(yr,ku),a(ae,Pu),d(e,gn,s),d(e,be,s),a(be,Ke),a(Ke,vr),N(Qt,vr,null),a(be,Au),a(be,wr),a(wr,Tu),d(e,bn,s),d(e,Xa,s),a(Xa,Cu),d(e,En,s),d(e,Fa,s),a(Fa,Du),d(e,$n,s),N(Kt,e,s),d(e,kn,s),d(e,Ra,s),a(Ra,Nu),d(e,Pn,s),d(e,Ee,s),a(Ee,Ze),a(Ze,gr),N(Zt,gr,null),a(Ee,Iu),a(Ee,br),a(br,Su),d(e,An,s),d(e,et,s),a(et,zu),a(et,Wa),a(Wa,Ou),a(et,ju),d(e,Tn,s),d(e,tt,s),a(tt,Lu),a(tt,Er),a(Er,Uu),a(tt,Mu),d(e,Cn,s),N(ea,e,s),d(e,Dn,s),d(e,at,s),a(at,Gu),a(at,Va),a(Va,Hu),a(at,Yu),d(e,Nn,s),N(ta,e,s),d(e,In,s),d(e,ot,s),a(ot,qu),a(ot,$r),a($r,Bu),a(ot,xu),d(e,Sn,s),d(e,$e,s),a($e,rt),a(rt,kr),N(aa,kr,null),a($e,Ju),a($e,Pr),a(Pr,Xu),d(e,zn,s),d(e,q,s),a(q,Fu),a(q,Ar),a(Ar,Ru),a(q,Wu),a(q,Tr),a(Tr,Vu),a(q,Qu),a(q,Cr),a(Cr,Ku),a(q,Zu),a(q,Dr),a(Dr,ef),a(q,tf),d(e,On,s),d(e,ke,s),a(ke,lt),a(lt,Nr),N(oa,Nr,null),a(ke,af),a(ke,Ir),a(Ir,of),d(e,jn,s),d(e,nt,s),a(nt,rf),a(nt,Sr),a(Sr,lf),a(nt,nf),d(e,Ln,s),N(ra,e,s),d(e,Un,s),d(e,Qa,s),a(Qa,sf),d(e,Mn,s),d(e,Ka,s),a(Ka,cf),d(e,Gn,s),N(la,e,s),d(e,Hn,s),d(e,Pe,s),a(Pe,it),a(it,zr),N(na,zr,null),a(Pe,uf),a(Pe,Or),a(Or,ff),d(e,Yn,s),d(e,Za,s),a(Za,hf),d(e,qn,s),d(e,oe,s),a(oe,pf),a(oe,jr),a(jr,df),a(oe,mf),a(oe,Lr),a(Lr,_f),a(oe,yf),d(e,Bn,s),N(st,e,s),d(e,xn,s),d(e,Ae,s),a(Ae,ct),a(ct,Ur),N(ia,Ur,null),a(Ae,vf),a(Ae,Mr),a(Mr,wf),d(e,Jn,s),d(e,ut,s),a(ut,gf),a(ut,Gr),a(Gr,bf),a(ut,Ef),d(e,Xn,s),d(e,re,s),a(re,$f),a(re,eo),a(eo,kf),a(re,Pf),a(re,to),a(to,Af),a(re,Tf),d(e,Fn,s),d(e,ft,s),a(ft,Cf),a(ft,ao),a(ao,Df),a(ft,Nf),d(e,Rn,s),d(e,le,s),a(le,Hr),a(Hr,If),a(le,Sf),a(le,sa),a(sa,zf),a(sa,oo),a(oo,Of),a(sa,jf),a(le,Lf),a(le,ca),a(ca,Uf),a(ca,ro),a(ro,Mf),a(ca,Gf),d(e,Wn,s),d(e,F,s),a(F,Hf),a(F,Yr),a(Yr,Yf),a(F,qf),a(F,qr),a(qr,Bf),a(F,xf),a(F,Br),a(Br,Jf),a(F,Xf),d(e,Vn,s),d(e,ne,s),a(ne,Ff),a(ne,lo),a(lo,Rf),a(ne,Wf),a(ne,xr),a(xr,Vf),a(ne,Qf),d(e,Qn,s),d(e,ht,s),a(ht,Jr),a(Jr,Kf),a(ht,Zf),a(ht,ua),a(ua,eh),a(ua,Xr),a(Xr,th),a(ua,ah),d(e,Kn,s),d(e,no,s),a(no,oh),d(e,Zn,s),d(e,pt,s),a(pt,Te),a(Te,rh),a(Te,Fr),a(Fr,lh),a(Te,nh),a(Te,Rr),a(Rr,ih),a(Te,sh),a(pt,ch),a(pt,Wr),a(Wr,uh),d(e,ei,s),d(e,R,s),a(R,fh),a(R,Vr),a(Vr,hh),a(R,ph),a(R,io),a(io,dh),a(R,mh),a(R,Qr),a(Qr,_h),a(R,yh),d(e,ti,s),N(dt,e,s),d(e,ai,s),N(mt,e,s),d(e,oi,s),d(e,_t,s),a(_t,vh),a(_t,so),a(so,wh),a(_t,gh),ri=!0},p(e,[s]){const fa={};s&2&&(fa.$$scope={dirty:s,ctx:e}),De.$set(fa);const Kr={};s&2&&(Kr.$$scope={dirty:s,ctx:e}),Ie.$set(Kr);const Zr={};s&2&&(Zr.$$scope={dirty:s,ctx:e}),Se.$set(Zr);const el={};s&2&&(el.$$scope={dirty:s,ctx:e}),Me.$set(el);const tl={};s&2&&(tl.$$scope={dirty:s,ctx:e}),Ge.$set(tl);const ha={};s&2&&(ha.$$scope={dirty:s,ctx:e}),Je.$set(ha);const al={};s&2&&(al.$$scope={dirty:s,ctx:e}),st.$set(al);const ol={};s&2&&(ol.$$scope={dirty:s,ctx:e}),dt.$set(ol);const rl={};s&2&&(rl.$$scope={dirty:s,ctx:e}),mt.$set(rl)},i(e){ri||($(l.$$.fragment,e),$(y.$$.fragment,e),$(O.$$.fragment,e),$(Pt.$$.fragment,e),$(De.$$.fragment,e),$(Dt.$$.fragment,e),$(Ie.$$.fragment,e),$(Se.$$.fragment,e),$(It.$$.fragment,e),$(St.$$.fragment,e),$(zt.$$.fragment,e),$(Me.$$.fragment,e),$(Ge.$$.fragment,e),$(Ot.$$.fragment,e),$(jt.$$.fragment,e),$(Lt.$$.fragment,e),$(Ut.$$.fragment,e),$(Mt.$$.fragment,e),$(Gt.$$.fragment,e),$(Ht.$$.fragment,e),$(Yt.$$.fragment,e),$(Je.$$.fragment,e),$(qt.$$.fragment,e),$(Bt.$$.fragment,e),$(Xt.$$.fragment,e),$(Ft.$$.fragment,e),$(Rt.$$.fragment,e),$(Wt.$$.fragment,e),$(Vt.$$.fragment,e),$(Qt.$$.fragment,e),$(Kt.$$.fragment,e),$(Zt.$$.fragment,e),$(ea.$$.fragment,e),$(ta.$$.fragment,e),$(aa.$$.fragment,e),$(oa.$$.fragment,e),$(ra.$$.fragment,e),$(la.$$.fragment,e),$(na.$$.fragment,e),$(st.$$.fragment,e),$(ia.$$.fragment,e),$(dt.$$.fragment,e),$(mt.$$.fragment,e),ri=!0)},o(e){P(l.$$.fragment,e),P(y.$$.fragment,e),P(O.$$.fragment,e),P(Pt.$$.fragment,e),P(De.$$.fragment,e),P(Dt.$$.fragment,e),P(Ie.$$.fragment,e),P(Se.$$.fragment,e),P(It.$$.fragment,e),P(St.$$.fragment,e),P(zt.$$.fragment,e),P(Me.$$.fragment,e),P(Ge.$$.fragment,e),P(Ot.$$.fragment,e),P(jt.$$.fragment,e),P(Lt.$$.fragment,e),P(Ut.$$.fragment,e),P(Mt.$$.fragment,e),P(Gt.$$.fragment,e),P(Ht.$$.fragment,e),P(Yt.$$.fragment,e),P(Je.$$.fragment,e),P(qt.$$.fragment,e),P(Bt.$$.fragment,e),P(Xt.$$.fragment,e),P(Ft.$$.fragment,e),P(Rt.$$.fragment,e),P(Wt.$$.fragment,e),P(Vt.$$.fragment,e),P(Qt.$$.fragment,e),P(Kt.$$.fragment,e),P(Zt.$$.fragment,e),P(ea.$$.fragment,e),P(ta.$$.fragment,e),P(aa.$$.fragment,e),P(oa.$$.fragment,e),P(ra.$$.fragment,e),P(la.$$.fragment,e),P(na.$$.fragment,e),P(st.$$.fragment,e),P(ia.$$.fragment,e),P(dt.$$.fragment,e),P(mt.$$.fragment,e),ri=!1},d(e){t(o),e&&t(h),I(l,e),e&&t(r),e&&t(_),I(y),e&&t(j),e&&t(z),e&&t(A),e&&t(T),I(O),e&&t(ll),e&&t(pa),e&&t(nl),e&&t(da),e&&t(il),I(Pt,e),e&&t(sl),e&&t(_a),e&&t(cl),e&&t(At),e&&t(ul),e&&t(W),e&&t(fl),I(De,e),e&&t(hl),e&&t(Tt),e&&t(pl),I(Dt,e),e&&t(dl),e&&t(Ne),e&&t(ml),I(Ie,e),e&&t(_l),e&&t(V),e&&t(yl),e&&t(ga),e&&t(vl),I(Se,e),e&&t(wl),e&&t(ze),e&&t(gl),e&&t(Q),e&&t(bl),e&&t(Oe),e&&t(El),e&&t(Nt),e&&t($l),e&&t(Pa),e&&t(kl),e&&t(pe),I(It),e&&t(Pl),e&&t(K),e&&t(Al),e&&t(Le),e&&t(Tl),I(St,e),e&&t(Cl),e&&t(Ue),e&&t(Dl),I(zt,e),e&&t(Nl),I(Me,e),e&&t(Il),I(Ge,e),e&&t(Sl),e&&t(de),I(Ot),e&&t(zl),e&&t(X),e&&t(Ol),e&&t(Da),e&&t(jl),I(jt,e),e&&t(Ll),e&&t(Ye),e&&t(Ul),e&&t(Z),e&&t(Ml),e&&t(qe),e&&t(Gl),e&&t(Ia),e&&t(Hl),I(Lt,e),e&&t(Yl),e&&t(Sa),e&&t(ql),e&&t(za),e&&t(Bl),I(Ut,e),e&&t(xl),e&&t(Oa),e&&t(Jl),I(Mt,e),e&&t(Xl),e&&t(ja),e&&t(Fl),I(Gt,e),e&&t(Rl),e&&t(La),e&&t(Wl),e&&t(ye),I(Ht),e&&t(Vl),e&&t(xe),e&&t(Ql),e&&t(Ma),e&&t(Kl),I(Yt,e),e&&t(Zl),I(Je,e),e&&t(en),e&&t(ve),I(qt),e&&t(tn),e&&t(Ga),e&&t(an),e&&t(Ha),e&&t(on),e&&t(Fe),e&&t(rn),e&&t(Ya),e&&t(ln),e&&t(ee),e&&t(nn),I(Bt,e),e&&t(sn),e&&t(Re),e&&t(cn),e&&t(te),e&&t(un),e&&t(we),I(Xt),e&&t(fn),e&&t(Ba),e&&t(hn),e&&t(ge),I(Ft),e&&t(pn),e&&t(xa),e&&t(dn),I(Rt,e),e&&t(mn),e&&t(Ja),e&&t(_n),I(Wt,e),e&&t(yn),e&&t(Qe),e&&t(vn),I(Vt,e),e&&t(wn),e&&t(ae),e&&t(gn),e&&t(be),I(Qt),e&&t(bn),e&&t(Xa),e&&t(En),e&&t(Fa),e&&t($n),I(Kt,e),e&&t(kn),e&&t(Ra),e&&t(Pn),e&&t(Ee),I(Zt),e&&t(An),e&&t(et),e&&t(Tn),e&&t(tt),e&&t(Cn),I(ea,e),e&&t(Dn),e&&t(at),e&&t(Nn),I(ta,e),e&&t(In),e&&t(ot),e&&t(Sn),e&&t($e),I(aa),e&&t(zn),e&&t(q),e&&t(On),e&&t(ke),I(oa),e&&t(jn),e&&t(nt),e&&t(Ln),I(ra,e),e&&t(Un),e&&t(Qa),e&&t(Mn),e&&t(Ka),e&&t(Gn),I(la,e),e&&t(Hn),e&&t(Pe),I(na),e&&t(Yn),e&&t(Za),e&&t(qn),e&&t(oe),e&&t(Bn),I(st,e),e&&t(xn),e&&t(Ae),I(ia),e&&t(Jn),e&&t(ut),e&&t(Xn),e&&t(re),e&&t(Fn),e&&t(ft),e&&t(Rn),e&&t(le),e&&t(Wn),e&&t(F),e&&t(Vn),e&&t(ne),e&&t(Qn),e&&t(ht),e&&t(Kn),e&&t(no),e&&t(Zn),e&&t(pt),e&&t(ei),e&&t(R),e&&t(ti),I(dt,e),e&&t(ai),I(mt,e),e&&t(oi),e&&t(_t)}}}const b_={local:"quick-tour",sections:[{local:"main-use",title:"Main use"},{local:"distributed-evaluation",title:"Distributed evaluation"},{local:"launching-your-distributed-script",title:"Launching your distributed script"},{local:"launching-training-from-a-notebook",title:"Launching training from a notebook"},{local:"training-on-tpu",title:"Training on TPU"},{local:"other-caveats",sections:[{local:"execute-a-statement-only-on-one-processes",title:"Execute a statement only on one processes"},{local:"defer-execution",title:"Defer execution"},{local:"savingloading-a-model",title:"Saving/loading a model"},{local:"gradient-clipping",title:"Gradient clipping"},{local:"mixed-precision-training",title:"Mixed Precision training"},{local:"deepspeed",title:"DeepSpeed"}],title:"Other caveats"},{local:"internal-mechanism",title:"Internal mechanism"}],title:"Quick tour"};function E_(m,o,h){let{fw:l}=o;return m.$$set=r=>{"fw"in r&&h(0,l=r.fw)},[l]}class T_ extends To{constructor(o){super();Co(this,o,E_,g_,Do,{fw:0})}}export{T_ as default,b_ as metadata};
