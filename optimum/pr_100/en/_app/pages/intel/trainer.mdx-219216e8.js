import{S as ie,i as se,s as le,e as a,k as y,w as M,t as Q,M as ce,c as o,d as t,m as T,a as l,x as S,h as W,b as i,F as n,g as k,y as C,L as me,q,o as U,B}from"../../chunks/vendor-19e06bd2.js";import{D as ae}from"../../chunks/Docstring-395e5a9c.js";import{I as oe}from"../../chunks/IconCopyLink-3c713d38.js";function pe(F){let c,$,r,s,b,g,H,w,R,E,m,u,N,f,V,I,j,A,p,_,J,h,v,G,x,K,P;return g=new oe({}),f=new oe({}),_=new ae({props:{name:"class optimum.intel.IncTrainer",anchor:"optimum.intel.IncTrainer",parameters:[{name:"model",val:": typing.Union[transformers.modeling_utils.PreTrainedModel, torch.nn.modules.module.Module] = None"},{name:"args",val:": TrainingArguments = None"},{name:"data_collator",val:": typing.Optional[DataCollator] = None"},{name:"train_dataset",val:": typing.Optional[torch.utils.data.dataset.Dataset] = None"},{name:"eval_dataset",val:": typing.Optional[torch.utils.data.dataset.Dataset] = None"},{name:"tokenizer",val:": typing.Optional[transformers.tokenization_utils_base.PreTrainedTokenizerBase] = None"},{name:"model_init",val:": typing.Callable[[], transformers.modeling_utils.PreTrainedModel] = None"},{name:"compute_metrics",val:": typing.Union[typing.Callable[[transformers.trainer_utils.EvalPrediction], typing.Dict], NoneType] = None"},{name:"callbacks",val:": typing.Optional[typing.List[transformers.trainer_callback.TrainerCallback]] = None"},{name:"optimizers",val:": typing.Tuple[torch.optim.optimizer.Optimizer, torch.optim.lr_scheduler.LambdaLR] = (None, None)"}],source:"https://github.com/huggingface/optimum/blob/pr_100/src/optimum/intel/neural_compressor/trainer_inc.py#L51"}}),v=new ae({props:{name:"train",anchor:"optimum.intel.IncTrainer.train",parameters:[{name:"pruner",val:": typing.Optional[neural_compressor.experimental.pruning.Pruning] = None"},{name:"resume_from_checkpoint",val:": typing.Union[str, bool, NoneType] = None"},{name:"trial",val:": typing.Union[ForwardRef('optuna.Trial'), typing.Dict[str, typing.Any]] = None"},{name:"ignore_keys_for_eval",val:": typing.Optional[typing.List[str]] = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_100/src/optimum/intel/neural_compressor/trainer_inc.py#L52",parametersDescription:[{anchor:"optimum.intel.IncTrainer.train.pruner",description:`<strong>pruner</strong> (<code>Pruning</code>, <em>optional</em>) &#x2014;
Pruning object handling the pruning process.`,name:"pruner"},{anchor:"optimum.intel.IncTrainer.train.resume_from_checkpoint",description:`<strong>resume_from_checkpoint</strong> (<code>str</code> or <code>bool</code>, <em>optional</em>) &#x2014;
If a <code>str</code>, local path to a saved checkpoint as saved by a previous instance of
<code>Trainer</code>. If a <code>bool</code> and equals <em>True</em>, load the last checkpoint in
<em>args.output_dir</em> as saved by a previous instance of <code>Trainer</code>. If present,
training will resume from the model/optimizer/scheduler states loaded here.`,name:"resume_from_checkpoint"},{anchor:"optimum.intel.IncTrainer.train.trial",description:`<strong>trial</strong> (<code>optuna.Trial</code> or <code>Dict[str, Any]</code>, <em>optional</em>) &#x2014;
The trial run or the hyperparameter dictionary for hyperparameter search.`,name:"trial"},{anchor:"optimum.intel.IncTrainer.train.ignore_keys_for_eval",description:`<strong>ignore_keys_for_eval</strong> (<code>List[str]</code>, <em>optional</em>) &#x2014;
A list of keys in the output of your model (if it is a dictionary) that should be ignored when
gathering predictions for evaluation during the training.
kwargs &#x2014;
Additional keyword arguments used to hide deprecated arguments`,name:"ignore_keys_for_eval"}]}}),{c(){c=a("meta"),$=y(),r=a("h1"),s=a("a"),b=a("span"),M(g.$$.fragment),H=y(),w=a("span"),R=Q("Trainer"),E=y(),m=a("h2"),u=a("a"),N=a("span"),M(f.$$.fragment),V=y(),I=a("span"),j=Q("IncTrainer"),A=y(),p=a("div"),M(_.$$.fragment),J=y(),h=a("div"),M(v.$$.fragment),G=y(),x=a("p"),K=Q("Main training entry point."),this.h()},l(e){const d=ce('[data-svelte="svelte-1phssyn"]',document.head);c=o(d,"META",{name:!0,content:!0}),d.forEach(t),$=T(e),r=o(e,"H1",{class:!0});var D=l(r);s=o(D,"A",{id:!0,class:!0,href:!0});var X=l(s);b=o(X,"SPAN",{});var Y=l(b);S(g.$$.fragment,Y),Y.forEach(t),X.forEach(t),H=T(D),w=o(D,"SPAN",{});var Z=l(w);R=W(Z,"Trainer"),Z.forEach(t),D.forEach(t),E=T(e),m=o(e,"H2",{class:!0});var L=l(m);u=o(L,"A",{id:!0,class:!0,href:!0});var ee=l(u);N=o(ee,"SPAN",{});var te=l(N);S(f.$$.fragment,te),te.forEach(t),ee.forEach(t),V=T(L),I=o(L,"SPAN",{});var ne=l(I);j=W(ne,"IncTrainer"),ne.forEach(t),L.forEach(t),A=T(e),p=o(e,"DIV",{class:!0});var O=l(p);S(_.$$.fragment,O),J=T(O),h=o(O,"DIV",{class:!0});var z=l(h);S(v.$$.fragment,z),G=T(z),x=o(z,"P",{});var re=l(x);K=W(re,"Main training entry point."),re.forEach(t),z.forEach(t),O.forEach(t),this.h()},h(){i(c,"name","hf:doc:metadata"),i(c,"content",JSON.stringify(de)),i(s,"id","trainer"),i(s,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(s,"href","#trainer"),i(r,"class","relative group"),i(u,"id","optimum.intel.IncTrainer"),i(u,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),i(u,"href","#optimum.intel.IncTrainer"),i(m,"class","relative group"),i(h,"class","docstring"),i(p,"class","docstring")},m(e,d){n(document.head,c),k(e,$,d),k(e,r,d),n(r,s),n(s,b),C(g,b,null),n(r,H),n(r,w),n(w,R),k(e,E,d),k(e,m,d),n(m,u),n(u,N),C(f,N,null),n(m,V),n(m,I),n(I,j),k(e,A,d),k(e,p,d),C(_,p,null),n(p,J),n(p,h),C(v,h,null),n(h,G),n(h,x),n(x,K),P=!0},p:me,i(e){P||(q(g.$$.fragment,e),q(f.$$.fragment,e),q(_.$$.fragment,e),q(v.$$.fragment,e),P=!0)},o(e){U(g.$$.fragment,e),U(f.$$.fragment,e),U(_.$$.fragment,e),U(v.$$.fragment,e),P=!1},d(e){t(c),e&&t($),e&&t(r),B(g),e&&t(E),e&&t(m),B(f),e&&t(A),e&&t(p),B(_),B(v)}}}const de={local:"trainer",sections:[{local:"optimum.intel.IncTrainer",title:"IncTrainer"}],title:"Trainer"};function ue(F,c,$){let{fw:r}=c;return F.$$set=s=>{"fw"in s&&$(0,r=s.fw)},[r]}class _e extends ie{constructor(c){super();se(this,c,ue,pe,le,{fw:0})}}export{_e as default,de as metadata};
