import{S as ka,i as wa,s as ba,e as n,k as c,w as I,t as s,M as Ea,c as i,d as a,m,a as l,x as L,h as o,b as z,F as e,g as p,y as F,L as Oa,q as S,o as W,B as X,v as $a}from"../chunks/vendor-19e06bd2.js";import{I as Ta}from"../chunks/IconCopyLink-3c713d38.js";import{C as K}from"../chunks/CodeBlock-9dd1fdfb.js";function xa(Ue){let q,qt,y,k,V,T,Wt,Y,Xt,yt,d,Bt,Z,Jt,Ut,tt,Gt,Kt,et,Vt,Yt,at,Zt,te,vt,x,kt,h,ee,st,ae,se,ot,oe,ne,nt,ie,le,it,re,pe,wt,C,bt,g,ce,lt,me,de,rt,he,ue,Et,R,Ot,u,fe,pt,ge,_e,ct,je,ze,D,mt,qe,ye,$t,A,Tt,w,ve,dt,ke,we,xt,P,Ct,b,be,ht,Ee,Oe,Rt,Q,Dt,B,$e,At,f,H,Te,ut,xe,Ce,Re,v,De,ft,Ae,Pe,gt,Qe,He,Me,M,Ne,_t,Ie,Le,Fe,jt,Se,Pt,E,We,N,zt,Xe,Be,Qt,J,Je,Ht;return T=new Ta({}),x=new K({props:{code:`from optimum.onnxruntime import ORTConfig, ORTQuantizer

# The model we wish to quantize
model_ckpt = "distilbert-base-uncased-finetuned-sst-2-english"
# The type of quantization to apply
ort_config = ORTConfig(quantization_approach="dynamic")
quantizer = ORTQuantizer(ort_config)
# Quantize the model!
quantizer.fit(model_ckpt, output_dir=".", feature="sequence-classification")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTConfig, ORTQuantizer

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># The model we wish to quantize</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>model_ckpt = <span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># The type of quantization to apply</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>ort_config = ORTConfig(quantization_approach=<span class="hljs-string">&quot;dynamic&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>quantizer = ORTQuantizer(ort_config)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Quantize the model!</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>quantizer.fit(model_ckpt, output_dir=<span class="hljs-string">&quot;.&quot;</span>, feature=<span class="hljs-string">&quot;sequence-classification&quot;</span>)`}}),C=new K({props:{code:`from datasets import Dataset
from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModel

# Load quantized model
ort_model = ORTModel("model-quantized.onnx", quantizer.onnx_config)
# Create a dataset or load one from the Hub
ds = Dataset.from_dict({"sentence": ["I love burritos!"]})
# Tokenize the inputs & convert to PyTorch tensors
tokenizer = AutoTokenizer.from_pretrained(model_ckpt)

def preprocess_fn(ex):
    return tokenizer(ex["sentence"])

tokenized_ds = ds.map(preprocess_fn, remove_columns=ds.column_names)
tokenized_ds.set_format("torch")
# Create dataloader and run evaluation
dataloader = DataLoader(tokenized_ds)
ort_outputs = ort_model.evaluation_loop(dataloader)
# Extract logits!
ort_outputs.predictions`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> Dataset
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModel

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Load quantized model</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>ort_model = ORTModel(<span class="hljs-string">&quot;model-quantized.onnx&quot;</span>, quantizer.onnx_config)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Create a dataset or load one from the Hub</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>ds = Dataset.from_dict({<span class="hljs-string">&quot;sentence&quot;</span>: [<span class="hljs-string">&quot;I love burritos!&quot;</span>]})
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Tokenize the inputs &amp; convert to PyTorch tensors</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(model_ckpt)

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">preprocess_fn</span>(<span class="hljs-params">ex</span>):
<span class="hljs-meta">... </span>    <span class="hljs-keyword">return</span> tokenizer(ex[<span class="hljs-string">&quot;sentence&quot;</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenized_ds = ds.<span class="hljs-built_in">map</span>(preprocess_fn, remove_columns=ds.column_names)
<span class="hljs-meta">&gt;&gt;&gt; </span>tokenized_ds.set_format(<span class="hljs-string">&quot;torch&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Create dataloader and run evaluation</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>dataloader = DataLoader(tokenized_ds)
<span class="hljs-meta">&gt;&gt;&gt; </span>ort_outputs = ort_model.evaluation_loop(dataloader)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Extract logits!</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>ort_outputs.predictions`}}),R=new K({props:{code:'ort_config = ORTConfig(quantization_approach="static")',highlighted:'<span class="hljs-meta">&gt;&gt;&gt; </span>ort_config = ORTConfig(quantization_approach=<span class="hljs-string">&quot;static&quot;</span>)'}}),A=new K({props:{code:`from transformers import DataCollatorWithPadding

# We use a data collator to pad the examples in a batch
data_collator = DataCollatorWithPadding(tokenizer)
# For calibration we define the dataset and preprocessing function
quantizer = ORTQuantizer(
    ort_config,
    dataset_name="glue",
    dataset_config_name="sst2",
    preprocess_function=preprocess_fn,
    data_collator=data_collator,
)
# Quantize the same way we did for dynamic quantization!
quantizer.fit(model_ckpt, output_dir=".", feature="sequence-classification")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> DataCollatorWithPadding

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># We use a data collator to pad the examples in a batch</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>data_collator = DataCollatorWithPadding(tokenizer)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># For calibration we define the dataset and preprocessing function</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>quantizer = ORTQuantizer(
<span class="hljs-meta">... </span>    ort_config,
<span class="hljs-meta">... </span>    dataset_name=<span class="hljs-string">&quot;glue&quot;</span>,
<span class="hljs-meta">... </span>    dataset_config_name=<span class="hljs-string">&quot;sst2&quot;</span>,
<span class="hljs-meta">... </span>    preprocess_function=preprocess_fn,
<span class="hljs-meta">... </span>    data_collator=data_collator,
<span class="hljs-meta">... </span>)
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Quantize the same way we did for dynamic quantization!</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>quantizer.fit(model_ckpt, output_dir=<span class="hljs-string">&quot;.&quot;</span>, feature=<span class="hljs-string">&quot;sequence-classification&quot;</span>)`}}),P=new K({props:{code:`# opt_level=99 enables all graph optimisations
ort_config = ORTConfig(opt_level=99)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># opt_level=99 enables all graph optimisations</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>ort_config = ORTConfig(opt_level=<span class="hljs-number">99</span>)`}}),Q=new K({props:{code:`from optimum.onnxruntime import ORTOptimizer

optimizer = ORTOptimizer(ort_config)
optimizer.fit(model_ckpt, output_dir=".", feature="sequence-classification")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTOptimizer

<span class="hljs-meta">&gt;&gt;&gt; </span>optimizer = ORTOptimizer(ort_config)
<span class="hljs-meta">&gt;&gt;&gt; </span>optimizer.fit(model_ckpt, output_dir=<span class="hljs-string">&quot;.&quot;</span>, feature=<span class="hljs-string">&quot;sequence-classification&quot;</span>)`}}),{c(){q=n("meta"),qt=c(),y=n("h1"),k=n("a"),V=n("span"),I(T.$$.fragment),Wt=c(),Y=n("span"),Xt=s("Quickstart"),yt=c(),d=n("p"),Bt=s("At its core, \u{1F917} Optimum uses "),Z=n("em"),Jt=s("configuration objects"),Ut=s(" to define parameters for optimization on different accelerators. These objects are then used to instantiate dedicated "),tt=n("em"),Gt=s("optimizers"),Kt=s(", "),et=n("em"),Vt=s("quantizers"),Yt=s(", and "),at=n("em"),Zt=s("pruners"),te=s(". For example, here\u2019s how you can apply dynamic quantization with ONNX Runtime:"),vt=c(),I(x.$$.fragment),kt=c(),h=n("p"),ee=s("In this example, we\u2019ve quantized a model from the Hugging Face Hub, but it could also be a path to a local model directory. The "),st=n("code"),ae=s("feature"),se=s(" argument in the "),ot=n("code"),oe=s("fit()"),ne=s(" method corresponds to the type of task that we wish to quantize the model for. The result from applying the "),nt=n("code"),ie=s("fit()"),le=s(" method is a "),it=n("code"),re=s("model-quantized.onnx"),pe=s(" file that can be used to run inference. Here\u2019s an example of how to load an ONNX Runtime model and generate predictions with it:"),wt=c(),I(C.$$.fragment),bt=c(),g=n("p"),ce=s("Similarly, you can apply static quantization by simply changing the "),lt=n("code"),me=s("quantization_approach"),de=s(" in the "),rt=n("code"),he=s("ORTConfig"),ue=s(" object:"),Et=c(),I(R.$$.fragment),Ot=c(),u=n("p"),fe=s("Static quantization relies on feeding batches of data through the model to observe the activation patterns ahead of inference time. The ideal quantization scheme is then calculated and saved. To support this, \u{1F917} Optimum allows you to provide a "),pt=n("em"),ge=s("calibration dataset"),_e=s(". The calibration dataset can be a simple "),ct=n("code"),je=s("Dataset"),ze=s(" object from the \u{1F917} Datasets library, or any dataset that\u2019s hosted on the Hugging Face Hub. For this example, we\u2019ll pick the "),D=n("a"),mt=n("code"),qe=s("sst2"),ye=s(" dataset that the model was originally trained on:"),$t=c(),I(A.$$.fragment),Tt=c(),w=n("p"),ve=s("As a final example, let\u2019s take a look at applying "),dt=n("em"),ke=s("graph optimizations"),we=s(" techniques such as operator fusion and constant folding. As before, we load a configuration object, but this time by setting the optimization level instead of the quantization approach:"),xt=c(),I(P.$$.fragment),Ct=c(),b=n("p"),be=s("Next, we load an "),ht=n("em"),Ee=s("optimizer"),Oe=s(" to apply these optimisations to our model:"),Rt=c(),I(Q.$$.fragment),Dt=c(),B=n("p"),$e=s("And that\u2019s it - the model is now optimized and ready for inference! As you can see, the process is similar in each case:"),At=c(),f=n("ol"),H=n("li"),Te=s("Define the optimization / quantization strategies via an "),ut=n("code"),xe=s("ORTConfig"),Ce=s(" object"),Re=c(),v=n("li"),De=s("Instantiate a "),ft=n("code"),Ae=s("ORTQuantizer"),Pe=s(" or "),gt=n("code"),Qe=s("ORTOptimizer"),He=s(" class"),Me=c(),M=n("li"),Ne=s("Apply the "),_t=n("code"),Ie=s("fit()"),Le=s(" method"),Fe=c(),jt=n("li"),Se=s("Run inference"),Pt=c(),E=n("p"),We=s("Check out the "),N=n("a"),zt=n("code"),Xe=s("examples"),Be=s(" directory for more sophisticated usage."),Qt=c(),J=n("p"),Je=s("Happy optimising \u{1F917}!"),this.h()},l(t){const r=Ea('[data-svelte="svelte-1phssyn"]',document.head);q=i(r,"META",{name:!0,content:!0}),r.forEach(a),qt=m(t),y=i(t,"H1",{class:!0});var Mt=l(y);k=i(Mt,"A",{id:!0,class:!0,href:!0});var Ge=l(k);V=i(Ge,"SPAN",{});var Ke=l(V);L(T.$$.fragment,Ke),Ke.forEach(a),Ge.forEach(a),Wt=m(Mt),Y=i(Mt,"SPAN",{});var Ve=l(Y);Xt=o(Ve,"Quickstart"),Ve.forEach(a),Mt.forEach(a),yt=m(t),d=i(t,"P",{});var _=l(d);Bt=o(_,"At its core, \u{1F917} Optimum uses "),Z=i(_,"EM",{});var Ye=l(Z);Jt=o(Ye,"configuration objects"),Ye.forEach(a),Ut=o(_," to define parameters for optimization on different accelerators. These objects are then used to instantiate dedicated "),tt=i(_,"EM",{});var Ze=l(tt);Gt=o(Ze,"optimizers"),Ze.forEach(a),Kt=o(_,", "),et=i(_,"EM",{});var ta=l(et);Vt=o(ta,"quantizers"),ta.forEach(a),Yt=o(_,", and "),at=i(_,"EM",{});var ea=l(at);Zt=o(ea,"pruners"),ea.forEach(a),te=o(_,". For example, here\u2019s how you can apply dynamic quantization with ONNX Runtime:"),_.forEach(a),vt=m(t),L(x.$$.fragment,t),kt=m(t),h=i(t,"P",{});var j=l(h);ee=o(j,"In this example, we\u2019ve quantized a model from the Hugging Face Hub, but it could also be a path to a local model directory. The "),st=i(j,"CODE",{});var aa=l(st);ae=o(aa,"feature"),aa.forEach(a),se=o(j," argument in the "),ot=i(j,"CODE",{});var sa=l(ot);oe=o(sa,"fit()"),sa.forEach(a),ne=o(j," method corresponds to the type of task that we wish to quantize the model for. The result from applying the "),nt=i(j,"CODE",{});var oa=l(nt);ie=o(oa,"fit()"),oa.forEach(a),le=o(j," method is a "),it=i(j,"CODE",{});var na=l(it);re=o(na,"model-quantized.onnx"),na.forEach(a),pe=o(j," file that can be used to run inference. Here\u2019s an example of how to load an ONNX Runtime model and generate predictions with it:"),j.forEach(a),wt=m(t),L(C.$$.fragment,t),bt=m(t),g=i(t,"P",{});var U=l(g);ce=o(U,"Similarly, you can apply static quantization by simply changing the "),lt=i(U,"CODE",{});var ia=l(lt);me=o(ia,"quantization_approach"),ia.forEach(a),de=o(U," in the "),rt=i(U,"CODE",{});var la=l(rt);he=o(la,"ORTConfig"),la.forEach(a),ue=o(U," object:"),U.forEach(a),Et=m(t),L(R.$$.fragment,t),Ot=m(t),u=i(t,"P",{});var O=l(u);fe=o(O,"Static quantization relies on feeding batches of data through the model to observe the activation patterns ahead of inference time. The ideal quantization scheme is then calculated and saved. To support this, \u{1F917} Optimum allows you to provide a "),pt=i(O,"EM",{});var ra=l(pt);ge=o(ra,"calibration dataset"),ra.forEach(a),_e=o(O,". The calibration dataset can be a simple "),ct=i(O,"CODE",{});var pa=l(ct);je=o(pa,"Dataset"),pa.forEach(a),ze=o(O," object from the \u{1F917} Datasets library, or any dataset that\u2019s hosted on the Hugging Face Hub. For this example, we\u2019ll pick the "),D=i(O,"A",{href:!0,rel:!0});var ca=l(D);mt=i(ca,"CODE",{});var ma=l(mt);qe=o(ma,"sst2"),ma.forEach(a),ca.forEach(a),ye=o(O," dataset that the model was originally trained on:"),O.forEach(a),$t=m(t),L(A.$$.fragment,t),Tt=m(t),w=i(t,"P",{});var Nt=l(w);ve=o(Nt,"As a final example, let\u2019s take a look at applying "),dt=i(Nt,"EM",{});var da=l(dt);ke=o(da,"graph optimizations"),da.forEach(a),we=o(Nt," techniques such as operator fusion and constant folding. As before, we load a configuration object, but this time by setting the optimization level instead of the quantization approach:"),Nt.forEach(a),xt=m(t),L(P.$$.fragment,t),Ct=m(t),b=i(t,"P",{});var It=l(b);be=o(It,"Next, we load an "),ht=i(It,"EM",{});var ha=l(ht);Ee=o(ha,"optimizer"),ha.forEach(a),Oe=o(It," to apply these optimisations to our model:"),It.forEach(a),Rt=m(t),L(Q.$$.fragment,t),Dt=m(t),B=i(t,"P",{});var ua=l(B);$e=o(ua,"And that\u2019s it - the model is now optimized and ready for inference! As you can see, the process is similar in each case:"),ua.forEach(a),At=m(t),f=i(t,"OL",{});var $=l(f);H=i($,"LI",{});var Lt=l(H);Te=o(Lt,"Define the optimization / quantization strategies via an "),ut=i(Lt,"CODE",{});var fa=l(ut);xe=o(fa,"ORTConfig"),fa.forEach(a),Ce=o(Lt," object"),Lt.forEach(a),Re=m($),v=i($,"LI",{});var G=l(v);De=o(G,"Instantiate a "),ft=i(G,"CODE",{});var ga=l(ft);Ae=o(ga,"ORTQuantizer"),ga.forEach(a),Pe=o(G," or "),gt=i(G,"CODE",{});var _a=l(gt);Qe=o(_a,"ORTOptimizer"),_a.forEach(a),He=o(G," class"),G.forEach(a),Me=m($),M=i($,"LI",{});var Ft=l(M);Ne=o(Ft,"Apply the "),_t=i(Ft,"CODE",{});var ja=l(_t);Ie=o(ja,"fit()"),ja.forEach(a),Le=o(Ft," method"),Ft.forEach(a),Fe=m($),jt=i($,"LI",{});var za=l(jt);Se=o(za,"Run inference"),za.forEach(a),$.forEach(a),Pt=m(t),E=i(t,"P",{});var St=l(E);We=o(St,"Check out the "),N=i(St,"A",{href:!0,rel:!0});var qa=l(N);zt=i(qa,"CODE",{});var ya=l(zt);Xe=o(ya,"examples"),ya.forEach(a),qa.forEach(a),Be=o(St," directory for more sophisticated usage."),St.forEach(a),Qt=m(t),J=i(t,"P",{});var va=l(J);Je=o(va,"Happy optimising \u{1F917}!"),va.forEach(a),this.h()},h(){z(q,"name","hf:doc:metadata"),z(q,"content",JSON.stringify(Ca)),z(k,"id","quickstart"),z(k,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),z(k,"href","#quickstart"),z(y,"class","relative group"),z(D,"href","https://huggingface.co/datasets/glue/viewer/sst2/test"),z(D,"rel","nofollow"),z(N,"href","https://github.com/huggingface/optimum/tree/main/examples"),z(N,"rel","nofollow")},m(t,r){e(document.head,q),p(t,qt,r),p(t,y,r),e(y,k),e(k,V),F(T,V,null),e(y,Wt),e(y,Y),e(Y,Xt),p(t,yt,r),p(t,d,r),e(d,Bt),e(d,Z),e(Z,Jt),e(d,Ut),e(d,tt),e(tt,Gt),e(d,Kt),e(d,et),e(et,Vt),e(d,Yt),e(d,at),e(at,Zt),e(d,te),p(t,vt,r),F(x,t,r),p(t,kt,r),p(t,h,r),e(h,ee),e(h,st),e(st,ae),e(h,se),e(h,ot),e(ot,oe),e(h,ne),e(h,nt),e(nt,ie),e(h,le),e(h,it),e(it,re),e(h,pe),p(t,wt,r),F(C,t,r),p(t,bt,r),p(t,g,r),e(g,ce),e(g,lt),e(lt,me),e(g,de),e(g,rt),e(rt,he),e(g,ue),p(t,Et,r),F(R,t,r),p(t,Ot,r),p(t,u,r),e(u,fe),e(u,pt),e(pt,ge),e(u,_e),e(u,ct),e(ct,je),e(u,ze),e(u,D),e(D,mt),e(mt,qe),e(u,ye),p(t,$t,r),F(A,t,r),p(t,Tt,r),p(t,w,r),e(w,ve),e(w,dt),e(dt,ke),e(w,we),p(t,xt,r),F(P,t,r),p(t,Ct,r),p(t,b,r),e(b,be),e(b,ht),e(ht,Ee),e(b,Oe),p(t,Rt,r),F(Q,t,r),p(t,Dt,r),p(t,B,r),e(B,$e),p(t,At,r),p(t,f,r),e(f,H),e(H,Te),e(H,ut),e(ut,xe),e(H,Ce),e(f,Re),e(f,v),e(v,De),e(v,ft),e(ft,Ae),e(v,Pe),e(v,gt),e(gt,Qe),e(v,He),e(f,Me),e(f,M),e(M,Ne),e(M,_t),e(_t,Ie),e(M,Le),e(f,Fe),e(f,jt),e(jt,Se),p(t,Pt,r),p(t,E,r),e(E,We),e(E,N),e(N,zt),e(zt,Xe),e(E,Be),p(t,Qt,r),p(t,J,r),e(J,Je),Ht=!0},p:Oa,i(t){Ht||(S(T.$$.fragment,t),S(x.$$.fragment,t),S(C.$$.fragment,t),S(R.$$.fragment,t),S(A.$$.fragment,t),S(P.$$.fragment,t),S(Q.$$.fragment,t),Ht=!0)},o(t){W(T.$$.fragment,t),W(x.$$.fragment,t),W(C.$$.fragment,t),W(R.$$.fragment,t),W(A.$$.fragment,t),W(P.$$.fragment,t),W(Q.$$.fragment,t),Ht=!1},d(t){a(q),t&&a(qt),t&&a(y),X(T),t&&a(yt),t&&a(d),t&&a(vt),X(x,t),t&&a(kt),t&&a(h),t&&a(wt),X(C,t),t&&a(bt),t&&a(g),t&&a(Et),X(R,t),t&&a(Ot),t&&a(u),t&&a($t),X(A,t),t&&a(Tt),t&&a(w),t&&a(xt),X(P,t),t&&a(Ct),t&&a(b),t&&a(Rt),X(Q,t),t&&a(Dt),t&&a(B),t&&a(At),t&&a(f),t&&a(Pt),t&&a(E),t&&a(Qt),t&&a(J)}}}const Ca={local:"quickstart",title:"Quickstart"};function Ra(Ue){return $a(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Qa extends ka{constructor(q){super();wa(this,q,Ra,xa,ba,{})}}export{Qa as default,Ca as metadata};
