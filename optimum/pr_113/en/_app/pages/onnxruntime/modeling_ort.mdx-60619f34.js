import{S as ji,i as Ri,s as Fi,e as n,k as l,w as h,t as a,M as Ai,c as s,d as o,m,a as r,x as f,h as i,b as c,F as e,g as u,y as g,q as _,o as k,B as w,v as Ci}from"../../chunks/vendor-4918fc3c.js";import{T as vn}from"../../chunks/Tip-3d800dd6.js";import{D as L}from"../../chunks/Docstring-1b707a93.js";import{C as X}from"../../chunks/CodeBlock-99419108.js";import{I as qe}from"../../chunks/IconCopyLink-21d338b1.js";function Pi(W){let d,O,v,x,y;return{c(){d=n("p"),O=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),v=n("code"),x=a("Module"),y=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){d=s(T,"P",{});var $=r(d);O=i($,"Although the recipe for forward pass needs to be defined within this function, one should call the "),v=s($,"CODE",{});var j=r(v);x=i(j,"Module"),j.forEach(o),y=i($,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),$.forEach(o)},m(T,$){u(T,d,$),e(d,O),e(d,v),e(v,x),e(d,y)},d(T){T&&o(d)}}}function Ni(W){let d,O,v,x,y;return{c(){d=n("p"),O=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),v=n("code"),x=a("Module"),y=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){d=s(T,"P",{});var $=r(d);O=i($,"Although the recipe for forward pass needs to be defined within this function, one should call the "),v=s($,"CODE",{});var j=r(v);x=i(j,"Module"),j.forEach(o),y=i($,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),$.forEach(o)},m(T,$){u(T,d,$),e(d,O),e(d,v),e(v,x),e(d,y)},d(T){T&&o(d)}}}function Si(W){let d,O,v,x,y;return{c(){d=n("p"),O=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),v=n("code"),x=a("Module"),y=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){d=s(T,"P",{});var $=r(d);O=i($,"Although the recipe for forward pass needs to be defined within this function, one should call the "),v=s($,"CODE",{});var j=r(v);x=i(j,"Module"),j.forEach(o),y=i($,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),$.forEach(o)},m(T,$){u(T,d,$),e(d,O),e(d,v),e(v,x),e(d,y)},d(T){T&&o(d)}}}function Di(W){let d,O,v,x,y;return{c(){d=n("p"),O=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),v=n("code"),x=a("Module"),y=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(T){d=s(T,"P",{});var $=r(d);O=i($,"Although the recipe for forward pass needs to be defined within this function, one should call the "),v=s($,"CODE",{});var j=r(v);x=i(j,"Module"),j.forEach(o),y=i($,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),$.forEach(o)},m(T,$){u(T,d,$),e(d,O),e(d,v),e(v,x),e(d,y)},d(T){T&&o(d)}}}function Ii(W){let d,O,v,x,y,T,$,j,Tn,zo,me,$n,_t,xn,bn,jo,K,pe,bt,Me,yn,yt,On,Ro,N,qn,Ot,Mn,En,qt,zn,jn,Mt,Rn,Fn,Et,An,Cn,Fo,Ee,Ao,H,Pn,zt,Nn,Sn,jt,Dn,In,Rt,Hn,Qn,Co,ze,Po,ce,Ln,kt,Xn,Wn,No,Z,de,Ft,je,Bn,At,Un,So,Q,Gn,Ct,Vn,Jn,Re,Yn,Kn,Pt,Zn,es,Do,Fe,Io,ee,ue,Nt,Ae,ts,St,os,Ho,R,Ce,ns,Pe,ss,Dt,rs,as,is,he,Ne,ls,wt,ms,It,ps,cs,fe,Se,ds,Ht,us,hs,ge,De,fs,Qt,gs,Qo,te,_e,Lt,Ie,_s,Xt,ks,Lo,F,He,ws,Wt,vs,Ts,Qe,$s,Bt,xs,bs,ys,Ut,Os,qs,q,Le,Ms,oe,Es,Gt,zs,js,Vt,Rs,Fs,As,ke,Cs,Jt,Ps,Ns,Xe,Ss,We,Ds,Yt,Is,Hs,Qs,Be,Xo,ne,we,Kt,Ue,Ls,Zt,Xs,Wo,A,Ge,Ws,eo,Bs,Us,Ve,Gs,to,Vs,Js,Ys,oo,Ks,Zs,M,Je,er,se,tr,no,or,nr,so,sr,rr,ar,ve,ir,ro,lr,mr,Ye,pr,Ke,cr,ao,dr,ur,hr,Ze,Bo,re,Te,io,et,fr,lo,gr,Uo,C,tt,_r,mo,kr,wr,ot,vr,po,Tr,$r,xr,co,br,yr,b,nt,Or,ae,qr,uo,Mr,Er,ho,zr,jr,Rr,$e,Fr,fo,Ar,Cr,st,Pr,rt,Nr,go,Sr,Dr,Ir,at,Hr,it,Qr,_o,Lr,Xr,Wr,lt,Go,ie,xe,ko,mt,Br,wo,Ur,Vo,P,pt,Gr,vo,Vr,Jr,ct,Yr,To,Kr,Zr,ea,$o,ta,oa,E,dt,na,le,sa,xo,ra,aa,bo,ia,la,ma,be,pa,yo,ca,da,ut,ua,ht,ha,Oo,fa,ga,_a,ft,Jo;return T=new qe({}),Me=new qe({}),Ee=new X({props:{code:`from transformers import AutoTokenizer, pipeline
-from transformers import AutoModelForQuestionAnswering
+from optimum.onnxruntime import ORTModelForQuestionAnswering

-model = AutoModelForQuestionAnswering.from_pretrained("deepset/roberta-base-squad2")
+model = ORTModelForQuestionAnswering.from_pretrained("deepset/roberta-base-squad2",from_transformers=True)
tokenizer = AutoTokenizer.from_pretrained("deepset/roberta-base-squad2")

onnx_qa = pipeline("question-answering",model=model,tokenizer=tokenizer)

question = "What's my name?"
context = "My name is Philipp and I live in Nuremberg."
pred = onnx_qa(question, context)`,highlighted:`from transformers import AutoTokenizer, pipeline
<span class="hljs-deletion">-from transformers import AutoModelForQuestionAnswering</span>
<span class="hljs-addition">+from optimum.onnxruntime import ORTModelForQuestionAnswering</span>

<span class="hljs-deletion">-model = AutoModelForQuestionAnswering.from_pretrained(&quot;deepset/roberta-base-squad2&quot;)</span>
<span class="hljs-addition">+model = ORTModelForQuestionAnswering.from_pretrained(&quot;deepset/roberta-base-squad2&quot;,from_transformers=True)</span>
tokenizer = AutoTokenizer.from_pretrained(&quot;deepset/roberta-base-squad2&quot;)

onnx_qa = pipeline(&quot;question-answering&quot;,model=model,tokenizer=tokenizer)

question = &quot;What&#x27;s my name?&quot;
context = &quot;My name is Philipp and I live in Nuremberg.&quot;
pred = onnx_qa(question, context)`}}),ze=new X({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForSequenceClassification

# load model from hub and convert
model = ORTModelForSequenceClassification.from_pretrained("distilbert-base-uncased-finetuned-sst-2-english",from_transformers=True)
tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased-finetuned-sst-2-english")

# optimize model
model.optimize()
# quantize model
model.quantize()

# create pipeline
onnx_clx = pipeline("text-classification",model=model,tokenizer=tokenizer)

result = onnx_clx(text="This is a great model")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification

<span class="hljs-comment"># load model from hub and convert</span>
model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>,from_transformers=<span class="hljs-literal">True</span>)
tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)

<span class="hljs-comment"># optimize model</span>
model.optimize()
<span class="hljs-comment"># quantize model</span>
model.quantize()

<span class="hljs-comment"># create pipeline</span>
onnx_clx = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>,model=model,tokenizer=tokenizer)

result = onnx_clx(text=<span class="hljs-string">&quot;This is a great model&quot;</span>)`}}),je=new qe({}),Fe=new X({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForSequenceClassification

# load model from hub and convert
model = ORTModelForSequenceClassification.from_pretrained("distilbert-base-uncased-finetuned-sst-2-english",from_transformers=True)
tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased-finetuned-sst-2-english")

# optimize model
model.optimize()
# quantize model
model.quantize()

# save converted model
model.save_pretrained("a_local_path_for_convert_onnx_model")
tokenizer.save_pretrained("a_local_path_for_convert_onnx_model")

# push model onnx model to HF Hub
model.push_to_hub("a_local_path_for_convert_onnx_model",
                  repository_id="my-onnx-repo",
                  use_auth_token=True
                  )`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification

<span class="hljs-comment"># load model from hub and convert</span>
model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>,from_transformers=<span class="hljs-literal">True</span>)
tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)

<span class="hljs-comment"># optimize model</span>
model.optimize()
<span class="hljs-comment"># quantize model</span>
model.quantize()

<span class="hljs-comment"># save converted model</span>
model.save_pretrained(<span class="hljs-string">&quot;a_local_path_for_convert_onnx_model&quot;</span>)
tokenizer.save_pretrained(<span class="hljs-string">&quot;a_local_path_for_convert_onnx_model&quot;</span>)

<span class="hljs-comment"># push model onnx model to HF Hub</span>
model.push_to_hub(<span class="hljs-string">&quot;a_local_path_for_convert_onnx_model&quot;</span>,
                  repository_id=<span class="hljs-string">&quot;my-onnx-repo&quot;</span>,
                  use_auth_token=<span class="hljs-literal">True</span>
                  )`}}),Ae=new qe({}),Ce=new L({props:{name:"class optimum.onnxruntime.ORTModel",anchor:"optimum.onnxruntime.ORTModel",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L72"}}),Ne=new L({props:{name:"load_model",anchor:"optimum.onnxruntime.ORTModel.load_model",parameters:[{name:"path",val:": typing.Union[str, pathlib.Path]"},{name:"provider",val:" = None"}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L174",parametersDescription:[{anchor:"optimum.onnxruntime.ORTModel.load_model.path",description:`<strong>path</strong> (<code>str</code> or <code>Path</code>) &#x2014;
Directory from which to load
provider(<code>str</code>) &#x2014;
Onnxruntime provider to use for loading the model, defaults to <em>CUDAExecutionProvider</em> if GPU is
available else <em>CPUExecutionProvider</em>`,name:"path"}]}}),Se=new L({props:{name:"optimize",anchor:"optimum.onnxruntime.ORTModel.optimize",parameters:[{name:"input_path",val:": typing.Union[str, pathlib.Path] = None"},{name:"model_type",val:": str = 'bert'"},{name:"output_path",val:": typing.Union[str, pathlib.Path] = '/github/home/.cache/huggingface/transformers'"},{name:"opt_level",val:": int = 1"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L84",parametersDescription:[{anchor:"optimum.onnxruntime.ORTModel.optimize.input_path",description:`<strong>input_path</strong> (<code>str</code> or <code>Path</code>) &#x2014;
Directory from which to load
output_path(<code>str</code>) &#x2014;
Directory where the quantized model should be saved, default to
<em>transformers.file_utils.default_cache_path</em>, which is the cache dir for transformers.`,name:"input_path"}]}}),De=new L({props:{name:"quantize",anchor:"optimum.onnxruntime.ORTModel.quantize",parameters:[{name:"input_path",val:": typing.Union[str, pathlib.Path] = None"},{name:"output_path",val:": typing.Union[str, pathlib.Path] = '/github/home/.cache/huggingface/transformers'"}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L137",parametersDescription:[{anchor:"optimum.onnxruntime.ORTModel.quantize.input_path",description:`<strong>input_path</strong> (<code>str</code> or <code>Path</code>) &#x2014;
Directory from which to load
output_path(<code>str</code>) &#x2014;
Directory where the quantized model should be saved, default to
<em>transformers.file_utils.default_cache_path</em>, which is the cache dir for transformers.`,name:"input_path"}]}}),Ie=new qe({}),He=new L({props:{name:"class optimum.onnxruntime.ORTModelForFeatureExtraction",anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L371",parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.config",description:`<strong>config</strong> ([<code>PretrainedConfig</code>](https &#x2014;//huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig)): Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <code>from_pretrained</code> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.model",description:"<strong>model</strong> ([<code>onnxruntime.InferenceSession</code>](https &#x2014;//onnxruntime.ai/docs/api/python/api_summary.html#inferencesession)): This is the main class used to run a model. Check out the <code>load_model</code>",name:"model"},{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.for",description:"<strong>for</strong> more information. &#x2014;",name:"for"}]}}),Le=new L({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L384",parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForFeatureExtraction.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}]}}),ke=new vn({props:{$$slots:{default:[Pi]},$$scope:{ctx:W}}}),Xe=new X({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForFeatureExtraction
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/all-MiniLM-L6-v2")
model = ORTModelForFeatureExtraction.from_pretrained("optimum/all-MiniLM-L6-v2")

inputs = tokenizer("My Name is Philipp and i live in Germany.", return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits
list(logits.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForFeatureExtraction
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForFeatureExtraction.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;My Name is Philipp and i live in Germany.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)`}}),Be=new X({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForFeatureExtraction

tokenizer = AutoTokenizer.from_pretrained("optimum/all-MiniLM-L6-v2")
model = ORTModelForFeatureExtraction.from_pretrained("optimum/all-MiniLM-L6-v2")
onnx_ner = pipeline("feature-extraction", model=model, tokenizer=tokenizer)

text = "My Name is Philipp and i live in Germany."
pred = onnx_ner(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForFeatureExtraction

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForFeatureExtraction.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_ner = pipeline(<span class="hljs-string">&quot;feature-extraction&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;My Name is Philipp and i live in Germany.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_ner(text)`}}),Ue=new qe({}),Ge=new L({props:{name:"class optimum.onnxruntime.ORTModelForQuestionAnswering",anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L456",parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.config",description:`<strong>config</strong> ([<code>PretrainedConfig</code>](https &#x2014;//huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig)): Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <code>from_pretrained</code> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.model",description:"<strong>model</strong> ([<code>onnxruntime.InferenceSession</code>](https &#x2014;//onnxruntime.ai/docs/api/python/api_summary.html#inferencesession)): This is the main class used to run a model. Check out the <code>load_model</code>",name:"model"},{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.for",description:"<strong>for</strong> more information. &#x2014;",name:"for"}]}}),Je=new L({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L469",parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForQuestionAnswering.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}]}}),ve=new vn({props:{$$slots:{default:[Ni]},$$scope:{ctx:W}}}),Ye=new X({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForQuestionAnswering
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/roberta-base-squad2")
model = ORTModelForQuestionAnswering.from_pretrained("optimum/roberta-base-squad2")

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"
inputs = tokenizer(question, text, return_tensors="pt")
start_positions = torch.tensor([1])
end_positions = torch.tensor([3])

outputs = model(**inputs, start_positions=start_positions, end_positions=end_positions)
start_scores = outputs.start_logits
end_scores = outputs.end_logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForQuestionAnswering
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(question, text, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>start_positions = torch.tensor([<span class="hljs-number">1</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>end_positions = torch.tensor([<span class="hljs-number">3</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, start_positions=start_positions, end_positions=end_positions)
<span class="hljs-meta">&gt;&gt;&gt; </span>start_scores = outputs.start_logits
<span class="hljs-meta">&gt;&gt;&gt; </span>end_scores = outputs.end_logits`}}),Ze=new X({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForQuestionAnswering

tokenizer = AutoTokenizer.from_pretrained("optimum/roberta-base-squad2")
model = ORTModelForQuestionAnswering.from_pretrained("optimum/roberta-base-squad2")
onnx_qa = pipeline("question-answering", model=model, tokenizer=tokenizer)

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"
pred = onnx_qa(question, text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForQuestionAnswering

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_qa = pipeline(<span class="hljs-string">&quot;question-answering&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_qa(question, text)`}}),et=new qe({}),tt=new L({props:{name:"class optimum.onnxruntime.ORTModelForSequenceClassification",anchor:"optimum.onnxruntime.ORTModelForSequenceClassification",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L556",parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.config",description:`<strong>config</strong> ([<code>PretrainedConfig</code>](https &#x2014;//huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig)): Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <code>from_pretrained</code> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.model",description:"<strong>model</strong> ([<code>onnxruntime.InferenceSession</code>](https &#x2014;//onnxruntime.ai/docs/api/python/api_summary.html#inferencesession)): This is the main class used to run a model. Check out the <code>load_model</code>",name:"model"},{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.for",description:"<strong>for</strong> more information. &#x2014;",name:"for"}]}}),nt=new L({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L570",parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForSequenceClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}]}}),$e=new vn({props:{$$slots:{default:[Si]},$$scope:{ctx:W}}}),st=new X({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForSequenceClassification
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")
model = ORTModelForSequenceClassification.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits
list(logits.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)`}}),at=new X({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForSequenceClassification

tokenizer = AutoTokenizer.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")
model = ORTModelForSequenceClassification.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")
onnx_clx = pipeline("text-classification", model=model, tokenizer=tokenizer)

text = "Hello, my dog is cute"
pred = onnx_clx(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_clx = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_clx(text)`}}),lt=new X({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForSequenceClassification

tokenizer = AutoTokenizer.from_pretrained("optimum/distilbert-base-uncased-mnli")
model = ORTModelForSequenceClassification.from_pretrained("optimum/distilbert-base-uncased-mnli")
onnx_z0 = pipeline("zero-shot-classification", model=model, tokenizer=tokenizer)

sequence_to_classify = "Who are you voting for in 2020?"
candidate_labels = ["Europe", "public health", "politics", "elections"]
pred = onnx_z0(sequence_to_classify, candidate_labels, multi_class=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-mnli&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-mnli&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_z0 = pipeline(<span class="hljs-string">&quot;zero-shot-classification&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>sequence_to_classify = <span class="hljs-string">&quot;Who are you voting for in 2020?&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>candidate_labels = [<span class="hljs-string">&quot;Europe&quot;</span>, <span class="hljs-string">&quot;public health&quot;</span>, <span class="hljs-string">&quot;politics&quot;</span>, <span class="hljs-string">&quot;elections&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_z0(sequence_to_classify, candidate_labels, multi_class=<span class="hljs-literal">True</span>)`}}),mt=new qe({}),pt=new L({props:{name:"class optimum.onnxruntime.ORTModelForTokenClassification",anchor:"optimum.onnxruntime.ORTModelForTokenClassification",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L641",parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.config",description:`<strong>config</strong> ([<code>PretrainedConfig</code>](https &#x2014;//huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig)): Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <code>from_pretrained</code> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.model",description:"<strong>model</strong> ([<code>onnxruntime.InferenceSession</code>](https &#x2014;//onnxruntime.ai/docs/api/python/api_summary.html#inferencesession)): This is the main class used to run a model. Check out the <code>load_model</code>",name:"model"},{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.for",description:"<strong>for</strong> more information. &#x2014;",name:"for"}]}}),dt=new L({props:{name:"forward",anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L654",parametersDescription:[{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.ORTModelForTokenClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}]}}),be=new vn({props:{$$slots:{default:[Di]},$$scope:{ctx:W}}}),ut=new X({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import ORTModelForTokenClassification
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/bert-base-NER")
model = ORTModelForTokenClassification.from_pretrained("optimum/bert-base-NER")

inputs = tokenizer("My Name is Philipp and i live in Germany.", return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits
list(logits.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForTokenClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;My Name is Philipp and i live in Germany.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)`}}),ft=new X({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import ORTModelForTokenClassification

tokenizer = AutoTokenizer.from_pretrained("optimum/bert-base-NER")
model = ORTModelForTokenClassification.from_pretrained("optimum/bert-base-NER")
onnx_ner = pipeline("token-classification", model=model, tokenizer=tokenizer)

text = "My Name is Philipp and i live in Germany."
pred = onnx_ner(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> ORTModelForTokenClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = ORTModelForTokenClassification.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_ner = pipeline(<span class="hljs-string">&quot;token-classification&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;My Name is Philipp and i live in Germany.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_ner(text)`}}),{c(){d=n("meta"),O=l(),v=n("h1"),x=n("a"),y=n("span"),h(T.$$.fragment),$=l(),j=n("span"),Tn=a("Optimum Inference with ONNX Runtime"),zo=l(),me=n("p"),$n=a(`Optimum Inference is a utility package for building and running inference with accelerated runtime like ONNX Runtime.
Optimum Inference can be used to load optimized models from the `),_t=n("a"),xn=a("Hugging Face Hub"),bn=a(` and create pipelines
to run accelerated inference without rewriting your APIs.`),jo=l(),K=n("h2"),pe=n("a"),bt=n("span"),h(Me.$$.fragment),yn=l(),yt=n("span"),On=a("Switching from Transformers to Optimum Inference"),Ro=l(),N=n("p"),qn=a("The Optimum Inference models are API compatible with Hugging Face Transformers models. This means you can just replace your "),Ot=n("code"),Mn=a("AutoModelForXxx"),En=a(" class with the corresponding "),qt=n("code"),zn=a("ORTModelForXxx"),jn=a(" class in "),Mt=n("code"),Rn=a("optimum"),Fn=a(". For example, this is how you can use a question answering model in "),Et=n("code"),An=a("optimum"),Cn=a(":"),Fo=l(),h(Ee.$$.fragment),Ao=l(),H=n("p"),Pn=a("Optimum Inference also includes methods to convert vanilla Transformers models to optimized ones via the "),zt=n("code"),Nn=a('from_pretrained("{model_id}",from_transformers=True)'),Sn=a(` method.
After you have converted a model you can even `),jt=n("code"),Dn=a("optimize"),In=a(" or "),Rt=n("code"),Hn=a("quantize"),Qn=a(" the model if it is supported by the runtime you use."),Co=l(),h(ze.$$.fragment),Po=l(),ce=n("p"),Ln=a("You can find a complete walkhrough Optimum Inference for ONNX Runtime in this "),kt=n("a"),Xn=a("notebook"),Wn=a("."),No=l(),Z=n("h3"),de=n("a"),Ft=n("span"),h(je.$$.fragment),Bn=l(),At=n("span"),Un=a("Working with the [Hugging Face Model Hub](https://hf.co/models)"),So=l(),Q=n("p"),Gn=a("The Optimum model classes, e.g. "),Ct=n("code"),Vn=a("ORTModel"),Jn=a(" are directly integrated with the "),Re=n("a"),Yn=a("Hugging Face Model Hub"),Kn=a(`) meaning you can not only
load model from the Hub but also push your models to the Hub with `),Pt=n("code"),Zn=a("push_to_hub()"),es=a(` method. Below you find an example which pulls a vanilla transformers model
from the Hub and converts it to an optimum model and pushes it back into a new repository.`),Do=l(),h(Fe.$$.fragment),Io=l(),ee=n("h2"),ue=n("a"),Nt=n("span"),h(Ae.$$.fragment),ts=l(),St=n("span"),os=a("ORTModel"),Ho=l(),R=n("div"),h(Ce.$$.fragment),ns=l(),Pe=n("p"),ss=a(`Base ORTModel class for implementing models using ONNX Runtime. The ORTModel implements generic methods for interacting
with the Hugging Face Hub as well as exporting vanilla transformers models to ONNX using `),Dt=n("code"),rs=a("transformers.onnx"),as=a(` toolchain.
The ORTModel implements additionally generic methods for optimizing and quantizing Onnx models.`),is=l(),he=n("div"),h(Ne.$$.fragment),ls=l(),wt=n("p"),ms=a("loads ONNX Inference session with Provider. Default Provider is if GPU available else "),It=n("em"),ps=a("CPUExecutionProvider"),cs=l(),fe=n("div"),h(Se.$$.fragment),ds=l(),Ht=n("p"),us=a("optimizes the model using onnxruntime.tools.transformers.optimize"),hs=l(),ge=n("div"),h(De.$$.fragment),fs=l(),Qt=n("p"),gs=a("quantizes the mode using onnxruntime.tools.transformers.optimize"),Qo=l(),te=n("h2"),_e=n("a"),Lt=n("span"),h(Ie.$$.fragment),_s=l(),Xt=n("span"),ks=a("ORTModelForFeatureExtraction"),Lo=l(),F=n("div"),h(He.$$.fragment),ws=l(),Wt=n("p"),vs=a("Onnx Model with a MaskedLMOutput for feature-extraction tasks."),Ts=l(),Qe=n("p"),$s=a("This model inherits from "),Bt=n("code"),xs=a("ORTModel"),bs=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),ys=l(),Ut=n("p"),Os=a("Feature Extraction model for ONNX."),qs=l(),q=n("div"),h(Le.$$.fragment),Ms=l(),oe=n("p"),Es=a("The "),Gt=n("code"),zs=a("ORTModelForFeatureExtraction"),js=a(" forward method, overrides the "),Vt=n("code"),Rs=a("__call__"),Fs=a(" special method."),As=l(),h(ke.$$.fragment),Cs=l(),Jt=n("p"),Ps=a("Example of feature extraction:"),Ns=l(),h(Xe.$$.fragment),Ss=l(),We=n("p"),Ds=a("Example using "),Yt=n("code"),Is=a("transformers.pipelines"),Hs=a(":"),Qs=l(),h(Be.$$.fragment),Xo=l(),ne=n("h2"),we=n("a"),Kt=n("span"),h(Ue.$$.fragment),Ls=l(),Zt=n("span"),Xs=a("ORTModelForQuestionAnswering"),Wo=l(),A=n("div"),h(Ge.$$.fragment),Ws=l(),eo=n("p"),Bs=a("Onnx Model with a QuestionAnsweringModelOutput for extractive question-answering tasks like SQuAD."),Us=l(),Ve=n("p"),Gs=a("This model inherits from "),to=n("code"),Vs=a("ORTModel"),Js=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),Ys=l(),oo=n("p"),Ks=a("Question Answering model for ONNX."),Zs=l(),M=n("div"),h(Je.$$.fragment),er=l(),se=n("p"),tr=a("The "),no=n("code"),or=a("ORTModelForQuestionAnswering"),nr=a(" forward method, overrides the "),so=n("code"),sr=a("__call__"),rr=a(" special method."),ar=l(),h(ve.$$.fragment),ir=l(),ro=n("p"),lr=a("Example of question answering:"),mr=l(),h(Ye.$$.fragment),pr=l(),Ke=n("p"),cr=a("Example using "),ao=n("code"),dr=a("transformers.pipelines"),ur=a(":"),hr=l(),h(Ze.$$.fragment),Bo=l(),re=n("h2"),Te=n("a"),io=n("span"),h(et.$$.fragment),fr=l(),lo=n("span"),gr=a("ORTModelForSequenceClassification"),Uo=l(),C=n("div"),h(tt.$$.fragment),_r=l(),mo=n("p"),kr=a(`Onnx Model with a sequence classification/regression head on top (a linear layer on top of the
pooled output) e.g. for GLUE tasks.`),wr=l(),ot=n("p"),vr=a("This model inherits from "),po=n("code"),Tr=a("ORTModel"),$r=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),xr=l(),co=n("p"),br=a("Sequence Classification model for ONNX."),yr=l(),b=n("div"),h(nt.$$.fragment),Or=l(),ae=n("p"),qr=a("The "),uo=n("code"),Mr=a("ORTModelForSequenceClassification"),Er=a(" forward method, overrides the "),ho=n("code"),zr=a("__call__"),jr=a(" special method."),Rr=l(),h($e.$$.fragment),Fr=l(),fo=n("p"),Ar=a("Example of single-label classification:"),Cr=l(),h(st.$$.fragment),Pr=l(),rt=n("p"),Nr=a("Example using "),go=n("code"),Sr=a("transformers.pipelines"),Dr=a(":"),Ir=l(),h(at.$$.fragment),Hr=l(),it=n("p"),Qr=a("Example using zero-shot-classification "),_o=n("code"),Lr=a("transformers.pipelines"),Xr=a(":"),Wr=l(),h(lt.$$.fragment),Go=l(),ie=n("h2"),xe=n("a"),ko=n("span"),h(mt.$$.fragment),Br=l(),wo=n("span"),Ur=a("ORTModelForTokenClassification"),Vo=l(),P=n("div"),h(pt.$$.fragment),Gr=l(),vo=n("p"),Vr=a(`Onnx Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g.
for Named-Entity-Recognition (NER) tasks.`),Jr=l(),ct=n("p"),Yr=a("This model inherits from "),To=n("code"),Kr=a("ORTModel"),Zr=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),ea=l(),$o=n("p"),ta=a("Sequence Classification model for ONNX."),oa=l(),E=n("div"),h(dt.$$.fragment),na=l(),le=n("p"),sa=a("The "),xo=n("code"),ra=a("ORTModelForTokenClassification"),aa=a(" forward method, overrides the "),bo=n("code"),ia=a("__call__"),la=a(" special method."),ma=l(),h(be.$$.fragment),pa=l(),yo=n("p"),ca=a("Example of token classification:"),da=l(),h(ut.$$.fragment),ua=l(),ht=n("p"),ha=a("Example using "),Oo=n("code"),fa=a("transformers.pipelines"),ga=a(":"),_a=l(),h(ft.$$.fragment),this.h()},l(t){const p=Ai('[data-svelte="svelte-1phssyn"]',document.head);d=s(p,"META",{name:!0,content:!0}),p.forEach(o),O=m(t),v=s(t,"H1",{class:!0});var gt=r(v);x=s(gt,"A",{id:!0,class:!0,href:!0});var qo=r(x);y=s(qo,"SPAN",{});var Mo=r(y);f(T.$$.fragment,Mo),Mo.forEach(o),qo.forEach(o),$=m(gt),j=s(gt,"SPAN",{});var Eo=r(j);Tn=i(Eo,"Optimum Inference with ONNX Runtime"),Eo.forEach(o),gt.forEach(o),zo=m(t),me=s(t,"P",{});var Yo=r(me);$n=i(Yo,`Optimum Inference is a utility package for building and running inference with accelerated runtime like ONNX Runtime.
Optimum Inference can be used to load optimized models from the `),_t=s(Yo,"A",{href:!0});var wa=r(_t);xn=i(wa,"Hugging Face Hub"),wa.forEach(o),bn=i(Yo,` and create pipelines
to run accelerated inference without rewriting your APIs.`),Yo.forEach(o),jo=m(t),K=s(t,"H2",{class:!0});var Ko=r(K);pe=s(Ko,"A",{id:!0,class:!0,href:!0});var va=r(pe);bt=s(va,"SPAN",{});var Ta=r(bt);f(Me.$$.fragment,Ta),Ta.forEach(o),va.forEach(o),yn=m(Ko),yt=s(Ko,"SPAN",{});var $a=r(yt);On=i($a,"Switching from Transformers to Optimum Inference"),$a.forEach(o),Ko.forEach(o),Ro=m(t),N=s(t,"P",{});var B=r(N);qn=i(B,"The Optimum Inference models are API compatible with Hugging Face Transformers models. This means you can just replace your "),Ot=s(B,"CODE",{});var xa=r(Ot);Mn=i(xa,"AutoModelForXxx"),xa.forEach(o),En=i(B," class with the corresponding "),qt=s(B,"CODE",{});var ba=r(qt);zn=i(ba,"ORTModelForXxx"),ba.forEach(o),jn=i(B," class in "),Mt=s(B,"CODE",{});var ya=r(Mt);Rn=i(ya,"optimum"),ya.forEach(o),Fn=i(B,". For example, this is how you can use a question answering model in "),Et=s(B,"CODE",{});var Oa=r(Et);An=i(Oa,"optimum"),Oa.forEach(o),Cn=i(B,":"),B.forEach(o),Fo=m(t),f(Ee.$$.fragment,t),Ao=m(t),H=s(t,"P",{});var ye=r(H);Pn=i(ye,"Optimum Inference also includes methods to convert vanilla Transformers models to optimized ones via the "),zt=s(ye,"CODE",{});var qa=r(zt);Nn=i(qa,'from_pretrained("{model_id}",from_transformers=True)'),qa.forEach(o),Sn=i(ye,` method.
After you have converted a model you can even `),jt=s(ye,"CODE",{});var Ma=r(jt);Dn=i(Ma,"optimize"),Ma.forEach(o),In=i(ye," or "),Rt=s(ye,"CODE",{});var Ea=r(Rt);Hn=i(Ea,"quantize"),Ea.forEach(o),Qn=i(ye," the model if it is supported by the runtime you use."),ye.forEach(o),Co=m(t),f(ze.$$.fragment,t),Po=m(t),ce=s(t,"P",{});var Zo=r(ce);Ln=i(Zo,"You can find a complete walkhrough Optimum Inference for ONNX Runtime in this "),kt=s(Zo,"A",{href:!0});var za=r(kt);Xn=i(za,"notebook"),za.forEach(o),Wn=i(Zo,"."),Zo.forEach(o),No=m(t),Z=s(t,"H3",{class:!0});var en=r(Z);de=s(en,"A",{id:!0,class:!0,href:!0});var ja=r(de);Ft=s(ja,"SPAN",{});var Ra=r(Ft);f(je.$$.fragment,Ra),Ra.forEach(o),ja.forEach(o),Bn=m(en),At=s(en,"SPAN",{});var Fa=r(At);Un=i(Fa,"Working with the [Hugging Face Model Hub](https://hf.co/models)"),Fa.forEach(o),en.forEach(o),So=m(t),Q=s(t,"P",{});var Oe=r(Q);Gn=i(Oe,"The Optimum model classes, e.g. "),Ct=s(Oe,"CODE",{});var Aa=r(Ct);Vn=i(Aa,"ORTModel"),Aa.forEach(o),Jn=i(Oe," are directly integrated with the "),Re=s(Oe,"A",{href:!0,rel:!0});var Ca=r(Re);Yn=i(Ca,"Hugging Face Model Hub"),Ca.forEach(o),Kn=i(Oe,`) meaning you can not only
load model from the Hub but also push your models to the Hub with `),Pt=s(Oe,"CODE",{});var Pa=r(Pt);Zn=i(Pa,"push_to_hub()"),Pa.forEach(o),es=i(Oe,` method. Below you find an example which pulls a vanilla transformers model
from the Hub and converts it to an optimum model and pushes it back into a new repository.`),Oe.forEach(o),Do=m(t),f(Fe.$$.fragment,t),Io=m(t),ee=s(t,"H2",{class:!0});var tn=r(ee);ue=s(tn,"A",{id:!0,class:!0,href:!0});var Na=r(ue);Nt=s(Na,"SPAN",{});var Sa=r(Nt);f(Ae.$$.fragment,Sa),Sa.forEach(o),Na.forEach(o),ts=m(tn),St=s(tn,"SPAN",{});var Da=r(St);os=i(Da,"ORTModel"),Da.forEach(o),tn.forEach(o),Ho=m(t),R=s(t,"DIV",{class:!0});var U=r(R);f(Ce.$$.fragment,U),ns=m(U),Pe=s(U,"P",{});var on=r(Pe);ss=i(on,`Base ORTModel class for implementing models using ONNX Runtime. The ORTModel implements generic methods for interacting
with the Hugging Face Hub as well as exporting vanilla transformers models to ONNX using `),Dt=s(on,"CODE",{});var Ia=r(Dt);rs=i(Ia,"transformers.onnx"),Ia.forEach(o),as=i(on,` toolchain.
The ORTModel implements additionally generic methods for optimizing and quantizing Onnx models.`),on.forEach(o),is=m(U),he=s(U,"DIV",{class:!0});var nn=r(he);f(Ne.$$.fragment,nn),ls=m(nn),wt=s(nn,"P",{});var ka=r(wt);ms=i(ka,"loads ONNX Inference session with Provider. Default Provider is if GPU available else "),It=s(ka,"EM",{});var Ha=r(It);ps=i(Ha,"CPUExecutionProvider"),Ha.forEach(o),ka.forEach(o),nn.forEach(o),cs=m(U),fe=s(U,"DIV",{class:!0});var sn=r(fe);f(Se.$$.fragment,sn),ds=m(sn),Ht=s(sn,"P",{});var Qa=r(Ht);us=i(Qa,"optimizes the model using onnxruntime.tools.transformers.optimize"),Qa.forEach(o),sn.forEach(o),hs=m(U),ge=s(U,"DIV",{class:!0});var rn=r(ge);f(De.$$.fragment,rn),fs=m(rn),Qt=s(rn,"P",{});var La=r(Qt);gs=i(La,"quantizes the mode using onnxruntime.tools.transformers.optimize"),La.forEach(o),rn.forEach(o),U.forEach(o),Qo=m(t),te=s(t,"H2",{class:!0});var an=r(te);_e=s(an,"A",{id:!0,class:!0,href:!0});var Xa=r(_e);Lt=s(Xa,"SPAN",{});var Wa=r(Lt);f(Ie.$$.fragment,Wa),Wa.forEach(o),Xa.forEach(o),_s=m(an),Xt=s(an,"SPAN",{});var Ba=r(Xt);ks=i(Ba,"ORTModelForFeatureExtraction"),Ba.forEach(o),an.forEach(o),Lo=m(t),F=s(t,"DIV",{class:!0});var G=r(F);f(He.$$.fragment,G),ws=m(G),Wt=s(G,"P",{});var Ua=r(Wt);vs=i(Ua,"Onnx Model with a MaskedLMOutput for feature-extraction tasks."),Ua.forEach(o),Ts=m(G),Qe=s(G,"P",{});var ln=r(Qe);$s=i(ln,"This model inherits from "),Bt=s(ln,"CODE",{});var Ga=r(Bt);xs=i(Ga,"ORTModel"),Ga.forEach(o),bs=i(ln,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),ln.forEach(o),ys=m(G),Ut=s(G,"P",{});var Va=r(Ut);Os=i(Va,"Feature Extraction model for ONNX."),Va.forEach(o),qs=m(G),q=s(G,"DIV",{class:!0});var S=r(q);f(Le.$$.fragment,S),Ms=m(S),oe=s(S,"P",{});var vt=r(oe);Es=i(vt,"The "),Gt=s(vt,"CODE",{});var Ja=r(Gt);zs=i(Ja,"ORTModelForFeatureExtraction"),Ja.forEach(o),js=i(vt," forward method, overrides the "),Vt=s(vt,"CODE",{});var Ya=r(Vt);Rs=i(Ya,"__call__"),Ya.forEach(o),Fs=i(vt," special method."),vt.forEach(o),As=m(S),f(ke.$$.fragment,S),Cs=m(S),Jt=s(S,"P",{});var Ka=r(Jt);Ps=i(Ka,"Example of feature extraction:"),Ka.forEach(o),Ns=m(S),f(Xe.$$.fragment,S),Ss=m(S),We=s(S,"P",{});var mn=r(We);Ds=i(mn,"Example using "),Yt=s(mn,"CODE",{});var Za=r(Yt);Is=i(Za,"transformers.pipelines"),Za.forEach(o),Hs=i(mn,":"),mn.forEach(o),Qs=m(S),f(Be.$$.fragment,S),S.forEach(o),G.forEach(o),Xo=m(t),ne=s(t,"H2",{class:!0});var pn=r(ne);we=s(pn,"A",{id:!0,class:!0,href:!0});var ei=r(we);Kt=s(ei,"SPAN",{});var ti=r(Kt);f(Ue.$$.fragment,ti),ti.forEach(o),ei.forEach(o),Ls=m(pn),Zt=s(pn,"SPAN",{});var oi=r(Zt);Xs=i(oi,"ORTModelForQuestionAnswering"),oi.forEach(o),pn.forEach(o),Wo=m(t),A=s(t,"DIV",{class:!0});var V=r(A);f(Ge.$$.fragment,V),Ws=m(V),eo=s(V,"P",{});var ni=r(eo);Bs=i(ni,"Onnx Model with a QuestionAnsweringModelOutput for extractive question-answering tasks like SQuAD."),ni.forEach(o),Us=m(V),Ve=s(V,"P",{});var cn=r(Ve);Gs=i(cn,"This model inherits from "),to=s(cn,"CODE",{});var si=r(to);Vs=i(si,"ORTModel"),si.forEach(o),Js=i(cn,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),cn.forEach(o),Ys=m(V),oo=s(V,"P",{});var ri=r(oo);Ks=i(ri,"Question Answering model for ONNX."),ri.forEach(o),Zs=m(V),M=s(V,"DIV",{class:!0});var D=r(M);f(Je.$$.fragment,D),er=m(D),se=s(D,"P",{});var Tt=r(se);tr=i(Tt,"The "),no=s(Tt,"CODE",{});var ai=r(no);or=i(ai,"ORTModelForQuestionAnswering"),ai.forEach(o),nr=i(Tt," forward method, overrides the "),so=s(Tt,"CODE",{});var ii=r(so);sr=i(ii,"__call__"),ii.forEach(o),rr=i(Tt," special method."),Tt.forEach(o),ar=m(D),f(ve.$$.fragment,D),ir=m(D),ro=s(D,"P",{});var li=r(ro);lr=i(li,"Example of question answering:"),li.forEach(o),mr=m(D),f(Ye.$$.fragment,D),pr=m(D),Ke=s(D,"P",{});var dn=r(Ke);cr=i(dn,"Example using "),ao=s(dn,"CODE",{});var mi=r(ao);dr=i(mi,"transformers.pipelines"),mi.forEach(o),ur=i(dn,":"),dn.forEach(o),hr=m(D),f(Ze.$$.fragment,D),D.forEach(o),V.forEach(o),Bo=m(t),re=s(t,"H2",{class:!0});var un=r(re);Te=s(un,"A",{id:!0,class:!0,href:!0});var pi=r(Te);io=s(pi,"SPAN",{});var ci=r(io);f(et.$$.fragment,ci),ci.forEach(o),pi.forEach(o),fr=m(un),lo=s(un,"SPAN",{});var di=r(lo);gr=i(di,"ORTModelForSequenceClassification"),di.forEach(o),un.forEach(o),Uo=m(t),C=s(t,"DIV",{class:!0});var J=r(C);f(tt.$$.fragment,J),_r=m(J),mo=s(J,"P",{});var ui=r(mo);kr=i(ui,`Onnx Model with a sequence classification/regression head on top (a linear layer on top of the
pooled output) e.g. for GLUE tasks.`),ui.forEach(o),wr=m(J),ot=s(J,"P",{});var hn=r(ot);vr=i(hn,"This model inherits from "),po=s(hn,"CODE",{});var hi=r(po);Tr=i(hi,"ORTModel"),hi.forEach(o),$r=i(hn,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),hn.forEach(o),xr=m(J),co=s(J,"P",{});var fi=r(co);br=i(fi,"Sequence Classification model for ONNX."),fi.forEach(o),yr=m(J),b=s(J,"DIV",{class:!0});var z=r(b);f(nt.$$.fragment,z),Or=m(z),ae=s(z,"P",{});var $t=r(ae);qr=i($t,"The "),uo=s($t,"CODE",{});var gi=r(uo);Mr=i(gi,"ORTModelForSequenceClassification"),gi.forEach(o),Er=i($t," forward method, overrides the "),ho=s($t,"CODE",{});var _i=r(ho);zr=i(_i,"__call__"),_i.forEach(o),jr=i($t," special method."),$t.forEach(o),Rr=m(z),f($e.$$.fragment,z),Fr=m(z),fo=s(z,"P",{});var ki=r(fo);Ar=i(ki,"Example of single-label classification:"),ki.forEach(o),Cr=m(z),f(st.$$.fragment,z),Pr=m(z),rt=s(z,"P",{});var fn=r(rt);Nr=i(fn,"Example using "),go=s(fn,"CODE",{});var wi=r(go);Sr=i(wi,"transformers.pipelines"),wi.forEach(o),Dr=i(fn,":"),fn.forEach(o),Ir=m(z),f(at.$$.fragment,z),Hr=m(z),it=s(z,"P",{});var gn=r(it);Qr=i(gn,"Example using zero-shot-classification "),_o=s(gn,"CODE",{});var vi=r(_o);Lr=i(vi,"transformers.pipelines"),vi.forEach(o),Xr=i(gn,":"),gn.forEach(o),Wr=m(z),f(lt.$$.fragment,z),z.forEach(o),J.forEach(o),Go=m(t),ie=s(t,"H2",{class:!0});var _n=r(ie);xe=s(_n,"A",{id:!0,class:!0,href:!0});var Ti=r(xe);ko=s(Ti,"SPAN",{});var $i=r(ko);f(mt.$$.fragment,$i),$i.forEach(o),Ti.forEach(o),Br=m(_n),wo=s(_n,"SPAN",{});var xi=r(wo);Ur=i(xi,"ORTModelForTokenClassification"),xi.forEach(o),_n.forEach(o),Vo=m(t),P=s(t,"DIV",{class:!0});var Y=r(P);f(pt.$$.fragment,Y),Gr=m(Y),vo=s(Y,"P",{});var bi=r(vo);Vr=i(bi,`Onnx Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g.
for Named-Entity-Recognition (NER) tasks.`),bi.forEach(o),Jr=m(Y),ct=s(Y,"P",{});var kn=r(ct);Yr=i(kn,"This model inherits from "),To=s(kn,"CODE",{});var yi=r(To);Kr=i(yi,"ORTModel"),yi.forEach(o),Zr=i(kn,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),kn.forEach(o),ea=m(Y),$o=s(Y,"P",{});var Oi=r($o);ta=i(Oi,"Sequence Classification model for ONNX."),Oi.forEach(o),oa=m(Y),E=s(Y,"DIV",{class:!0});var I=r(E);f(dt.$$.fragment,I),na=m(I),le=s(I,"P",{});var xt=r(le);sa=i(xt,"The "),xo=s(xt,"CODE",{});var qi=r(xo);ra=i(qi,"ORTModelForTokenClassification"),qi.forEach(o),aa=i(xt," forward method, overrides the "),bo=s(xt,"CODE",{});var Mi=r(bo);ia=i(Mi,"__call__"),Mi.forEach(o),la=i(xt," special method."),xt.forEach(o),ma=m(I),f(be.$$.fragment,I),pa=m(I),yo=s(I,"P",{});var Ei=r(yo);ca=i(Ei,"Example of token classification:"),Ei.forEach(o),da=m(I),f(ut.$$.fragment,I),ua=m(I),ht=s(I,"P",{});var wn=r(ht);ha=i(wn,"Example using "),Oo=s(wn,"CODE",{});var zi=r(Oo);fa=i(zi,"transformers.pipelines"),zi.forEach(o),ga=i(wn,":"),wn.forEach(o),_a=m(I),f(ft.$$.fragment,I),I.forEach(o),Y.forEach(o),this.h()},h(){c(d,"name","hf:doc:metadata"),c(d,"content",JSON.stringify(Hi)),c(x,"id","optimum-inference-with-onnx-runtime"),c(x,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(x,"href","#optimum-inference-with-onnx-runtime"),c(v,"class","relative group"),c(_t,"href","hf.co/models"),c(pe,"id","switching-from-transformers-to-optimum-inference"),c(pe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(pe,"href","#switching-from-transformers-to-optimum-inference"),c(K,"class","relative group"),c(kt,"href","xx"),c(de,"id","working-with-the-hugging-face-model-hubhttpshfcomodels"),c(de,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(de,"href","#working-with-the-hugging-face-model-hubhttpshfcomodels"),c(Z,"class","relative group"),c(Re,"href","https://hf.co/models"),c(Re,"rel","nofollow"),c(ue,"id","optimum.onnxruntime.ORTModel"),c(ue,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ue,"href","#optimum.onnxruntime.ORTModel"),c(ee,"class","relative group"),c(he,"class","docstring"),c(fe,"class","docstring"),c(ge,"class","docstring"),c(R,"class","docstring"),c(_e,"id","optimum.onnxruntime.ORTModelForFeatureExtraction"),c(_e,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(_e,"href","#optimum.onnxruntime.ORTModelForFeatureExtraction"),c(te,"class","relative group"),c(q,"class","docstring"),c(F,"class","docstring"),c(we,"id","optimum.onnxruntime.ORTModelForQuestionAnswering"),c(we,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(we,"href","#optimum.onnxruntime.ORTModelForQuestionAnswering"),c(ne,"class","relative group"),c(M,"class","docstring"),c(A,"class","docstring"),c(Te,"id","optimum.onnxruntime.ORTModelForSequenceClassification"),c(Te,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(Te,"href","#optimum.onnxruntime.ORTModelForSequenceClassification"),c(re,"class","relative group"),c(b,"class","docstring"),c(C,"class","docstring"),c(xe,"id","optimum.onnxruntime.ORTModelForTokenClassification"),c(xe,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(xe,"href","#optimum.onnxruntime.ORTModelForTokenClassification"),c(ie,"class","relative group"),c(E,"class","docstring"),c(P,"class","docstring")},m(t,p){e(document.head,d),u(t,O,p),u(t,v,p),e(v,x),e(x,y),g(T,y,null),e(v,$),e(v,j),e(j,Tn),u(t,zo,p),u(t,me,p),e(me,$n),e(me,_t),e(_t,xn),e(me,bn),u(t,jo,p),u(t,K,p),e(K,pe),e(pe,bt),g(Me,bt,null),e(K,yn),e(K,yt),e(yt,On),u(t,Ro,p),u(t,N,p),e(N,qn),e(N,Ot),e(Ot,Mn),e(N,En),e(N,qt),e(qt,zn),e(N,jn),e(N,Mt),e(Mt,Rn),e(N,Fn),e(N,Et),e(Et,An),e(N,Cn),u(t,Fo,p),g(Ee,t,p),u(t,Ao,p),u(t,H,p),e(H,Pn),e(H,zt),e(zt,Nn),e(H,Sn),e(H,jt),e(jt,Dn),e(H,In),e(H,Rt),e(Rt,Hn),e(H,Qn),u(t,Co,p),g(ze,t,p),u(t,Po,p),u(t,ce,p),e(ce,Ln),e(ce,kt),e(kt,Xn),e(ce,Wn),u(t,No,p),u(t,Z,p),e(Z,de),e(de,Ft),g(je,Ft,null),e(Z,Bn),e(Z,At),e(At,Un),u(t,So,p),u(t,Q,p),e(Q,Gn),e(Q,Ct),e(Ct,Vn),e(Q,Jn),e(Q,Re),e(Re,Yn),e(Q,Kn),e(Q,Pt),e(Pt,Zn),e(Q,es),u(t,Do,p),g(Fe,t,p),u(t,Io,p),u(t,ee,p),e(ee,ue),e(ue,Nt),g(Ae,Nt,null),e(ee,ts),e(ee,St),e(St,os),u(t,Ho,p),u(t,R,p),g(Ce,R,null),e(R,ns),e(R,Pe),e(Pe,ss),e(Pe,Dt),e(Dt,rs),e(Pe,as),e(R,is),e(R,he),g(Ne,he,null),e(he,ls),e(he,wt),e(wt,ms),e(wt,It),e(It,ps),e(R,cs),e(R,fe),g(Se,fe,null),e(fe,ds),e(fe,Ht),e(Ht,us),e(R,hs),e(R,ge),g(De,ge,null),e(ge,fs),e(ge,Qt),e(Qt,gs),u(t,Qo,p),u(t,te,p),e(te,_e),e(_e,Lt),g(Ie,Lt,null),e(te,_s),e(te,Xt),e(Xt,ks),u(t,Lo,p),u(t,F,p),g(He,F,null),e(F,ws),e(F,Wt),e(Wt,vs),e(F,Ts),e(F,Qe),e(Qe,$s),e(Qe,Bt),e(Bt,xs),e(Qe,bs),e(F,ys),e(F,Ut),e(Ut,Os),e(F,qs),e(F,q),g(Le,q,null),e(q,Ms),e(q,oe),e(oe,Es),e(oe,Gt),e(Gt,zs),e(oe,js),e(oe,Vt),e(Vt,Rs),e(oe,Fs),e(q,As),g(ke,q,null),e(q,Cs),e(q,Jt),e(Jt,Ps),e(q,Ns),g(Xe,q,null),e(q,Ss),e(q,We),e(We,Ds),e(We,Yt),e(Yt,Is),e(We,Hs),e(q,Qs),g(Be,q,null),u(t,Xo,p),u(t,ne,p),e(ne,we),e(we,Kt),g(Ue,Kt,null),e(ne,Ls),e(ne,Zt),e(Zt,Xs),u(t,Wo,p),u(t,A,p),g(Ge,A,null),e(A,Ws),e(A,eo),e(eo,Bs),e(A,Us),e(A,Ve),e(Ve,Gs),e(Ve,to),e(to,Vs),e(Ve,Js),e(A,Ys),e(A,oo),e(oo,Ks),e(A,Zs),e(A,M),g(Je,M,null),e(M,er),e(M,se),e(se,tr),e(se,no),e(no,or),e(se,nr),e(se,so),e(so,sr),e(se,rr),e(M,ar),g(ve,M,null),e(M,ir),e(M,ro),e(ro,lr),e(M,mr),g(Ye,M,null),e(M,pr),e(M,Ke),e(Ke,cr),e(Ke,ao),e(ao,dr),e(Ke,ur),e(M,hr),g(Ze,M,null),u(t,Bo,p),u(t,re,p),e(re,Te),e(Te,io),g(et,io,null),e(re,fr),e(re,lo),e(lo,gr),u(t,Uo,p),u(t,C,p),g(tt,C,null),e(C,_r),e(C,mo),e(mo,kr),e(C,wr),e(C,ot),e(ot,vr),e(ot,po),e(po,Tr),e(ot,$r),e(C,xr),e(C,co),e(co,br),e(C,yr),e(C,b),g(nt,b,null),e(b,Or),e(b,ae),e(ae,qr),e(ae,uo),e(uo,Mr),e(ae,Er),e(ae,ho),e(ho,zr),e(ae,jr),e(b,Rr),g($e,b,null),e(b,Fr),e(b,fo),e(fo,Ar),e(b,Cr),g(st,b,null),e(b,Pr),e(b,rt),e(rt,Nr),e(rt,go),e(go,Sr),e(rt,Dr),e(b,Ir),g(at,b,null),e(b,Hr),e(b,it),e(it,Qr),e(it,_o),e(_o,Lr),e(it,Xr),e(b,Wr),g(lt,b,null),u(t,Go,p),u(t,ie,p),e(ie,xe),e(xe,ko),g(mt,ko,null),e(ie,Br),e(ie,wo),e(wo,Ur),u(t,Vo,p),u(t,P,p),g(pt,P,null),e(P,Gr),e(P,vo),e(vo,Vr),e(P,Jr),e(P,ct),e(ct,Yr),e(ct,To),e(To,Kr),e(ct,Zr),e(P,ea),e(P,$o),e($o,ta),e(P,oa),e(P,E),g(dt,E,null),e(E,na),e(E,le),e(le,sa),e(le,xo),e(xo,ra),e(le,aa),e(le,bo),e(bo,ia),e(le,la),e(E,ma),g(be,E,null),e(E,pa),e(E,yo),e(yo,ca),e(E,da),g(ut,E,null),e(E,ua),e(E,ht),e(ht,ha),e(ht,Oo),e(Oo,fa),e(ht,ga),e(E,_a),g(ft,E,null),Jo=!0},p(t,[p]){const gt={};p&2&&(gt.$$scope={dirty:p,ctx:t}),ke.$set(gt);const qo={};p&2&&(qo.$$scope={dirty:p,ctx:t}),ve.$set(qo);const Mo={};p&2&&(Mo.$$scope={dirty:p,ctx:t}),$e.$set(Mo);const Eo={};p&2&&(Eo.$$scope={dirty:p,ctx:t}),be.$set(Eo)},i(t){Jo||(_(T.$$.fragment,t),_(Me.$$.fragment,t),_(Ee.$$.fragment,t),_(ze.$$.fragment,t),_(je.$$.fragment,t),_(Fe.$$.fragment,t),_(Ae.$$.fragment,t),_(Ce.$$.fragment,t),_(Ne.$$.fragment,t),_(Se.$$.fragment,t),_(De.$$.fragment,t),_(Ie.$$.fragment,t),_(He.$$.fragment,t),_(Le.$$.fragment,t),_(ke.$$.fragment,t),_(Xe.$$.fragment,t),_(Be.$$.fragment,t),_(Ue.$$.fragment,t),_(Ge.$$.fragment,t),_(Je.$$.fragment,t),_(ve.$$.fragment,t),_(Ye.$$.fragment,t),_(Ze.$$.fragment,t),_(et.$$.fragment,t),_(tt.$$.fragment,t),_(nt.$$.fragment,t),_($e.$$.fragment,t),_(st.$$.fragment,t),_(at.$$.fragment,t),_(lt.$$.fragment,t),_(mt.$$.fragment,t),_(pt.$$.fragment,t),_(dt.$$.fragment,t),_(be.$$.fragment,t),_(ut.$$.fragment,t),_(ft.$$.fragment,t),Jo=!0)},o(t){k(T.$$.fragment,t),k(Me.$$.fragment,t),k(Ee.$$.fragment,t),k(ze.$$.fragment,t),k(je.$$.fragment,t),k(Fe.$$.fragment,t),k(Ae.$$.fragment,t),k(Ce.$$.fragment,t),k(Ne.$$.fragment,t),k(Se.$$.fragment,t),k(De.$$.fragment,t),k(Ie.$$.fragment,t),k(He.$$.fragment,t),k(Le.$$.fragment,t),k(ke.$$.fragment,t),k(Xe.$$.fragment,t),k(Be.$$.fragment,t),k(Ue.$$.fragment,t),k(Ge.$$.fragment,t),k(Je.$$.fragment,t),k(ve.$$.fragment,t),k(Ye.$$.fragment,t),k(Ze.$$.fragment,t),k(et.$$.fragment,t),k(tt.$$.fragment,t),k(nt.$$.fragment,t),k($e.$$.fragment,t),k(st.$$.fragment,t),k(at.$$.fragment,t),k(lt.$$.fragment,t),k(mt.$$.fragment,t),k(pt.$$.fragment,t),k(dt.$$.fragment,t),k(be.$$.fragment,t),k(ut.$$.fragment,t),k(ft.$$.fragment,t),Jo=!1},d(t){o(d),t&&o(O),t&&o(v),w(T),t&&o(zo),t&&o(me),t&&o(jo),t&&o(K),w(Me),t&&o(Ro),t&&o(N),t&&o(Fo),w(Ee,t),t&&o(Ao),t&&o(H),t&&o(Co),w(ze,t),t&&o(Po),t&&o(ce),t&&o(No),t&&o(Z),w(je),t&&o(So),t&&o(Q),t&&o(Do),w(Fe,t),t&&o(Io),t&&o(ee),w(Ae),t&&o(Ho),t&&o(R),w(Ce),w(Ne),w(Se),w(De),t&&o(Qo),t&&o(te),w(Ie),t&&o(Lo),t&&o(F),w(He),w(Le),w(ke),w(Xe),w(Be),t&&o(Xo),t&&o(ne),w(Ue),t&&o(Wo),t&&o(A),w(Ge),w(Je),w(ve),w(Ye),w(Ze),t&&o(Bo),t&&o(re),w(et),t&&o(Uo),t&&o(C),w(tt),w(nt),w($e),w(st),w(at),w(lt),t&&o(Go),t&&o(ie),w(mt),t&&o(Vo),t&&o(P),w(pt),w(dt),w(be),w(ut),w(ft)}}}const Hi={local:"optimum-inference-with-onnx-runtime",sections:[{local:"switching-from-transformers-to-optimum-inference",sections:[{local:"working-with-the-hugging-face-model-hubhttpshfcomodels",title:"Working with the [Hugging Face Model Hub](https://hf.co/models)"}],title:"Switching from Transformers to Optimum Inference"},{local:"optimum.onnxruntime.ORTModel",title:"ORTModel"},{local:"optimum.onnxruntime.ORTModelForFeatureExtraction",title:"ORTModelForFeatureExtraction"},{local:"optimum.onnxruntime.ORTModelForQuestionAnswering",title:"ORTModelForQuestionAnswering"},{local:"optimum.onnxruntime.ORTModelForSequenceClassification",title:"ORTModelForSequenceClassification"},{local:"optimum.onnxruntime.ORTModelForTokenClassification",title:"ORTModelForTokenClassification"}],title:"Optimum Inference with ONNX Runtime"};function Qi(W){return Ci(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Gi extends ji{constructor(d){super();Ri(this,d,Qi,Ii,Fi,{})}}export{Gi as default,Hi as metadata};
