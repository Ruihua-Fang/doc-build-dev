import{S as Mi,i as Ni,s as Si,e as o,k as l,w as h,t as a,M as Di,c as s,d as n,m,a as r,x as f,h as i,b as c,F as e,g as u,y as g,q as _,o as x,B as k,v as Ii}from"../../chunks/vendor-19e06bd2.js";import{T as yo}from"../../chunks/Tip-f0fa2d82.js";import{D as H}from"../../chunks/Docstring-395e5a9c.js";import{C as B}from"../../chunks/CodeBlock-9dd1fdfb.js";import{I as Ee}from"../../chunks/IconCopyLink-3c713d38.js";function Hi(U){let d,q,v,b,O;return{c(){d=o("p"),q=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),v=o("code"),b=a("Module"),O=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(w){d=s(w,"P",{});var $=r(d);q=i($,"Although the recipe for forward pass needs to be defined within this function, one should call the "),v=s($,"CODE",{});var F=r(v);b=i(F,"Module"),F.forEach(n),O=i($,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),$.forEach(n)},m(w,$){u(w,d,$),e(d,q),e(d,v),e(v,b),e(d,O)},d(w){w&&n(d)}}}function Qi(U){let d,q,v,b,O;return{c(){d=o("p"),q=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),v=o("code"),b=a("Module"),O=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(w){d=s(w,"P",{});var $=r(d);q=i($,"Although the recipe for forward pass needs to be defined within this function, one should call the "),v=s($,"CODE",{});var F=r(v);b=i(F,"Module"),F.forEach(n),O=i($,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),$.forEach(n)},m(w,$){u(w,d,$),e(d,q),e(d,v),e(v,b),e(d,O)},d(w){w&&n(d)}}}function Li(U){let d,q,v,b,O;return{c(){d=o("p"),q=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),v=o("code"),b=a("Module"),O=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(w){d=s(w,"P",{});var $=r(d);q=i($,"Although the recipe for forward pass needs to be defined within this function, one should call the "),v=s($,"CODE",{});var F=r(v);b=i(F,"Module"),F.forEach(n),O=i($,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),$.forEach(n)},m(w,$){u(w,d,$),e(d,q),e(d,v),e(v,b),e(d,O)},d(w){w&&n(d)}}}function Wi(U){let d,q,v,b,O;return{c(){d=o("p"),q=a("Although the recipe for forward pass needs to be defined within this function, one should call the "),v=o("code"),b=a("Module"),O=a(`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`)},l(w){d=s(w,"P",{});var $=r(d);q=i($,"Although the recipe for forward pass needs to be defined within this function, one should call the "),v=s($,"CODE",{});var F=r(v);b=i(F,"Module"),F.forEach(n),O=i($,`
instance afterwards instead of this since the former takes care of running the pre and post processing steps while
the latter silently ignores them.`),$.forEach(n)},m(w,$){u(w,d,$),e(d,q),e(d,v),e(v,b),e(d,O)},d(w){w&&n(d)}}}function Bi(U){let d,q,v,b,O,w,$,F,Oo,An,le,qo,kt,Eo,zo,Cn,Y,me,Et,ze,jo,zt,To,Pn,R,Fo,jt,Ao,Co,Tt,Po,Mo,Mn,je,Nn,Q,No,Ft,So,Do,At,Io,Ho,Ct,Qo,Lo,Sn,Te,Dn,pe,Wo,vt,Bo,Uo,In,K,ce,Pt,Fe,Ro,Mt,Xo,Hn,L,Go,Nt,Vo,Jo,Ae,Yo,Ko,St,Zo,es,Qn,Ce,Ln,Z,de,Dt,Pe,ts,It,ns,Wn,A,Me,os,Ne,ss,Ht,rs,as,is,ue,Se,ls,De,ms,Qt,ps,cs,ds,he,Ie,us,wt,hs,Lt,fs,gs,fe,He,_s,Wt,xs,ks,ge,Qe,vs,Bt,ws,Bn,ee,_e,Ut,Le,$s,Rt,bs,Un,C,We,ys,Xt,Os,qs,Be,Es,Gt,zs,js,Ts,Vt,Fs,As,E,Ue,Cs,te,Ps,Jt,Ms,Ns,Yt,Ss,Ds,Is,xe,Hs,Kt,Qs,Ls,Re,Ws,Xe,Bs,Zt,Us,Rs,Xs,Ge,Rn,ne,ke,en,Ve,Gs,tn,Vs,Xn,P,Je,Js,nn,Ys,Ks,Ye,Zs,on,er,tr,nr,sn,or,sr,z,Ke,rr,oe,ar,rn,ir,lr,an,mr,pr,cr,ve,dr,ln,ur,hr,Ze,fr,et,gr,mn,_r,xr,kr,tt,Gn,se,we,pn,nt,vr,cn,wr,Vn,M,ot,$r,dn,br,yr,st,Or,un,qr,Er,zr,hn,jr,Tr,y,rt,Fr,re,Ar,fn,Cr,Pr,gn,Mr,Nr,Sr,$e,Dr,_n,Ir,Hr,at,Qr,it,Lr,xn,Wr,Br,Ur,lt,Rr,mt,Xr,kn,Gr,Vr,Jr,pt,Jn,ae,be,vn,ct,Yr,wn,Kr,Yn,N,dt,Zr,$n,ea,ta,ut,na,bn,oa,sa,ra,yn,aa,ia,j,ht,la,ie,ma,On,pa,ca,qn,da,ua,ha,ye,fa,En,ga,_a,ft,xa,gt,ka,zn,va,wa,$a,_t,Kn;return w=new Ee({}),ze=new Ee({}),je=new B({props:{code:`from transformers import AutoTokenizer, pipeline
-from transformers import AutoModelForQuestionAnswering
+ from optimum.onnxruntime import OnnxForQuestionAnswering

-model = AutoModelForQuestionAnswering.from_pretrained("philschmid/distilbert-onnx")
+model = OnnxForQuestionAnswering.from_pretrained("philschmid/distilbert-onnx")
tokenizer = AutoTokenizer.from_pretrained("philschmid/distilbert-onnx")

onnx_qa = pipeline("question-answering",model=model,tokenizer=tokenizer)

question = "Whats my name?"
context = "My Name is Philipp and I live in Nuremberg."
pred = onnx_qa(question, context)`,highlighted:`from transformers import AutoTokenizer, pipeline
<span class="hljs-deletion">-from transformers import AutoModelForQuestionAnswering</span>
<span class="hljs-addition">+ from optimum.onnxruntime import OnnxForQuestionAnswering</span>

<span class="hljs-deletion">-model = AutoModelForQuestionAnswering.from_pretrained(&quot;philschmid/distilbert-onnx&quot;)</span>
<span class="hljs-addition">+model = OnnxForQuestionAnswering.from_pretrained(&quot;philschmid/distilbert-onnx&quot;)</span>
tokenizer = AutoTokenizer.from_pretrained(&quot;philschmid/distilbert-onnx&quot;)

onnx_qa = pipeline(&quot;question-answering&quot;,model=model,tokenizer=tokenizer)

question = &quot;Whats my name?&quot;
context = &quot;My Name is Philipp and I live in Nuremberg.&quot;
pred = onnx_qa(question, context)`}}),Te=new B({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import OnnxForSequenceClassification

# load model from hub and convert
model = OnnxForSequenceClassification.from_transformers("distilbert-base-uncased-finetuned-sst-2-english")
tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased-finetuned-sst-2-english")

# optimize model
model.optimize()
# quantize model
model.quantize()

# create pipeline
onnx_clx = pipeline("text-classification",model=model,tokenizer=tokenizer)

result = onnx_clx(text="This is a great model")`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> OnnxForSequenceClassification

<span class="hljs-comment"># load model from hub and convert</span>
model = OnnxForSequenceClassification.from_transformers(<span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)
tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)

<span class="hljs-comment"># optimize model</span>
model.optimize()
<span class="hljs-comment"># quantize model</span>
model.quantize()

<span class="hljs-comment"># create pipeline</span>
onnx_clx = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>,model=model,tokenizer=tokenizer)

result = onnx_clx(text=<span class="hljs-string">&quot;This is a great model&quot;</span>)`}}),Fe=new Ee({}),Ce=new B({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import OnnxForSequenceClassification

# load model from hub and convert
model = OnnxForSequenceClassification.from_transformers("distilbert-base-uncased-finetuned-sst-2-english")
tokenizer = AutoTokenizer.from_pretrained("distilbert-base-uncased-finetuned-sst-2-english")

# optimize model
model.optimize()
# quantize model
model.quantize()

# save converted model
model.save_pretrained("a_local_path_for_convert_onnx_model")
tokenizer.save_pretrained("a_local_path_for_convert_onnx_model")

# push model onnx model to HF Hub
model.push_to_hub("a_local_path_for_convert_onnx_model",
                  repository_id="my-onnx-repo",
                  use_auth_token=True
                  )`,highlighted:`<span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> OnnxForSequenceClassification

<span class="hljs-comment"># load model from hub and convert</span>
model = OnnxForSequenceClassification.from_transformers(<span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)
tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)

<span class="hljs-comment"># optimize model</span>
model.optimize()
<span class="hljs-comment"># quantize model</span>
model.quantize()

<span class="hljs-comment"># save converted model</span>
model.save_pretrained(<span class="hljs-string">&quot;a_local_path_for_convert_onnx_model&quot;</span>)
tokenizer.save_pretrained(<span class="hljs-string">&quot;a_local_path_for_convert_onnx_model&quot;</span>)

<span class="hljs-comment"># push model onnx model to HF Hub</span>
model.push_to_hub(<span class="hljs-string">&quot;a_local_path_for_convert_onnx_model&quot;</span>,
                  repository_id=<span class="hljs-string">&quot;my-onnx-repo&quot;</span>,
                  use_auth_token=<span class="hljs-literal">True</span>
                  )`}}),Pe=new Ee({}),Me=new H({props:{name:"class optimum.onnxruntime.OnnxModel",anchor:"optimum.onnxruntime.OnnxModel",parameters:[{name:"model",val:" = None"},{name:"config",val:" = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L72"}}),Se=new H({props:{name:"from_transformers",anchor:"optimum.onnxruntime.OnnxModel.from_transformers",parameters:[{name:"model_id",val:": str"},{name:"save_dir",val:": typing.Union[str, pathlib.Path] = '/github/home/.cache/huggingface/transformers'"},{name:"use_auth_token",val:": typing.Union[bool, str, NoneType] = None"},{name:"revision",val:": typing.Optional[str] = None"},{name:"force_download",val:": bool = True"},{name:"cache_dir",val:": typing.Optional[str] = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L264",parametersDescription:[{anchor:"optimum.onnxruntime.OnnxModel.from_transformers.model_id",description:`<strong>model_id</strong> (<code>str</code> or <code>Path</code>) &#x2014;
Directory from which to load`,name:"model_id"},{anchor:"optimum.onnxruntime.OnnxModel.from_transformers.save_dir",description:`<strong>save_dir</strong> (<code>str</code> or <code>Path</code>) &#x2014;
Directory where the onnx model should be saved, default to <em>transformers.file_utils.default_cache_path</em>, which is the cache dir for
transformers.`,name:"save_dir"},{anchor:"optimum.onnxruntime.OnnxModel.from_transformers.use_auth_token",description:`<strong>use_auth_token</strong> (<code>str</code> or <code>bool</code>) &#x2014;
Is needed to load models from a private repository`,name:"use_auth_token"},{anchor:"optimum.onnxruntime.OnnxModel.from_transformers.revision",description:`<strong>revision</strong> (<code>str</code>) &#x2014;
Revision is the specific model version to use. It can be a branch name, a tag name, or a commit id`,name:"revision"},{anchor:"optimum.onnxruntime.OnnxModel.from_transformers.cache_dir",description:`<strong>cache_dir</strong> (<code>Union[str, Path]</code>, <em>optional</em>) &#x2014;
Path to a directory in which a downloaded pretrained model configuration should be cached if the
standard cache should not be used.`,name:"cache_dir"},{anchor:"optimum.onnxruntime.OnnxModel.from_transformers.force_download",description:`<strong>force_download</strong> (<code>bool</code>, <em>optional</em>, defaults to <code>False</code>) &#x2014;
Whether or not to force the (re-)download of the model weights and configuration files, overriding the
cached versions if they exist.`,name:"force_download"},{anchor:"optimum.onnxruntime.OnnxModel.from_transformers.kwargs",description:`<strong>kwargs</strong> (<code>Dict</code>, <em>optional</em>) &#x2014;:
kwargs will be passed to the model during initialization`,name:"kwargs"}]}}),Ie=new H({props:{name:"load_model",anchor:"optimum.onnxruntime.OnnxModel.load_model",parameters:[{name:"path",val:": typing.Union[str, pathlib.Path]"},{name:"provider",val:" = None"}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L174",parametersDescription:[{anchor:"optimum.onnxruntime.OnnxModel.load_model.path",description:`<strong>path</strong> (<code>str</code> or <code>Path</code>) &#x2014;
Directory from which to load
provider(<code>str</code>) &#x2014;
Onnxruntime provider to use for loading the model, defaults to <em>CUDAExecutionProvider</em> if GPU is
available else <em>CPUExecutionProvider</em>`,name:"path"}]}}),He=new H({props:{name:"optimize",anchor:"optimum.onnxruntime.OnnxModel.optimize",parameters:[{name:"input_path",val:": typing.Union[str, pathlib.Path] = None"},{name:"model_type",val:": str = 'bert'"},{name:"output_path",val:": typing.Union[str, pathlib.Path] = '/github/home/.cache/huggingface/transformers'"},{name:"opt_level",val:": int = 1"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L84",parametersDescription:[{anchor:"optimum.onnxruntime.OnnxModel.optimize.input_path",description:`<strong>input_path</strong> (<code>str</code> or <code>Path</code>) &#x2014;
Directory from which to load
output_path(<code>str</code>) &#x2014;
Directory where to save the quantized model should be saved, default to
<em>transformers.file_utils.default_cache_path</em>, which is the cache dir for transformers.`,name:"input_path"}]}}),Qe=new H({props:{name:"quantize",anchor:"optimum.onnxruntime.OnnxModel.quantize",parameters:[{name:"input_path",val:": typing.Union[str, pathlib.Path] = None"},{name:"output_path",val:": typing.Union[str, pathlib.Path] = '/github/home/.cache/huggingface/transformers'"}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L137",parametersDescription:[{anchor:"optimum.onnxruntime.OnnxModel.quantize.input_path",description:`<strong>input_path</strong> (<code>str</code> or <code>Path</code>) &#x2014;
Directory from which to load
output_path(<code>str</code>) &#x2014;
Directory where to save the quantized model should be saved, default to
<em>transformers.file_utils.default_cache_path</em>, which is the cache dir for transformers.`,name:"input_path"}]}}),Le=new Ee({}),We=new H({props:{name:"class optimum.onnxruntime.OnnxForFeatureExtraction",anchor:"optimum.onnxruntime.OnnxForFeatureExtraction",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L371",parametersDescription:[{anchor:"optimum.onnxruntime.OnnxForFeatureExtraction.config",description:`<strong>config</strong> ([<code>PretrainedConfig</code>](https &#x2014;//huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig)): Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <code>from_pretrained</code> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.OnnxForFeatureExtraction.model",description:"<strong>model</strong> ([<code>onnxruntime.InferenceSession</code>](https &#x2014;//onnxruntime.ai/docs/api/python/api_summary.html#inferencesession)): This is the main class used to run a model. Check out the <code>load_model</code>",name:"model"},{anchor:"optimum.onnxruntime.OnnxForFeatureExtraction.for",description:"<strong>for</strong> more information. &#x2014;",name:"for"}]}}),Ue=new H({props:{name:"forward",anchor:"optimum.onnxruntime.OnnxForFeatureExtraction.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L384",parametersDescription:[{anchor:"optimum.onnxruntime.OnnxForFeatureExtraction.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.OnnxForFeatureExtraction.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.OnnxForFeatureExtraction.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}]}}),xe=new yo({props:{$$slots:{default:[Hi]},$$scope:{ctx:U}}}),Re=new B({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import OnnxForFeatureExtraction
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/all-MiniLM-L6-v2")
model = OnnxForFeatureExtraction.from_pretrained("optimum/all-MiniLM-L6-v2")

inputs = tokenizer("My Name is Philipp and i live in Germany.", return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits
list(logits.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> OnnxForFeatureExtraction
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = OnnxForFeatureExtraction.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;My Name is Philipp and i live in Germany.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)`}}),Ge=new B({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import OnnxForFeatureExtraction

tokenizer = AutoTokenizer.from_pretrained("optimum/all-MiniLM-L6-v2")
model = OnnxForFeatureExtraction.from_pretrained("optimum/all-MiniLM-L6-v2")
onnx_ner = pipeline("feature-extraction", model=model, tokenizer=tokenizer)

text = "My Name is Philipp and i live in Germany."
pred = onnx_ner(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> OnnxForFeatureExtraction

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = OnnxForFeatureExtraction.from_pretrained(<span class="hljs-string">&quot;optimum/all-MiniLM-L6-v2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_ner = pipeline(<span class="hljs-string">&quot;feature-extraction&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;My Name is Philipp and i live in Germany.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_ner(text)`}}),Ve=new Ee({}),Je=new H({props:{name:"class optimum.onnxruntime.OnnxForQuestionAnswering",anchor:"optimum.onnxruntime.OnnxForQuestionAnswering",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L456",parametersDescription:[{anchor:"optimum.onnxruntime.OnnxForQuestionAnswering.config",description:`<strong>config</strong> ([<code>PretrainedConfig</code>](https &#x2014;//huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig)): Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <code>from_pretrained</code> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.OnnxForQuestionAnswering.model",description:"<strong>model</strong> ([<code>onnxruntime.InferenceSession</code>](https &#x2014;//onnxruntime.ai/docs/api/python/api_summary.html#inferencesession)): This is the main class used to run a model. Check out the <code>load_model</code>",name:"model"},{anchor:"optimum.onnxruntime.OnnxForQuestionAnswering.for",description:"<strong>for</strong> more information. &#x2014;",name:"for"}]}}),Ke=new H({props:{name:"forward",anchor:"optimum.onnxruntime.OnnxForQuestionAnswering.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L469",parametersDescription:[{anchor:"optimum.onnxruntime.OnnxForQuestionAnswering.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.OnnxForQuestionAnswering.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.OnnxForQuestionAnswering.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}]}}),ve=new yo({props:{$$slots:{default:[Qi]},$$scope:{ctx:U}}}),Ze=new B({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import OnnxForQuestionAnswering
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/roberta-base-squad2")
model = OnnxForQuestionAnswering.from_pretrained("optimum/roberta-base-squad2")

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"
inputs = tokenizer(question, text, return_tensors="pt")
start_positions = torch.tensor([1])
end_positions = torch.tensor([3])

outputs = model(**inputs, start_positions=start_positions, end_positions=end_positions)
start_scores = outputs.start_logits
end_scores = outputs.end_logits`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> OnnxForQuestionAnswering
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = OnnxForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(question, text, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>start_positions = torch.tensor([<span class="hljs-number">1</span>])
<span class="hljs-meta">&gt;&gt;&gt; </span>end_positions = torch.tensor([<span class="hljs-number">3</span>])

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs, start_positions=start_positions, end_positions=end_positions)
<span class="hljs-meta">&gt;&gt;&gt; </span>start_scores = outputs.start_logits
<span class="hljs-meta">&gt;&gt;&gt; </span>end_scores = outputs.end_logits`}}),tt=new B({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import OnnxForQuestionAnswering

tokenizer = AutoTokenizer.from_pretrained("optimum/roberta-base-squad2")
model = OnnxForQuestionAnswering.from_pretrained("optimum/roberta-base-squad2")
onnx_qa = pipeline("question-answering", model=model, tokenizer=tokenizer)

question, text = "Who was Jim Henson?", "Jim Henson was a nice puppet"
pred = onnx_qa(question, text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> OnnxForQuestionAnswering

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = OnnxForQuestionAnswering.from_pretrained(<span class="hljs-string">&quot;optimum/roberta-base-squad2&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_qa = pipeline(<span class="hljs-string">&quot;question-answering&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>question, text = <span class="hljs-string">&quot;Who was Jim Henson?&quot;</span>, <span class="hljs-string">&quot;Jim Henson was a nice puppet&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_qa(question, text)`}}),nt=new Ee({}),ot=new H({props:{name:"class optimum.onnxruntime.OnnxForSequenceClassification",anchor:"optimum.onnxruntime.OnnxForSequenceClassification",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L556",parametersDescription:[{anchor:"optimum.onnxruntime.OnnxForSequenceClassification.config",description:`<strong>config</strong> ([<code>PretrainedConfig</code>](https &#x2014;//huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig)): Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <code>from_pretrained</code> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.OnnxForSequenceClassification.model",description:"<strong>model</strong> ([<code>onnxruntime.InferenceSession</code>](https &#x2014;//onnxruntime.ai/docs/api/python/api_summary.html#inferencesession)): This is the main class used to run a model. Check out the <code>load_model</code>",name:"model"},{anchor:"optimum.onnxruntime.OnnxForSequenceClassification.for",description:"<strong>for</strong> more information. &#x2014;",name:"for"}]}}),rt=new H({props:{name:"forward",anchor:"optimum.onnxruntime.OnnxForSequenceClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L570",parametersDescription:[{anchor:"optimum.onnxruntime.OnnxForSequenceClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.OnnxForSequenceClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.OnnxForSequenceClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}]}}),$e=new yo({props:{$$slots:{default:[Li]},$$scope:{ctx:U}}}),at=new B({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import OnnxForSequenceClassification
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")
model = OnnxForSequenceClassification.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")

inputs = tokenizer("Hello, my dog is cute", return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits
list(logits.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> OnnxForSequenceClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = OnnxForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)`}}),lt=new B({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import OnnxForSequenceClassification

tokenizer = AutoTokenizer.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")
model = OnnxForSequenceClassification.from_pretrained("optimum/distilbert-base-uncased-finetuned-sst-2-english")
onnx_clx = pipeline("text-classification", model=model, tokenizer=tokenizer)

text = "Hello, my dog is cute"
pred = onnx_clx(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> OnnxForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = OnnxForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-finetuned-sst-2-english&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_clx = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;Hello, my dog is cute&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_clx(text)`}}),pt=new B({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import OnnxForSequenceClassification

tokenizer = AutoTokenizer.from_pretrained("optimum/distilbert-base-uncased-mnli")
model = OnnxForSequenceClassification.from_pretrained("optimum/distilbert-base-uncased-mnli")
onnx_z0 = pipeline("zero-shot-classification", model=model, tokenizer=tokenizer)

sequence_to_classify = "Who are you voting for in 2020?"
candidate_labels = ["Europe", "public health", "politics", "elections"]
pred = onnx_z0(sequence_to_classify, candidate_labels, multi_class=True)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> OnnxForSequenceClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-mnli&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = OnnxForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;optimum/distilbert-base-uncased-mnli&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_z0 = pipeline(<span class="hljs-string">&quot;zero-shot-classification&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>sequence_to_classify = <span class="hljs-string">&quot;Who are you voting for in 2020?&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>candidate_labels = [<span class="hljs-string">&quot;Europe&quot;</span>, <span class="hljs-string">&quot;public health&quot;</span>, <span class="hljs-string">&quot;politics&quot;</span>, <span class="hljs-string">&quot;elections&quot;</span>]
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_z0(sequence_to_classify, candidate_labels, multi_class=<span class="hljs-literal">True</span>)`}}),ct=new Ee({}),dt=new H({props:{name:"class optimum.onnxruntime.OnnxForTokenClassification",anchor:"optimum.onnxruntime.OnnxForTokenClassification",parameters:[{name:"*args",val:""},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L641",parametersDescription:[{anchor:"optimum.onnxruntime.OnnxForTokenClassification.config",description:`<strong>config</strong> ([<code>PretrainedConfig</code>](https &#x2014;//huggingface.co/docs/transformers/main_classes/configuration#transformers.PretrainedConfig)): Model configuration class with all the parameters of the model.
Initializing with a config file does not load the weights associated with the model, only the
configuration. Check out the <code>from_pretrained</code> method to load the model weights.`,name:"config"},{anchor:"optimum.onnxruntime.OnnxForTokenClassification.model",description:"<strong>model</strong> ([<code>onnxruntime.InferenceSession</code>](https &#x2014;//onnxruntime.ai/docs/api/python/api_summary.html#inferencesession)): This is the main class used to run a model. Check out the <code>load_model</code>",name:"model"},{anchor:"optimum.onnxruntime.OnnxForTokenClassification.for",description:"<strong>for</strong> more information. &#x2014;",name:"for"}]}}),ht=new H({props:{name:"forward",anchor:"optimum.onnxruntime.OnnxForTokenClassification.forward",parameters:[{name:"input_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"attention_mask",val:": typing.Optional[torch.Tensor] = None"},{name:"token_type_ids",val:": typing.Optional[torch.Tensor] = None"},{name:"**kwargs",val:""}],source:"https://github.com/huggingface/optimum/blob/pr_113/src/optimum/onnxruntime/modeling_ort.py#L654",parametersDescription:[{anchor:"optimum.onnxruntime.OnnxForTokenClassification.forward.input_ids",description:`<strong>input_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>) &#x2014;
Indices of input sequence tokens in the vocabulary.
Indices can be obtained using <a href="https://huggingface.co/docs/transformers/autoclass_tutorial#autotokenizer" rel="nofollow"><code>AutoTokenizer</code></a>.
See <a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.encode" rel="nofollow"><code>PreTrainedTokenizer.encode</code></a> and
<a href="https://huggingface.co/docs/transformers/main_classes/tokenizer#transformers.PreTrainedTokenizerBase.__call__" rel="nofollow"><code>PreTrainedTokenizer.__call__</code></a> for details.
<a href="https://huggingface.co/docs/transformers/glossary#input-ids" rel="nofollow">What are input IDs?</a>`,name:"input_ids"},{anchor:"optimum.onnxruntime.OnnxForTokenClassification.forward.attention_mask",description:`<strong>attention_mask</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Mask to avoid performing attention on padding token indices. Mask values selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>not masked</strong>,</li>
<li>0 for tokens that are <strong>masked</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#attention-mask" rel="nofollow">What are attention masks?</a></li>
</ul>`,name:"attention_mask"},{anchor:"optimum.onnxruntime.OnnxForTokenClassification.forward.token_type_ids",description:`<strong>token_type_ids</strong> (<code>torch.Tensor</code> of shape <code>(batch_size, sequence_length)</code>, <em>optional</em>) &#x2014;
Segment token indices to indicate first and second portions of the inputs. Indices are selected in <code>[0, 1]</code>:<ul>
<li>1 for tokens that are <strong>sentence A</strong>,</li>
<li>0 for tokens that are <strong>sentence B</strong>.
<a href="https://huggingface.co/docs/transformers/glossary#token-type-ids" rel="nofollow">What are token type IDs?</a></li>
</ul>`,name:"token_type_ids"}]}}),ye=new yo({props:{$$slots:{default:[Wi]},$$scope:{ctx:U}}}),ft=new B({props:{code:`from transformers import AutoTokenizer
from optimum.onnxruntime import OnnxForTokenClassification
import torch

tokenizer = AutoTokenizer.from_pretrained("optimum/bert-base-NER")
model = OnnxForTokenClassification.from_pretrained("optimum/bert-base-NER")

inputs = tokenizer("My Name is Philipp and i live in Germany.", return_tensors="pt")

outputs = model(**inputs)
logits = outputs.logits
list(logits.shape)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> OnnxForTokenClassification
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> torch

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = OnnxForTokenClassification.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>inputs = tokenizer(<span class="hljs-string">&quot;My Name is Philipp and i live in Germany.&quot;</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)

<span class="hljs-meta">&gt;&gt;&gt; </span>outputs = model(**inputs)
<span class="hljs-meta">&gt;&gt;&gt; </span>logits = outputs.logits
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">list</span>(logits.shape)`}}),_t=new B({props:{code:`from transformers import AutoTokenizer, pipeline
from optimum.onnxruntime import OnnxForTokenClassification

tokenizer = AutoTokenizer.from_pretrained("optimum/bert-base-NER")
model = OnnxForTokenClassification.from_pretrained("optimum/bert-base-NER")
onnx_ner = pipeline("token-classification", model=model, tokenizer=tokenizer)

text = "My Name is Philipp and i live in Germany."
pred = onnx_ner(text)`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, pipeline
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> optimum.onnxruntime <span class="hljs-keyword">import</span> OnnxForTokenClassification

<span class="hljs-meta">&gt;&gt;&gt; </span>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>model = OnnxForTokenClassification.from_pretrained(<span class="hljs-string">&quot;optimum/bert-base-NER&quot;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>onnx_ner = pipeline(<span class="hljs-string">&quot;token-classification&quot;</span>, model=model, tokenizer=tokenizer)

<span class="hljs-meta">&gt;&gt;&gt; </span>text = <span class="hljs-string">&quot;My Name is Philipp and i live in Germany.&quot;</span>
<span class="hljs-meta">&gt;&gt;&gt; </span>pred = onnx_ner(text)`}}),{c(){d=o("meta"),q=l(),v=o("h1"),b=o("a"),O=o("span"),h(w.$$.fragment),$=l(),F=o("span"),Oo=a("Optimum Inference with Onnxrunime"),An=l(),le=o("p"),qo=a(`Optimum Inference is a utility package for building and running inference with accleratored runtime like Onnxruntime.
Optimum Inference can be used to load optimized models from the `),kt=o("a"),Eo=a("Hugging Face Hub"),zo=a(` and create pipelines
to run acclerated inference without rewriting your APIs.`),Cn=l(),Y=o("h2"),me=o("a"),Et=o("span"),h(ze.$$.fragment),jo=l(),zt=o("span"),To=a("Switching from Transfromers to Optimum Inference"),Pn=l(),R=o("p"),Fo=a("The Optimum Inference models are API compatible with Transformers models, meaning you can just replace your "),jt=o("code"),Ao=a("AutoFor*"),Co=a(" with the optimum "),Tt=o("code"),Po=a("OnnxFor*"),Mo=a(" class."),Mn=l(),h(je.$$.fragment),Nn=l(),Q=o("p"),No=a("Optimum Inference also includes methods to convert vanilla Transformers models to optimized models ("),Ft=o("code"),So=a(".from_transfromers"),Do=a(`).
After you have converted a model you can even `),At=o("code"),Io=a("optimize"),Ho=a(" or "),Ct=o("code"),Qo=a("quantize"),Lo=a(" the model if it is supported by the runtime you use."),Sn=l(),h(Te.$$.fragment),Dn=l(),pe=o("p"),Wo=a("You can find a complete walkhrough optimum inference for Onnxruntime in this "),vt=o("a"),Bo=a("notebook"),Uo=a("."),In=l(),K=o("h3"),ce=o("a"),Pt=o("span"),h(Fe.$$.fragment),Ro=l(),Mt=o("span"),Xo=a("Working with the [Hugging Face Model Hub](https://hf.co/models)"),Hn=l(),L=o("p"),Go=a("The optimum model classes, e.g. "),Nt=o("code"),Vo=a("OnnxModel"),Jo=a(" are directly integrated with the "),Ae=o("a"),Yo=a("Hugging Face Model Hub"),Ko=a(`) meaning you can not only
load model from the Hub but also push your models to the Hub with `),St=o("code"),Zo=a("push_to_hub"),es=a(` method. Below you find an example which pulls a vanilla transformers model
from the Hub and converts it to an optimum model and pushes it back into a new repository.`),Qn=l(),h(Ce.$$.fragment),Ln=l(),Z=o("h2"),de=o("a"),Dt=o("span"),h(Pe.$$.fragment),ts=l(),It=o("span"),ns=a("OnnxModel"),Wn=l(),A=o("div"),h(Me.$$.fragment),os=l(),Ne=o("p"),ss=a(`Base OnnxModel class for implementing models using ONNX Runtime. The OnnxModel implements generic methods for interacting
with the Hugging Face Hub as well as exporting vanilla transformers models to ONNX using `),Ht=o("code"),rs=a("transformers.onnx"),as=a(` toolchain.
The OnnxModel implements additionally generic methods for optimizing and quantizing Onnx models.`),is=l(),ue=o("div"),h(Se.$$.fragment),ls=l(),De=o("p"),ms=a("Converts a vanilla Transformers model into an optimized model using "),Qt=o("em"),ps=a("transformers.onnx.export_onnx"),cs=a("."),ds=l(),he=o("div"),h(Ie.$$.fragment),us=l(),wt=o("p"),hs=a("loads ONNX Inference session with Provider. Default Provider is if GPU available else "),Lt=o("em"),fs=a("CPUExecutionProvider"),gs=l(),fe=o("div"),h(He.$$.fragment),_s=l(),Wt=o("p"),xs=a("optimizes the mode using onnxruntime.tools.transformers.optimize"),ks=l(),ge=o("div"),h(Qe.$$.fragment),vs=l(),Bt=o("p"),ws=a("quantizes the mode using onnxruntime.tools.transformers.optimize"),Bn=l(),ee=o("h2"),_e=o("a"),Ut=o("span"),h(Le.$$.fragment),$s=l(),Rt=o("span"),bs=a("OnnxForFeatureExtraction"),Un=l(),C=o("div"),h(We.$$.fragment),ys=l(),Xt=o("p"),Os=a("Onnx Model with a MaskedLMOutput for feature-extraction tasks."),qs=l(),Be=o("p"),Es=a("This model inherits from "),Gt=o("code"),zs=a("OnnxModel"),js=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),Ts=l(),Vt=o("p"),Fs=a("Feature Extraction model for ONNX."),As=l(),E=o("div"),h(Ue.$$.fragment),Cs=l(),te=o("p"),Ps=a("The "),Jt=o("code"),Ms=a("OnnxForFeatureExtraction"),Ns=a(" forward method, overrides the "),Yt=o("code"),Ss=a("__call__"),Ds=a(" special method."),Is=l(),h(xe.$$.fragment),Hs=l(),Kt=o("p"),Qs=a("Example of feature extraction:"),Ls=l(),h(Re.$$.fragment),Ws=l(),Xe=o("p"),Bs=a("Example using "),Zt=o("code"),Us=a("transformers.pipelines"),Rs=a(":"),Xs=l(),h(Ge.$$.fragment),Rn=l(),ne=o("h2"),ke=o("a"),en=o("span"),h(Ve.$$.fragment),Gs=l(),tn=o("span"),Vs=a("OnnxForQuestionAnswering"),Xn=l(),P=o("div"),h(Je.$$.fragment),Js=l(),nn=o("p"),Ys=a("Onnx Model with a QuestionAnsweringModelOutput for extractive question-answering tasks like SQuAD."),Ks=l(),Ye=o("p"),Zs=a("This model inherits from "),on=o("code"),er=a("OnnxModel"),tr=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),nr=l(),sn=o("p"),or=a("Question Answering model for ONNX."),sr=l(),z=o("div"),h(Ke.$$.fragment),rr=l(),oe=o("p"),ar=a("The "),rn=o("code"),ir=a("OnnxForQuestionAnswering"),lr=a(" forward method, overrides the "),an=o("code"),mr=a("__call__"),pr=a(" special method."),cr=l(),h(ve.$$.fragment),dr=l(),ln=o("p"),ur=a("Example of question answering:"),hr=l(),h(Ze.$$.fragment),fr=l(),et=o("p"),gr=a("Example using "),mn=o("code"),_r=a("transformers.pipelines"),xr=a(":"),kr=l(),h(tt.$$.fragment),Gn=l(),se=o("h2"),we=o("a"),pn=o("span"),h(nt.$$.fragment),vr=l(),cn=o("span"),wr=a("OnnxForSequenceClassification"),Vn=l(),M=o("div"),h(ot.$$.fragment),$r=l(),dn=o("p"),br=a(`Onnx Model with a sequence classification/regression head on top (a linear layer on top of the
pooled output) e.g. for GLUE tasks.`),yr=l(),st=o("p"),Or=a("This model inherits from "),un=o("code"),qr=a("OnnxModel"),Er=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),zr=l(),hn=o("p"),jr=a("Sequence Classification model for ONNX."),Tr=l(),y=o("div"),h(rt.$$.fragment),Fr=l(),re=o("p"),Ar=a("The "),fn=o("code"),Cr=a("OnnxForSequenceClassification"),Pr=a(" forward method, overrides the "),gn=o("code"),Mr=a("__call__"),Nr=a(" special method."),Sr=l(),h($e.$$.fragment),Dr=l(),_n=o("p"),Ir=a("Example of single-label classification:"),Hr=l(),h(at.$$.fragment),Qr=l(),it=o("p"),Lr=a("Example using "),xn=o("code"),Wr=a("transformers.pipelines"),Br=a(":"),Ur=l(),h(lt.$$.fragment),Rr=l(),mt=o("p"),Xr=a("Example using zero-shot-classification "),kn=o("code"),Gr=a("transformers.pipelines"),Vr=a(":"),Jr=l(),h(pt.$$.fragment),Jn=l(),ae=o("h2"),be=o("a"),vn=o("span"),h(ct.$$.fragment),Yr=l(),wn=o("span"),Kr=a("OnnxForTokenClassification"),Yn=l(),N=o("div"),h(dt.$$.fragment),Zr=l(),$n=o("p"),ea=a(`Onnx Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g.
for Named-Entity-Recognition (NER) tasks.`),ta=l(),ut=o("p"),na=a("This model inherits from "),bn=o("code"),oa=a("OnnxModel"),sa=a(`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),ra=l(),yn=o("p"),aa=a("Sequence Classification model for ONNX."),ia=l(),j=o("div"),h(ht.$$.fragment),la=l(),ie=o("p"),ma=a("The "),On=o("code"),pa=a("OnnxForTokenClassification"),ca=a(" forward method, overrides the "),qn=o("code"),da=a("__call__"),ua=a(" special method."),ha=l(),h(ye.$$.fragment),fa=l(),En=o("p"),ga=a("Example of token classification:"),_a=l(),h(ft.$$.fragment),xa=l(),gt=o("p"),ka=a("Example using "),zn=o("code"),va=a("transformers.pipelines"),wa=a(":"),$a=l(),h(_t.$$.fragment),this.h()},l(t){const p=Di('[data-svelte="svelte-1phssyn"]',document.head);d=s(p,"META",{name:!0,content:!0}),p.forEach(n),q=m(t),v=s(t,"H1",{class:!0});var xt=r(v);b=s(xt,"A",{id:!0,class:!0,href:!0});var jn=r(b);O=s(jn,"SPAN",{});var Tn=r(O);f(w.$$.fragment,Tn),Tn.forEach(n),jn.forEach(n),$=m(xt),F=s(xt,"SPAN",{});var Fn=r(F);Oo=i(Fn,"Optimum Inference with Onnxrunime"),Fn.forEach(n),xt.forEach(n),An=m(t),le=s(t,"P",{});var Zn=r(le);qo=i(Zn,`Optimum Inference is a utility package for building and running inference with accleratored runtime like Onnxruntime.
Optimum Inference can be used to load optimized models from the `),kt=s(Zn,"A",{href:!0});var ya=r(kt);Eo=i(ya,"Hugging Face Hub"),ya.forEach(n),zo=i(Zn,` and create pipelines
to run acclerated inference without rewriting your APIs.`),Zn.forEach(n),Cn=m(t),Y=s(t,"H2",{class:!0});var eo=r(Y);me=s(eo,"A",{id:!0,class:!0,href:!0});var Oa=r(me);Et=s(Oa,"SPAN",{});var qa=r(Et);f(ze.$$.fragment,qa),qa.forEach(n),Oa.forEach(n),jo=m(eo),zt=s(eo,"SPAN",{});var Ea=r(zt);To=i(Ea,"Switching from Transfromers to Optimum Inference"),Ea.forEach(n),eo.forEach(n),Pn=m(t),R=s(t,"P",{});var $t=r(R);Fo=i($t,"The Optimum Inference models are API compatible with Transformers models, meaning you can just replace your "),jt=s($t,"CODE",{});var za=r(jt);Ao=i(za,"AutoFor*"),za.forEach(n),Co=i($t," with the optimum "),Tt=s($t,"CODE",{});var ja=r(Tt);Po=i(ja,"OnnxFor*"),ja.forEach(n),Mo=i($t," class."),$t.forEach(n),Mn=m(t),f(je.$$.fragment,t),Nn=m(t),Q=s(t,"P",{});var Oe=r(Q);No=i(Oe,"Optimum Inference also includes methods to convert vanilla Transformers models to optimized models ("),Ft=s(Oe,"CODE",{});var Ta=r(Ft);So=i(Ta,".from_transfromers"),Ta.forEach(n),Do=i(Oe,`).
After you have converted a model you can even `),At=s(Oe,"CODE",{});var Fa=r(At);Io=i(Fa,"optimize"),Fa.forEach(n),Ho=i(Oe," or "),Ct=s(Oe,"CODE",{});var Aa=r(Ct);Qo=i(Aa,"quantize"),Aa.forEach(n),Lo=i(Oe," the model if it is supported by the runtime you use."),Oe.forEach(n),Sn=m(t),f(Te.$$.fragment,t),Dn=m(t),pe=s(t,"P",{});var to=r(pe);Wo=i(to,"You can find a complete walkhrough optimum inference for Onnxruntime in this "),vt=s(to,"A",{href:!0});var Ca=r(vt);Bo=i(Ca,"notebook"),Ca.forEach(n),Uo=i(to,"."),to.forEach(n),In=m(t),K=s(t,"H3",{class:!0});var no=r(K);ce=s(no,"A",{id:!0,class:!0,href:!0});var Pa=r(ce);Pt=s(Pa,"SPAN",{});var Ma=r(Pt);f(Fe.$$.fragment,Ma),Ma.forEach(n),Pa.forEach(n),Ro=m(no),Mt=s(no,"SPAN",{});var Na=r(Mt);Xo=i(Na,"Working with the [Hugging Face Model Hub](https://hf.co/models)"),Na.forEach(n),no.forEach(n),Hn=m(t),L=s(t,"P",{});var qe=r(L);Go=i(qe,"The optimum model classes, e.g. "),Nt=s(qe,"CODE",{});var Sa=r(Nt);Vo=i(Sa,"OnnxModel"),Sa.forEach(n),Jo=i(qe," are directly integrated with the "),Ae=s(qe,"A",{href:!0,rel:!0});var Da=r(Ae);Yo=i(Da,"Hugging Face Model Hub"),Da.forEach(n),Ko=i(qe,`) meaning you can not only
load model from the Hub but also push your models to the Hub with `),St=s(qe,"CODE",{});var Ia=r(St);Zo=i(Ia,"push_to_hub"),Ia.forEach(n),es=i(qe,` method. Below you find an example which pulls a vanilla transformers model
from the Hub and converts it to an optimum model and pushes it back into a new repository.`),qe.forEach(n),Qn=m(t),f(Ce.$$.fragment,t),Ln=m(t),Z=s(t,"H2",{class:!0});var oo=r(Z);de=s(oo,"A",{id:!0,class:!0,href:!0});var Ha=r(de);Dt=s(Ha,"SPAN",{});var Qa=r(Dt);f(Pe.$$.fragment,Qa),Qa.forEach(n),Ha.forEach(n),ts=m(oo),It=s(oo,"SPAN",{});var La=r(It);ns=i(La,"OnnxModel"),La.forEach(n),oo.forEach(n),Wn=m(t),A=s(t,"DIV",{class:!0});var W=r(A);f(Me.$$.fragment,W),os=m(W),Ne=s(W,"P",{});var so=r(Ne);ss=i(so,`Base OnnxModel class for implementing models using ONNX Runtime. The OnnxModel implements generic methods for interacting
with the Hugging Face Hub as well as exporting vanilla transformers models to ONNX using `),Ht=s(so,"CODE",{});var Wa=r(Ht);rs=i(Wa,"transformers.onnx"),Wa.forEach(n),as=i(so,` toolchain.
The OnnxModel implements additionally generic methods for optimizing and quantizing Onnx models.`),so.forEach(n),is=m(W),ue=s(W,"DIV",{class:!0});var ro=r(ue);f(Se.$$.fragment,ro),ls=m(ro),De=s(ro,"P",{});var ao=r(De);ms=i(ao,"Converts a vanilla Transformers model into an optimized model using "),Qt=s(ao,"EM",{});var Ba=r(Qt);ps=i(Ba,"transformers.onnx.export_onnx"),Ba.forEach(n),cs=i(ao,"."),ao.forEach(n),ro.forEach(n),ds=m(W),he=s(W,"DIV",{class:!0});var io=r(he);f(Ie.$$.fragment,io),us=m(io),wt=s(io,"P",{});var ba=r(wt);hs=i(ba,"loads ONNX Inference session with Provider. Default Provider is if GPU available else "),Lt=s(ba,"EM",{});var Ua=r(Lt);fs=i(Ua,"CPUExecutionProvider"),Ua.forEach(n),ba.forEach(n),io.forEach(n),gs=m(W),fe=s(W,"DIV",{class:!0});var lo=r(fe);f(He.$$.fragment,lo),_s=m(lo),Wt=s(lo,"P",{});var Ra=r(Wt);xs=i(Ra,"optimizes the mode using onnxruntime.tools.transformers.optimize"),Ra.forEach(n),lo.forEach(n),ks=m(W),ge=s(W,"DIV",{class:!0});var mo=r(ge);f(Qe.$$.fragment,mo),vs=m(mo),Bt=s(mo,"P",{});var Xa=r(Bt);ws=i(Xa,"quantizes the mode using onnxruntime.tools.transformers.optimize"),Xa.forEach(n),mo.forEach(n),W.forEach(n),Bn=m(t),ee=s(t,"H2",{class:!0});var po=r(ee);_e=s(po,"A",{id:!0,class:!0,href:!0});var Ga=r(_e);Ut=s(Ga,"SPAN",{});var Va=r(Ut);f(Le.$$.fragment,Va),Va.forEach(n),Ga.forEach(n),$s=m(po),Rt=s(po,"SPAN",{});var Ja=r(Rt);bs=i(Ja,"OnnxForFeatureExtraction"),Ja.forEach(n),po.forEach(n),Un=m(t),C=s(t,"DIV",{class:!0});var X=r(C);f(We.$$.fragment,X),ys=m(X),Xt=s(X,"P",{});var Ya=r(Xt);Os=i(Ya,"Onnx Model with a MaskedLMOutput for feature-extraction tasks."),Ya.forEach(n),qs=m(X),Be=s(X,"P",{});var co=r(Be);Es=i(co,"This model inherits from "),Gt=s(co,"CODE",{});var Ka=r(Gt);zs=i(Ka,"OnnxModel"),Ka.forEach(n),js=i(co,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),co.forEach(n),Ts=m(X),Vt=s(X,"P",{});var Za=r(Vt);Fs=i(Za,"Feature Extraction model for ONNX."),Za.forEach(n),As=m(X),E=s(X,"DIV",{class:!0});var S=r(E);f(Ue.$$.fragment,S),Cs=m(S),te=s(S,"P",{});var bt=r(te);Ps=i(bt,"The "),Jt=s(bt,"CODE",{});var ei=r(Jt);Ms=i(ei,"OnnxForFeatureExtraction"),ei.forEach(n),Ns=i(bt," forward method, overrides the "),Yt=s(bt,"CODE",{});var ti=r(Yt);Ss=i(ti,"__call__"),ti.forEach(n),Ds=i(bt," special method."),bt.forEach(n),Is=m(S),f(xe.$$.fragment,S),Hs=m(S),Kt=s(S,"P",{});var ni=r(Kt);Qs=i(ni,"Example of feature extraction:"),ni.forEach(n),Ls=m(S),f(Re.$$.fragment,S),Ws=m(S),Xe=s(S,"P",{});var uo=r(Xe);Bs=i(uo,"Example using "),Zt=s(uo,"CODE",{});var oi=r(Zt);Us=i(oi,"transformers.pipelines"),oi.forEach(n),Rs=i(uo,":"),uo.forEach(n),Xs=m(S),f(Ge.$$.fragment,S),S.forEach(n),X.forEach(n),Rn=m(t),ne=s(t,"H2",{class:!0});var ho=r(ne);ke=s(ho,"A",{id:!0,class:!0,href:!0});var si=r(ke);en=s(si,"SPAN",{});var ri=r(en);f(Ve.$$.fragment,ri),ri.forEach(n),si.forEach(n),Gs=m(ho),tn=s(ho,"SPAN",{});var ai=r(tn);Vs=i(ai,"OnnxForQuestionAnswering"),ai.forEach(n),ho.forEach(n),Xn=m(t),P=s(t,"DIV",{class:!0});var G=r(P);f(Je.$$.fragment,G),Js=m(G),nn=s(G,"P",{});var ii=r(nn);Ys=i(ii,"Onnx Model with a QuestionAnsweringModelOutput for extractive question-answering tasks like SQuAD."),ii.forEach(n),Ks=m(G),Ye=s(G,"P",{});var fo=r(Ye);Zs=i(fo,"This model inherits from "),on=s(fo,"CODE",{});var li=r(on);er=i(li,"OnnxModel"),li.forEach(n),tr=i(fo,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),fo.forEach(n),nr=m(G),sn=s(G,"P",{});var mi=r(sn);or=i(mi,"Question Answering model for ONNX."),mi.forEach(n),sr=m(G),z=s(G,"DIV",{class:!0});var D=r(z);f(Ke.$$.fragment,D),rr=m(D),oe=s(D,"P",{});var yt=r(oe);ar=i(yt,"The "),rn=s(yt,"CODE",{});var pi=r(rn);ir=i(pi,"OnnxForQuestionAnswering"),pi.forEach(n),lr=i(yt," forward method, overrides the "),an=s(yt,"CODE",{});var ci=r(an);mr=i(ci,"__call__"),ci.forEach(n),pr=i(yt," special method."),yt.forEach(n),cr=m(D),f(ve.$$.fragment,D),dr=m(D),ln=s(D,"P",{});var di=r(ln);ur=i(di,"Example of question answering:"),di.forEach(n),hr=m(D),f(Ze.$$.fragment,D),fr=m(D),et=s(D,"P",{});var go=r(et);gr=i(go,"Example using "),mn=s(go,"CODE",{});var ui=r(mn);_r=i(ui,"transformers.pipelines"),ui.forEach(n),xr=i(go,":"),go.forEach(n),kr=m(D),f(tt.$$.fragment,D),D.forEach(n),G.forEach(n),Gn=m(t),se=s(t,"H2",{class:!0});var _o=r(se);we=s(_o,"A",{id:!0,class:!0,href:!0});var hi=r(we);pn=s(hi,"SPAN",{});var fi=r(pn);f(nt.$$.fragment,fi),fi.forEach(n),hi.forEach(n),vr=m(_o),cn=s(_o,"SPAN",{});var gi=r(cn);wr=i(gi,"OnnxForSequenceClassification"),gi.forEach(n),_o.forEach(n),Vn=m(t),M=s(t,"DIV",{class:!0});var V=r(M);f(ot.$$.fragment,V),$r=m(V),dn=s(V,"P",{});var _i=r(dn);br=i(_i,`Onnx Model with a sequence classification/regression head on top (a linear layer on top of the
pooled output) e.g. for GLUE tasks.`),_i.forEach(n),yr=m(V),st=s(V,"P",{});var xo=r(st);Or=i(xo,"This model inherits from "),un=s(xo,"CODE",{});var xi=r(un);qr=i(xi,"OnnxModel"),xi.forEach(n),Er=i(xo,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),xo.forEach(n),zr=m(V),hn=s(V,"P",{});var ki=r(hn);jr=i(ki,"Sequence Classification model for ONNX."),ki.forEach(n),Tr=m(V),y=s(V,"DIV",{class:!0});var T=r(y);f(rt.$$.fragment,T),Fr=m(T),re=s(T,"P",{});var Ot=r(re);Ar=i(Ot,"The "),fn=s(Ot,"CODE",{});var vi=r(fn);Cr=i(vi,"OnnxForSequenceClassification"),vi.forEach(n),Pr=i(Ot," forward method, overrides the "),gn=s(Ot,"CODE",{});var wi=r(gn);Mr=i(wi,"__call__"),wi.forEach(n),Nr=i(Ot," special method."),Ot.forEach(n),Sr=m(T),f($e.$$.fragment,T),Dr=m(T),_n=s(T,"P",{});var $i=r(_n);Ir=i($i,"Example of single-label classification:"),$i.forEach(n),Hr=m(T),f(at.$$.fragment,T),Qr=m(T),it=s(T,"P",{});var ko=r(it);Lr=i(ko,"Example using "),xn=s(ko,"CODE",{});var bi=r(xn);Wr=i(bi,"transformers.pipelines"),bi.forEach(n),Br=i(ko,":"),ko.forEach(n),Ur=m(T),f(lt.$$.fragment,T),Rr=m(T),mt=s(T,"P",{});var vo=r(mt);Xr=i(vo,"Example using zero-shot-classification "),kn=s(vo,"CODE",{});var yi=r(kn);Gr=i(yi,"transformers.pipelines"),yi.forEach(n),Vr=i(vo,":"),vo.forEach(n),Jr=m(T),f(pt.$$.fragment,T),T.forEach(n),V.forEach(n),Jn=m(t),ae=s(t,"H2",{class:!0});var wo=r(ae);be=s(wo,"A",{id:!0,class:!0,href:!0});var Oi=r(be);vn=s(Oi,"SPAN",{});var qi=r(vn);f(ct.$$.fragment,qi),qi.forEach(n),Oi.forEach(n),Yr=m(wo),wn=s(wo,"SPAN",{});var Ei=r(wn);Kr=i(Ei,"OnnxForTokenClassification"),Ei.forEach(n),wo.forEach(n),Yn=m(t),N=s(t,"DIV",{class:!0});var J=r(N);f(dt.$$.fragment,J),Zr=m(J),$n=s(J,"P",{});var zi=r($n);ea=i(zi,`Onnx Model with a token classification head on top (a linear layer on top of the hidden-states output) e.g.
for Named-Entity-Recognition (NER) tasks.`),zi.forEach(n),ta=m(J),ut=s(J,"P",{});var $o=r(ut);na=i($o,"This model inherits from "),bn=s($o,"CODE",{});var ji=r(bn);oa=i(ji,"OnnxModel"),ji.forEach(n),sa=i($o,`. Check the superclass documentation for the generic methods the
library implements for all its model (such as downloading or saving)`),$o.forEach(n),ra=m(J),yn=s(J,"P",{});var Ti=r(yn);aa=i(Ti,"Sequence Classification model for ONNX."),Ti.forEach(n),ia=m(J),j=s(J,"DIV",{class:!0});var I=r(j);f(ht.$$.fragment,I),la=m(I),ie=s(I,"P",{});var qt=r(ie);ma=i(qt,"The "),On=s(qt,"CODE",{});var Fi=r(On);pa=i(Fi,"OnnxForTokenClassification"),Fi.forEach(n),ca=i(qt," forward method, overrides the "),qn=s(qt,"CODE",{});var Ai=r(qn);da=i(Ai,"__call__"),Ai.forEach(n),ua=i(qt," special method."),qt.forEach(n),ha=m(I),f(ye.$$.fragment,I),fa=m(I),En=s(I,"P",{});var Ci=r(En);ga=i(Ci,"Example of token classification:"),Ci.forEach(n),_a=m(I),f(ft.$$.fragment,I),xa=m(I),gt=s(I,"P",{});var bo=r(gt);ka=i(bo,"Example using "),zn=s(bo,"CODE",{});var Pi=r(zn);va=i(Pi,"transformers.pipelines"),Pi.forEach(n),wa=i(bo,":"),bo.forEach(n),$a=m(I),f(_t.$$.fragment,I),I.forEach(n),J.forEach(n),this.h()},h(){c(d,"name","hf:doc:metadata"),c(d,"content",JSON.stringify(Ui)),c(b,"id","optimum-inference-with-onnxrunime"),c(b,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(b,"href","#optimum-inference-with-onnxrunime"),c(v,"class","relative group"),c(kt,"href","hf.co/models"),c(me,"id","switching-from-transfromers-to-optimum-inference"),c(me,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(me,"href","#switching-from-transfromers-to-optimum-inference"),c(Y,"class","relative group"),c(vt,"href","xx"),c(ce,"id","working-with-the-hugging-face-model-hubhttpshfcomodels"),c(ce,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ce,"href","#working-with-the-hugging-face-model-hubhttpshfcomodels"),c(K,"class","relative group"),c(Ae,"href","https://hf.co/models"),c(Ae,"rel","nofollow"),c(de,"id","optimum.onnxruntime.OnnxModel"),c(de,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(de,"href","#optimum.onnxruntime.OnnxModel"),c(Z,"class","relative group"),c(ue,"class","docstring"),c(he,"class","docstring"),c(fe,"class","docstring"),c(ge,"class","docstring"),c(A,"class","docstring"),c(_e,"id","optimum.onnxruntime.OnnxForFeatureExtraction"),c(_e,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(_e,"href","#optimum.onnxruntime.OnnxForFeatureExtraction"),c(ee,"class","relative group"),c(E,"class","docstring"),c(C,"class","docstring"),c(ke,"id","optimum.onnxruntime.OnnxForQuestionAnswering"),c(ke,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(ke,"href","#optimum.onnxruntime.OnnxForQuestionAnswering"),c(ne,"class","relative group"),c(z,"class","docstring"),c(P,"class","docstring"),c(we,"id","optimum.onnxruntime.OnnxForSequenceClassification"),c(we,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(we,"href","#optimum.onnxruntime.OnnxForSequenceClassification"),c(se,"class","relative group"),c(y,"class","docstring"),c(M,"class","docstring"),c(be,"id","optimum.onnxruntime.OnnxForTokenClassification"),c(be,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),c(be,"href","#optimum.onnxruntime.OnnxForTokenClassification"),c(ae,"class","relative group"),c(j,"class","docstring"),c(N,"class","docstring")},m(t,p){e(document.head,d),u(t,q,p),u(t,v,p),e(v,b),e(b,O),g(w,O,null),e(v,$),e(v,F),e(F,Oo),u(t,An,p),u(t,le,p),e(le,qo),e(le,kt),e(kt,Eo),e(le,zo),u(t,Cn,p),u(t,Y,p),e(Y,me),e(me,Et),g(ze,Et,null),e(Y,jo),e(Y,zt),e(zt,To),u(t,Pn,p),u(t,R,p),e(R,Fo),e(R,jt),e(jt,Ao),e(R,Co),e(R,Tt),e(Tt,Po),e(R,Mo),u(t,Mn,p),g(je,t,p),u(t,Nn,p),u(t,Q,p),e(Q,No),e(Q,Ft),e(Ft,So),e(Q,Do),e(Q,At),e(At,Io),e(Q,Ho),e(Q,Ct),e(Ct,Qo),e(Q,Lo),u(t,Sn,p),g(Te,t,p),u(t,Dn,p),u(t,pe,p),e(pe,Wo),e(pe,vt),e(vt,Bo),e(pe,Uo),u(t,In,p),u(t,K,p),e(K,ce),e(ce,Pt),g(Fe,Pt,null),e(K,Ro),e(K,Mt),e(Mt,Xo),u(t,Hn,p),u(t,L,p),e(L,Go),e(L,Nt),e(Nt,Vo),e(L,Jo),e(L,Ae),e(Ae,Yo),e(L,Ko),e(L,St),e(St,Zo),e(L,es),u(t,Qn,p),g(Ce,t,p),u(t,Ln,p),u(t,Z,p),e(Z,de),e(de,Dt),g(Pe,Dt,null),e(Z,ts),e(Z,It),e(It,ns),u(t,Wn,p),u(t,A,p),g(Me,A,null),e(A,os),e(A,Ne),e(Ne,ss),e(Ne,Ht),e(Ht,rs),e(Ne,as),e(A,is),e(A,ue),g(Se,ue,null),e(ue,ls),e(ue,De),e(De,ms),e(De,Qt),e(Qt,ps),e(De,cs),e(A,ds),e(A,he),g(Ie,he,null),e(he,us),e(he,wt),e(wt,hs),e(wt,Lt),e(Lt,fs),e(A,gs),e(A,fe),g(He,fe,null),e(fe,_s),e(fe,Wt),e(Wt,xs),e(A,ks),e(A,ge),g(Qe,ge,null),e(ge,vs),e(ge,Bt),e(Bt,ws),u(t,Bn,p),u(t,ee,p),e(ee,_e),e(_e,Ut),g(Le,Ut,null),e(ee,$s),e(ee,Rt),e(Rt,bs),u(t,Un,p),u(t,C,p),g(We,C,null),e(C,ys),e(C,Xt),e(Xt,Os),e(C,qs),e(C,Be),e(Be,Es),e(Be,Gt),e(Gt,zs),e(Be,js),e(C,Ts),e(C,Vt),e(Vt,Fs),e(C,As),e(C,E),g(Ue,E,null),e(E,Cs),e(E,te),e(te,Ps),e(te,Jt),e(Jt,Ms),e(te,Ns),e(te,Yt),e(Yt,Ss),e(te,Ds),e(E,Is),g(xe,E,null),e(E,Hs),e(E,Kt),e(Kt,Qs),e(E,Ls),g(Re,E,null),e(E,Ws),e(E,Xe),e(Xe,Bs),e(Xe,Zt),e(Zt,Us),e(Xe,Rs),e(E,Xs),g(Ge,E,null),u(t,Rn,p),u(t,ne,p),e(ne,ke),e(ke,en),g(Ve,en,null),e(ne,Gs),e(ne,tn),e(tn,Vs),u(t,Xn,p),u(t,P,p),g(Je,P,null),e(P,Js),e(P,nn),e(nn,Ys),e(P,Ks),e(P,Ye),e(Ye,Zs),e(Ye,on),e(on,er),e(Ye,tr),e(P,nr),e(P,sn),e(sn,or),e(P,sr),e(P,z),g(Ke,z,null),e(z,rr),e(z,oe),e(oe,ar),e(oe,rn),e(rn,ir),e(oe,lr),e(oe,an),e(an,mr),e(oe,pr),e(z,cr),g(ve,z,null),e(z,dr),e(z,ln),e(ln,ur),e(z,hr),g(Ze,z,null),e(z,fr),e(z,et),e(et,gr),e(et,mn),e(mn,_r),e(et,xr),e(z,kr),g(tt,z,null),u(t,Gn,p),u(t,se,p),e(se,we),e(we,pn),g(nt,pn,null),e(se,vr),e(se,cn),e(cn,wr),u(t,Vn,p),u(t,M,p),g(ot,M,null),e(M,$r),e(M,dn),e(dn,br),e(M,yr),e(M,st),e(st,Or),e(st,un),e(un,qr),e(st,Er),e(M,zr),e(M,hn),e(hn,jr),e(M,Tr),e(M,y),g(rt,y,null),e(y,Fr),e(y,re),e(re,Ar),e(re,fn),e(fn,Cr),e(re,Pr),e(re,gn),e(gn,Mr),e(re,Nr),e(y,Sr),g($e,y,null),e(y,Dr),e(y,_n),e(_n,Ir),e(y,Hr),g(at,y,null),e(y,Qr),e(y,it),e(it,Lr),e(it,xn),e(xn,Wr),e(it,Br),e(y,Ur),g(lt,y,null),e(y,Rr),e(y,mt),e(mt,Xr),e(mt,kn),e(kn,Gr),e(mt,Vr),e(y,Jr),g(pt,y,null),u(t,Jn,p),u(t,ae,p),e(ae,be),e(be,vn),g(ct,vn,null),e(ae,Yr),e(ae,wn),e(wn,Kr),u(t,Yn,p),u(t,N,p),g(dt,N,null),e(N,Zr),e(N,$n),e($n,ea),e(N,ta),e(N,ut),e(ut,na),e(ut,bn),e(bn,oa),e(ut,sa),e(N,ra),e(N,yn),e(yn,aa),e(N,ia),e(N,j),g(ht,j,null),e(j,la),e(j,ie),e(ie,ma),e(ie,On),e(On,pa),e(ie,ca),e(ie,qn),e(qn,da),e(ie,ua),e(j,ha),g(ye,j,null),e(j,fa),e(j,En),e(En,ga),e(j,_a),g(ft,j,null),e(j,xa),e(j,gt),e(gt,ka),e(gt,zn),e(zn,va),e(gt,wa),e(j,$a),g(_t,j,null),Kn=!0},p(t,[p]){const xt={};p&2&&(xt.$$scope={dirty:p,ctx:t}),xe.$set(xt);const jn={};p&2&&(jn.$$scope={dirty:p,ctx:t}),ve.$set(jn);const Tn={};p&2&&(Tn.$$scope={dirty:p,ctx:t}),$e.$set(Tn);const Fn={};p&2&&(Fn.$$scope={dirty:p,ctx:t}),ye.$set(Fn)},i(t){Kn||(_(w.$$.fragment,t),_(ze.$$.fragment,t),_(je.$$.fragment,t),_(Te.$$.fragment,t),_(Fe.$$.fragment,t),_(Ce.$$.fragment,t),_(Pe.$$.fragment,t),_(Me.$$.fragment,t),_(Se.$$.fragment,t),_(Ie.$$.fragment,t),_(He.$$.fragment,t),_(Qe.$$.fragment,t),_(Le.$$.fragment,t),_(We.$$.fragment,t),_(Ue.$$.fragment,t),_(xe.$$.fragment,t),_(Re.$$.fragment,t),_(Ge.$$.fragment,t),_(Ve.$$.fragment,t),_(Je.$$.fragment,t),_(Ke.$$.fragment,t),_(ve.$$.fragment,t),_(Ze.$$.fragment,t),_(tt.$$.fragment,t),_(nt.$$.fragment,t),_(ot.$$.fragment,t),_(rt.$$.fragment,t),_($e.$$.fragment,t),_(at.$$.fragment,t),_(lt.$$.fragment,t),_(pt.$$.fragment,t),_(ct.$$.fragment,t),_(dt.$$.fragment,t),_(ht.$$.fragment,t),_(ye.$$.fragment,t),_(ft.$$.fragment,t),_(_t.$$.fragment,t),Kn=!0)},o(t){x(w.$$.fragment,t),x(ze.$$.fragment,t),x(je.$$.fragment,t),x(Te.$$.fragment,t),x(Fe.$$.fragment,t),x(Ce.$$.fragment,t),x(Pe.$$.fragment,t),x(Me.$$.fragment,t),x(Se.$$.fragment,t),x(Ie.$$.fragment,t),x(He.$$.fragment,t),x(Qe.$$.fragment,t),x(Le.$$.fragment,t),x(We.$$.fragment,t),x(Ue.$$.fragment,t),x(xe.$$.fragment,t),x(Re.$$.fragment,t),x(Ge.$$.fragment,t),x(Ve.$$.fragment,t),x(Je.$$.fragment,t),x(Ke.$$.fragment,t),x(ve.$$.fragment,t),x(Ze.$$.fragment,t),x(tt.$$.fragment,t),x(nt.$$.fragment,t),x(ot.$$.fragment,t),x(rt.$$.fragment,t),x($e.$$.fragment,t),x(at.$$.fragment,t),x(lt.$$.fragment,t),x(pt.$$.fragment,t),x(ct.$$.fragment,t),x(dt.$$.fragment,t),x(ht.$$.fragment,t),x(ye.$$.fragment,t),x(ft.$$.fragment,t),x(_t.$$.fragment,t),Kn=!1},d(t){n(d),t&&n(q),t&&n(v),k(w),t&&n(An),t&&n(le),t&&n(Cn),t&&n(Y),k(ze),t&&n(Pn),t&&n(R),t&&n(Mn),k(je,t),t&&n(Nn),t&&n(Q),t&&n(Sn),k(Te,t),t&&n(Dn),t&&n(pe),t&&n(In),t&&n(K),k(Fe),t&&n(Hn),t&&n(L),t&&n(Qn),k(Ce,t),t&&n(Ln),t&&n(Z),k(Pe),t&&n(Wn),t&&n(A),k(Me),k(Se),k(Ie),k(He),k(Qe),t&&n(Bn),t&&n(ee),k(Le),t&&n(Un),t&&n(C),k(We),k(Ue),k(xe),k(Re),k(Ge),t&&n(Rn),t&&n(ne),k(Ve),t&&n(Xn),t&&n(P),k(Je),k(Ke),k(ve),k(Ze),k(tt),t&&n(Gn),t&&n(se),k(nt),t&&n(Vn),t&&n(M),k(ot),k(rt),k($e),k(at),k(lt),k(pt),t&&n(Jn),t&&n(ae),k(ct),t&&n(Yn),t&&n(N),k(dt),k(ht),k(ye),k(ft),k(_t)}}}const Ui={local:"optimum-inference-with-onnxrunime",sections:[{local:"switching-from-transfromers-to-optimum-inference",sections:[{local:"working-with-the-hugging-face-model-hubhttpshfcomodels",title:"Working with the [Hugging Face Model Hub](https://hf.co/models)"}],title:"Switching from Transfromers to Optimum Inference"},{local:"optimum.onnxruntime.OnnxModel",title:"OnnxModel"},{local:"optimum.onnxruntime.OnnxForFeatureExtraction",title:"OnnxForFeatureExtraction"},{local:"optimum.onnxruntime.OnnxForQuestionAnswering",title:"OnnxForQuestionAnswering"},{local:"optimum.onnxruntime.OnnxForSequenceClassification",title:"OnnxForSequenceClassification"},{local:"optimum.onnxruntime.OnnxForTokenClassification",title:"OnnxForTokenClassification"}],title:"Optimum Inference with Onnxrunime"};function Ri(U){return Ii(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Ki extends Mi{constructor(d){super();Ni(this,d,Ri,Bi,Si,{})}}export{Ki as default,Ui as metadata};
