import{S as _a,i as ka,s as $a,e as t,k as p,w as D,t as c,M as ja,c as o,d as a,m,a as r,x as F,h as f,b as n,F as e,g as i,y as R,L as Aa,q as C,o as H,B as Y}from"../chunks/vendor-e67aec41.js";import{I as ks}from"../chunks/IconCopyLink-ffd7f84e.js";import{C as ba}from"../chunks/CodeBlock-e2bcf023.js";function Ea($s){let w,N,u,d,J,j,js,O,As,os,v,_,U,A,Es,Z,Ps,rs,E,P,qs,xs,ls,h,q,Ms,x,Is,zs,Ts,K,Ns,Ss,Q,Bs,Gs,V,Ls,Ws,X,Ds,is,y,k,ss,M,Fs,as,Rs,ns,S,Cs,ps,B,Hs,ms,I,cs,G,Ys,fs,b,$,es,z,Js,ts,Os,hs,L,Us,us,T,ds,W,Zs,ws;return j=new ks({}),A=new ks({}),M=new ks({}),I=new ba({props:{codee:`import os; import psutil; import timeit
from datasets import load_dataset

mem_before = psutil.Process(os.getpid()).memory_info().rss  / (1024 * 1024)
wiki = load_dataset("wikipedia", "20200501.en", split='train')
mem_after = psutil.Process(os.getpid()).memory_info().rss >> 20

print(f"RAM memory used: {(mem_after - mem_before)} MB"),`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> os; <span class="hljs-keyword">import</span> psutil; <span class="hljs-keyword">import</span> timeit
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

<span class="hljs-comment"># Process.memory_info is expressed in bytes, so convert to megabytes </span>
<span class="hljs-meta">&gt;&gt;&gt; </span>mem_before = psutil.Process(os.getpid()).memory_info().rss  / (<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>wiki = load_dataset(<span class="hljs-string">&quot;wikipedia&quot;</span>, <span class="hljs-string">&quot;20200501.en&quot;</span>, split=<span class="hljs-string">&#x27;train&#x27;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>mem_after = psutil.Process(os.getpid()).memory_info().rss &gt;&gt; <span class="hljs-number">20</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;RAM memory used: <span class="hljs-subst">{(mem_after - mem_before)}</span> MB&quot;</span>)
<span class="hljs-string">&#x27;RAM memory used: 9 MB&#x27;</span>`}}),z=new ks({}),T=new ba({props:{codee:`s = """batch_size = 1000
for i in range(0, len(wiki), batch_size):
    batch = wiki[i:i + batch_size]
"""

time = timeit.timeit(stmt=s, number=1, globals=globals())
print(f"Time to iterate over the {wiki.dataset_size >> 30} GB dataset: {time:.1f} sec, "
      f"ie. {float(wiki.dataset_size >> 27)/time:.1f} Gb/s"),`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">&quot;&quot;&quot;batch_size = 1000
<span class="hljs-meta">... </span>for i in range(0, len(wiki), batch_size):
<span class="hljs-meta">... </span>    batch = wiki[i:i + batch_size]
<span class="hljs-meta">... </span>&quot;&quot;&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>time = timeit.timeit(stmt=s, number=<span class="hljs-number">1</span>, <span class="hljs-built_in">globals</span>=<span class="hljs-built_in">globals</span>())
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Time to iterate over the <span class="hljs-subst">{wiki.dataset_size &gt;&gt; <span class="hljs-number">30</span>}</span> GB dataset: <span class="hljs-subst">{time:<span class="hljs-number">.1</span>f}</span> sec, &quot;</span>
<span class="hljs-meta">... </span>      <span class="hljs-string">f&quot;ie. <span class="hljs-subst">{<span class="hljs-built_in">float</span>(wiki.dataset_size &gt;&gt; <span class="hljs-number">27</span>)/time:<span class="hljs-number">.1</span>f}</span> Gb/s&quot;</span>)
<span class="hljs-string">&#x27;Time to iterate over the 17 GB dataset: 85 sec, ie. 1.7 Gb/s&#x27;</span>`}}),{c(){w=t("meta"),N=p(),u=t("h1"),d=t("a"),J=t("span"),D(j.$$.fragment),js=p(),O=t("span"),As=c("Datasets \u{1F91D} Arrow"),os=p(),v=t("h2"),_=t("a"),U=t("span"),D(A.$$.fragment),Es=p(),Z=t("span"),Ps=c("What is Arrow?"),rs=p(),E=t("p"),P=t("a"),qs=c("Arrow"),xs=c(" enables large amounts of data to be processed and moved quickly. It is a specific data format that stores data in a columnar memory layout. This provides several significant advantages:"),ls=p(),h=t("ul"),q=t("li"),Ms=c("Arrow\u2019s standard format allows "),x=t("a"),Is=c("zero-copy reads"),zs=c(" which removes virtually all serialization overhead."),Ts=p(),K=t("li"),Ns=c("Arrow is language-agnostic so it supports different programming languages."),Ss=p(),Q=t("li"),Bs=c("Arrow is column-oriented so it is faster at querying and processing slices or columns of data."),Gs=p(),V=t("li"),Ls=c("Arrow allows for copy-free hand-offs to standard machine learning tools such as NumPy, Pandas, PyTorch, and TensorFlow."),Ws=p(),X=t("li"),Ds=c("Arrow supports many, possibly nested, column types."),is=p(),y=t("h2"),k=t("a"),ss=t("span"),D(M.$$.fragment),Fs=p(),as=t("span"),Rs=c("Memory-mapping"),ns=p(),S=t("p"),Cs=c(`\u{1F917} Datasets uses Arrow for its local caching system. It allows datasets to be backed by an on-disk cache, which is memory-mapped for fast lookup.
This architecture allows for large datasets to be used on machines with relatively small device memory.`),ps=p(),B=t("p"),Hs=c("For example, loading the full English Wikipedia dataset only takes a few MB of RAM:"),ms=p(),D(I.$$.fragment),cs=p(),G=t("p"),Ys=c(`This is possible because the Arrow data is actually memory-mapped from disk, and not loaded in memory.
Memory-mapping allows access to data on disk, and leverages virtual memory capabilities for fast lookups.`),fs=p(),b=t("h2"),$=t("a"),es=t("span"),D(z.$$.fragment),Js=p(),ts=t("span"),Os=c("Performance"),hs=p(),L=t("p"),Us=c("Iterating over a memory-mapped dataset using Arrow is fast. Iterating over Wikipedia on a laptop gives you speeds of 1-3 Gbit/s:"),us=p(),D(T.$$.fragment),ds=p(),W=t("p"),Zs=c("You can obtain the best performance by accessing slices of data (or \u201Cbatches\u201D), in order to reduce the amount of lookups on disk."),this.h()},l(s){const l=ja('[data-svelte="svelte-1phssyn"]',document.head);w=o(l,"META",{name:!0,content:!0}),l.forEach(a),N=m(s),u=o(s,"H1",{class:!0});var gs=r(u);d=o(gs,"A",{id:!0,class:!0,href:!0});var Qs=r(d);J=o(Qs,"SPAN",{});var Vs=r(J);F(j.$$.fragment,Vs),Vs.forEach(a),Qs.forEach(a),js=m(gs),O=o(gs,"SPAN",{});var Xs=r(O);As=f(Xs,"Datasets \u{1F91D} Arrow"),Xs.forEach(a),gs.forEach(a),os=m(s),v=o(s,"H2",{class:!0});var vs=r(v);_=o(vs,"A",{id:!0,class:!0,href:!0});var sa=r(_);U=o(sa,"SPAN",{});var aa=r(U);F(A.$$.fragment,aa),aa.forEach(a),sa.forEach(a),Es=m(vs),Z=o(vs,"SPAN",{});var ea=r(Z);Ps=f(ea,"What is Arrow?"),ea.forEach(a),vs.forEach(a),rs=m(s),E=o(s,"P",{});var Ks=r(E);P=o(Ks,"A",{href:!0,rel:!0});var ta=r(P);qs=f(ta,"Arrow"),ta.forEach(a),xs=f(Ks," enables large amounts of data to be processed and moved quickly. It is a specific data format that stores data in a columnar memory layout. This provides several significant advantages:"),Ks.forEach(a),ls=m(s),h=o(s,"UL",{});var g=r(h);q=o(g,"LI",{});var ys=r(q);Ms=f(ys,"Arrow\u2019s standard format allows "),x=o(ys,"A",{href:!0,rel:!0});var oa=r(x);Is=f(oa,"zero-copy reads"),oa.forEach(a),zs=f(ys," which removes virtually all serialization overhead."),ys.forEach(a),Ts=m(g),K=o(g,"LI",{});var ra=r(K);Ns=f(ra,"Arrow is language-agnostic so it supports different programming languages."),ra.forEach(a),Ss=m(g),Q=o(g,"LI",{});var la=r(Q);Bs=f(la,"Arrow is column-oriented so it is faster at querying and processing slices or columns of data."),la.forEach(a),Gs=m(g),V=o(g,"LI",{});var ia=r(V);Ls=f(ia,"Arrow allows for copy-free hand-offs to standard machine learning tools such as NumPy, Pandas, PyTorch, and TensorFlow."),ia.forEach(a),Ws=m(g),X=o(g,"LI",{});var na=r(X);Ds=f(na,"Arrow supports many, possibly nested, column types."),na.forEach(a),g.forEach(a),is=m(s),y=o(s,"H2",{class:!0});var bs=r(y);k=o(bs,"A",{id:!0,class:!0,href:!0});var pa=r(k);ss=o(pa,"SPAN",{});var ma=r(ss);F(M.$$.fragment,ma),ma.forEach(a),pa.forEach(a),Fs=m(bs),as=o(bs,"SPAN",{});var ca=r(as);Rs=f(ca,"Memory-mapping"),ca.forEach(a),bs.forEach(a),ns=m(s),S=o(s,"P",{});var fa=r(S);Cs=f(fa,`\u{1F917} Datasets uses Arrow for its local caching system. It allows datasets to be backed by an on-disk cache, which is memory-mapped for fast lookup.
This architecture allows for large datasets to be used on machines with relatively small device memory.`),fa.forEach(a),ps=m(s),B=o(s,"P",{});var ha=r(B);Hs=f(ha,"For example, loading the full English Wikipedia dataset only takes a few MB of RAM:"),ha.forEach(a),ms=m(s),F(I.$$.fragment,s),cs=m(s),G=o(s,"P",{});var ua=r(G);Ys=f(ua,`This is possible because the Arrow data is actually memory-mapped from disk, and not loaded in memory.
Memory-mapping allows access to data on disk, and leverages virtual memory capabilities for fast lookups.`),ua.forEach(a),fs=m(s),b=o(s,"H2",{class:!0});var _s=r(b);$=o(_s,"A",{id:!0,class:!0,href:!0});var da=r($);es=o(da,"SPAN",{});var wa=r(es);F(z.$$.fragment,wa),wa.forEach(a),da.forEach(a),Js=m(_s),ts=o(_s,"SPAN",{});var ga=r(ts);Os=f(ga,"Performance"),ga.forEach(a),_s.forEach(a),hs=m(s),L=o(s,"P",{});var va=r(L);Us=f(va,"Iterating over a memory-mapped dataset using Arrow is fast. Iterating over Wikipedia on a laptop gives you speeds of 1-3 Gbit/s:"),va.forEach(a),us=m(s),F(T.$$.fragment,s),ds=m(s),W=o(s,"P",{});var ya=r(W);Zs=f(ya,"You can obtain the best performance by accessing slices of data (or \u201Cbatches\u201D), in order to reduce the amount of lookups on disk."),ya.forEach(a),this.h()},h(){n(w,"name","hf:doc:metadata"),n(w,"content",JSON.stringify(Pa)),n(d,"id","datasets-arrow"),n(d,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),n(d,"href","#datasets-arrow"),n(u,"class","relative group"),n(_,"id","what-is-arrow"),n(_,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),n(_,"href","#what-is-arrow"),n(v,"class","relative group"),n(P,"href","https://arrow.apache.org/"),n(P,"rel","nofollow"),n(x,"href","https://en.wikipedia.org/wiki/Zero-copy"),n(x,"rel","nofollow"),n(k,"id","memorymapping"),n(k,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),n(k,"href","#memorymapping"),n(y,"class","relative group"),n($,"id","performance"),n($,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),n($,"href","#performance"),n(b,"class","relative group")},m(s,l){e(document.head,w),i(s,N,l),i(s,u,l),e(u,d),e(d,J),R(j,J,null),e(u,js),e(u,O),e(O,As),i(s,os,l),i(s,v,l),e(v,_),e(_,U),R(A,U,null),e(v,Es),e(v,Z),e(Z,Ps),i(s,rs,l),i(s,E,l),e(E,P),e(P,qs),e(E,xs),i(s,ls,l),i(s,h,l),e(h,q),e(q,Ms),e(q,x),e(x,Is),e(q,zs),e(h,Ts),e(h,K),e(K,Ns),e(h,Ss),e(h,Q),e(Q,Bs),e(h,Gs),e(h,V),e(V,Ls),e(h,Ws),e(h,X),e(X,Ds),i(s,is,l),i(s,y,l),e(y,k),e(k,ss),R(M,ss,null),e(y,Fs),e(y,as),e(as,Rs),i(s,ns,l),i(s,S,l),e(S,Cs),i(s,ps,l),i(s,B,l),e(B,Hs),i(s,ms,l),R(I,s,l),i(s,cs,l),i(s,G,l),e(G,Ys),i(s,fs,l),i(s,b,l),e(b,$),e($,es),R(z,es,null),e(b,Js),e(b,ts),e(ts,Os),i(s,hs,l),i(s,L,l),e(L,Us),i(s,us,l),R(T,s,l),i(s,ds,l),i(s,W,l),e(W,Zs),ws=!0},p:Aa,i(s){ws||(C(j.$$.fragment,s),C(A.$$.fragment,s),C(M.$$.fragment,s),C(I.$$.fragment,s),C(z.$$.fragment,s),C(T.$$.fragment,s),ws=!0)},o(s){H(j.$$.fragment,s),H(A.$$.fragment,s),H(M.$$.fragment,s),H(I.$$.fragment,s),H(z.$$.fragment,s),H(T.$$.fragment,s),ws=!1},d(s){a(w),s&&a(N),s&&a(u),Y(j),s&&a(os),s&&a(v),Y(A),s&&a(rs),s&&a(E),s&&a(ls),s&&a(h),s&&a(is),s&&a(y),Y(M),s&&a(ns),s&&a(S),s&&a(ps),s&&a(B),s&&a(ms),Y(I,s),s&&a(cs),s&&a(G),s&&a(fs),s&&a(b),Y(z),s&&a(hs),s&&a(L),s&&a(us),Y(T,s),s&&a(ds),s&&a(W)}}}const Pa={local:"datasets-arrow",sections:[{local:"what-is-arrow",title:"What is Arrow?"},{local:"memorymapping",title:"Memory-mapping"},{local:"performance",title:"Performance"}],title:"Datasets \u{1F91D} Arrow"};function qa($s,w,N){let{fw:u}=w;return $s.$$set=d=>{"fw"in d&&N(0,u=d.fw)},[u]}class za extends _a{constructor(w){super();ka(this,w,qa,Ea,$a,{fw:0})}}export{za as default,Pa as metadata};
