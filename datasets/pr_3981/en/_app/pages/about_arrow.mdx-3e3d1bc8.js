import{S as _a,i as ka,s as $a,e as t,k as p,w as W,t as c,M as ja,c as o,d as a,m,a as r,x as R,h as f,b as n,F as e,g as i,y as D,L as Aa,q as F,o as C,B as H,v as Ea}from"../chunks/vendor-aa873a46.js";import{I as ks}from"../chunks/IconCopyLink-d0ca3106.js";import{C as ba}from"../chunks/CodeBlock-1f14baf3.js";function Pa(Ks){let d,ts,g,b,U,j,$s,Y,js,os,w,_,J,A,As,O,Es,rs,E,P,Ps,qs,ls,h,q,xs,x,Ms,Is,zs,Z,Ts,Ss,K,Ns,Bs,Q,Ls,Gs,V,Ws,is,v,k,X,M,Rs,ss,Ds,ns,S,Fs,ps,N,Cs,ms,I,cs,B,Hs,fs,y,$,as,z,Us,es,Ys,hs,L,Js,us,T,ds,G,Os,gs;return j=new ks({}),A=new ks({}),M=new ks({}),I=new ba({props:{code:`import os; import psutil; import timeit
from datasets import load_dataset

mem_before = psutil.Process(os.getpid()).memory_info().rss  / (1024 * 1024)
wiki = load_dataset("wikipedia", "20200501.en", split='train')
mem_after = psutil.Process(os.getpid()).memory_info().rss >> 20

print(f"RAM memory used: {(mem_after - mem_before)} MB")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">import</span> os; <span class="hljs-keyword">import</span> psutil; <span class="hljs-keyword">import</span> timeit
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset

<span class="hljs-comment"># Process.memory_info is expressed in bytes, so convert to megabytes </span>
<span class="hljs-meta">&gt;&gt;&gt; </span>mem_before = psutil.Process(os.getpid()).memory_info().rss  / (<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>wiki = load_dataset(<span class="hljs-string">&quot;wikipedia&quot;</span>, <span class="hljs-string">&quot;20200501.en&quot;</span>, split=<span class="hljs-string">&#x27;train&#x27;</span>)
<span class="hljs-meta">&gt;&gt;&gt; </span>mem_after = psutil.Process(os.getpid()).memory_info().rss &gt;&gt; <span class="hljs-number">20</span>

<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;RAM memory used: <span class="hljs-subst">{(mem_after - mem_before)}</span> MB&quot;</span>)
<span class="hljs-string">&#x27;RAM memory used: 9 MB&#x27;</span>`}}),z=new ks({}),T=new ba({props:{code:`s = """batch_size = 1000
for i in range(0, len(wiki), batch_size):
    batch = wiki[i:i + batch_size]
"""

time = timeit.timeit(stmt=s, number=1, globals=globals())
print(f"Time to iterate over the {wiki.dataset_size >> 30} GB dataset: {time:.1f} sec, "
      f"ie. {float(wiki.dataset_size >> 27)/time:.1f} Gb/s")`,highlighted:`<span class="hljs-meta">&gt;&gt;&gt; </span>s = <span class="hljs-string">&quot;&quot;&quot;batch_size = 1000
<span class="hljs-meta">... </span>for i in range(0, len(wiki), batch_size):
<span class="hljs-meta">... </span>    batch = wiki[i:i + batch_size]
<span class="hljs-meta">... </span>&quot;&quot;&quot;</span>

<span class="hljs-meta">&gt;&gt;&gt; </span>time = timeit.timeit(stmt=s, number=<span class="hljs-number">1</span>, <span class="hljs-built_in">globals</span>=<span class="hljs-built_in">globals</span>())
<span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Time to iterate over the <span class="hljs-subst">{wiki.dataset_size &gt;&gt; <span class="hljs-number">30</span>}</span> GB dataset: <span class="hljs-subst">{time:<span class="hljs-number">.1</span>f}</span> sec, &quot;</span>
<span class="hljs-meta">... </span>      <span class="hljs-string">f&quot;ie. <span class="hljs-subst">{<span class="hljs-built_in">float</span>(wiki.dataset_size &gt;&gt; <span class="hljs-number">27</span>)/time:<span class="hljs-number">.1</span>f}</span> Gb/s&quot;</span>)
<span class="hljs-string">&#x27;Time to iterate over the 17 GB dataset: 85 sec, ie. 1.7 Gb/s&#x27;</span>`}}),{c(){d=t("meta"),ts=p(),g=t("h1"),b=t("a"),U=t("span"),W(j.$$.fragment),$s=p(),Y=t("span"),js=c("Datasets \u{1F91D} Arrow"),os=p(),w=t("h2"),_=t("a"),J=t("span"),W(A.$$.fragment),As=p(),O=t("span"),Es=c("What is Arrow?"),rs=p(),E=t("p"),P=t("a"),Ps=c("Arrow"),qs=c(" enables large amounts of data to be processed and moved quickly. It is a specific data format that stores data in a columnar memory layout. This provides several significant advantages:"),ls=p(),h=t("ul"),q=t("li"),xs=c("Arrow\u2019s standard format allows "),x=t("a"),Ms=c("zero-copy reads"),Is=c(" which removes virtually all serialization overhead."),zs=p(),Z=t("li"),Ts=c("Arrow is language-agnostic so it supports different programming languages."),Ss=p(),K=t("li"),Ns=c("Arrow is column-oriented so it is faster at querying and processing slices or columns of data."),Bs=p(),Q=t("li"),Ls=c("Arrow allows for copy-free hand-offs to standard machine learning tools such as NumPy, Pandas, PyTorch, and TensorFlow."),Gs=p(),V=t("li"),Ws=c("Arrow supports many, possibly nested, column types."),is=p(),v=t("h2"),k=t("a"),X=t("span"),W(M.$$.fragment),Rs=p(),ss=t("span"),Ds=c("Memory-mapping"),ns=p(),S=t("p"),Fs=c(`\u{1F917} Datasets uses Arrow for its local caching system. It allows datasets to be backed by an on-disk cache, which is memory-mapped for fast lookup.
This architecture allows for large datasets to be used on machines with relatively small device memory.`),ps=p(),N=t("p"),Cs=c("For example, loading the full English Wikipedia dataset only takes a few MB of RAM:"),ms=p(),W(I.$$.fragment),cs=p(),B=t("p"),Hs=c(`This is possible because the Arrow data is actually memory-mapped from disk, and not loaded in memory.
Memory-mapping allows access to data on disk, and leverages virtual memory capabilities for fast lookups.`),fs=p(),y=t("h2"),$=t("a"),as=t("span"),W(z.$$.fragment),Us=p(),es=t("span"),Ys=c("Performance"),hs=p(),L=t("p"),Js=c("Iterating over a memory-mapped dataset using Arrow is fast. Iterating over Wikipedia on a laptop gives you speeds of 1-3 Gbit/s:"),us=p(),W(T.$$.fragment),ds=p(),G=t("p"),Os=c("You can obtain the best performance by accessing slices of data (or \u201Cbatches\u201D), in order to reduce the amount of lookups on disk."),this.h()},l(s){const l=ja('[data-svelte="svelte-1phssyn"]',document.head);d=o(l,"META",{name:!0,content:!0}),l.forEach(a),ts=m(s),g=o(s,"H1",{class:!0});var ws=r(g);b=o(ws,"A",{id:!0,class:!0,href:!0});var Qs=r(b);U=o(Qs,"SPAN",{});var Vs=r(U);R(j.$$.fragment,Vs),Vs.forEach(a),Qs.forEach(a),$s=m(ws),Y=o(ws,"SPAN",{});var Xs=r(Y);js=f(Xs,"Datasets \u{1F91D} Arrow"),Xs.forEach(a),ws.forEach(a),os=m(s),w=o(s,"H2",{class:!0});var vs=r(w);_=o(vs,"A",{id:!0,class:!0,href:!0});var sa=r(_);J=o(sa,"SPAN",{});var aa=r(J);R(A.$$.fragment,aa),aa.forEach(a),sa.forEach(a),As=m(vs),O=o(vs,"SPAN",{});var ea=r(O);Es=f(ea,"What is Arrow?"),ea.forEach(a),vs.forEach(a),rs=m(s),E=o(s,"P",{});var Zs=r(E);P=o(Zs,"A",{href:!0,rel:!0});var ta=r(P);Ps=f(ta,"Arrow"),ta.forEach(a),qs=f(Zs," enables large amounts of data to be processed and moved quickly. It is a specific data format that stores data in a columnar memory layout. This provides several significant advantages:"),Zs.forEach(a),ls=m(s),h=o(s,"UL",{});var u=r(h);q=o(u,"LI",{});var ys=r(q);xs=f(ys,"Arrow\u2019s standard format allows "),x=o(ys,"A",{href:!0,rel:!0});var oa=r(x);Ms=f(oa,"zero-copy reads"),oa.forEach(a),Is=f(ys," which removes virtually all serialization overhead."),ys.forEach(a),zs=m(u),Z=o(u,"LI",{});var ra=r(Z);Ts=f(ra,"Arrow is language-agnostic so it supports different programming languages."),ra.forEach(a),Ss=m(u),K=o(u,"LI",{});var la=r(K);Ns=f(la,"Arrow is column-oriented so it is faster at querying and processing slices or columns of data."),la.forEach(a),Bs=m(u),Q=o(u,"LI",{});var ia=r(Q);Ls=f(ia,"Arrow allows for copy-free hand-offs to standard machine learning tools such as NumPy, Pandas, PyTorch, and TensorFlow."),ia.forEach(a),Gs=m(u),V=o(u,"LI",{});var na=r(V);Ws=f(na,"Arrow supports many, possibly nested, column types."),na.forEach(a),u.forEach(a),is=m(s),v=o(s,"H2",{class:!0});var bs=r(v);k=o(bs,"A",{id:!0,class:!0,href:!0});var pa=r(k);X=o(pa,"SPAN",{});var ma=r(X);R(M.$$.fragment,ma),ma.forEach(a),pa.forEach(a),Rs=m(bs),ss=o(bs,"SPAN",{});var ca=r(ss);Ds=f(ca,"Memory-mapping"),ca.forEach(a),bs.forEach(a),ns=m(s),S=o(s,"P",{});var fa=r(S);Fs=f(fa,`\u{1F917} Datasets uses Arrow for its local caching system. It allows datasets to be backed by an on-disk cache, which is memory-mapped for fast lookup.
This architecture allows for large datasets to be used on machines with relatively small device memory.`),fa.forEach(a),ps=m(s),N=o(s,"P",{});var ha=r(N);Cs=f(ha,"For example, loading the full English Wikipedia dataset only takes a few MB of RAM:"),ha.forEach(a),ms=m(s),R(I.$$.fragment,s),cs=m(s),B=o(s,"P",{});var ua=r(B);Hs=f(ua,`This is possible because the Arrow data is actually memory-mapped from disk, and not loaded in memory.
Memory-mapping allows access to data on disk, and leverages virtual memory capabilities for fast lookups.`),ua.forEach(a),fs=m(s),y=o(s,"H2",{class:!0});var _s=r(y);$=o(_s,"A",{id:!0,class:!0,href:!0});var da=r($);as=o(da,"SPAN",{});var ga=r(as);R(z.$$.fragment,ga),ga.forEach(a),da.forEach(a),Us=m(_s),es=o(_s,"SPAN",{});var wa=r(es);Ys=f(wa,"Performance"),wa.forEach(a),_s.forEach(a),hs=m(s),L=o(s,"P",{});var va=r(L);Js=f(va,"Iterating over a memory-mapped dataset using Arrow is fast. Iterating over Wikipedia on a laptop gives you speeds of 1-3 Gbit/s:"),va.forEach(a),us=m(s),R(T.$$.fragment,s),ds=m(s),G=o(s,"P",{});var ya=r(G);Os=f(ya,"You can obtain the best performance by accessing slices of data (or \u201Cbatches\u201D), in order to reduce the amount of lookups on disk."),ya.forEach(a),this.h()},h(){n(d,"name","hf:doc:metadata"),n(d,"content",JSON.stringify(qa)),n(b,"id","datasets-arrow"),n(b,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),n(b,"href","#datasets-arrow"),n(g,"class","relative group"),n(_,"id","what-is-arrow"),n(_,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),n(_,"href","#what-is-arrow"),n(w,"class","relative group"),n(P,"href","https://arrow.apache.org/"),n(P,"rel","nofollow"),n(x,"href","https://en.wikipedia.org/wiki/Zero-copy"),n(x,"rel","nofollow"),n(k,"id","memorymapping"),n(k,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),n(k,"href","#memorymapping"),n(v,"class","relative group"),n($,"id","performance"),n($,"class","header-link block pr-1.5 text-lg no-hover:hidden with-hover:absolute with-hover:p-1.5 with-hover:opacity-0 with-hover:group-hover:opacity-100 with-hover:right-full"),n($,"href","#performance"),n(y,"class","relative group")},m(s,l){e(document.head,d),i(s,ts,l),i(s,g,l),e(g,b),e(b,U),D(j,U,null),e(g,$s),e(g,Y),e(Y,js),i(s,os,l),i(s,w,l),e(w,_),e(_,J),D(A,J,null),e(w,As),e(w,O),e(O,Es),i(s,rs,l),i(s,E,l),e(E,P),e(P,Ps),e(E,qs),i(s,ls,l),i(s,h,l),e(h,q),e(q,xs),e(q,x),e(x,Ms),e(q,Is),e(h,zs),e(h,Z),e(Z,Ts),e(h,Ss),e(h,K),e(K,Ns),e(h,Bs),e(h,Q),e(Q,Ls),e(h,Gs),e(h,V),e(V,Ws),i(s,is,l),i(s,v,l),e(v,k),e(k,X),D(M,X,null),e(v,Rs),e(v,ss),e(ss,Ds),i(s,ns,l),i(s,S,l),e(S,Fs),i(s,ps,l),i(s,N,l),e(N,Cs),i(s,ms,l),D(I,s,l),i(s,cs,l),i(s,B,l),e(B,Hs),i(s,fs,l),i(s,y,l),e(y,$),e($,as),D(z,as,null),e(y,Us),e(y,es),e(es,Ys),i(s,hs,l),i(s,L,l),e(L,Js),i(s,us,l),D(T,s,l),i(s,ds,l),i(s,G,l),e(G,Os),gs=!0},p:Aa,i(s){gs||(F(j.$$.fragment,s),F(A.$$.fragment,s),F(M.$$.fragment,s),F(I.$$.fragment,s),F(z.$$.fragment,s),F(T.$$.fragment,s),gs=!0)},o(s){C(j.$$.fragment,s),C(A.$$.fragment,s),C(M.$$.fragment,s),C(I.$$.fragment,s),C(z.$$.fragment,s),C(T.$$.fragment,s),gs=!1},d(s){a(d),s&&a(ts),s&&a(g),H(j),s&&a(os),s&&a(w),H(A),s&&a(rs),s&&a(E),s&&a(ls),s&&a(h),s&&a(is),s&&a(v),H(M),s&&a(ns),s&&a(S),s&&a(ps),s&&a(N),s&&a(ms),H(I,s),s&&a(cs),s&&a(B),s&&a(fs),s&&a(y),H(z),s&&a(hs),s&&a(L),s&&a(us),H(T,s),s&&a(ds),s&&a(G)}}}const qa={local:"datasets-arrow",sections:[{local:"what-is-arrow",title:"What is Arrow?"},{local:"memorymapping",title:"Memory-mapping"},{local:"performance",title:"Performance"}],title:"Datasets \u{1F91D} Arrow"};function xa(Ks){return Ea(()=>{new URLSearchParams(window.location.search).get("fw")}),[]}class Ta extends _a{constructor(d){super();ka(this,d,xa,Pa,$a,{})}}export{Ta as default,qa as metadata};
